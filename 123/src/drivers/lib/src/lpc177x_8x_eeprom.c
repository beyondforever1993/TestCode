/**********************************************************************
* $Id$        lpc177x_8x_eeprom.c            2011-06-02
*//**
* @file        lpc177x_8x_eeprom.c
* @brief    Contains all functions support for EEPROM firmware library on
*            LPC177x_8x
* @version    1.0
* @date        02. June. 2011
* @author    NXP MCU SW Application Team
* 
* Copyright(C) 2011, NXP Semiconductor
* All rights reserved.
*
***********************************************************************
* Software that is described herein is for illustrative purposes only
* which provides customers with programming information regarding the
* products. This software is supplied "AS IS" without any warranties.
* NXP Semiconductors assumes no responsibility or liability for the
* use of the software, conveys no license or title under any patent,
* copyright, or mask work right to the product. NXP Semiconductors
* reserves the right to make changes in the software without
* notification. NXP Semiconductors also make no representation or
* warranty that such application will be suitable for the specified
* use without further testing or modification.
* Permission to use, copy, modify, and distribute this software and its
* documentation is hereby granted, under NXP Semiconductors'
* relevant copyright in the software, without fee, provided that it
* is used in conjunction with NXP Semiconductors microcontrollers.  This
* copyright, permission, and disclaimer notice must appear in all copies of
* this code.
**********************************************************************/

/* Peripheral group ----------------------------------------------------------- */
/** @addtogroup EEPROM
 * @{
 */

 
/* Includes ------------------------------------------------------------------- */
#include "lpc177x_8x_eeprom.h"
#include "lpc177x_8x_clkpwr.h"

/* Public Functions ----------------------------------------------------------- */

/*********************************************************************//**
 * @brief         Initial EEPROM
 * @param[in]    None
 * @return         None
 **********************************************************************/
void EEPROM_Init(void)
{
    uint32_t val, cclk;
    
    LPC_EEPROM->PWRDWN = 0x0;
    /* EEPROM is automate turn on after reset */
    /* Setting clock:
    * EEPROM required a 375kHz. This clock is generated by dividing the
    * system bus clock.
    */
    cclk = CLKPWR_GetCLK(CLKPWR_CLKTYPE_CPU);
    val = (cclk/375000)-1;
    LPC_EEPROM->CLKDIV = val;

    /* Setting wait state */
    val  = ((((cclk / 1000000) * 15) / 1000) + 1);
    val |= (((((cclk / 1000000) * 55) / 1000) + 1) << 8);
    val |= (((((cclk / 1000000) * 35) / 1000) + 1) << 16);
    LPC_EEPROM->WSTATE = val;
}

/*********************************************************************//**
 * @brief         Write data to EEPROM at specific address
 * @param[in]    page_offset offset of data in page register(0 - 63)
 *              page_address page address (0-62)                    
 *                 mode    Write mode, should be:
 *                     - MODE_8_BIT    : write 8 bit mode
 *                     - MODE_16_BIT    : write 16 bit mode
 *                     - MODE_32_BIT    : write 32 bit mode
 *                 data    buffer that contain data that will be written to buffer
 *                 count    number written data
 * @return         None
 * @note        This function actually write data into EEPROM memory and automatically
 *                 write into next page if current page is overflowed
 **********************************************************************/
void EEPROM_Write(uint16_t usAddr, uint8_t *pucData, uint32_t ulLen)
{
    uint32_t i;
    
    LPC_EEPROM->ADDR = usAddr;
    //update data to page register
    for(i=0;i<ulLen;i++)
    {
        LPC_EEPROM->INT_CLR_STATUS = ((1 << EEPROM_ENDOF_RW)|(1 << EEPROM_ENDOF_PROG));
        LPC_EEPROM->CMD = EEPROM_CMD_8_BIT_WRITE;
        LPC_EEPROM->WDATA = pucData[i];
        while(!((LPC_EEPROM->INT_STATUS >> EEPROM_ENDOF_RW)&0x01));
        usAddr++;
        if(((usAddr - 1) / EEPROM_PAGE_SIZE) > (EEPROM_PAGE_NUM - 1))
        {
            break;
        }
        if((0 == (usAddr % EEPROM_PAGE_SIZE)) || (i == ulLen - 1)){
            //update to EEPROM memory
            LPC_EEPROM->ADDR = EEPROM_PAGE_ADRESS(((usAddr - 1) / EEPROM_PAGE_SIZE));
            LPC_EEPROM->CMD  = EEPROM_CMD_ERASE_PRG_PAGE;
            while(!((LPC_EEPROM->INT_STATUS >> EEPROM_ENDOF_PROG)&0x01));
        }
    }
    return;
}

/*********************************************************************//**
 * @brief         Read data to EEPROM at specific address
 * @param[in]
 *                 data    buffer that contain data that will be written to buffer
 *                 mode    Read mode, should be:
 *                     - MODE_8_BIT    : read 8 bit mode
 *                     - MODE_16_BIT    : read 16 bit mode
 *                     - MODE_32_BIT    : read 32 bit mode
 *                 count    number read data (bytes)
 * @return         data    buffer that contain data that will be read to buffer
 **********************************************************************/
void EEPROM_Read(uint16_t usAddr, uint8_t *pucData, uint32_t ulLen)
{
    uint32_t i;

    LPC_EEPROM->ADDR = usAddr;
    LPC_EEPROM->CMD = EEPROM_CMD_8_BIT_READ|EEPROM_CMD_RDPREFETCH;
    for(i=0;i<ulLen;i++)
    {
        LPC_EEPROM->INT_CLR_STATUS = (1 << EEPROM_ENDOF_RW);
        pucData[i] = LPC_EEPROM->RDATA & 0xff;
        while(!((LPC_EEPROM->INT_STATUS >> EEPROM_ENDOF_RW)&0x01));
    }
    return;
}

/*********************************************************************//**
 * @brief         Erase a page at the specific address
 * @param[in]    address EEPROM page address (0-62)
 * @return         data    buffer that contain data that will be read to buffer
 **********************************************************************/
void EEPROM_Erase(uint16_t page_address)
{
    uint32_t i;
    uint32_t count = EEPROM_PAGE_SIZE/4;

    LPC_EEPROM->INT_CLR_STATUS = ((1 << EEPROM_ENDOF_RW)|(1 << EEPROM_ENDOF_PROG));  

    //clear page register
    LPC_EEPROM->ADDR = EEPROM_PAGE_OFFSET(0);
    LPC_EEPROM->CMD = EEPROM_CMD_32_BIT_WRITE;
    for(i=0;i<count;i++)
    {
        LPC_EEPROM->WDATA = 0;
        while(!((LPC_EEPROM->INT_STATUS >> EEPROM_ENDOF_RW)&0x01));
        LPC_EEPROM->INT_CLR_STATUS = (1 << EEPROM_ENDOF_RW);
    }

    LPC_EEPROM->INT_CLR_STATUS = (0x1 << EEPROM_ENDOF_PROG);
    LPC_EEPROM->ADDR = EEPROM_PAGE_ADRESS(page_address);
    LPC_EEPROM->CMD = EEPROM_CMD_ERASE_PRG_PAGE;
    while(!((LPC_EEPROM->INT_STATUS >> EEPROM_ENDOF_PROG)&0x01));
    LPC_EEPROM->INT_CLR_STATUS = (1 << EEPROM_ENDOF_PROG);
}

/*********************************************************************//**
 * @brief         Enable/Disable EEPROM power down mdoe
 * @param[in]    NewState    PowerDown mode state, should be:
 *                     - ENABLE: Enable power down mode
 *                     - DISABLE: Disable power down mode
 * @return         None
 **********************************************************************/
void EEPROM_PowerDown(FunctionalState NewState)
{
    if(NewState == ENABLE)
        LPC_EEPROM->PWRDWN = 0x1;
    else
        LPC_EEPROM->PWRDWN = 0x0;
}

/**
 * @}
 */

/* --------------------------------- End Of File ------------------------------ */

