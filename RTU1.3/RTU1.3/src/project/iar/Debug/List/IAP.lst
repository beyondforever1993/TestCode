###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:22 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\HuaceApp\ #
#                    iap\IAP.c                                                #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\HuaceApp\ #
#                    iap\IAP.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RT #
#                    U_1.2\project\iar\Debug\List\ -o                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\IAP.lst                                    #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\IAP.o                                       #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\HuaceApp\iap\IAP.c
      1          /*****************************************************************************
      2           * $Id$
      3           *
      4           * Project: 	NXP LPC1700 Secondary Bootloader Example
      5           *
      6           * Description: Provides access to In-Application Programming (IAP) routines
      7           * 			    contained within the bootROM sector of LPC1100 devices.
      8           *
      9           * Copyright(C) 2010, NXP Semiconductor
     10           * All rights reserved.
     11           *
     12           *****************************************************************************
     13           * Software that is described herein is for illustrative purposes only
     14           * which provides customers with programming information regarding the
     15           * products. This software is supplied "AS IS" without any warranties.
     16           * NXP Semiconductors assumes no responsibility or liability for the
     17           * use of the software, conveys no license or title under any patent,
     18           * copyright, or mask work right to the product. NXP Semiconductors
     19           * reserves the right to make changes in the software without
     20           * notification. NXP Semiconductors also make no representation or
     21           * warranty that such application will be suitable for the specified
     22           * use without further testing or modification.
     23           *****************************************************************************/
     24          #include "IAP.h"
     25          #include "LPC177x_8x.h"
     26          #include "system_LPC177x_8x.h"
     27          
     28          /* IAP Command Definitions */
     29          #define	IAP_CMD_PREPARE_SECTORS			50
     30          #define	IAP_CMD_COPY_RAM_TO_FLASH		51
     31          #define	IAP_CMD_ERASE_SECTORS			52
     32          #define	IAP_CMD_BLANK_CHECK_SECTORS		53
     33          #define	IAP_CMD_READ_PART_ID			54
     34          #define	IAP_CMD_READ_BOOT_ROM_VERSION	55
     35          #define	IAP_CMD_COMPARE					56
     36          #define	IAP_CMD_REINVOKE_ISP			57
     37          #define IAP_CMD_READ_SERIAL_NUMBER		58
     38          
     39          /*----------------------------------------------------------------------------
     40            Clock Variable definitions
     41           *----------------------------------------------------------------------------*/

   \                                 In section .data, align 4
     42          uint32_t SystemFrequency = IRC_OSC; /*!< System Clock Frequency (Core Clock)  */
   \                     SystemFrequency:
   \   00000000   0x00B71B00         DC32 12000000
     43          
     44          /* IAP boot ROM location and access function */
     45          #define IAP_ROM_LOCATION				0x1FFF1FF1UL
     46          #define IAP_EXECUTE_CMD(a, b)			((void (*)())(IAP_ROM_LOCATION))(a, b)
     47          
     48          /*****************************************************************************
     49          ** Function name:	u32IAP_PrepareSectors
     50          **
     51          ** Description:		Prepares sector(s) for erasing or write operations. This
     52          ** 					command must be executed before executing the "Copy RAM to
     53          ** 					Flash" or "Erase Sector(s)" commands.
     54          **
     55          ** Parameters:		u32StartSector - Number of first sector to prepare.
     56          ** 					u32EndSector - Number of last sector to prepare.
     57          **
     58          ** Returned value:	Status code returned by IAP ROM function.
     59          **
     60          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     61          uint32_t u32IAP_PrepareSectors(uint32_t u32StartSector, uint32_t u32EndSector)
     62          {
   \                     u32IAP_PrepareSectors:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     63          	uint32_t u32Status;
     64          	uint32_t au32Result[5];
     65          	uint32_t au32Command[5];
     66          
     67          	if (u32EndSector < u32StartSector)
   \   00000008   0x42A5             CMP      R5,R4
   \   0000000A   0xD202             BCS.N    ??u32IAP_PrepareSectors_0
     68          	{
     69          		u32Status = IAP_STA_INVALD_PARAM;
   \   0000000C   0x200C             MOVS     R0,#+12
   \   0000000E   0x0006             MOVS     R6,R0
   \   00000010   0xE009             B.N      ??u32IAP_PrepareSectors_1
     70          	}
     71          	else
     72          	{
     73          		au32Command[0] = IAP_CMD_PREPARE_SECTORS;
   \                     ??u32IAP_PrepareSectors_0:
   \   00000012   0x2032             MOVS     R0,#+50
   \   00000014   0x9000             STR      R0,[SP, #+0]
     74          		au32Command[1] = u32StartSector;
   \   00000016   0x9401             STR      R4,[SP, #+4]
     75          		au32Command[2] = u32EndSector;
   \   00000018   0x9502             STR      R5,[SP, #+8]
     76          
     77          		IAP_EXECUTE_CMD(au32Command, au32Result);
   \   0000001A   0xA905             ADD      R1,SP,#+20
   \   0000001C   0xA800             ADD      R0,SP,#+0
   \   0000001E   0x....             LDR.N    R2,??DataTable8  ;; 0x1fff1ff1
   \   00000020   0x4790             BLX      R2
     78          
     79          		u32Status = au32Result[0];
   \   00000022   0x9805             LDR      R0,[SP, #+20]
   \   00000024   0x0006             MOVS     R6,R0
     80          	}
     81          	return u32Status;
   \                     ??u32IAP_PrepareSectors_1:
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0xB00A             ADD      SP,SP,#+40
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
     82          }
     83          
     84          /*****************************************************************************
     85          ** Function name:	u32IAP_CopyRAMToFlash
     86          **
     87          ** Description:		Program the flash memory with data stored in RAM.
     88          **
     89          ** Parameters:	   	u32DstAddr - Destination Flash address, should be a 256
     90          **                               byte boundary.
     91          **			 		u32SrcAddr - Source RAM address, should be a word boundary
     92          **			 		u32Len     - Number of 8-bit bytes to write, must be 256
     93          **								 512, 1024, or 4096.
     94          *
     95          ** Returned value:	Status code returned by IAP ROM function.
     96          **
     97          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     98          uint32_t u32IAP_CopyRAMToFlash(uint32_t u32DstAddr, uint32_t u32SrcAddr, uint32_t u32Len)
     99          {
   \                     u32IAP_CopyRAMToFlash:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    100          	uint32_t au32Result[5];
    101          	uint32_t au32Command[5];
    102          
    103          	au32Command[0] = IAP_CMD_COPY_RAM_TO_FLASH;
   \   0000000A   0x2033             MOVS     R0,#+51
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    104          	au32Command[1] = u32DstAddr;
   \   0000000E   0x9401             STR      R4,[SP, #+4]
    105          	au32Command[2] = u32SrcAddr;
   \   00000010   0x9502             STR      R5,[SP, #+8]
    106          	au32Command[3] = u32Len;
   \   00000012   0x9603             STR      R6,[SP, #+12]
    107          	au32Command[4] = SystemFrequency / 1000UL;	/* Core clock frequency in kHz */
   \   00000014   0x....             LDR.N    R0,??DataTable8_1
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF44F 0x717A      MOV      R1,#+1000
   \   0000001C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000020   0x9004             STR      R0,[SP, #+16]
    108          
    109          	IAP_EXECUTE_CMD(au32Command, au32Result);
   \   00000022   0xA905             ADD      R1,SP,#+20
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x....             LDR.N    R2,??DataTable8  ;; 0x1fff1ff1
   \   00000028   0x4790             BLX      R2
    110          
    111          	return au32Result[0];
   \   0000002A   0x9805             LDR      R0,[SP, #+20]
   \   0000002C   0xB00A             ADD      SP,SP,#+40
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    112          }
    113          
    114          /*****************************************************************************
    115          ** Function name:	u32IAP_EraseSectors
    116          **
    117          ** Description:		Erase a sector or multiple sectors of on-chip Flash memory.
    118          **
    119          ** Parameters:		u32StartSector - Number of first sector to erase.
    120          ** 					u32EndSector - Number of last sector to erase.
    121          *
    122          ** Returned value:	Status code returned by IAP ROM function.
    123          **
    124          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    125          uint32_t u32IAP_EraseSectors(uint32_t u32StartSector, uint32_t u32EndSector)
    126          {
   \                     u32IAP_EraseSectors:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    127          	uint32_t u32Status;
    128          	uint32_t au32Result[5];
    129          	uint32_t au32Command[5];
    130          
    131          	if (u32EndSector < u32StartSector)
   \   00000008   0x42A5             CMP      R5,R4
   \   0000000A   0xD202             BCS.N    ??u32IAP_EraseSectors_0
    132          	{
    133          		u32Status = IAP_STA_INVALD_PARAM;
   \   0000000C   0x200C             MOVS     R0,#+12
   \   0000000E   0x0006             MOVS     R6,R0
   \   00000010   0xE010             B.N      ??u32IAP_EraseSectors_1
    134          	}
    135          	else
    136          	{
    137          		au32Command[0] = IAP_CMD_ERASE_SECTORS;
   \                     ??u32IAP_EraseSectors_0:
   \   00000012   0x2034             MOVS     R0,#+52
   \   00000014   0x9000             STR      R0,[SP, #+0]
    138          		au32Command[1] = u32StartSector;
   \   00000016   0x9401             STR      R4,[SP, #+4]
    139          		au32Command[2] = u32EndSector;
   \   00000018   0x9502             STR      R5,[SP, #+8]
    140          		au32Command[3] = SystemFrequency / 1000UL;	/* Core clock frequency in kHz */
   \   0000001A   0x....             LDR.N    R0,??DataTable8_1
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000022   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000026   0x9003             STR      R0,[SP, #+12]
    141          
    142          		IAP_EXECUTE_CMD(au32Command, au32Result);
   \   00000028   0xA905             ADD      R1,SP,#+20
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x....             LDR.N    R2,??DataTable8  ;; 0x1fff1ff1
   \   0000002E   0x4790             BLX      R2
    143          
    144          		u32Status = au32Result[0];
   \   00000030   0x9805             LDR      R0,[SP, #+20]
   \   00000032   0x0006             MOVS     R6,R0
    145          	}
    146          	return u32Status;
   \                     ??u32IAP_EraseSectors_1:
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0xB00A             ADD      SP,SP,#+40
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    147          }
    148          
    149          /*****************************************************************************
    150          ** Function name:	u32IAP_BlankCheckSectors
    151          **
    152          ** Description:		Blank check a sector or multiple sectors of on-chip flash
    153          ** 					memory.
    154          **
    155          ** Parameters:		u32StartSector - Number of first sector to check.
    156          ** 					u32EndSector - Number of last sector to check.
    157          ** 					pu32Result[0] - Offset of the first non blank word location
    158          **                  if the Status Code is IAP_STA_SECTOR_NOT_BLANK.
    159          ** 					pu32Result[1] - Contents of non blank word location.
    160          **
    161          ** Returned value:	Status code returned by IAP ROM function.
    162          **
    163          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    164          uint32_t u32IAP_BlankCheckSectors(uint32_t u32StartSector, uint32_t u32EndSector, uint32_t *pu32Result)
    165          {
   \                     u32IAP_BlankCheckSectors:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    166          	uint32_t u32Status;
    167          	uint32_t au32Result[5];
    168          	uint32_t au32Command[5];
    169          
    170          	if (u32EndSector < u32StartSector)
   \   0000000A   0x42A5             CMP      R5,R4
   \   0000000C   0xD202             BCS.N    ??u32IAP_BlankCheckSectors_0
    171          	{
    172          		u32Status = IAP_STA_INVALD_PARAM;
   \   0000000E   0x200C             MOVS     R0,#+12
   \   00000010   0x0007             MOVS     R7,R0
   \   00000012   0xE010             B.N      ??u32IAP_BlankCheckSectors_1
    173          	}
    174          	else
    175          	{
    176          		au32Command[0] = IAP_CMD_BLANK_CHECK_SECTORS;
   \                     ??u32IAP_BlankCheckSectors_0:
   \   00000014   0x2035             MOVS     R0,#+53
   \   00000016   0x9000             STR      R0,[SP, #+0]
    177          		au32Command[1] = u32StartSector;
   \   00000018   0x9401             STR      R4,[SP, #+4]
    178          		au32Command[2] = u32EndSector;
   \   0000001A   0x9502             STR      R5,[SP, #+8]
    179          
    180          		IAP_EXECUTE_CMD(au32Command, au32Result);
   \   0000001C   0xA905             ADD      R1,SP,#+20
   \   0000001E   0xA800             ADD      R0,SP,#+0
   \   00000020   0x....             LDR.N    R2,??DataTable8  ;; 0x1fff1ff1
   \   00000022   0x4790             BLX      R2
    181          
    182          		if (au32Result[0] == IAP_STA_SECTOR_NOT_BLANK)
   \   00000024   0x9805             LDR      R0,[SP, #+20]
   \   00000026   0x2808             CMP      R0,#+8
   \   00000028   0xD103             BNE.N    ??u32IAP_BlankCheckSectors_2
    183          		{
    184          			*pu32Result       = au32Result[0];
   \   0000002A   0x9805             LDR      R0,[SP, #+20]
   \   0000002C   0x6030             STR      R0,[R6, #+0]
    185          			*(pu32Result + 1) = au32Result[1];
   \   0000002E   0x9806             LDR      R0,[SP, #+24]
   \   00000030   0x6070             STR      R0,[R6, #+4]
    186          		}
    187          		u32Status = au32Result[0];
   \                     ??u32IAP_BlankCheckSectors_2:
   \   00000032   0x9805             LDR      R0,[SP, #+20]
   \   00000034   0x0007             MOVS     R7,R0
    188          	}
    189          	return u32Status;
   \                     ??u32IAP_BlankCheckSectors_1:
   \   00000036   0x0038             MOVS     R0,R7
   \   00000038   0xB00B             ADD      SP,SP,#+44
   \   0000003A   0xBDF0             POP      {R4-R7,PC}       ;; return
    190          }
    191          
    192          /*****************************************************************************
    193          ** Function name:	u32IAP_ReadPartID
    194          **
    195          ** Description:		Read the part identification number.
    196          **
    197          ** Parameters:		pu32PartID - Pointer to storage for part ID number.
    198          *
    199          ** Returned value:	Status code returned by IAP ROM function.
    200          **
    201          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    202          uint32_t u32IAP_ReadPartID(uint32_t *pu32PartID)
    203          {
   \                     u32IAP_ReadPartID:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    204          	uint32_t au32Result[5];
    205          	uint32_t au32Command[5];
    206          
    207          	au32Command[0] = IAP_CMD_READ_PART_ID;
   \   00000006   0x2036             MOVS     R0,#+54
   \   00000008   0x9000             STR      R0,[SP, #+0]
    208          
    209          	IAP_EXECUTE_CMD(au32Command, au32Result);
   \   0000000A   0xA905             ADD      R1,SP,#+20
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x....             LDR.N    R2,??DataTable8  ;; 0x1fff1ff1
   \   00000010   0x4790             BLX      R2
    210          
    211          	*pu32PartID = au32Result[1];
   \   00000012   0x9806             LDR      R0,[SP, #+24]
   \   00000014   0x6020             STR      R0,[R4, #+0]
    212          
    213          	return au32Result[0];
   \   00000016   0x9805             LDR      R0,[SP, #+20]
   \   00000018   0xB00A             ADD      SP,SP,#+40
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    214          }
    215          
    216          /*****************************************************************************
    217          ** Function name:	u32IAP_ReadBootVersion
    218          **
    219          ** Description:		Read the boot code version number.
    220          **
    221          ** Parameters:		pu32Major - Major version number in ASCII format.
    222          ** 					pu32Minor - Minor version number in ASCII format.
    223          **
    224          ** Returned value:	Status code returned by IAP ROM function.
    225          **
    226          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    227          uint32_t u32IAP_ReadBootVersion(uint32_t *pu32Major, uint32_t *pu32Minor)
    228          {
   \                     u32IAP_ReadBootVersion:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    229          	uint32_t au32Result[5];
    230          	uint32_t au32Command[5];
    231          
    232          	au32Command[0] = IAP_CMD_READ_BOOT_ROM_VERSION;
   \   00000008   0x2037             MOVS     R0,#+55
   \   0000000A   0x9005             STR      R0,[SP, #+20]
    233          
    234          	IAP_EXECUTE_CMD(au32Command, au32Result);
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0xA805             ADD      R0,SP,#+20
   \   00000010   0x....             LDR.N    R2,??DataTable8  ;; 0x1fff1ff1
   \   00000012   0x4790             BLX      R2
    235          
    236          	*pu32Major = (au32Result[1] & 0x0000FF00UL) >> 8;
   \   00000014   0x9801             LDR      R0,[SP, #+4]
   \   00000016   0xF3C0 0x2007      UBFX     R0,R0,#+8,#+8
   \   0000001A   0x6020             STR      R0,[R4, #+0]
    237          	*pu32Minor = au32Result[1] & 0x000000FFUL;
   \   0000001C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x6028             STR      R0,[R5, #+0]
    238          
    239          	return au32Result[0];
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0xB00B             ADD      SP,SP,#+44
   \   00000028   0xBD30             POP      {R4,R5,PC}       ;; return
    240          }
    241          
    242          /*****************************************************************************
    243          ** Function name:	u32IAP_ReadBootVersion
    244          **
    245          ** Description:		Read the boot code version number.
    246          **
    247          ** Parameters:		pu32Major - Major version number in ASCII format.
    248          ** 					pu32Minor - Minor version number in ASCII format.
    249          **
    250          ** Returned value:	Status code returned by IAP ROM function.
    251          **
    252          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    253          void u32IAP_ReadSerialNumber(uint32_t *pu32byte0, uint32_t *pu32byte1,
    254          								 uint32_t *pu32byte2, uint32_t *pu32byte3)
    255          {
   \                     u32IAP_ReadSerialNumber:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    256          	uint32_t au32Result[5];
    257          	uint32_t au32Command[5];
    258          
    259          	au32Command[0] = IAP_CMD_READ_SERIAL_NUMBER;
   \   0000000C   0x203A             MOVS     R0,#+58
   \   0000000E   0x9005             STR      R0,[SP, #+20]
    260          
    261          	IAP_EXECUTE_CMD(au32Command, au32Result);
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0xA805             ADD      R0,SP,#+20
   \   00000014   0x....             LDR.N    R2,??DataTable8  ;; 0x1fff1ff1
   \   00000016   0x4790             BLX      R2
    262          
    263          	*pu32byte0 = au32Result[0];
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x6020             STR      R0,[R4, #+0]
    264          	*pu32byte1 = au32Result[1];
   \   0000001C   0x9801             LDR      R0,[SP, #+4]
   \   0000001E   0x6028             STR      R0,[R5, #+0]
    265          	*pu32byte2 = au32Result[2];
   \   00000020   0x9802             LDR      R0,[SP, #+8]
   \   00000022   0x6030             STR      R0,[R6, #+0]
    266          	*pu32byte3 = au32Result[3];
   \   00000024   0x9803             LDR      R0,[SP, #+12]
   \   00000026   0x6038             STR      R0,[R7, #+0]
    267          
    268          	return;
   \   00000028   0xB00B             ADD      SP,SP,#+44
   \   0000002A   0xBDF0             POP      {R4-R7,PC}       ;; return
    269          }
    270          
    271          /*****************************************************************************
    272          ** Function name:	u32IAP_Compare
    273          **
    274          ** Description:		Compares the memory contents at two locations.
    275          **
    276          ** Parameters:		u32Len - Number of bytes to compare, must be a multiple of 4.
    277          **					pu32Offset - Offset of the first mismatch if the Status Code is COMPARE_ERROR
    278          **
    279          ** Returned value:	Status code returned by IAP ROM function.
    280          **
    281          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    282          uint32_t u32IAP_Compare(uint32_t u32DstAddr, uint32_t u32SrcAddr, uint32_t u32Len, uint32_t *pu32Offset)
    283          {
   \                     u32IAP_Compare:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    284          	uint32_t au32Result[5];
    285          	uint32_t au32Command[5];
    286          
    287          	au32Command[0] = IAP_CMD_COMPARE;
   \   0000000C   0x2038             MOVS     R0,#+56
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    288          	au32Command[1] = u32DstAddr;
   \   00000010   0x9401             STR      R4,[SP, #+4]
    289          	au32Command[2] = u32SrcAddr;
   \   00000012   0x9502             STR      R5,[SP, #+8]
    290          	au32Command[3] = u32Len;
   \   00000014   0x9603             STR      R6,[SP, #+12]
    291          
    292          	IAP_EXECUTE_CMD(au32Command, au32Result);
   \   00000016   0xA905             ADD      R1,SP,#+20
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x....             LDR.N    R2,??DataTable8  ;; 0x1fff1ff1
   \   0000001C   0x4790             BLX      R2
    293          
    294          	if (au32Result[0] == IAP_STA_COMPARE_ERROR)
   \   0000001E   0x9805             LDR      R0,[SP, #+20]
   \   00000020   0x280A             CMP      R0,#+10
   \   00000022   0xD103             BNE.N    ??u32IAP_Compare_0
    295          	{
    296          		if (pu32Offset != 0)
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD001             BEQ.N    ??u32IAP_Compare_0
    297          		{
    298          			*pu32Offset = au32Result[1];
   \   00000028   0x9806             LDR      R0,[SP, #+24]
   \   0000002A   0x6038             STR      R0,[R7, #+0]
    299          		}
    300          	}
    301          	return au32Result[0];
   \                     ??u32IAP_Compare_0:
   \   0000002C   0x9805             LDR      R0,[SP, #+20]
   \   0000002E   0xB00B             ADD      SP,SP,#+44
   \   00000030   0xBDF0             POP      {R4-R7,PC}       ;; return
    302          }
    303          
    304          /*****************************************************************************
    305          ** Function name:	vIAP_ReinvokeISP
    306          **
    307          ** Description:		Invoke the bootloader in ISP mode.
    308          **
    309          ** Parameters:		None.
    310          *
    311          ** Returned value:	None.
    312          **
    313          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    314          void vIAP_ReinvokeISP(void)
    315          {
   \                     vIAP_ReinvokeISP:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    316          	uint32_t au32Result[5];
    317          	uint32_t au32Command[5];
    318          
    319          	au32Command[0] = IAP_CMD_REINVOKE_ISP;
   \   00000004   0x2039             MOVS     R0,#+57
   \   00000006   0x9000             STR      R0,[SP, #+0]
    320          
    321          	IAP_EXECUTE_CMD(au32Command, au32Result);
   \   00000008   0xA905             ADD      R1,SP,#+20
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x....             LDR.N    R2,??DataTable8  ;; 0x1fff1ff1
   \   0000000E   0x4790             BLX      R2
    322          }
   \   00000010   0xB00B             ADD      SP,SP,#+44
   \   00000012   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x1FFF1FF1         DC32     0x1fff1ff1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     SystemFrequency
    323          
    324          /*****************************************************************************
    325           **                            End Of File
    326           *****************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   u32IAP_BlankCheckSectors
        64   -- Indirect call
      64   u32IAP_Compare
        64   -- Indirect call
      56   u32IAP_CopyRAMToFlash
        56   -- Indirect call
      56   u32IAP_EraseSectors
        56   -- Indirect call
      56   u32IAP_PrepareSectors
        56   -- Indirect call
      56   u32IAP_ReadBootVersion
        56   -- Indirect call
      48   u32IAP_ReadPartID
        48   -- Indirect call
      64   u32IAP_ReadSerialNumber
        64   -- Indirect call
      48   vIAP_ReinvokeISP
        48   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  SystemFrequency
      60  u32IAP_BlankCheckSectors
      50  u32IAP_Compare
      48  u32IAP_CopyRAMToFlash
      58  u32IAP_EraseSectors
      44  u32IAP_PrepareSectors
      42  u32IAP_ReadBootVersion
      28  u32IAP_ReadPartID
      44  u32IAP_ReadSerialNumber
      20  vIAP_ReinvokeISP

 
   4 bytes in section .data
 402 bytes in section .text
 
 402 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
