###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      26/Mar/2017  12:36:51 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\桌面\RTU_1.2\bsp\TILT\TILT.c                 #
#    Command line =  D:\wangfan2\桌面\RTU_1.2\bsp\TILT\TILT.c -lCN            #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\List\ -o      #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\Obj\          #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\桌面\RTU_1.2\project\iar\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\ADC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RTC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\TILT\ -I  #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RDLevel\  #
#                    -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RS232\ #
#                     -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\OS-v2 #
#                    \ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\Vibr #
#                    ationString\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\ #
#                    ..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\ucos2\uCOS-II #
#                    \Source\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\u #
#                    cos2\uC-LIB\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\ #
#                    ..\ucos2\uC-CPU\ -I D:\wangfan2\桌面\RTU_1.2\project\iar #
#                    \..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I                #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\cmsis\Drivers #
#                    \source\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\c #
#                    msis\Drivers\include\ -I D:\wangfan2\桌面\RTU_1.2\projec #
#                    t\iar\..\..\app\ -I D:\wangfan2\桌面\RTU_1.2\project\iar #
#                    \..\..\uC-Probe\Target\Plugins\uCOS-II\ -I               #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Workspaces\ -I                            #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Source\ -I D:\wangfan2\桌面\RTU_1.2\proje #
#                    ct\iar\..\..\uC-Probe\Target\Communication\Generic\Sourc #
#                    e\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Prob #
#                    e\Target\Communication\Generic\RS-232\Source\ -I         #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\Ports\NXP\LPC17xx\ -I    #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\OS\uCOS-II\ -I           #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\cmsis\Core\CM #
#                    3\CoreSupport\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\. #
#                    .\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\ -I  #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\DEVI #
#                    CE_BT\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\Hua #
#                    ceApp\DEVICE_COM\ -I D:\wangfan2\桌面\RTU_1.2\project\ia #
#                    r\..\..\HuaceApp\DEVICE_GPRS\ -I                         #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\DEVI #
#                    CE_GPS\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\Hu #
#                    aceApp\DEVICE_RADIO\ -I D:\wangfan2\桌面\RTU_1.2\project #
#                    \iar\..\..\HuaceApp\iap\ -I                              #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\FatFs\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\USB\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\bsp\spi_flash #
#                    \ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp #
#                    \LED\ -On --use_c++_inline                               #
#    List file    =  D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\List\TILT.lst #
#    Object file  =  D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\Obj\TILT.o    #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\桌面\RTU_1.2\bsp\TILT\TILT.c
      1          #include "TILT.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memset
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
      2          #include <RTC.h>
      3          #include <string.h>
      4          #include <stdlib.h>
      5          #include <stdint.h>
      6          #include <stdio.h>
      7          #include <File.h>
      8          

   \                                 In section .bss, align 4
      9          static uint16_t tilt_id[100];
   \                     tilt_id:
   \   00000000                      DS8 200
     10          

   \                                 In section .bss, align 4
     11          static uint8_t  tilt_buf[100];
   \                     tilt_buf:
   \   00000000                      DS8 100
     12          

   \                                 In section .bss, align 1
     13          static uint8_t tilt_cnt;//侧斜仪总数
   \                     tilt_cnt:
   \   00000000                      DS8 1
     14          
     15          /**
     16          
     17          **/

   \                                 In section .text, align 2, keep-with-next
     18          void tilt_init(void)
     19          {
   \                     tilt_init:
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
     20            
     21            uint16_t len;
     22            
     23            /** 初始化变量 **/
     24            
     25            memset(tilt_id,0,sizeof(tilt_id));
   \   00000002   0x22C8             MOVS     R2,#+200
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable2
   \   00000008   0x.... 0x....      BL       memset
     26            
     27            tilt_cnt = 0;
   \   0000000C   0x....             LDR.N    R0,??DataTable2_1
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7001             STRB     R1,[R0, #+0]
     28            
     29            
     30            /** 广播 **/
     31            uint8_t cmd[] = {0x00,0x00,0x00,0x00,0x00,0x23,0xc2,0x41};
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable2_2
   \   00000016   0xC90C             LDM      R1!,{R2,R3}
   \   00000018   0xC00C             STM      R0!,{R2,R3}
   \   0000001A   0x3908             SUBS     R1,R1,#+8
   \   0000001C   0x3808             SUBS     R0,R0,#+8
     32            
     33            GPIO_OutputValue(RS485_OE_PORT,RS485_OE_PIN,1);
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0xF45F 0x2100      MOVS     R1,#+524288
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       GPIO_OutputValue
     34            
     35            SendOutHardware(TILT_PORT_ID , cmd, sizeof(cmd));
   \   0000002A   0x2208             MOVS     R2,#+8
   \   0000002C   0xA900             ADD      R1,SP,#+0
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x.... 0x....      BL       SendOutHardware
     36            
     37            OSTimeDly(10);//50ms
   \   00000034   0x200A             MOVS     R0,#+10
   \   00000036   0x.... 0x....      BL       OSTimeDly
     38            
     39            GPIO_OutputValue(RS485_OE_PORT,RS485_OE_PIN,0);
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0xF45F 0x2100      MOVS     R1,#+524288
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       GPIO_OutputValue
     40            
     41            OSTimeDlyHMSM(0,0,3,0);//3s
   \   00000046   0x2300             MOVS     R3,#+0
   \   00000048   0x2203             MOVS     R2,#+3
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      BL       OSTimeDlyHMSM
     42            
     43            if( g_DeviceGPS.WrSp != g_DeviceGPS.RdSp)
   \   00000052   0x....             LDR.N    R0,??DataTable2_3
   \   00000054   0x8B00             LDRH     R0,[R0, #+24]
   \   00000056   0x....             LDR.N    R1,??DataTable2_3
   \   00000058   0x8B49             LDRH     R1,[R1, #+26]
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD04F             BEQ.N    ??tilt_init_0
     44            {      
     45              uint8_t tilt_idx = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
     46              
     47              while( g_DeviceGPS.RdSp != g_DeviceGPS.WrSp)
   \                     ??tilt_init_1:
   \   00000060   0x....             LDR.N    R1,??DataTable2_3
   \   00000062   0x8B49             LDRH     R1,[R1, #+26]
   \   00000064   0x....             LDR.N    R2,??DataTable2_3
   \   00000066   0x8B12             LDRH     R2,[R2, #+24]
   \   00000068   0x4291             CMP      R1,R2
   \   0000006A   0xD039             BEQ.N    ??tilt_init_2
     48              {
     49                len = 0;
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x000C             MOVS     R4,R1
     50                
     51                for( len = 0; len < 19 ; len++)
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x000C             MOVS     R4,R1
   \                     ??tilt_init_3:
   \   00000074   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000076   0x2C13             CMP      R4,#+19
   \   00000078   0xDA1E             BGE.N    ??tilt_init_4
     52                {
     53                  
     54                  tilt_buf[len] = g_DeviceGPS.Buf[g_DeviceGPS.RdSp];
   \   0000007A   0x....             LDR.N    R1,??DataTable2_3
   \   0000007C   0x8B49             LDRH     R1,[R1, #+26]
   \   0000007E   0x....             LDR.N    R2,??DataTable2_3
   \   00000080   0x6952             LDR      R2,[R2, #+20]
   \   00000082   0x5C89             LDRB     R1,[R1, R2]
   \   00000084   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000086   0x....             LDR.N    R2,??DataTable2_4
   \   00000088   0x54A1             STRB     R1,[R4, R2]
     55                  
     56                  INCREASE_POINTER(g_DeviceGPS.RdSp);
   \   0000008A   0x....             LDR.N    R1,??DataTable2_3
   \   0000008C   0x8B49             LDRH     R1,[R1, #+26]
   \   0000008E   0x1C49             ADDS     R1,R1,#+1
   \   00000090   0x....             LDR.N    R2,??DataTable2_3
   \   00000092   0x8351             STRH     R1,[R2, #+26]
   \   00000094   0x....             LDR.N    R1,??DataTable2_3
   \   00000096   0x8B49             LDRH     R1,[R1, #+26]
   \   00000098   0xF44F 0x6200      MOV      R2,#+2048
   \   0000009C   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   000000A0   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   000000A4   0x....             LDR.N    R1,??DataTable2_3
   \   000000A6   0x834B             STRH     R3,[R1, #+26]
     57                  
     58                  if( g_DeviceGPS.RdSp == g_DeviceGPS.WrSp)
   \   000000A8   0x....             LDR.N    R1,??DataTable2_3
   \   000000AA   0x8B49             LDRH     R1,[R1, #+26]
   \   000000AC   0x....             LDR.N    R2,??DataTable2_3
   \   000000AE   0x8B12             LDRH     R2,[R2, #+24]
   \   000000B0   0x4291             CMP      R1,R2
   \   000000B2   0xD001             BEQ.N    ??tilt_init_4
     59                  {
     60                    break;
     61                  }
     62                
     63                }
   \                     ??tilt_init_5:
   \   000000B4   0x1C64             ADDS     R4,R4,#+1
   \   000000B6   0xE7DD             B.N      ??tilt_init_3
     64                
     65                /** 解析出所有ID **/
     66                if( (tilt_buf[0] == 0x00) && (tilt_buf[1] == 0x16))
   \                     ??tilt_init_4:
   \   000000B8   0x....             LDR.N    R1,??DataTable2_4
   \   000000BA   0x7809             LDRB     R1,[R1, #+0]
   \   000000BC   0x2900             CMP      R1,#+0
   \   000000BE   0xD1CF             BNE.N    ??tilt_init_1
   \   000000C0   0x....             LDR.N    R1,??DataTable2_4
   \   000000C2   0x7849             LDRB     R1,[R1, #+1]
   \   000000C4   0x2916             CMP      R1,#+22
   \   000000C6   0xD1CB             BNE.N    ??tilt_init_1
     67                {
     68                  tilt_id[tilt_idx++] = (tilt_buf[2] << 8) + tilt_buf[3];
   \   000000C8   0x....             LDR.N    R1,??DataTable2_4
   \   000000CA   0x7889             LDRB     R1,[R1, #+2]
   \   000000CC   0x....             LDR.N    R2,??DataTable2_4
   \   000000CE   0x78D2             LDRB     R2,[R2, #+3]
   \   000000D0   0xEB12 0x2101      ADDS     R1,R2,R1, LSL #+8
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0x....             LDR.N    R2,??DataTable2
   \   000000D8   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   000000DC   0x1C40             ADDS     R0,R0,#+1
   \   000000DE   0xE7BF             B.N      ??tilt_init_1
     69                }
     70                
     71              }
     72              
     73              
     74              tilt_cnt = tilt_idx;
   \                     ??tilt_init_2:
   \   000000E0   0x....             LDR.N    R1,??DataTable2_1
   \   000000E2   0x7008             STRB     R0,[R1, #+0]
     75              
     76              if( tilt_cnt == rs485_para.cnt)
   \   000000E4   0x....             LDR.N    R1,??DataTable2_1
   \   000000E6   0x7809             LDRB     R1,[R1, #+0]
   \   000000E8   0x....             LDR.N    R2,??DataTable2_5
   \   000000EA   0x6892             LDR      R2,[R2, #+8]
   \   000000EC   0x4291             CMP      R1,R2
   \   000000EE   0xD102             BNE.N    ??tilt_init_6
     77              {
     78                g_RtuStatus.dist = 1;
   \   000000F0   0x....             LDR.N    R1,??DataTable2_6
   \   000000F2   0x2201             MOVS     R2,#+1
   \   000000F4   0x72CA             STRB     R2,[R1, #+11]
     79              }
     80                    
     81              g_DeviceGPS.RdSp = g_DeviceGPS.WrSp;//清空
   \                     ??tilt_init_6:
   \   000000F6   0x....             LDR.N    R1,??DataTable2_3
   \   000000F8   0x....             LDR.N    R2,??DataTable2_3
   \   000000FA   0x8B12             LDRH     R2,[R2, #+24]
   \   000000FC   0x834A             STRH     R2,[R1, #+26]
     82            }
     83            
     84          }
   \                     ??tilt_init_0:
   \   000000FE   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     85          /**
     86          addr不是真实的地址，只是一个地址索引，从1开始，到rs485_para.cnt
     87          **/

   \                                 In section .text, align 2, keep-with-next
     88          void tilt_quiry(uint32_t addr)
     89          {
   \                     tilt_quiry:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
     90          //  uint8_t cmd[8];
     91          //  uint16_t checksum;
     92          //  
     93          //  if( addr > tilt_cnt)
     94          //    return;
     95          //  
     96          //    cmd[0] = 0x00;
     97          //    cmd[1] = 0x16;
     98          //    cmd[2] = (tilt_id[addr-1] >> 8)&0xff;
     99          //    cmd[3] = tilt_id[addr-1] & 0xff;
    100          //    cmd[4] = 0x01; // function num
    101          //    cmd[5] = 0x00;
    102          //    
    103          //    checksum = crc16_cal(cmd,6);
    104          //    
    105          //    cmd[6] = (checksum >> 8)&0xff;
    106          //    cmd[7] = checksum & 0xff;
    107            
    108              uint8_t cmd[7];
    109            uint16_t checksum;
    110            
    111            if( addr > tilt_cnt)
   \   00000006   0x....             LDR.N    R0,??DataTable2_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x42A0             CMP      R0,R4
   \   0000000C   0xD338             BCC.N    ??tilt_quiry_0
    112              return;
    113            
    114              cmd[0] = 0x00;
   \                     ??tilt_quiry_1:
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    115              cmd[1] = 0x16;
   \   00000014   0x2016             MOVS     R0,#+22
   \   00000016   0xF88D 0x0001      STRB     R0,[SP, #+1]
    116              cmd[2] = (tilt_id[addr-1] >> 8)&0xff;
   \   0000001A   0x....             LDR.N    R0,??DataTable2
   \   0000001C   0xEB10 0x0044      ADDS     R0,R0,R4, LSL #+1
   \   00000020   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   00000024   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000026   0x0A00             LSRS     R0,R0,#+8
   \   00000028   0xF88D 0x0002      STRB     R0,[SP, #+2]
    117              cmd[3] = tilt_id[addr-1] & 0xff;
   \   0000002C   0x....             LDR.N    R0,??DataTable2
   \   0000002E   0xEB10 0x0044      ADDS     R0,R0,R4, LSL #+1
   \   00000032   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   00000036   0xF88D 0x0003      STRB     R0,[SP, #+3]
    118              cmd[4] = 0x01; // function num
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    119              
    120              checksum = crc16_cal(cmd,5);
   \   00000040   0x2105             MOVS     R1,#+5
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       crc16_cal
   \   00000048   0x0005             MOVS     R5,R0
    121              
    122              cmd[5] = (checksum >> 8)&0xff;
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0x0A28             LSRS     R0,R5,#+8
   \   0000004E   0xF88D 0x0005      STRB     R0,[SP, #+5]
    123              cmd[6] = checksum & 0xff;
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0xF88D 0x0006      STRB     R0,[SP, #+6]
    124            
    125            GPIO_OutputValue(RS485_OE_PORT,RS485_OE_PIN,1);
   \   00000058   0x2201             MOVS     R2,#+1
   \   0000005A   0xF45F 0x2100      MOVS     R1,#+524288
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x.... 0x....      BL       GPIO_OutputValue
    126            
    127            SendOutHardware(TILT_PORT_ID , cmd, sizeof(cmd));
   \   00000064   0x2207             MOVS     R2,#+7
   \   00000066   0xA900             ADD      R1,SP,#+0
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0x.... 0x....      BL       SendOutHardware
    128            
    129            OSTimeDly(2);//10ms
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0x.... 0x....      BL       OSTimeDly
    130            
    131            GPIO_OutputValue(RS485_OE_PORT,RS485_OE_PIN,0);
   \   00000074   0x2200             MOVS     R2,#+0
   \   00000076   0xF45F 0x2100      MOVS     R1,#+524288
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x.... 0x....      BL       GPIO_OutputValue
    132            
    133          }
   \                     ??tilt_quiry_0:
   \   00000080   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
    134          void tilt_process(uint8_t* p_pkg,uint32_t len,uint8_t flag)
    135          {
   \                     tilt_process:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB090             SUB      SP,SP,#+64
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    136            
    137            uint16_t check_sum;
    138            
    139            int ang_x,ang_y;
    140            uint16_t tilt_addr;
    141            
    142            /** CRC16 校验 **/
    143            if(len < 23)
   \   0000000C   0x2D17             CMP      R5,#+23
   \   0000000E   0xD377             BCC.N    ??tilt_process_0
    144              return;
    145            
    146            if( p_pkg[4] != 0x81)
   \                     ??tilt_process_1:
   \   00000010   0x7920             LDRB     R0,[R4, #+4]
   \   00000012   0x2881             CMP      R0,#+129
   \   00000014   0xD174             BNE.N    ??tilt_process_0
    147              return;
    148            
    149            check_sum = crc16_cal(p_pkg,21);
   \                     ??tilt_process_2:
   \   00000016   0x2115             MOVS     R1,#+21
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       crc16_cal
   \   0000001E   0x0007             MOVS     R7,R0
    150            
    151            if( check_sum != ((p_pkg[21] << 8)+p_pkg[22]) )
   \   00000020   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000022   0x7D60             LDRB     R0,[R4, #+21]
   \   00000024   0x7DA1             LDRB     R1,[R4, #+22]
   \   00000026   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000002A   0x4287             CMP      R7,R0
   \   0000002C   0xD168             BNE.N    ??tilt_process_0
    152              return;
    153            
    154            /** 状态灯 **/
    155            
    156            g_RtuStatus.led_dwload = 1;
   \                     ??tilt_process_3:
   \   0000002E   0x....             LDR.N    R0,??DataTable2_6
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xF880 0x1037      STRB     R1,[R0, #+55]
    157            
    158            g_RtuStatus.dist = 1;//传感器OK
   \   00000036   0x....             LDR.N    R0,??DataTable2_6
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x72C1             STRB     R1,[R0, #+11]
    159            
    160            
    161            /** 数据保存 **/
    162            
    163            struct DATA_STRUCT dat;
    164            
    165            dat.type = 2;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xF88D 0x000F      STRB     R0,[SP, #+15]
    166            
    167            tilt_addr = (p_pkg[2] << 8)+ p_pkg[3];
   \   00000042   0x78A0             LDRB     R0,[R4, #+2]
   \   00000044   0x78E1             LDRB     R1,[R4, #+3]
   \   00000046   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000004A   0x4682             MOV      R10,R0
    168            
    169            ang_x = (p_pkg[13] << 24) +(p_pkg[14] << 16) +(p_pkg[15] << 8) +(p_pkg[16] << 0);
   \   0000004C   0x7B60             LDRB     R0,[R4, #+13]
   \   0000004E   0x7BA1             LDRB     R1,[R4, #+14]
   \   00000050   0x0409             LSLS     R1,R1,#+16
   \   00000052   0xEB11 0x6000      ADDS     R0,R1,R0, LSL #+24
   \   00000056   0x7BE1             LDRB     R1,[R4, #+15]
   \   00000058   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   0000005C   0x7C21             LDRB     R1,[R4, #+16]
   \   0000005E   0x1808             ADDS     R0,R1,R0
   \   00000060   0x4680             MOV      R8,R0
    170            
    171            ang_y = (p_pkg[17] << 24) +(p_pkg[18] << 16) +(p_pkg[19] << 8) +(p_pkg[20] << 0);
   \   00000062   0x7C60             LDRB     R0,[R4, #+17]
   \   00000064   0x7CA1             LDRB     R1,[R4, #+18]
   \   00000066   0x0409             LSLS     R1,R1,#+16
   \   00000068   0xEB11 0x6000      ADDS     R0,R1,R0, LSL #+24
   \   0000006C   0x7CE1             LDRB     R1,[R4, #+19]
   \   0000006E   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   00000072   0x7D21             LDRB     R1,[R4, #+20]
   \   00000074   0x1808             ADDS     R0,R1,R0
   \   00000076   0x4681             MOV      R9,R0
    172              
    173            sprintf(rs485_para.data,"%s,%d,%d,%d",rs485_para.sname,tilt_addr+80,ang_x,ang_y);
   \   00000078   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   0000007C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000080   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000084   0xF11A 0x0350      ADDS     R3,R10,#+80
   \   00000088   0x....             LDR.N    R2,??DataTable2_7
   \   0000008A   0x....             LDR.N    R1,??DataTable2_8
   \   0000008C   0x....             LDR.N    R0,??DataTable2_9
   \   0000008E   0x.... 0x....      BL       sprintf
    174            
    175            if(flag == 1)
   \   00000092   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000094   0x2E01             CMP      R6,#+1
   \   00000096   0xD133             BNE.N    ??tilt_process_4
    176            {
    177              struct TIME_STRUCT time_now;
    178              
    179              rtc_get_time(&time_now);
   \   00000098   0xA800             ADD      R0,SP,#+0
   \   0000009A   0x.... 0x....      BL       rtc_get_time
    180              
    181              if((time_now.y < 2015) || (time_now.y > 2100))
   \   0000009E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000A2   0xF240 0x71DF      MOVW     R1,#+2015
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xDB05             BLT.N    ??tilt_process_5
   \   000000AA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000AE   0xF640 0x0135      MOVW     R1,#+2101
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xDB00             BLT.N    ??tilt_process_6
    182              {
    183                return;
   \                     ??tilt_process_5:
   \   000000B6   0xE023             B.N      ??tilt_process_0
    184              }
    185              
    186              dat.y = time_now.y;
   \                     ??tilt_process_6:
   \   000000B8   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000BC   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    187              dat.m = time_now.m;
   \   000000C0   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000C4   0xF88D 0x000A      STRB     R0,[SP, #+10]
    188              dat.d = time_now.d;
   \   000000C8   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000CC   0xF88D 0x000B      STRB     R0,[SP, #+11]
    189              dat.H = time_now.H;
   \   000000D0   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000D4   0xF88D 0x000C      STRB     R0,[SP, #+12]
    190              dat.M = time_now.M;
   \   000000D8   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   000000DC   0xF88D 0x000D      STRB     R0,[SP, #+13]
    191              dat.S = time_now.S;
   \   000000E0   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   000000E4   0xF88D 0x000E      STRB     R0,[SP, #+14]
    192              
    193              memcpy(dat.data,rs485_para.data,sizeof(dat.data));
   \   000000E8   0x222A             MOVS     R2,#+42
   \   000000EA   0x....             LDR.N    R1,??DataTable2_9
   \   000000EC   0xA804             ADD      R0,SP,#+16
   \   000000EE   0x.... 0x....      BL       memcpy
    194              
    195              g_RtuStatus.led_dwload = 1;
   \   000000F2   0x....             LDR.N    R0,??DataTable2_6
   \   000000F4   0x2101             MOVS     R1,#+1
   \   000000F6   0xF880 0x1037      STRB     R1,[R0, #+55]
    196              file_write(&dat);
   \   000000FA   0xA802             ADD      R0,SP,#+8
   \   000000FC   0x.... 0x....      BL       file_write
    197            }
    198          }
   \                     ??tilt_process_4:
   \                     ??tilt_process_0:
   \   00000100   0xB010             ADD      SP,SP,#+64
   \   00000102   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     tilt_id

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     tilt_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     `?<Constant {0, 0, 0, 0, 0, 35, 194, 65}>`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     g_DeviceGPS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     tilt_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     rs485_para

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     g_RtuStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x........         DC32     rs485_para+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x........         DC32     `?<Constant "%s,%d,%d,%d">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x........         DC32     rs485_para+0x35

   \                                 In section .rodata, align 4
   \                     `?<Constant {0, 0, 0, 0, 0, 35, 194, 65}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 35, 194, 65
   \              0x00 0x00    
   \              0x00 0x23    
   \              0xC2 0x41    

   \                                 In section .rodata, align 4
   \                     `?<Constant "%s,%d,%d,%d">`:
   \   00000000   0x25 0x73          DC8 "%s,%d,%d,%d"
   \              0x2C 0x25    
   \              0x64 0x2C    
   \              0x25 0x64    
   \              0x2C 0x25    
   \              0x64 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   memcpy
        16   -> __aeabi_memcpy
      16   memset
        16   -> __aeabi_memset
      16   tilt_init
        16   -> GPIO_OutputValue
        16   -> OSTimeDly
        16   -> OSTimeDlyHMSM
        16   -> SendOutHardware
        16   -> memset
      96   tilt_process
        96   -> crc16_cal
        96   -> file_write
        96   -> memcpy
        96   -> rtc_get_time
        96   -> sprintf
      24   tilt_quiry
        24   -> GPIO_OutputValue
        24   -> OSTimeDly
        24   -> SendOutHardware
        24   -> crc16_cal


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "%s,%d,%d,%d">
       8  ?<Constant {0, 0, 0, 0, 0, 35, 194, 65}>
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      22  memcpy
      22  memset
     100  tilt_buf
       1  tilt_cnt
     200  tilt_id
     256  tilt_init
     262  tilt_process
     130  tilt_quiry

 
 301 bytes in section .bss
  20 bytes in section .rodata
 732 bytes in section .text
 
 688 bytes of CODE  memory (+ 44 bytes shared)
  20 bytes of CONST memory
 301 bytes of DATA  memory

Errors: none
Warnings: 1
