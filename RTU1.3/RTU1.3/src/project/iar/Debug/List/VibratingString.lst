###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      10/Jan/2017  15:05:09 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\SVN\Firmware\RTU\代码\RTU_1.2\bsp\Vibrating Wire      #
#                    Transducer\VibratingString.c                             #
#    Command line =  "D:\SVN\Firmware\RTU\代码\RTU_1.2\bsp\Vibrating Wire     #
#                    Transducer\VibratingString.c" -lCN                       #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\Debug\List\ #
#                     -o D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\Debug\O #
#                    bj\ --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\    #
#                    -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\BS #
#                    P\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\.. #
#                    \BSP\ADC\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\ia #
#                    r\..\..\BSP\RTC\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\pro #
#                    ject\iar\..\..\BSP\TILT\ -I                              #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\BSP\R #
#                    DLevel\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\ #
#                    ..\..\BSP\RS232\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\pro #
#                    ject\iar\..\..\BSP\OS-v2\ -I                             #
#                    "D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\BSP\ #
#                    Vibrating Wire Transducer\" -I                           #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\ucos2 #
#                    \uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\ -I             #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\ucos2 #
#                    \uCOS-II\Source\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\pro #
#                    ject\iar\..\..\ucos2\uC-LIB\ -I                          #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\ucos2 #
#                    \uC-CPU\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar #
#                    \..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I                #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\cmsis #
#                    \Drivers\source\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\pro #
#                    ject\iar\..\..\cmsis\Drivers\include\ -I                 #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\app\  #
#                    -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\uC #
#                    -Probe\Target\Plugins\uCOS-II\ -I                        #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\uC-Pr #
#                    obe\Target\Demos\Intro\Workspaces\ -I                    #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\uC-Pr #
#                    obe\Target\Demos\Intro\Source\ -I                        #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\uC-Pr #
#                    obe\Target\Communication\Generic\Source\ -I              #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\uC-Pr #
#                    obe\Target\Communication\Generic\RS-232\Source\ -I       #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\uC-Pr #
#                    obe\Target\Communication\Generic\RS-232\Ports\NXP\LPC17x #
#                    x\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\.. #
#                    \uC-Probe\Target\Communication\Generic\RS-232\OS\uCOS-II #
#                    \ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\ #
#                    cmsis\Core\CM3\CoreSupport\ -I                           #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\cmsis #
#                    \Core\CM3\DeviceSupport\NXP\LPC177x_8x\ -I               #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\Huace #
#                    App\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\ #
#                    ..\HuaceApp\DEVICE_BT\ -I D:\SVN\Firmware\RTU\代码\RTU_1 #
#                    .2\project\iar\..\..\HuaceApp\DEVICE_COM\ -I             #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\Huace #
#                    App\DEVICE_GPRS\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\pro #
#                    ject\iar\..\..\HuaceApp\DEVICE_GPS\ -I                   #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\Huace #
#                    App\DEVICE_RADIO\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\pr #
#                    oject\iar\..\..\HuaceApp\iap\ -I                         #
#                    D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\FatFs #
#                    \ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\..\ #
#                    USB\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\..\ #
#                    ..\bsp\spi_flash\ -I D:\SVN\Firmware\RTU\代码\RTU_1.2\pr #
#                    oject\iar\..\..\HuaceApp\LED\ -On --use_c++_inline       #
#    List file    =  D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\Debug\List\ #
#                    VibratingString.lst                                      #
#    Object file  =  D:\SVN\Firmware\RTU\代码\RTU_1.2\project\iar\Debug\Obj\V #
#                    ibratingString.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

D:\SVN\Firmware\RTU\代码\RTU_1.2\bsp\Vibrating Wire Transducer\VibratingString.c
      1          #include "includes.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable6  ;; 0xe000e100
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0xe000e180
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority:
   \   00000000   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD508             BPL.N    ??NVIC_SetPriority_0
   \   00000006   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000008   0xF010 0x020F      ANDS     R2,R0,#0xF
   \   0000000C   0x....             LDR.N    R3,??DataTable6_2  ;; 0xe000ed18
   \   0000000E   0x18D2             ADDS     R2,R2,R3
   \   00000010   0x00CB             LSLS     R3,R1,#+3
   \   00000012   0xF802 0x3C04      STRB     R3,[R2, #-4]
   \   00000016   0xE003             B.N      ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0:
   \   00000018   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000001A   0x....             LDR.N    R2,??DataTable6_3  ;; 0xe000e400
   \   0000001C   0x00CB             LSLS     R3,R1,#+3
   \   0000001E   0x5483             STRB     R3,[R0, R2]
   \                     ??NVIC_SetPriority_1:
   \   00000020   0x4770             BX       LR               ;; return
      2          
      3          

   \                                 In section .bss, align 1
      4          UINT8 first_capture = 0;
   \                     first_capture:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
      5          UINT8 count = 0;
   \                     count:
   \   00000000                      DS8 1
      6          static void Pwm_SetFre(UINT32 freq);

   \                                 In section .bss, align 4
      7          struct CAPTURE CaptureDat = {0};
   \                     CaptureDat:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
      8          struct SCAN ScanDat = {0};
   \                     ScanDat:
   \   00000000                      DS8 4
      9          
     10          

   \                                 In section .text, align 2, keep-with-next
     11          void Pwm_init()
     12          {
   \                     Pwm_init:
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
     13          	uint32_t MatchVal;
     14          	PWM_TIMERCFG_Type PWMCfgDat;
     15          	PWM_MATCHCFG_Type PWMMatchCfgDat;
     16          	PWM_CAPTURECFG_Type PWMCaptureCfgDat;
     17          	
     18          	GPIO_OutputValue(BRD_PWM_POWER_12V_PORT, BRD_PWM_POWER_12V_MASK, SWITCH_LOW);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xF45F 0x2180      MOVS     R1,#+262144
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       GPIO_OutputValue
     19          
     20          	/* PWM block section -------------------------------------------- */
     21          	/* Initialize PWM peripheral, timer mode
     22          	* PWM prescale value = 1 (absolute value - tick value) */		/*	*/
     23          	PWMCfgDat.PrescaleOption = PWM_TIMER_PRESCALE_TICKVAL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0008      STRB     R0,[SP, #+8]
     24          	PWMCfgDat.PrescaleValue = PRESCALEVALUE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x9003             STR      R0,[SP, #+12]
     25          	PWM_Init(_USING_PWM_NO, PWM_MODE_TIMER, (void *) &PWMCfgDat);
   \   00000018   0xAA02             ADD      R2,SP,#+8
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       PWM_Init
     26          
     27          	// Initialize PWM pin connect
     28          	PINSEL_ConfigPin (PWM_VMT_PORT, PWM_VMT_PIN, 1);
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x.... 0x....      BL       PINSEL_ConfigPin
     29          	// Initialize PWM pin connect
     30          	PINSEL_ConfigPin (PWM_VMT_PORT, PWM_CAP0_PIN, 1);	
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x2106             MOVS     R1,#+6
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0x.... 0x....      BL       PINSEL_ConfigPin
     31          
     32          
     33          	/* Set match value for PWM match channel 0 = 256, update immediately */
     34          	MatchVal = 4294967295;		//2^32
   \   00000036   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000003A   0x0004             MOVS     R4,R0
     35          	PWM_MatchUpdate(_USING_PWM_NO, 0, MatchVal, PWM_MATCH_UPDATE_NOW);
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x0022             MOVS     R2,R4
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x.... 0x....      BL       PWM_MatchUpdate
     36          
     37          	/* PWM Timer/Counter will be reset when channel 0 matching
     38          	* no interrupt when match
     39          	* no stop when match */
     40          	PWMMatchCfgDat.IntOnMatch = ENABLE;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF88D 0x0001      STRB     R0,[SP, #+1]
     41          	PWMMatchCfgDat.MatchChannel = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF88D 0x0000      STRB     R0,[SP, #+0]
     42          	PWMMatchCfgDat.ResetOnMatch = ENABLE;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xF88D 0x0003      STRB     R0,[SP, #+3]
     43          	PWMMatchCfgDat.StopOnMatch = DISABLE;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF88D 0x0002      STRB     R0,[SP, #+2]
     44          	PWM_ConfigMatch(_USING_PWM_NO, &PWMMatchCfgDat);
   \   00000060   0xA900             ADD      R1,SP,#+0
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x.... 0x....      BL       PWM_ConfigMatch
     45          
     46          	/* Configure each PWM channel: --------------------------------------------- */
     47          	/* - Single edge
     48          	* - PWM Duty on each PWM channel determined by
     49          	* the match on channel 0 to the match of that match channel.
     50          	* Example: PWM Duty on PWM channel 1 determined by
     51          	* the match on channel 0 to the match of match channel 1.
     52          	*/
     53          
     54          	/* Configure PWM channel edge option
     55          	* Note: PWM Channel 1 is in single mode as default state and
     56          	* can not be changed to double edge mode */
     57          
     58          
     59          	/* Set up match value */
     60          	
     61          	PWM_MatchUpdate(_USING_PWM_NO, PWM_VMT_CHANNEL, MatchVal/2, PWM_MATCH_UPDATE_NOW);
   \   00000068   0x2300             MOVS     R3,#+0
   \   0000006A   0x0862             LSRS     R2,R4,#+1
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x.... 0x....      BL       PWM_MatchUpdate
     62          
     63          	/* Configure match option */
     64          	PWMMatchCfgDat.IntOnMatch = DISABLE;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF88D 0x0001      STRB     R0,[SP, #+1]
     65          	PWMMatchCfgDat.MatchChannel = PWM_VMT_CHANNEL;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF88D 0x0000      STRB     R0,[SP, #+0]
     66          	PWMMatchCfgDat.ResetOnMatch = DISABLE;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF88D 0x0003      STRB     R0,[SP, #+3]
     67          	PWMMatchCfgDat.StopOnMatch = DISABLE;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF88D 0x0002      STRB     R0,[SP, #+2]
     68          	PWM_ConfigMatch(_USING_PWM_NO, &PWMMatchCfgDat);
   \   0000008C   0xA900             ADD      R1,SP,#+0
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x.... 0x....      BL       PWM_ConfigMatch
     69          	
     70          	PWMCaptureCfgDat.CaptureChannel = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF88D 0x0004      STRB     R0,[SP, #+4]
     71          	PWMCaptureCfgDat.RisingEdge = ENABLE;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xF88D 0x0005      STRB     R0,[SP, #+5]
     72          	PWMCaptureCfgDat.FallingEdge = DISABLE;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF88D 0x0006      STRB     R0,[SP, #+6]
     73          	PWMCaptureCfgDat.IntOnCaption = ENABLE;
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xF88D 0x0007      STRB     R0,[SP, #+7]
     74          	PWM_ConfigCapture(_USING_PWM_NO, &PWMCaptureCfgDat);
   \   000000AC   0xA901             ADD      R1,SP,#+4
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x.... 0x....      BL       PWM_ConfigCapture
     75          
     76          	/* Enable PWM Channel Output */
     77          	PWM_ChannelCmd(_USING_PWM_NO, PWM_VMT_CHANNEL, DISABLE);
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x.... 0x....      BL       PWM_ChannelCmd
     78          
     79          	/* Reset and Start counter */
     80          	PWM_ResetCounter(_USING_PWM_NO);
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x.... 0x....      BL       PWM_ResetCounter
     81          
     82          	PWM_CounterCmd(_USING_PWM_NO, ENABLE);
   \   000000C4   0x2101             MOVS     R1,#+1
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x.... 0x....      BL       PWM_CounterCmd
     83          
     84          	/* Start PWM now */
     85          	//PWM_Cmd(_USING_PWM_NO, ENABLE);
     86              /* preemption = 1, sub-priority = 1 */
     87          	NVIC_SetPriority(PWM1_IRQn, ((0x01<<3)|0x01));
   \   000000CC   0x2109             MOVS     R1,#+9
   \   000000CE   0x2009             MOVS     R0,#+9
   \   000000D0   0x.... 0x....      BL       NVIC_SetPriority
     88          
     89          //	/* Enable interrupt for timer 0 */
     90          //	NVIC_EnableIRQ(PWM1_IRQn);  
     91          }
   \   000000D4   0xBD1F             POP      {R0-R4,PC}       ;; return
     92          

   \                                 In section .text, align 2, keep-with-next
     93          void Pwm_scan_init(void)
     94          {
   \                     Pwm_scan_init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
     95          	uint32_t MatchVal;
     96          	PWM_TIMERCFG_Type PWMCfgDat;
     97          	PWM_MATCHCFG_Type PWMMatchCfgDat;
     98          	
     99          	GPIO_OutputValue(BRD_PWM_POWER_12V_PORT, BRD_PWM_POWER_12V_MASK, SWITCH_LOW);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF45F 0x2180      MOVS     R1,#+262144
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       GPIO_OutputValue
    100          
    101          	/* PWM block section -------------------------------------------- */
    102          	/* Initialize PWM peripheral, timer mode
    103          	* PWM prescale value = 1 (absolute value - tick value) */		/*	*/
    104          	PWMCfgDat.PrescaleOption = PWM_TIMER_PRESCALE_TICKVAL;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0004      STRB     R0,[SP, #+4]
    105          	PWMCfgDat.PrescaleValue = PRESCALEVALUE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x9002             STR      R0,[SP, #+8]
    106          	PWM_Init(_USING_PWM_NO, PWM_MODE_TIMER, (void *) &PWMCfgDat);
   \   0000001A   0xAA01             ADD      R2,SP,#+4
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       PWM_Init
    107          
    108          	// Initialize PWM pin connect
    109          	PINSEL_ConfigPin (PWM_VMT_PORT, PWM_VMT_PIN, 1);
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x.... 0x....      BL       PINSEL_ConfigPin
    110          
    111          
    112          	/* Set match value for PWM match channel 0 = 256, update immediately */
    113          	MatchVal = 10000;
   \   0000002E   0xF242 0x7010      MOVW     R0,#+10000
   \   00000032   0x0004             MOVS     R4,R0
    114          	PWM_MatchUpdate(_USING_PWM_NO, 0, MatchVal, PWM_MATCH_UPDATE_NOW);
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x0022             MOVS     R2,R4
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       PWM_MatchUpdate
    115          
    116          	/* PWM Timer/Counter will be reset when channel 0 matching
    117          	* no interrupt when match
    118          	* no stop when match */
    119          	PWMMatchCfgDat.IntOnMatch = ENABLE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0001      STRB     R0,[SP, #+1]
    120          	PWMMatchCfgDat.MatchChannel = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
    121          	PWMMatchCfgDat.ResetOnMatch = ENABLE;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    122          	PWMMatchCfgDat.StopOnMatch = DISABLE;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF88D 0x0002      STRB     R0,[SP, #+2]
    123          	PWM_ConfigMatch(_USING_PWM_NO, &PWMMatchCfgDat);
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       PWM_ConfigMatch
    124          
    125          	/* Configure each PWM channel: --------------------------------------------- */
    126          	/* - Single edge
    127          	* - PWM Duty on each PWM channel determined by
    128          	* the match on channel 0 to the match of that match channel.
    129          	* Example: PWM Duty on PWM channel 1 determined by
    130          	* the match on channel 0 to the match of match channel 1.
    131          	*/
    132          
    133          	/* Configure PWM channel edge option
    134          	* Note: PWM Channel 1 is in single mode as default state and
    135          	* can not be changed to double edge mode */
    136          
    137          
    138          	/* Set up match value */
    139          	
    140          	PWM_MatchUpdate(_USING_PWM_NO, PWM_VMT_CHANNEL, MatchVal/2, PWM_MATCH_UPDATE_NOW);
   \   00000060   0x2300             MOVS     R3,#+0
   \   00000062   0x0862             LSRS     R2,R4,#+1
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x.... 0x....      BL       PWM_MatchUpdate
    141          
    142          	/* Configure match option */
    143          	PWMMatchCfgDat.IntOnMatch = DISABLE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    144          	PWMMatchCfgDat.MatchChannel = PWM_VMT_CHANNEL;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xF88D 0x0000      STRB     R0,[SP, #+0]
    145          	PWMMatchCfgDat.ResetOnMatch = DISABLE;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    146          	PWMMatchCfgDat.StopOnMatch = DISABLE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF88D 0x0002      STRB     R0,[SP, #+2]
    147          	PWM_ConfigMatch(_USING_PWM_NO, &PWMMatchCfgDat);
   \   00000084   0xA900             ADD      R1,SP,#+0
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x.... 0x....      BL       PWM_ConfigMatch
    148          
    149          	/* Enable PWM Channel Output */
    150          	PWM_ChannelCmd(_USING_PWM_NO, PWM_VMT_CHANNEL, DISABLE);
   \   0000008C   0x2200             MOVS     R2,#+0
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x.... 0x....      BL       PWM_ChannelCmd
    151          
    152          	/* Reset and Start counter */
    153          	PWM_ResetCounter(_USING_PWM_NO);
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x.... 0x....      BL       PWM_ResetCounter
    154          
    155          	PWM_CounterCmd(_USING_PWM_NO, ENABLE);
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x.... 0x....      BL       PWM_CounterCmd
    156          
    157          	/* Start PWM now */
    158          	//PWM_Cmd(_USING_PWM_NO, ENABLE);
    159              /* preemption = 1, sub-priority = 1 */
    160          	NVIC_SetPriority(PWM1_IRQn, ((0x01<<3)|0x01));
   \   000000A4   0x2109             MOVS     R1,#+9
   \   000000A6   0x2009             MOVS     R0,#+9
   \   000000A8   0x.... 0x....      BL       NVIC_SetPriority
    161          
    162          //	/* Enable interrupt for timer 0 */
    163          //	NVIC_EnableIRQ(PWM1_IRQn);  
    164          
    165          }
   \   000000AC   0xBD1F             POP      {R0-R4,PC}       ;; return
    166          

   \                                 In section .text, align 2, keep-with-next
    167          void Pwm_measure_init(void)
    168          {
   \                     Pwm_measure_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    169          	//PWM_COUNTERCFG_Type PWMCfgDat;
    170          	PWM_TIMERCFG_Type PWMCfgDat;
    171          	PWM_CAPTURECFG_Type PWMCaptureCfgDat;
    172          
    173          //	/* PWM block section -------------------------------------------- */
    174          //	/* Initialize PWM peripheral, timer mode
    175          //	* PWM prescale value = 1 (absolute value - tick value) */		/*	*/
    176          //	PWMCfgDat.PrescaleOption = PWM_TIMER_PRESCALE_TICKVAL;
    177          //	PWMCfgDat.PrescaleValue = PRESCALEVALUE;
    178          //	PWM_Init(_USING_PWM_NO, PWM_MODE_TIMER, (void *) &PWMCfgDat);	
    179          
    180          //	// Initialize PWM pin connect
    181          //	PINSEL_ConfigPin (PWM_VMT_PORT, PWM_CAP0_PIN, 1);
    182          	
    183          	PWMCaptureCfgDat.CaptureChannel = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
    184          	PWMCaptureCfgDat.RisingEdge = DISABLE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    185          	PWMCaptureCfgDat.FallingEdge = ENABLE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
    186          	PWMCaptureCfgDat.IntOnCaption = ENABLE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF88D 0x0003      STRB     R0,[SP, #+3]
    187          	
    188          	PWM_ConfigCapture(_USING_PWM_NO, &PWMCaptureCfgDat);
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       PWM_ConfigCapture
    189          
    190          //	/* Enable PWM Channel Output */
    191          //	PWM_ChannelCmd(_USING_PWM_NO, PWM_VMT_CHANNEL, ENABLE);
    192          
    193          	/* Reset and Start counter */
    194          	PWM_ResetCounter(_USING_PWM_NO);
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      BL       PWM_ResetCounter
    195          
    196          //	PWM_CounterCmd(_USING_PWM_NO, ENABLE);
    197          
    198          	/* Start PWM now */
    199          	//PWM_Cmd(_USING_PWM_NO, ENABLE);	
    200          	
    201          //	NVIC_SetPriority(PWM1_IRQn, ((0x01<<3)|0x01));
    202          	NVIC_EnableIRQ(PWM1_IRQn);
   \   00000028   0x2009             MOVS     R0,#+9
   \   0000002A   0x.... 0x....      BL       NVIC_EnableIRQ
    203          	
    204          	CaptureDat.match_cnt = 0;
   \   0000002E   0x....             LDR.N    R0,??DataTable6_4
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6081             STR      R1,[R0, #+8]
    205          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
    206          

   \                                 In section .text, align 2, keep-with-next
    207          void Pwm_measure_Deinit(void)
    208          {
   \                     Pwm_measure_Deinit:
   \   00000000   0xB580             PUSH     {R7,LR}
    209          	PWM_CAPTURECFG_Type PWMCaptureCfgDat;
    210          	
    211          	PWMCaptureCfgDat.CaptureChannel = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
    212          	PWMCaptureCfgDat.RisingEdge = DISABLE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    213          	PWMCaptureCfgDat.FallingEdge = DISABLE;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
    214          	PWMCaptureCfgDat.IntOnCaption = DISABLE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0003      STRB     R0,[SP, #+3]
    215          	PWM_ConfigCapture(_USING_PWM_NO, &PWMCaptureCfgDat);	
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       PWM_ConfigCapture
    216          	
    217          	NVIC_DisableIRQ(PWM1_IRQn);
   \   00000022   0x2009             MOVS     R0,#+9
   \   00000024   0x.... 0x....      BL       NVIC_DisableIRQ
    218          }
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    219          

   \                                 In section .text, align 2, keep-with-next
    220          static void Pwm_SetFre(UINT32 freq)
    221          {
   \                     Pwm_SetFre:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    222          	uint32_t MatchVal;
    223          	
    224          	MatchVal = 60000000/PRESCALEVALUE/freq;		//60074520
   \   00000004   0x....             LDR.N    R0,??DataTable6_5  ;; 0x3938700
   \   00000006   0xFBB0 0xF0F4      UDIV     R0,R0,R4
   \   0000000A   0x0005             MOVS     R5,R0
    225          	PWM_MatchUpdate(_USING_PWM_NO, 0, MatchVal, PWM_MATCH_UPDATE_NOW);
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x002A             MOVS     R2,R5
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       PWM_MatchUpdate
    226          	PWM_MatchUpdate(_USING_PWM_NO, PWM_VMT_CHANNEL, MatchVal/2, PWM_MATCH_UPDATE_NOW);
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x086A             LSRS     R2,R5,#+1
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       PWM_MatchUpdate
    227          }
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    228          

   \                                 In section .text, align 2, keep-with-next
    229          void Pwm_ScanFreq(UINT32 StartFreq,UINT32 EndFreq)
    230          {
   \                     Pwm_ScanFreq:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    231          	UINT32 i,j;
    232          	PWM_MATCHCFG_Type PWMMatchCfgDat;
    233          	
    234          	if(StartFreq > EndFreq)
   \   00000006   0x42A5             CMP      R5,R4
   \   00000008   0xD364             BCC.N    ??Pwm_ScanFreq_0
    235          		return;
    236          	
    237          	GPIO_OutputValue(BRD_PWM_POWER_5V_PORT, BRD_PWM_POWER_5V_MASK, SWITCH_HIGH);
   \                     ??Pwm_ScanFreq_1:
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xF45F 0x2100      MOVS     R1,#+524288
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       GPIO_OutputValue
    238          	
    239          	PWMMatchCfgDat.IntOnMatch = ENABLE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF88D 0x0001      STRB     R0,[SP, #+1]
    240          	PWMMatchCfgDat.MatchChannel = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    241          	PWMMatchCfgDat.ResetOnMatch = ENABLE;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0003      STRB     R0,[SP, #+3]
    242          	PWMMatchCfgDat.StopOnMatch = DISABLE;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    243          	PWM_ConfigMatch(_USING_PWM_NO, &PWMMatchCfgDat);	
   \   0000002E   0xA900             ADD      R1,SP,#+0
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      BL       PWM_ConfigMatch
    244          	
    245          	PWM_ChannelCmd(_USING_PWM_NO, PWM_VMT_CHANNEL, ENABLE);
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       PWM_ChannelCmd
    246          	NVIC_EnableIRQ(PWM1_IRQn); 
   \   00000040   0x2009             MOVS     R0,#+9
   \   00000042   0x.... 0x....      BL       NVIC_EnableIRQ
    247          	for(i=StartFreq;i<EndFreq;i++)
   \   00000046   0x0026             MOVS     R6,R4
   \                     ??Pwm_ScanFreq_2:
   \   00000048   0x42AE             CMP      R6,R5
   \   0000004A   0xD212             BCS.N    ??Pwm_ScanFreq_3
    248          	{
    249          		Pwm_SetFre(i);
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0x.... 0x....      BL       Pwm_SetFre
    250          		ScanDat.match_cnt = 0;
   \   00000052   0x....             LDR.N    R0,??DataTable6_6
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x6001             STR      R1,[R0, #+0]
    251          		for(j=0;j<400000;j++)		//超时控制
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x0007             MOVS     R7,R0
   \                     ??Pwm_ScanFreq_4:
   \   0000005C   0x....             LDR.N    R0,??DataTable6_7  ;; 0x61a80
   \   0000005E   0x4287             CMP      R7,R0
   \   00000060   0xD205             BCS.N    ??Pwm_ScanFreq_5
    252          		{
    253          			if(ScanDat.match_cnt >= 1)		//振动n个周期
   \   00000062   0x....             LDR.N    R0,??DataTable6_6
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD101             BNE.N    ??Pwm_ScanFreq_5
    254          				break;
    255          		}
   \                     ??Pwm_ScanFreq_6:
   \   0000006A   0x1C7F             ADDS     R7,R7,#+1
   \   0000006C   0xE7F6             B.N      ??Pwm_ScanFreq_4
    256          	}
   \                     ??Pwm_ScanFreq_5:
   \   0000006E   0x1C76             ADDS     R6,R6,#+1
   \   00000070   0xE7EA             B.N      ??Pwm_ScanFreq_2
    257          	//PWM_DeInit(_USING_PWM_NO);
    258          	PWM_MatchUpdate(_USING_PWM_NO, PWM_VMT_CHANNEL, 0, PWM_MATCH_UPDATE_NOW);
   \                     ??Pwm_ScanFreq_3:
   \   00000072   0x2300             MOVS     R3,#+0
   \   00000074   0x2200             MOVS     R2,#+0
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x.... 0x....      BL       PWM_MatchUpdate
    259          	OSTimeDlyHMSM(0, 0, 0, 3);
   \   0000007E   0x2303             MOVS     R3,#+3
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      BL       OSTimeDlyHMSM
    260          	PWM_MatchUpdate(_USING_PWM_NO, 0, 4294967295, PWM_MATCH_UPDATE_NOW);
   \   0000008A   0x2300             MOVS     R3,#+0
   \   0000008C   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x.... 0x....      BL       PWM_MatchUpdate
    261          	GPIO_OutputValue(BRD_PWM_POWER_5V_PORT, BRD_PWM_POWER_5V_MASK, SWITCH_LOW);
   \   00000098   0x2200             MOVS     R2,#+0
   \   0000009A   0xF45F 0x2100      MOVS     R1,#+524288
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      BL       GPIO_OutputValue
    262          	
    263          	PWMMatchCfgDat.IntOnMatch = DISABLE;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF88D 0x0001      STRB     R0,[SP, #+1]
    264          	PWMMatchCfgDat.MatchChannel = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    265          	PWMMatchCfgDat.ResetOnMatch = DISABLE;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF88D 0x0003      STRB     R0,[SP, #+3]
    266          	PWMMatchCfgDat.StopOnMatch = DISABLE;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xF88D 0x0002      STRB     R0,[SP, #+2]
    267          	PWM_ConfigMatch(_USING_PWM_NO, &PWMMatchCfgDat);	
   \   000000BC   0xA900             ADD      R1,SP,#+0
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x.... 0x....      BL       PWM_ConfigMatch
    268          	
    269          	NVIC_DisableIRQ(PWM1_IRQn);
   \   000000C4   0x2009             MOVS     R0,#+9
   \   000000C6   0x.... 0x....      BL       NVIC_DisableIRQ
    270          	PWM_ChannelCmd(_USING_PWM_NO, PWM_VMT_CHANNEL, DISABLE);
   \   000000CA   0x2200             MOVS     R2,#+0
   \   000000CC   0x2101             MOVS     R1,#+1
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x.... 0x....      BL       PWM_ChannelCmd
    271          }
   \                     ??Pwm_ScanFreq_0:
   \   000000D4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    272          

   \                                 In section .text, align 2, keep-with-next
    273          void PWM1_IRQHandler()
    274          {
   \                     PWM1_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    275          	if (PWM_GetIntStatus(_USING_PWM_NO, PWM_INTSTAT_CAP0))
   \   00000002   0x2110             MOVS     R1,#+16
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       PWM_GetIntStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD036             BEQ.N    ??PWM1_IRQHandler_0
    276          	{
    277          		/* Clear the interrupt flag */
    278          		CaptureDat.match_cnt++;
   \   0000000E   0x....             LDR.N    R0,??DataTable6_4
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable6_4
   \   00000016   0x6088             STR      R0,[R1, #+8]
    279          		if(CaptureDat.match_cnt <= 10)		//舍弃前10次
   \   00000018   0x....             LDR.N    R0,??DataTable6_4
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x280B             CMP      R0,#+11
   \   0000001E   0xD203             BCS.N    ??PWM1_IRQHandler_1
    280          		{
    281          			PWM_ResetCounter(_USING_PWM_NO);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       PWM_ResetCounter
   \   00000026   0xE025             B.N      ??PWM1_IRQHandler_2
    282          		}
    283          		else if(CaptureDat.match_cnt < 20 )
   \                     ??PWM1_IRQHandler_1:
   \   00000028   0x....             LDR.N    R0,??DataTable6_4
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x2814             CMP      R0,#+20
   \   0000002E   0xD321             BCC.N    ??PWM1_IRQHandler_2
    284          		{}
    285          		else if(CaptureDat.match_cnt == 20 )	//采集10次
   \   00000030   0x....             LDR.N    R0,??DataTable6_4
   \   00000032   0x6880             LDR      R0,[R0, #+8]
   \   00000034   0x2814             CMP      R0,#+20
   \   00000036   0xD117             BNE.N    ??PWM1_IRQHandler_3
    286          		{
    287          			CaptureDat.CaptureVal = PWM_GetCaptureValue(_USING_PWM_NO, 0);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       PWM_GetCaptureValue
   \   00000040   0x....             LDR.N    R1,??DataTable6_4
   \   00000042   0x6008             STR      R0,[R1, #+0]
    288          			PWM_ResetCounter(_USING_PWM_NO);
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x.... 0x....      BL       PWM_ResetCounter
    289          			if(CaptureDat.CaptureVal)
   \   0000004A   0x....             LDR.N    R0,??DataTable6_4
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD006             BEQ.N    ??PWM1_IRQHandler_4
    290          				CaptureDat.freq_Value = 60000000*10/CaptureDat.CaptureVal;
   \   00000052   0x....             LDR.N    R0,??DataTable6_8  ;; 0x23c34600
   \   00000054   0x....             LDR.N    R1,??DataTable6_4
   \   00000056   0x6809             LDR      R1,[R1, #+0]
   \   00000058   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000005C   0x....             LDR.N    R1,??DataTable6_4
   \   0000005E   0x6048             STR      R0,[R1, #+4]
    291          			CaptureDat.match_cnt = 0;
   \                     ??PWM1_IRQHandler_4:
   \   00000060   0x....             LDR.N    R0,??DataTable6_4
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x6081             STR      R1,[R0, #+8]
   \   00000066   0xE005             B.N      ??PWM1_IRQHandler_2
    292          		}
    293          		else
    294          		{
    295          			CaptureDat.match_cnt = 0;
   \                     ??PWM1_IRQHandler_3:
   \   00000068   0x....             LDR.N    R0,??DataTable6_4
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x6081             STR      R1,[R0, #+8]
    296          			PWM_ResetCounter(_USING_PWM_NO);
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x.... 0x....      BL       PWM_ResetCounter
    297          		}
    298          		PWM_ClearIntPending(_USING_PWM_NO, PWM_INTSTAT_CAP0);
   \                     ??PWM1_IRQHandler_2:
   \   00000074   0x2110             MOVS     R1,#+16
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x.... 0x....      BL       PWM_ClearIntPending
    299          	}	
    300          	
    301          	if (PWM_GetIntStatus(_USING_PWM_NO, PWM_INTSTAT_MR0))
   \                     ??PWM1_IRQHandler_0:
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x.... 0x....      BL       PWM_GetIntStatus
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD008             BEQ.N    ??PWM1_IRQHandler_5
    302          	{
    303          		ScanDat.match_cnt++;
   \   00000088   0x....             LDR.N    R0,??DataTable6_6
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \   0000008E   0x....             LDR.N    R1,??DataTable6_6
   \   00000090   0x6008             STR      R0,[R1, #+0]
    304          		PWM_ClearIntPending(_USING_PWM_NO, PWM_INTSTAT_MR0);
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x.... 0x....      BL       PWM_ClearIntPending
    305          	}	
    306          	
    307          }
   \                     ??PWM1_IRQHandler_5:
   \   0000009A   0xBD01             POP      {R0,PC}          ;; return
    308          
    309          //TIM0 25ms

   \                                 In section .text, align 2, keep-with-next
    310          void Pwm_time_handler()
    311          {
    312          //	if (PWM_GetIntStatus(_USING_PWM_NO, PWM_INTSTAT_CAP0))
    313          //	{
    314          //		PWM_ClearIntPending(_USING_PWM_NO, PWM_INTSTAT_CAP0);
    315          //
    316          //		if(first_capture == TRUE)
    317          //		{
    318          //			TIM_Cmd(_MEASURE_TIM, DISABLE);
    319          //
    320          //			PWM_ResetCounter(_USING_PWM_NO);
    321          //
    322          //			//TIM_Cmd(_MEASURE_TIM, ENABLE);
    323          //
    324          //			count++;
    325          //
    326          //			if(count == 5)
    327          //				first_capture = FALSE; //stable
    328          //		}
    329          //		else
    330          //		{
    331          //			count = 0; //reset count for next use
    332          //			CaptureDat.CaptureVal = PWM_GetCaptureValue(_USING_PWM_NO, 0);
    333          //			first_capture = TRUE;
    334          //		}
    335          //	}	
    336          				
    337          //	count++;
    338          //	if(count >= 40)
    339          //	{
    340          //		count = 0;
    341          //		match_cnt = 0;
    342          //	}
    343          }
   \                     Pwm_time_handler:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     CaptureDat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x03938700         DC32     0x3938700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     ScanDat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x00061A80         DC32     0x61a80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x23C34600         DC32     0x23c34600
    344          
    345          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   NVIC_DisableIRQ
       4   NVIC_EnableIRQ
       0   NVIC_SetPriority
       8   PWM1_IRQHandler
         8   -> PWM_ClearIntPending
         8   -> PWM_GetCaptureValue
         8   -> PWM_GetIntStatus
         8   -> PWM_ResetCounter
      24   Pwm_ScanFreq
        24   -> GPIO_OutputValue
        24   -> NVIC_DisableIRQ
        24   -> NVIC_EnableIRQ
        24   -> OSTimeDlyHMSM
        24   -> PWM_ChannelCmd
        24   -> PWM_ConfigMatch
        24   -> PWM_MatchUpdate
        24   -> Pwm_SetFre
      16   Pwm_SetFre
        16   -> PWM_MatchUpdate
      24   Pwm_init
        24   -> GPIO_OutputValue
        24   -> NVIC_SetPriority
        24   -> PINSEL_ConfigPin
        24   -> PWM_ChannelCmd
        24   -> PWM_ConfigCapture
        24   -> PWM_ConfigMatch
        24   -> PWM_CounterCmd
        24   -> PWM_Init
        24   -> PWM_MatchUpdate
        24   -> PWM_ResetCounter
       8   Pwm_measure_Deinit
         8   -> NVIC_DisableIRQ
         8   -> PWM_ConfigCapture
       8   Pwm_measure_init
         8   -> NVIC_EnableIRQ
         8   -> PWM_ConfigCapture
         8   -> PWM_ResetCounter
      24   Pwm_scan_init
        24   -> GPIO_OutputValue
        24   -> NVIC_SetPriority
        24   -> PINSEL_ConfigPin
        24   -> PWM_ChannelCmd
        24   -> PWM_ConfigMatch
        24   -> PWM_CounterCmd
        24   -> PWM_Init
        24   -> PWM_MatchUpdate
        24   -> PWM_ResetCounter
       0   Pwm_time_handler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
      12  CaptureDat
      26  NVIC_DisableIRQ
      26  NVIC_EnableIRQ
      34  NVIC_SetPriority
     156  PWM1_IRQHandler
     214  Pwm_ScanFreq
      38  Pwm_SetFre
     214  Pwm_init
      42  Pwm_measure_Deinit
      54  Pwm_measure_init
     174  Pwm_scan_init
       2  Pwm_time_handler
       4  ScanDat
       1  count
       1  first_capture

 
    18 bytes in section .bss
 1 016 bytes in section .text
 
 1 016 bytes of CODE memory
    18 bytes of DATA memory

Errors: none
Warnings: 1
