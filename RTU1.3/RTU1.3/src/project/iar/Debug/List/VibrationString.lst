###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      26/Mar/2017  12:36:39 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\桌面\RTU_1.2\bsp\VibrationString\VibrationSt #
#                    ring.c                                                   #
#    Command line =  D:\wangfan2\桌面\RTU_1.2\bsp\VibrationString\VibrationSt #
#                    ring.c -lCN D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\L #
#                    ist\ -o D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\Obj\  #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\桌面\RTU_1.2\project\iar\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\ADC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RTC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\TILT\ -I  #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RDLevel\  #
#                    -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RS232\ #
#                     -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\OS-v2 #
#                    \ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\Vibr #
#                    ationString\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\ #
#                    ..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\ucos2\uCOS-II #
#                    \Source\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\u #
#                    cos2\uC-LIB\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\ #
#                    ..\ucos2\uC-CPU\ -I D:\wangfan2\桌面\RTU_1.2\project\iar #
#                    \..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I                #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\cmsis\Drivers #
#                    \source\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\c #
#                    msis\Drivers\include\ -I D:\wangfan2\桌面\RTU_1.2\projec #
#                    t\iar\..\..\app\ -I D:\wangfan2\桌面\RTU_1.2\project\iar #
#                    \..\..\uC-Probe\Target\Plugins\uCOS-II\ -I               #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Workspaces\ -I                            #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Source\ -I D:\wangfan2\桌面\RTU_1.2\proje #
#                    ct\iar\..\..\uC-Probe\Target\Communication\Generic\Sourc #
#                    e\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Prob #
#                    e\Target\Communication\Generic\RS-232\Source\ -I         #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\Ports\NXP\LPC17xx\ -I    #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\OS\uCOS-II\ -I           #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\cmsis\Core\CM #
#                    3\CoreSupport\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\. #
#                    .\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\ -I  #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\DEVI #
#                    CE_BT\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\Hua #
#                    ceApp\DEVICE_COM\ -I D:\wangfan2\桌面\RTU_1.2\project\ia #
#                    r\..\..\HuaceApp\DEVICE_GPRS\ -I                         #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\DEVI #
#                    CE_GPS\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\Hu #
#                    aceApp\DEVICE_RADIO\ -I D:\wangfan2\桌面\RTU_1.2\project #
#                    \iar\..\..\HuaceApp\iap\ -I                              #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\FatFs\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\USB\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\bsp\spi_flash #
#                    \ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp #
#                    \LED\ -On --use_c++_inline                               #
#    List file    =  D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\List\Vibratio #
#                    nString.lst                                              #
#    Object file  =  D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\Obj\Vibration #
#                    String.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\桌面\RTU_1.2\bsp\VibrationString\VibrationString.c
      1          #include "includes.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0xe000e100
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable9_1  ;; 0xe000e180
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority:
   \   00000000   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD509             BPL.N    ??NVIC_SetPriority_0
   \   00000006   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000008   0xF010 0x020F      ANDS     R2,R0,#0xF
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable9_2  ;; 0xe000ed18
   \   00000010   0x18D2             ADDS     R2,R2,R3
   \   00000012   0x00CB             LSLS     R3,R1,#+3
   \   00000014   0xF802 0x3C04      STRB     R3,[R2, #-4]
   \   00000018   0xE004             B.N      ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0:
   \   0000001A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable9_3  ;; 0xe000e400
   \   00000020   0x00CB             LSLS     R3,R1,#+3
   \   00000022   0x5483             STRB     R3,[R0, R2]
   \                     ??NVIC_SetPriority_1:
   \   00000024   0x4770             BX       LR               ;; return
      2          

   \                                 In section .bss, align 4
      3          struct DATA_MEASURE MeasureDat;
   \                     MeasureDat:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
      4          pwm_para_t pwm_para;
   \                     pwm_para:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
      5          static uint32_t pwm_task_timeout;
   \                     pwm_task_timeout:
   \   00000000                      DS8 4
      6          
      7          static void Pwm_SetFre(UINT32 freq);
      8          static void Pwm_measure_init(void);
      9          static void Pwm_measure_Deinit(void);
     10          static void Pwm_ScanFreq(UINT32 StartFreq,UINT32 EndFreq);
     11          static void Stri_measure_section(UINT32 frq_low, UINT32 frq_high);
     12          

   \                                 In section .text, align 2, keep-with-next
     13          void pwm_task(void)
     14          {
   \                     pwm_task:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB09B             SUB      SP,SP,#+108
     15          //	Stri_measure();
     16          //	OSTimeDlyHMSM(0, 0, 8, 0);
     17          	struct DATA_STRUCT dat;
     18          	struct TIME_STRUCT time_now;
     19          
     20                  UINT8 buf[30];
     21          	
     22          	if( pwm_para.frq_changed)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000008   0x7A00             LDRB     R0,[R0, #+8]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00C             BEQ.N    ??pwm_task_0
     23          	{
     24          		pwm_para.frq_changed = 0;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x7201             STRB     R1,[R0, #+8]
     25          		pwm_task_timeout = pwm_para.frq * 2400;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   0000001A   0x6840             LDR      R0,[R0, #+4]
   \   0000001C   0xF44F 0x6116      MOV      R1,#+2400
   \   00000020   0x4348             MULS     R0,R1,R0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   00000026   0x6008             STR      R0,[R1, #+0]
     26          	}	
     27          	
     28          	if(pwm_para.frq != 0)
   \                     ??pwm_task_0:
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD05D             BEQ.N    ??pwm_task_1
     29          	{
     30          		if(pwm_task_timeout ==0)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable9_5
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD158             BNE.N    ??pwm_task_1
     31          		{
     32          			pwm_task_timeout = pwm_para.frq * 2400;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000040   0x6840             LDR      R0,[R0, #+4]
   \   00000042   0xF44F 0x6116      MOV      R1,#+2400
   \   00000046   0x4348             MULS     R0,R1,R0
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   0000004C   0x6008             STR      R0,[R1, #+0]
     33          			rtc_get_time(&time_now);
   \   0000004E   0xA804             ADD      R0,SP,#+16
   \   00000050   0x.... 0x....      BL       rtc_get_time
     34          			
     35          			Stri_measure();
   \   00000054   0x.... 0x....      BL       Stri_measure
     36          			
     37          			dat.y = time_now.y;
   \   00000058   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   0000005C   0xF8AD 0x0018      STRH     R0,[SP, #+24]
     38          			dat.m = time_now.m;
   \   00000060   0xF89D 0x0012      LDRB     R0,[SP, #+18]
   \   00000064   0xF88D 0x001A      STRB     R0,[SP, #+26]
     39          			dat.d = time_now.d;
   \   00000068   0xF89D 0x0013      LDRB     R0,[SP, #+19]
   \   0000006C   0xF88D 0x001B      STRB     R0,[SP, #+27]
     40          			dat.H = time_now.H;
   \   00000070   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   00000074   0xF88D 0x001C      STRB     R0,[SP, #+28]
     41          			dat.M = time_now.M;
   \   00000078   0xF89D 0x0015      LDRB     R0,[SP, #+21]
   \   0000007C   0xF88D 0x001D      STRB     R0,[SP, #+29]
     42          			dat.S = time_now.S;		
   \   00000080   0xF89D 0x0016      LDRB     R0,[SP, #+22]
   \   00000084   0xF88D 0x001E      STRB     R0,[SP, #+30]
     43          			
     44          			dat.type = pwm_para.type;
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF88D 0x001F      STRB     R0,[SP, #+31]
     45          			
     46          			sprintf((char *)dat.data,"%s,%d",pwm_para.sname,pwm_para.freq_Value);
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000096   0x68C3             LDR      R3,[R0, #+12]
   \   00000098   0x.... 0x....      LDR.W    R2,??DataTable9_6
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable9_7
   \   000000A0   0xA808             ADD      R0,SP,#+32
   \   000000A2   0x.... 0x....      BL       sprintf
     47                                                         
     48                                  sprintf(buf,"%04d-%02d-%02d %02d:%02d:%02d\r\n",dat.y,dat.m,dat.d,\
     49                                    dat.H,dat.M,dat.S);
   \   000000A6   0xF89D 0x001E      LDRB     R0,[SP, #+30]
   \   000000AA   0x9003             STR      R0,[SP, #+12]
   \   000000AC   0xF89D 0x001D      LDRB     R0,[SP, #+29]
   \   000000B0   0x9002             STR      R0,[SP, #+8]
   \   000000B2   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \   000000B6   0x9001             STR      R0,[SP, #+4]
   \   000000B8   0xF89D 0x001B      LDRB     R0,[SP, #+27]
   \   000000BC   0x9000             STR      R0,[SP, #+0]
   \   000000BE   0xF89D 0x301A      LDRB     R3,[SP, #+26]
   \   000000C2   0xF8BD 0x2018      LDRH     R2,[SP, #+24]
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable9_8
   \   000000CA   0xA813             ADD      R0,SP,#+76
   \   000000CC   0x.... 0x....      BL       sprintf
     50                                  DebugMsg(buf);
   \   000000D0   0xA813             ADD      R0,SP,#+76
   \   000000D2   0x.... 0x....      BL       DebugMsg
     51          			
     52          			g_RtuStatus.led_dwload = 1;
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \   000000DA   0x2101             MOVS     R1,#+1
   \   000000DC   0xF880 0x1037      STRB     R1,[R0, #+55]
     53          			g_RtuStatus.stri = 1;
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \   000000E4   0x2101             MOVS     R1,#+1
   \   000000E6   0x7301             STRB     R1,[R0, #+12]
     54                                  file_write(&dat);
   \   000000E8   0xA806             ADD      R0,SP,#+24
   \   000000EA   0x.... 0x....      BL       file_write
     55          		}
     56          	}
     57          }
   \                     ??pwm_task_1:
   \   000000EE   0xB01B             ADD      SP,SP,#+108
   \   000000F0   0xBD00             POP      {PC}             ;; return
     58          

   \                                 In section .text, align 2, keep-with-next
     59          void Stri_measure(void)
     60          {
   \                     Stri_measure:
   \   00000000   0xB580             PUSH     {R7,LR}
     61          //总时间2.252411s	间隔446 1393
     62          	Stri_measure_section(846-2,1793+2);
   \   00000002   0xF240 0x7103      MOVW     R1,#+1795
   \   00000006   0xF44F 0x7053      MOV      R0,#+844
   \   0000000A   0x.... 0x....      BL       Stri_measure_section
     63          	if(pwm_para.freq_Value > FRQ_LOW && pwm_para.freq_Value < FRQ_HIGH)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0xF5B0 0x7FC8      CMP      R0,#+400
   \   00000018   0xD90D             BLS.N    ??Stri_measure_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0xF640 0x61D8      MOVW     R1,#+3800
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD206             BCS.N    ??Stri_measure_0
     64          	{
     65          		GPIO_OutputValue(BRD_PWM_SHUTD_PORT, BRD_PWM_SHUTD_MASK, SWITCH_LOW);
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0xF44F 0x5180      MOV      R1,#+4096
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       GPIO_OutputValue
     66          		return;	
   \   00000034   0xE031             B.N      ??Stri_measure_1
     67          	}
     68          	
     69          	Stri_measure_section(1793-2,3800);
   \                     ??Stri_measure_0:
   \   00000036   0xF640 0x61D8      MOVW     R1,#+3800
   \   0000003A   0xF240 0x60FF      MOVW     R0,#+1791
   \   0000003E   0x.... 0x....      BL       Stri_measure_section
     70          	if(pwm_para.freq_Value > FRQ_LOW && pwm_para.freq_Value < FRQ_HIGH)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF5B0 0x7FC8      CMP      R0,#+400
   \   0000004C   0xD90D             BLS.N    ??Stri_measure_2
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000052   0x68C0             LDR      R0,[R0, #+12]
   \   00000054   0xF640 0x61D8      MOVW     R1,#+3800
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD206             BCS.N    ??Stri_measure_2
     71          	{
     72          		GPIO_OutputValue(BRD_PWM_SHUTD_PORT, BRD_PWM_SHUTD_MASK, SWITCH_LOW);
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0xF44F 0x5180      MOV      R1,#+4096
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x.... 0x....      BL       GPIO_OutputValue
     73          		return;	
   \   00000068   0xE017             B.N      ??Stri_measure_1
     74          	}		
     75          	
     76          	Stri_measure_section(400,846+2);
   \                     ??Stri_measure_2:
   \   0000006A   0xF44F 0x7154      MOV      R1,#+848
   \   0000006E   0xF44F 0x70C8      MOV      R0,#+400
   \   00000072   0x.... 0x....      BL       Stri_measure_section
     77          	if(pwm_para.freq_Value > FRQ_LOW && pwm_para.freq_Value < FRQ_HIGH)
   \   00000076   0x....             LDR.N    R0,??DataTable9_4
   \   00000078   0x68C0             LDR      R0,[R0, #+12]
   \   0000007A   0xF5B0 0x7FC8      CMP      R0,#+400
   \   0000007E   0xD90C             BLS.N    ??Stri_measure_3
   \   00000080   0x....             LDR.N    R0,??DataTable9_4
   \   00000082   0x68C0             LDR      R0,[R0, #+12]
   \   00000084   0xF640 0x61D8      MOVW     R1,#+3800
   \   00000088   0x4288             CMP      R0,R1
   \   0000008A   0xD206             BCS.N    ??Stri_measure_3
     78          	{
     79          		GPIO_OutputValue(BRD_PWM_SHUTD_PORT, BRD_PWM_SHUTD_MASK, SWITCH_LOW);
   \   0000008C   0x2200             MOVS     R2,#+0
   \   0000008E   0xF44F 0x5180      MOV      R1,#+4096
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x.... 0x....      BL       GPIO_OutputValue
     80          		return;	
   \   00000098   0xE7FF             B.N      ??Stri_measure_1
     81          	}	
     82          }
   \                     ??Stri_measure_3:
   \                     ??Stri_measure_1:
   \   0000009A   0xBD01             POP      {R0,PC}          ;; return
     83          

   \                                 In section .text, align 2, keep-with-next
     84          static void Stri_measure_section(UINT32 frq_low, UINT32 frq_high)
     85          {
   \                     Stri_measure_section:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     86          	Pwm_ScanFreq(frq_low, frq_high);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Pwm_ScanFreq
     87          	OSTimeDlyHMSM(0, 0, 0, 10);
   \   0000000E   0x230A             MOVS     R3,#+10
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       OSTimeDlyHMSM
     88          	Pwm_measure_init();
   \   0000001A   0x.... 0x....      BL       Pwm_measure_init
     89          	OSTimeDlyHMSM(0, 0, 0, 100);
   \   0000001E   0x2364             MOVS     R3,#+100
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       OSTimeDlyHMSM
     90          	Pwm_measure_Deinit();
   \   0000002A   0x.... 0x....      BL       Pwm_measure_Deinit
     91          }
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     92          

   \                                 In section .text, align 2, keep-with-next
     93          void Pwm_init(void)
     94          {
   \                     Pwm_init:
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
     95          	uint32_t MatchVal;
     96          	PWM_TIMERCFG_Type PWMCfgDat;
     97          	PWM_MATCHCFG_Type PWMMatchCfgDat;
     98          	PWM_CAPTURECFG_Type PWMCaptureCfgDat;
     99          	
    100          	GPIO_OutputValue(BRD_PWM_POWER_12V_PORT, BRD_PWM_POWER_12V_MASK, SWITCH_LOW);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xF45F 0x2180      MOVS     R1,#+262144
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       GPIO_OutputValue
    101          
    102          	/* PWM block section -------------------------------------------- */
    103          	/* Initialize PWM peripheral, timer mode
    104          	* PWM prescale value = 1 (absolute value - tick value) */		/*	*/
    105          	PWMCfgDat.PrescaleOption = PWM_TIMER_PRESCALE_TICKVAL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0008      STRB     R0,[SP, #+8]
    106          	PWMCfgDat.PrescaleValue = PRESCALEVALUE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x9003             STR      R0,[SP, #+12]
    107          	PWM_Init(_USING_PWM_NO, PWM_MODE_TIMER, (void *) &PWMCfgDat);
   \   00000018   0xAA02             ADD      R2,SP,#+8
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       PWM_Init
    108          
    109          	// Initialize PWM pin connect
    110          	PINSEL_ConfigPin (PWM_VMT_PORT, PWM_VMT_PIN, 1);
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x.... 0x....      BL       PINSEL_ConfigPin
    111          	// Initialize PWM pin connect
    112          	PINSEL_ConfigPin (PWM_VMT_PORT, PWM_CAP0_PIN, 1);	
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x2106             MOVS     R1,#+6
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0x.... 0x....      BL       PINSEL_ConfigPin
    113          
    114          
    115          	/* Set match value for PWM match channel 0 = 256, update immediately */
    116          	MatchVal = 4294967295;		//2^32
   \   00000036   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000003A   0x0004             MOVS     R4,R0
    117          	PWM_MatchUpdate(_USING_PWM_NO, 0, MatchVal, PWM_MATCH_UPDATE_NOW);
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x0022             MOVS     R2,R4
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x.... 0x....      BL       PWM_MatchUpdate
    118          
    119          	/* PWM Timer/Counter will be reset when channel 0 matching
    120          	* no interrupt when match
    121          	* no stop when match */
    122          	PWMMatchCfgDat.IntOnMatch = ENABLE;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    123          	PWMMatchCfgDat.MatchChannel = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF88D 0x0000      STRB     R0,[SP, #+0]
    124          	PWMMatchCfgDat.ResetOnMatch = ENABLE;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xF88D 0x0003      STRB     R0,[SP, #+3]
    125          	PWMMatchCfgDat.StopOnMatch = DISABLE;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    126          	PWM_ConfigMatch(_USING_PWM_NO, &PWMMatchCfgDat);
   \   00000060   0xA900             ADD      R1,SP,#+0
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x.... 0x....      BL       PWM_ConfigMatch
    127          
    128          	/* Configure each PWM channel: --------------------------------------------- */
    129          	/* - Single edge
    130          	* - PWM Duty on each PWM channel determined by
    131          	* the match on channel 0 to the match of that match channel.
    132          	* Example: PWM Duty on PWM channel 1 determined by
    133          	* the match on channel 0 to the match of match channel 1.
    134          	*/
    135          
    136          	/* Configure PWM channel edge option
    137          	* Note: PWM Channel 1 is in single mode as default state and
    138          	* can not be changed to double edge mode */
    139          
    140          
    141          	/* Set up match value */
    142          	
    143          	PWM_MatchUpdate(_USING_PWM_NO, PWM_VMT_CHANNEL, MatchVal/2, PWM_MATCH_UPDATE_NOW);
   \   00000068   0x2300             MOVS     R3,#+0
   \   0000006A   0x0862             LSRS     R2,R4,#+1
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x.... 0x....      BL       PWM_MatchUpdate
    144          
    145          	/* Configure match option */
    146          	PWMMatchCfgDat.IntOnMatch = DISABLE;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF88D 0x0001      STRB     R0,[SP, #+1]
    147          	PWMMatchCfgDat.MatchChannel = PWM_VMT_CHANNEL;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    148          	PWMMatchCfgDat.ResetOnMatch = DISABLE;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF88D 0x0003      STRB     R0,[SP, #+3]
    149          	PWMMatchCfgDat.StopOnMatch = DISABLE;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF88D 0x0002      STRB     R0,[SP, #+2]
    150          	PWM_ConfigMatch(_USING_PWM_NO, &PWMMatchCfgDat);
   \   0000008C   0xA900             ADD      R1,SP,#+0
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x.... 0x....      BL       PWM_ConfigMatch
    151          	
    152          	PWMCaptureCfgDat.CaptureChannel = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF88D 0x0004      STRB     R0,[SP, #+4]
    153          	PWMCaptureCfgDat.RisingEdge = ENABLE;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    154          	PWMCaptureCfgDat.FallingEdge = DISABLE;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF88D 0x0006      STRB     R0,[SP, #+6]
    155          	PWMCaptureCfgDat.IntOnCaption = ENABLE;
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xF88D 0x0007      STRB     R0,[SP, #+7]
    156          	PWM_ConfigCapture(_USING_PWM_NO, &PWMCaptureCfgDat);
   \   000000AC   0xA901             ADD      R1,SP,#+4
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x.... 0x....      BL       PWM_ConfigCapture
    157          
    158          	/* Enable PWM Channel Output */
    159          	PWM_ChannelCmd(_USING_PWM_NO, PWM_VMT_CHANNEL, DISABLE);
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x.... 0x....      BL       PWM_ChannelCmd
    160          
    161          	/* Reset and Start counter */
    162          	PWM_ResetCounter(_USING_PWM_NO);
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x.... 0x....      BL       PWM_ResetCounter
    163          
    164          	PWM_CounterCmd(_USING_PWM_NO, ENABLE);
   \   000000C4   0x2101             MOVS     R1,#+1
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x.... 0x....      BL       PWM_CounterCmd
    165          
    166          	/* Start PWM now */
    167          	//PWM_Cmd(_USING_PWM_NO, ENABLE);
    168              /* preemption = 1, sub-priority = 1 */
    169          	NVIC_SetPriority(PWM1_IRQn, ((0x01<<3)|0x01));
   \   000000CC   0x2109             MOVS     R1,#+9
   \   000000CE   0x2009             MOVS     R0,#+9
   \   000000D0   0x.... 0x....      BL       NVIC_SetPriority
    170          
    171          //	/* Enable interrupt for timer 0 */
    172          //	NVIC_EnableIRQ(PWM1_IRQn);  
    173          }
   \   000000D4   0xBD1F             POP      {R0-R4,PC}       ;; return
    174          

   \                                 In section .text, align 2, keep-with-next
    175          static void Pwm_measure_init(void)
    176          {
   \                     Pwm_measure_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    177          	//PWM_COUNTERCFG_Type PWMCfgDat;
    178          	PWM_CAPTURECFG_Type PWMCaptureCfgDat;
    179          
    180          //	/* PWM block section -------------------------------------------- */
    181          //	/* Initialize PWM peripheral, timer mode
    182          //	* PWM prescale value = 1 (absolute value - tick value) */		/*	*/
    183          //	PWMCfgDat.PrescaleOption = PWM_TIMER_PRESCALE_TICKVAL;
    184          //	PWMCfgDat.PrescaleValue = PRESCALEVALUE;
    185          //	PWM_Init(_USING_PWM_NO, PWM_MODE_TIMER, (void *) &PWMCfgDat);	
    186          
    187          //	// Initialize PWM pin connect
    188          //	PINSEL_ConfigPin (PWM_VMT_PORT, PWM_CAP0_PIN, 1);
    189          	
    190          	PWMCaptureCfgDat.CaptureChannel = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
    191          	PWMCaptureCfgDat.RisingEdge = DISABLE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    192          	PWMCaptureCfgDat.FallingEdge = ENABLE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
    193          	PWMCaptureCfgDat.IntOnCaption = ENABLE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF88D 0x0003      STRB     R0,[SP, #+3]
    194          	
    195          	PWM_ConfigCapture(_USING_PWM_NO, &PWMCaptureCfgDat);
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       PWM_ConfigCapture
    196          
    197          //	/* Enable PWM Channel Output */
    198          //	PWM_ChannelCmd(_USING_PWM_NO, PWM_VMT_CHANNEL, ENABLE);
    199          
    200          	/* Reset and Start counter */
    201          	PWM_ResetCounter(_USING_PWM_NO);
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      BL       PWM_ResetCounter
    202          
    203          //	PWM_CounterCmd(_USING_PWM_NO, ENABLE);
    204          
    205          	/* Start PWM now */
    206          	//PWM_Cmd(_USING_PWM_NO, ENABLE);	
    207          	
    208          //	NVIC_SetPriority(PWM1_IRQn, ((0x01<<3)|0x01));
    209          	NVIC_EnableIRQ(PWM1_IRQn);
   \   00000028   0x2009             MOVS     R0,#+9
   \   0000002A   0x.... 0x....      BL       NVIC_EnableIRQ
    210          	
    211          	MeasureDat.CapMatch_cnt = 0;
   \   0000002E   0x....             LDR.N    R0,??DataTable9_10
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6041             STR      R1,[R0, #+4]
    212          	pwm_para.freq_Value = 0;
   \   00000034   0x....             LDR.N    R0,??DataTable9_4
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x60C1             STR      R1,[R0, #+12]
    213          }
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    214          

   \                                 In section .text, align 2, keep-with-next
    215          static void Pwm_measure_Deinit(void)
    216          {
   \                     Pwm_measure_Deinit:
   \   00000000   0xB580             PUSH     {R7,LR}
    217          	PWM_CAPTURECFG_Type PWMCaptureCfgDat;
    218          	
    219          	PWMCaptureCfgDat.CaptureChannel = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
    220          	PWMCaptureCfgDat.RisingEdge = DISABLE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    221          	PWMCaptureCfgDat.FallingEdge = DISABLE;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
    222          	PWMCaptureCfgDat.IntOnCaption = DISABLE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0003      STRB     R0,[SP, #+3]
    223          	PWM_ConfigCapture(_USING_PWM_NO, &PWMCaptureCfgDat);	
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       PWM_ConfigCapture
    224          	
    225          	NVIC_DisableIRQ(PWM1_IRQn);
   \   00000022   0x2009             MOVS     R0,#+9
   \   00000024   0x.... 0x....      BL       NVIC_DisableIRQ
    226          }
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    227          

   \                                 In section .text, align 2, keep-with-next
    228          static void Pwm_SetFre(UINT32 freq)
    229          {
   \                     Pwm_SetFre:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    230          	uint32_t MatchVal;
    231          	
    232          	MatchVal = 60000000/PRESCALEVALUE/freq;
   \   00000004   0x....             LDR.N    R0,??DataTable9_11  ;; 0x3938700
   \   00000006   0xFBB0 0xF0F4      UDIV     R0,R0,R4
   \   0000000A   0x0005             MOVS     R5,R0
    233          	PWM_MatchUpdate(_USING_PWM_NO, 0, MatchVal, PWM_MATCH_UPDATE_NOW);
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x002A             MOVS     R2,R5
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       PWM_MatchUpdate
    234          	PWM_MatchUpdate(_USING_PWM_NO, PWM_VMT_CHANNEL, MatchVal/2, PWM_MATCH_UPDATE_NOW);
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x086A             LSRS     R2,R5,#+1
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       PWM_MatchUpdate
    235          }
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    236          

   \                                 In section .text, align 2, keep-with-next
    237          static void Pwm_ScanFreq(UINT32 StartFreq,UINT32 EndFreq)
    238          {
   \                     Pwm_ScanFreq:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    239          	UINT32 i,j;
    240          	PWM_MATCHCFG_Type PWMMatchCfgDat;
    241          	
    242          	if(StartFreq > EndFreq)
   \   00000006   0x42A5             CMP      R5,R4
   \   00000008   0xD373             BCC.N    ??Pwm_ScanFreq_0
    243          		return;
    244          	
    245          	GPIO_OutputValue(BRD_PWM_POWER_5V_PORT, BRD_PWM_POWER_5V_MASK, SWITCH_HIGH);
   \                     ??Pwm_ScanFreq_1:
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xF45F 0x2100      MOVS     R1,#+524288
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       GPIO_OutputValue
    246          	GPIO_OutputValue(BRD_PWM_SHUTD_PORT, BRD_PWM_SHUTD_MASK, SWITCH_LOW);
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0xF44F 0x5180      MOV      R1,#+4096
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       GPIO_OutputValue
    247                  
    248          	
    249          	PWMMatchCfgDat.IntOnMatch = ENABLE;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0001      STRB     R0,[SP, #+1]
    250          	PWMMatchCfgDat.MatchChannel = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    251          	PWMMatchCfgDat.ResetOnMatch = ENABLE;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0003      STRB     R0,[SP, #+3]
    252          	PWMMatchCfgDat.StopOnMatch = DISABLE;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0002      STRB     R0,[SP, #+2]
    253          	PWM_ConfigMatch(_USING_PWM_NO, &PWMMatchCfgDat);	
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       PWM_ConfigMatch
    254          	
    255          	PWM_ChannelCmd(_USING_PWM_NO, PWM_VMT_CHANNEL, ENABLE);
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       PWM_ChannelCmd
    256          	NVIC_EnableIRQ(PWM1_IRQn); 
   \   0000004C   0x2009             MOVS     R0,#+9
   \   0000004E   0x.... 0x....      BL       NVIC_EnableIRQ
    257          	for(i=StartFreq-2;i<EndFreq+2;i++)
   \   00000052   0x1EA0             SUBS     R0,R4,#+2
   \   00000054   0x0006             MOVS     R6,R0
   \                     ??Pwm_ScanFreq_2:
   \   00000056   0x1CA8             ADDS     R0,R5,#+2
   \   00000058   0x4286             CMP      R6,R0
   \   0000005A   0xD213             BCS.N    ??Pwm_ScanFreq_3
    258          	{
    259          		Pwm_SetFre(i);
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0x.... 0x....      BL       Pwm_SetFre
    260          		MeasureDat.ScanMatch_cnt = 0;
   \   00000062   0x....             LDR.N    R0,??DataTable9_10
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x6081             STR      R1,[R0, #+8]
    261          		for(j=0;j<60000;j++)		//超时控制,约6-8个周期
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x0007             MOVS     R7,R0
   \                     ??Pwm_ScanFreq_4:
   \   0000006C   0xF64E 0x2060      MOVW     R0,#+60000
   \   00000070   0x4287             CMP      R7,R0
   \   00000072   0xD205             BCS.N    ??Pwm_ScanFreq_5
    262          		{
    263          			if(MeasureDat.ScanMatch_cnt >= 1)		//振动n个周期
   \   00000074   0x....             LDR.N    R0,??DataTable9_10
   \   00000076   0x6880             LDR      R0,[R0, #+8]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD101             BNE.N    ??Pwm_ScanFreq_5
    264          				break;
    265          		}
   \                     ??Pwm_ScanFreq_6:
   \   0000007C   0x1C7F             ADDS     R7,R7,#+1
   \   0000007E   0xE7F5             B.N      ??Pwm_ScanFreq_4
    266          	}
   \                     ??Pwm_ScanFreq_5:
   \   00000080   0x1C76             ADDS     R6,R6,#+1
   \   00000082   0xE7E8             B.N      ??Pwm_ScanFreq_2
    267          	//PWM_DeInit(_USING_PWM_NO);
    268          	PWM_MatchUpdate(_USING_PWM_NO, PWM_VMT_CHANNEL, 0, PWM_MATCH_UPDATE_NOW);
   \                     ??Pwm_ScanFreq_3:
   \   00000084   0x2300             MOVS     R3,#+0
   \   00000086   0x2200             MOVS     R2,#+0
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      BL       PWM_MatchUpdate
    269          	OSTimeDlyHMSM(0, 0, 0, 3);
   \   00000090   0x2303             MOVS     R3,#+3
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x.... 0x....      BL       OSTimeDlyHMSM
    270          	PWM_MatchUpdate(_USING_PWM_NO, 0, 4294967295, PWM_MATCH_UPDATE_NOW);
   \   0000009C   0x2300             MOVS     R3,#+0
   \   0000009E   0xF05F 0x32FF      MOVS     R2,#-1
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x.... 0x....      BL       PWM_MatchUpdate
    271          	GPIO_OutputValue(BRD_PWM_POWER_5V_PORT, BRD_PWM_POWER_5V_MASK, SWITCH_LOW);
   \   000000AA   0x2200             MOVS     R2,#+0
   \   000000AC   0xF45F 0x2100      MOVS     R1,#+524288
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x.... 0x....      BL       GPIO_OutputValue
    272          	GPIO_OutputValue(BRD_PWM_SHUTD_PORT, BRD_PWM_SHUTD_MASK, SWITCH_HIGH);
   \   000000B6   0x2201             MOVS     R2,#+1
   \   000000B8   0xF44F 0x5180      MOV      R1,#+4096
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0x.... 0x....      BL       GPIO_OutputValue
    273                  
    274          //        GPIO_OutputValue((3),(1<<(11)),SWITCH_HIGH);
    275          	
    276          	PWMMatchCfgDat.IntOnMatch = DISABLE;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF88D 0x0001      STRB     R0,[SP, #+1]
    277          	PWMMatchCfgDat.MatchChannel = 0;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    278          	PWMMatchCfgDat.ResetOnMatch = DISABLE;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xF88D 0x0003      STRB     R0,[SP, #+3]
    279          	PWMMatchCfgDat.StopOnMatch = DISABLE;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF88D 0x0002      STRB     R0,[SP, #+2]
    280          	PWM_ConfigMatch(_USING_PWM_NO, &PWMMatchCfgDat);	
   \   000000DA   0xA900             ADD      R1,SP,#+0
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0x.... 0x....      BL       PWM_ConfigMatch
    281          	
    282          	NVIC_DisableIRQ(PWM1_IRQn);
   \   000000E2   0x2009             MOVS     R0,#+9
   \   000000E4   0x.... 0x....      BL       NVIC_DisableIRQ
    283          	PWM_ChannelCmd(_USING_PWM_NO, PWM_VMT_CHANNEL, DISABLE);
   \   000000E8   0x2200             MOVS     R2,#+0
   \   000000EA   0x2101             MOVS     R1,#+1
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0x.... 0x....      BL       PWM_ChannelCmd
    284          }
   \                     ??Pwm_ScanFreq_0:
   \   000000F2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    285          

   \                                 In section .text, align 2, keep-with-next
    286          void PWM1_IRQHandler(void)
    287          {
   \                     PWM1_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    288          	if (PWM_GetIntStatus(_USING_PWM_NO, PWM_INTSTAT_CAP0))
   \   00000002   0x2110             MOVS     R1,#+16
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       PWM_GetIntStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD036             BEQ.N    ??PWM1_IRQHandler_0
    289          	{
    290          		/* Clear the interrupt flag */
    291          		MeasureDat.CapMatch_cnt++;
   \   0000000E   0x....             LDR.N    R0,??DataTable9_10
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable9_10
   \   00000016   0x6048             STR      R0,[R1, #+4]
    292          		if(MeasureDat.CapMatch_cnt <= 10)		//舍弃前10次
   \   00000018   0x....             LDR.N    R0,??DataTable9_10
   \   0000001A   0x6840             LDR      R0,[R0, #+4]
   \   0000001C   0x280B             CMP      R0,#+11
   \   0000001E   0xD203             BCS.N    ??PWM1_IRQHandler_1
    293          		{
    294          			PWM_ResetCounter(_USING_PWM_NO);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       PWM_ResetCounter
   \   00000026   0xE025             B.N      ??PWM1_IRQHandler_2
    295          		}
    296          		else if(MeasureDat.CapMatch_cnt < 20 )
   \                     ??PWM1_IRQHandler_1:
   \   00000028   0x....             LDR.N    R0,??DataTable9_10
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x2814             CMP      R0,#+20
   \   0000002E   0xD321             BCC.N    ??PWM1_IRQHandler_2
    297          		{}
    298          		else if(MeasureDat.CapMatch_cnt == 20 )	//采集10次
   \   00000030   0x....             LDR.N    R0,??DataTable9_10
   \   00000032   0x6840             LDR      R0,[R0, #+4]
   \   00000034   0x2814             CMP      R0,#+20
   \   00000036   0xD117             BNE.N    ??PWM1_IRQHandler_3
    299          		{
    300          			MeasureDat.CaptureVal = PWM_GetCaptureValue(_USING_PWM_NO, 0);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       PWM_GetCaptureValue
   \   00000040   0x....             LDR.N    R1,??DataTable9_10
   \   00000042   0x6008             STR      R0,[R1, #+0]
    301          			PWM_ResetCounter(_USING_PWM_NO);
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x.... 0x....      BL       PWM_ResetCounter
    302          			if(MeasureDat.CaptureVal)
   \   0000004A   0x....             LDR.N    R0,??DataTable9_10
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD006             BEQ.N    ??PWM1_IRQHandler_4
    303          				pwm_para.freq_Value = 60000000*10/MeasureDat.CaptureVal;
   \   00000052   0x....             LDR.N    R0,??DataTable9_12  ;; 0x23c34600
   \   00000054   0x....             LDR.N    R1,??DataTable9_10
   \   00000056   0x6809             LDR      R1,[R1, #+0]
   \   00000058   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000005C   0x....             LDR.N    R1,??DataTable9_4
   \   0000005E   0x60C8             STR      R0,[R1, #+12]
    304          			MeasureDat.CapMatch_cnt = 0;
   \                     ??PWM1_IRQHandler_4:
   \   00000060   0x....             LDR.N    R0,??DataTable9_10
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x6041             STR      R1,[R0, #+4]
   \   00000066   0xE005             B.N      ??PWM1_IRQHandler_2
    305          		}
    306          		else
    307          		{
    308          			MeasureDat.CapMatch_cnt = 0;
   \                     ??PWM1_IRQHandler_3:
   \   00000068   0x....             LDR.N    R0,??DataTable9_10
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x6041             STR      R1,[R0, #+4]
    309          			PWM_ResetCounter(_USING_PWM_NO);
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x.... 0x....      BL       PWM_ResetCounter
    310          		}
    311          		PWM_ClearIntPending(_USING_PWM_NO, PWM_INTSTAT_CAP0);
   \                     ??PWM1_IRQHandler_2:
   \   00000074   0x2110             MOVS     R1,#+16
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x.... 0x....      BL       PWM_ClearIntPending
    312          	}	
    313          	
    314          	if (PWM_GetIntStatus(_USING_PWM_NO, PWM_INTSTAT_MR0))
   \                     ??PWM1_IRQHandler_0:
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x.... 0x....      BL       PWM_GetIntStatus
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD008             BEQ.N    ??PWM1_IRQHandler_5
    315          	{
    316          		MeasureDat.ScanMatch_cnt++;
   \   00000088   0x....             LDR.N    R0,??DataTable9_10
   \   0000008A   0x6880             LDR      R0,[R0, #+8]
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \   0000008E   0x....             LDR.N    R1,??DataTable9_10
   \   00000090   0x6088             STR      R0,[R1, #+8]
    317          		PWM_ClearIntPending(_USING_PWM_NO, PWM_INTSTAT_MR0);
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x.... 0x....      BL       PWM_ClearIntPending
    318          	}	
    319          	
    320          }
   \                     ??PWM1_IRQHandler_5:
   \   0000009A   0xBD01             POP      {R0,PC}          ;; return
    321          

   \                                 In section .text, align 2, keep-with-next
    322          void pwm_timer_handler(void)
    323          {
    324          	if( pwm_task_timeout > 0)
   \                     pwm_timer_handler:
   \   00000000   0x....             LDR.N    R0,??DataTable9_5
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD004             BEQ.N    ??pwm_timer_handler_0
    325              	pwm_task_timeout--;		
   \   00000008   0x....             LDR.N    R0,??DataTable9_5
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable9_5
   \   00000010   0x6008             STR      R0,[R1, #+0]
    326          }
   \                     ??pwm_timer_handler_0:
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     pwm_para

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     pwm_task_timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     pwm_para+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     `?<Constant "%s,%d">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     `?<Constant "%04d-%02d-%02d %02d:%...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     g_RtuStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     MeasureDat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x03938700         DC32     0x3938700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x23C34600         DC32     0x23c34600

   \                                 In section .rodata, align 4
   \                     `?<Constant "%s,%d">`:
   \   00000000   0x25 0x73          DC8 "%s,%d"
   \              0x2C 0x25    
   \              0x64 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%04d-%02d-%02d %02d:%...">`:
   \   00000000   0x25 0x30          DC8 "%04d-%02d-%02d %02d:%02d:%02d\015\012"
   \              0x34 0x64    
   \              0x2D 0x25    
   \              0x30 0x32    
   \              0x64 0x2D    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x25    
   \              0x30 0x32    
   \              0x64 0x3A    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x3A 0x25    
   \              0x30 0x32    
   \              0x64 0x0D    
   \              0x0A 0x00    
    327          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   NVIC_DisableIRQ
       4   NVIC_EnableIRQ
       0   NVIC_SetPriority
       8   PWM1_IRQHandler
         8   -> PWM_ClearIntPending
         8   -> PWM_GetCaptureValue
         8   -> PWM_GetIntStatus
         8   -> PWM_ResetCounter
      24   Pwm_ScanFreq
        24   -> GPIO_OutputValue
        24   -> NVIC_DisableIRQ
        24   -> NVIC_EnableIRQ
        24   -> OSTimeDlyHMSM
        24   -> PWM_ChannelCmd
        24   -> PWM_ConfigMatch
        24   -> PWM_MatchUpdate
        24   -> Pwm_SetFre
      16   Pwm_SetFre
        16   -> PWM_MatchUpdate
      24   Pwm_init
        24   -> GPIO_OutputValue
        24   -> NVIC_SetPriority
        24   -> PINSEL_ConfigPin
        24   -> PWM_ChannelCmd
        24   -> PWM_ConfigCapture
        24   -> PWM_ConfigMatch
        24   -> PWM_CounterCmd
        24   -> PWM_Init
        24   -> PWM_MatchUpdate
        24   -> PWM_ResetCounter
       8   Pwm_measure_Deinit
         8   -> NVIC_DisableIRQ
         8   -> PWM_ConfigCapture
       8   Pwm_measure_init
         8   -> NVIC_EnableIRQ
         8   -> PWM_ConfigCapture
         8   -> PWM_ResetCounter
       8   Stri_measure
         8   -> GPIO_OutputValue
         8   -> Stri_measure_section
      16   Stri_measure_section
        16   -> OSTimeDlyHMSM
        16   -> Pwm_ScanFreq
        16   -> Pwm_measure_Deinit
        16   -> Pwm_measure_init
     112   pwm_task
       112   -> DebugMsg
       112   -> Stri_measure
       112   -> file_write
       112   -> rtc_get_time
       112   -> sprintf
       0   pwm_timer_handler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant "%04d-%02d-%02d %02d:%...">
       8  ?<Constant "%s,%d">
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      12  MeasureDat
      26  NVIC_DisableIRQ
      26  NVIC_EnableIRQ
      38  NVIC_SetPriority
     156  PWM1_IRQHandler
     244  Pwm_ScanFreq
      38  Pwm_SetFre
     214  Pwm_init
      42  Pwm_measure_Deinit
      60  Pwm_measure_init
     156  Stri_measure
      48  Stri_measure_section
      40  pwm_para
     242  pwm_task
       4  pwm_task_timeout
      20  pwm_timer_handler

 
    56 bytes in section .bss
    40 bytes in section .rodata
 1 362 bytes in section .text
 
 1 362 bytes of CODE  memory
    40 bytes of CONST memory
    56 bytes of DATA  memory

Errors: none
Warnings: 2
