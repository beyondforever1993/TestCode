###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:14 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Cor #
#                    e\CM3\CoreSupport\core_cm3.c                             #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Cor #
#                    e\CM3\CoreSupport\core_cm3.c -lCN                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\ -o D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë #
#                    \RTU_1.2\project\iar\Debug\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\core_cm3.lst                               #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\core_cm3.o                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Core\CM3\CoreSupport\core_cm3.c
      1          /**************************************************************************//**
      2           * @file     core_cm3.c
      3           * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Source File
      4           * @version  V2.00
      5           * @date     13. September 2010
      6           *
      7           * @note
      8           * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
      9           *
     10           * @par
     11           * ARM Limited (ARM) is supplying this software for use with Cortex-M
     12           * processor based microcontrollers.  This file can be freely distributed
     13           * within development tools that are supporting such ARM based processors.
     14           *
     15           * @par
     16           * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
     17           * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
     18           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
     19           * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
     20           * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
     21           *
     22           ******************************************************************************/
     23          
     24          
     25          #include <stdint.h>
     26          
     27          
     28          /* define compiler specific symbols */
     29          #if defined   ( __CC_ARM   )
     30            #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
     31            #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
     32          
     33          #elif defined ( __ICCARM__ )
     34            #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
     35            #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
     36          
     37          #elif defined (  __GNUC__  )
     38            #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
     39            #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
     40          
     41          #elif defined   (  __TASKING__  )
     42            #define __ASM            __asm           /*!< asm keyword for TASKING Compiler          */
     43            #define __INLINE         inline          /*!< inline keyword for TASKING Compiler       */
     44          
     45          #endif
     46          
     47          
     48          /* ##########################  Core Instruction Access  ######################### */
     49          
     50          #if defined ( __CC_ARM   ) /*------------------ RealView Compiler ----------------*/
     51          
     52          /** \brief  Reverse byte order (16 bit)
     53          
     54              This function reverses the byte order in two unsigned short values.
     55          
     56              \param [in]    value  Value to reverse
     57              \return               Reversed value
     58           */
     59          #if (__ARMCC_VERSION < 400677)
     60          
     61          __ASM uint32_t __REV16(uint32_t value)
     62          {
     63            rev16 r0, r0
     64            bx lr
     65          }
     66          #endif /* __ARMCC_VERSION  */
     67          
     68          
     69          /** \brief  Reverse byte order in signed short value
     70          
     71              This function reverses the byte order in a signed short value with sign extension to integer.
     72          
     73              \param [in]    value  Value to reverse
     74              \return               Reversed value
     75           */
     76          #if (__ARMCC_VERSION < 400677)
     77          __ASM int32_t __REVSH(int32_t value)
     78          {
     79            revsh r0, r0
     80            bx lr
     81          }
     82          #endif /* __ARMCC_VERSION  */
     83          
     84          
     85          /** \brief  Remove the exclusive lock
     86          
     87              This function removes the exclusive lock which is created by LDREX.
     88          
     89           */
     90          #if (__ARMCC_VERSION < 400000)
     91          __ASM void __CLREX(void)
     92          {
     93            clrex
     94          }
     95          #endif /* __ARMCC_VERSION  */
     96          
     97          
     98          #elif (defined (__ICCARM__)) /*---------------- ICC Compiler ---------------------*/
     99          /* obsolete */
    100          #elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
    101          /* obsolete */
    102          #elif (defined (__TASKING__)) /*--------------- TASKING Compiler -----------------*/
    103          /* obsolete */
    104          #endif
    105          
    106          
    107          /* ###########################  Core Function Access  ########################### */
    108          
    109          #if defined ( __CC_ARM   ) /*------------------ RealView Compiler ----------------*/
    110          
    111          /** \brief  Get Control Register
    112          
    113              This function returns the content of the Control Register.
    114          
    115              \return               Control Register value
    116           */
    117          #if       (__ARMCC_VERSION <  400000)
    118          __ASM uint32_t  __get_CONTROL(void)
    119          {
    120            mrs r0, control
    121            bx lr
    122          }
    123          #endif /*  __ARMCC_VERSION  */
    124          
    125          
    126          /** \brief  Set Control Register
    127          
    128              This function writes the given value to the Control Register.
    129          
    130              \param [in]    control  Control Register value to set
    131           */
    132          #if       (__ARMCC_VERSION <  400000)
    133          __ASM void __set_CONTROL(uint32_t control)
    134          {
    135            msr control, r0
    136            bx lr
    137          }
    138          #endif /*  __ARMCC_VERSION  */
    139          
    140          
    141          /** \brief  Get ISPR Register
    142          
    143              This function returns the content of the ISPR Register.
    144          
    145              \return               ISPR Register value
    146           */
    147          #if       (__ARMCC_VERSION <  400000)
    148          __ASM uint32_t __get_IPSR(void)
    149          {
    150            mrs r0, ipsr
    151            bx lr
    152          }
    153          #endif /*  __ARMCC_VERSION  */
    154          
    155          
    156          /** \brief  Get APSR Register
    157          
    158              This function returns the content of the APSR Register.
    159          
    160              \return               APSR Register value
    161           */
    162          #if       (__ARMCC_VERSION <  400000)
    163          __ASM uint32_t __get_APSR(void)
    164          {
    165            mrs r0, apsr
    166            bx lr
    167          }
    168          #endif /*  __ARMCC_VERSION  */
    169          
    170          
    171          /** \brief  Get xPSR Register
    172          
    173              This function returns the content of the xPSR Register.
    174          
    175              \return               xPSR Register value
    176           */
    177          #if       (__ARMCC_VERSION <  400000)
    178          __ASM uint32_t __get_xPSR(void)
    179          {
    180            mrs r0, xpsr
    181            bx lr
    182          }
    183          #endif /*  __ARMCC_VERSION  */
    184          
    185          
    186          /** \brief  Get Process Stack Pointer
    187          
    188              This function returns the current value of the Process Stack Pointer (PSP).
    189          
    190              \return               PSP Register value
    191           */
    192          #if       (__ARMCC_VERSION <  400000)
    193          __ASM uint32_t __get_PSP(void)
    194          {
    195            mrs r0, psp
    196            bx lr
    197          }
    198          #endif /*  __ARMCC_VERSION  */
    199          
    200          
    201          /** \brief  Set Process Stack Pointer
    202          
    203              This function assigns the given value to the Process Stack Pointer (PSP).
    204          
    205              \param [in]    topOfProcStack  Process Stack Pointer value to set
    206           */
    207          #if       (__ARMCC_VERSION <  400000)
    208          __ASM void __set_PSP(uint32_t topOfProcStack)
    209          {
    210            msr psp, r0
    211            bx lr
    212          }
    213          #endif /*  __ARMCC_VERSION  */
    214          
    215          
    216          /** \brief  Get Main Stack Pointer
    217          
    218              This function returns the current value of the Main Stack Pointer (MSP).
    219          
    220              \return               MSP Register value
    221           */
    222          #if       (__ARMCC_VERSION <  400000)
    223          __ASM uint32_t __get_MSP(void)
    224          {
    225            mrs r0, msp
    226            bx lr
    227          }
    228          #endif /*  __ARMCC_VERSION  */
    229          
    230          
    231          /** \brief  Set Main Stack Pointer
    232          
    233              This function assigns the given value to the Main Stack Pointer (MSP).
    234          
    235              \param [in]    topOfMainStack  Main Stack Pointer value to set
    236           */
    237          #if       (__ARMCC_VERSION <  400000)
    238          __ASM void __set_MSP(uint32_t mainStackPointer)
    239          {
    240            msr msp, r0
    241            bx lr
    242          }
    243          #endif /*  __ARMCC_VERSION  */
    244          
    245          
    246          /** \brief  Get Base Priority
    247          
    248              This function returns the current value of the Base Priority register.
    249          
    250              \return               Base Priority register value
    251           */
    252          #if       (__ARMCC_VERSION <  400000)
    253          __ASM uint32_t  __get_BASEPRI(void)
    254          {
    255            mrs r0, basepri
    256            bx lr
    257          }
    258          #endif /*  __ARMCC_VERSION  */
    259          
    260          
    261          /** \brief  Set Base Priority
    262          
    263              This function assigns the given value to the Base Priority register.
    264          
    265              \param [in]    basePri  Base Priority value to set
    266           */
    267          #if       (__ARMCC_VERSION <  400000)
    268          __ASM void __set_BASEPRI(uint32_t basePri)
    269          {
    270            msr basepri, r0
    271            bx lr
    272          }
    273          #endif /*  __ARMCC_VERSION  */
    274          
    275          /** \brief  Get Priority Mask
    276          
    277              This function returns the current state of the priority mask bit from the Priority Mask Register.
    278          
    279              \return               Priority Mask value
    280           */
    281          #if       (__ARMCC_VERSION <  400000)
    282          __ASM uint32_t __get_PRIMASK(void)
    283          {
    284            mrs r0, primask
    285            bx lr
    286          }
    287          #endif /*  __ARMCC_VERSION  */
    288          
    289          
    290          /** \brief  Set Priority Mask
    291          
    292              This function assigns the given value to the Priority Mask Register.
    293          
    294              \param [in]    priMask  Priority Mask
    295           */
    296          #if       (__ARMCC_VERSION <  400000)
    297          __ASM void __set_PRIMASK(uint32_t priMask)
    298          {
    299            msr primask, r0
    300            bx lr
    301          }
    302          #endif /*  __ARMCC_VERSION  */
    303          
    304          
    305          /** \brief  Get Fault Mask
    306          
    307              This function returns the current value of the Fault Mask Register.
    308          
    309              \return               Fault Mask value
    310           */
    311          #if       (__ARMCC_VERSION <  400000)
    312          __ASM uint32_t  __get_FAULTMASK(void)
    313          {
    314            mrs r0, faultmask
    315            bx lr
    316          }
    317          #endif /*  __ARMCC_VERSION  */
    318          
    319          
    320          /** \brief  Set the Fault Mask
    321          
    322               This function assigns the given value to the Fault Mask Register.
    323          
    324              \param [in]    faultMask  Fault Mask value value to set
    325           */
    326          #if       (__ARMCC_VERSION <  400000)
    327          __ASM void __set_FAULTMASK(uint32_t faultMask)
    328          {
    329            msr faultmask, r0
    330            bx lr
    331          }
    332          #endif /*  __ARMCC_VERSION  */
    333          
    334          
    335          
    336          #elif (defined (__ICCARM__)) /*---------------- ICC Compiler ---------------------*/
    337          /* obsolete */
    338          #elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
    339          /* obsolete */
    340          #elif (defined (__TASKING__)) /*--------------- TASKING Compiler -----------------*/
    341          /* obsolete */
    342          #endif
    343          
    344          
    345          
    346          
    347          
    348          
    349          
    350          
    351          
    352          
    353          
    354          
    355          
    356          
    357          
    358          
    359          


 

 


Errors: none
Warnings: none
