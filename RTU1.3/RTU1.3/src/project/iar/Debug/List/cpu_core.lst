###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:37 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uC- #
#                    CPU\cpu_core.c                                           #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uC- #
#                    CPU\cpu_core.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ú #
#                    Âë\RTU_1.2\project\iar\Debug\List\ -o                    #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\cpu_core.lst                               #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\cpu_core.o                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uC-CPU\cpu_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                               uC/CPU
      4          *                                    CPU CONFIGURATION & PORT LAYER
      5          *
      6          *                          (c) Copyright 2004-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/CPU is provided in source form for FREE evaluation, for educational
     11          *               use or peaceful research.  If you plan on using uC/CPU in a commercial
     12          *               product you need to contact Micrium to properly license its use in your
     13          *               product.  We provide ALL the source code for your convenience and to
     14          *               help you experience uC/CPU.  The fact that the source code is provided
     15          *               does NOT mean that you can use it without paying a licensing fee.
     16          *
     17          *               Knowledge of the source code may NOT be used to develop a similar product.
     18          *
     19          *               Please help us continue to provide the Embedded community with the finest
     20          *               software available.  Your honesty is greatly appreciated.
     21          *********************************************************************************************************
     22          */
     23          
     24          /*
     25          *********************************************************************************************************
     26          *
     27          *                                           CORE CPU MODULE
     28          *
     29          * Filename      : cpu_core.c
     30          * Version       : V1.23
     31          * Programmer(s) : SR
     32          *                 ITJ
     33          *********************************************************************************************************
     34          */
     35          
     36          
     37          /*
     38          *********************************************************************************************************
     39          *                                            INCLUDE FILES
     40          *********************************************************************************************************
     41          */
     42          
     43          #define    CPU_CORE_MODULE
     44          #include  <cpu_core.h>

   \                                 In section .bss, align 4
   \   __absolute char CPU_Name[16]
   \                     CPU_Name:
   \   00000000                      DS8 16

   \                                 In section .bss, align 2
   \   __absolute CPU_INT16U CPU_TS_TmrNbrShifts
   \                     CPU_TS_TmrNbrShifts:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \   __absolute CPU_TS CPU_TS_Lo
   \                     CPU_TS_Lo:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_TS CPU_TS_Hi
   \                     CPU_TS_Hi:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_TS CPU_TS_Prev
   \                     CPU_TS_Prev:
   \   00000000                      DS8 4
     45          
     46          
     47          /*$PAGE*/
     48          /*
     49          *********************************************************************************************************
     50          *                                            LOCAL DEFINES
     51          *********************************************************************************************************
     52          */
     53          
     54          
     55          /*
     56          *********************************************************************************************************
     57          *                                           LOCAL CONSTANTS
     58          *********************************************************************************************************
     59          */
     60          
     61          
     62          /*
     63          *********************************************************************************************************
     64          *                                          LOCAL DATA TYPES
     65          *********************************************************************************************************
     66          */
     67          
     68          
     69          /*
     70          *********************************************************************************************************
     71          *                                            LOCAL TABLES
     72          *********************************************************************************************************
     73          */
     74          
     75          /*
     76          *********************************************************************************************************
     77          *                                  CPU COUNT LEAD ZEROs LOOKUP TABLE
     78          *
     79          * Note(s) : (1) Index into bit pattern table determines the number of leading zeros in an 8-bit value :
     80          *
     81          *                         b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
     82          *                         ---  ---  ---  ---  ---  ---  ---  ---    ---------------
     83          *                          1    x    x    x    x    x    x    x            0
     84          *                          0    1    x    x    x    x    x    x            1
     85          *                          0    0    1    x    x    x    x    x            2
     86          *                          0    0    0    1    x    x    x    x            3
     87          *                          0    0    0    0    1    x    x    x            4
     88          *                          0    0    0    0    0    1    x    x            5
     89          *                          0    0    0    0    0    0    1    x            6
     90          *                          0    0    0    0    0    0    0    1            7
     91          *                          0    0    0    0    0    0    0    0            8
     92          *********************************************************************************************************
     93          */
     94          
     95          #ifndef   CPU_CFG_LEAD_ZEROS_ASM_PRESENT
     96          static  const  CPU_INT08U  CPU_CntLeadZerosTbl[256] = {         /* Data vals :                                          */
     97              8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,             /*   0x00 to 0x0F                                       */
     98              3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,             /*   0x10 to 0x1F                                       */
     99              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,             /*   0x20 to 0x2F                                       */
    100              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,             /*   0x30 to 0x3F                                       */
    101              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,             /*   0x40 to 0x4F                                       */
    102              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,             /*   0x50 to 0x5F                                       */
    103              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,             /*   0x60 to 0x6F                                       */
    104              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,             /*   0x70 to 0x7F                                       */
    105              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             /*   0x80 to 0x8F                                       */
    106              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             /*   0x90 to 0x9F                                       */
    107              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             /*   0xA0 to 0xAF                                       */
    108              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             /*   0xB0 to 0xBF                                       */
    109              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             /*   0xC0 to 0xCF                                       */
    110              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             /*   0xD0 to 0xDF                                       */
    111              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             /*   0xE0 to 0xEF                                       */
    112              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0              /*   0xF0 to 0xFF                                       */
    113          };
    114          #endif
    115          
    116          
    117          /*$PAGE*/
    118          /*
    119          *********************************************************************************************************
    120          *                                       LOCAL GLOBAL VARIABLES
    121          *********************************************************************************************************
    122          */
    123          
    124          
    125          /*
    126          *********************************************************************************************************
    127          *                                      LOCAL FUNCTION PROTOTYPES
    128          *********************************************************************************************************
    129          */
    130          
    131          #if    (CPU_CFG_NAME_EN   == DEF_ENABLED)                           /* ---------------- CPU NAME FNCTS ---------------- */
    132          static  void    CPU_NameInit         (void);
    133          #endif
    134          
    135          
    136                                                                              /* ----------------- CPU TS FNCTS ----------------- */
    137          #if   ((CPU_CFG_TS_TMR_EN == DEF_ENABLED) || \
    138                 (CPU_CFG_TS_EN     == DEF_ENABLED)) 
    139          static  void    CPU_TS_Init          (void);
    140          #endif
    141          
    142          #if    (CPU_CFG_TS_EN     == DEF_ENABLED)
    143          static  void    CPU_TS_UpdateHandler (CPU_TS  *p_ts_lo,
    144                                                CPU_TS  *p_ts_hi);
    145          #endif
    146          
    147          
    148          #ifdef  CPU_CFG_INT_DIS_MEAS_EN                                     /* ---------- CPU INT DIS TIME MEAS FNCTS --------- */
    149          static  void    CPU_IntDisMeasInit   (void);
    150          
    151          static  CPU_TS  CPU_IntDisMeasMaxCalc(CPU_TS   time_max_cnts_raw);
    152          #endif
    153          
    154          
    155          /*
    156          *********************************************************************************************************
    157          *                                     LOCAL CONFIGURATION ERRORS
    158          *********************************************************************************************************
    159          */
    160          
    161          
    162          /*$PAGE*/
    163          /*
    164          *********************************************************************************************************
    165          *                                             CPU_Init()
    166          *
    167          * Description : (1) Initialize CPU module :
    168          *
    169          *                   (a) Initialize CPU timestamps
    170          *                   (b) Initialize CPU interrupts disabled time measurements
    171          *                   (c) Initialize CPU host name
    172          *
    173          *
    174          * Argument(s) : none.
    175          *
    176          * Return(s)   : none.
    177          *
    178          * Caller(s)   : Your Product's Application.
    179          *
    180          *               This function is a CPU initialization function & MAY be called by application/
    181          *               initialization function(s).
    182          *
    183          * Note(s)     : (2) CPU_Init() MUST be called ... :
    184          *
    185          *                   (a) ONLY ONCE from a product's application; ...
    186          *                   (b) BEFORE product's application calls any core CPU module function(s)
    187          *
    188          *               (3) The following initialization functions MUST be sequenced as follows :
    189          *
    190          *                   (a) CPU_TS_Init()           SHOULD precede ALL calls to other CPU timestamp functions
    191          *
    192          *                   (b) CPU_IntDisMeasInit()    SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT() 
    193          *                                                   & other CPU interrupts disabled time measurement functions
    194          *********************************************************************************************************
    195          */
    196          

   \                                 In section .text, align 2, keep-with-next
    197          void  CPU_Init (void)
    198          {
   \                     CPU_Init:
   \   00000000   0xB580             PUSH     {R7,LR}
    199                                                                          /* --------------------- INIT TS ---------------------- */
    200          #if ((CPU_CFG_TS_TMR_EN == DEF_ENABLED) || \
    201               (CPU_CFG_TS_EN     == DEF_ENABLED)) 
    202              CPU_TS_Init();                                              /* See Note #3a.                                        */
   \   00000002   0x.... 0x....      BL       CPU_TS_Init
    203          #endif
    204                                                                          /* -------------- INIT INT DIS TIME MEAS -------------- */
    205          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    206              CPU_IntDisMeasInit();                                       /* See Note #3b.                                        */
    207          #endif
    208          
    209                                                                          /* ------------------ INIT CPU NAME ------------------- */
    210          #if (CPU_CFG_NAME_EN == DEF_ENABLED)
    211               CPU_NameInit();
   \   00000006   0x.... 0x....      BL       CPU_NameInit
    212          #endif
    213          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    214          
    215          
    216          /*$PAGE*/
    217          /*
    218          *********************************************************************************************************
    219          *                                            CPU_NameClr()
    220          *
    221          * Description : Clear CPU Name.
    222          *
    223          * Argument(s) : none.
    224          *
    225          * Return(s)   : none.
    226          *
    227          * Caller(s)   : CPU_NameInit(),
    228          *               Application.
    229          *
    230          *               This function is a CPU module application interface (API) function & MAY be called by
    231          *               application function(s).
    232          *
    233          * Note(s)     : none.
    234          *********************************************************************************************************
    235          */
    236          
    237          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    238          void  CPU_NameClr (void)
    239          {
   \                     CPU_NameClr:
   \   00000000   0xB510             PUSH     {R4,LR}
    240              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
    241          
    242          
    243              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x0004             MOVS     R4,R0
    244              Mem_Clr((void     *)&CPU_Name[0],
    245                      (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
   \   0000000A   0x2110             MOVS     R1,#+16
   \   0000000C   0x....             LDR.N    R0,??DataTable4
   \   0000000E   0x.... 0x....      BL       Mem_Clr
    246              CPU_CRITICAL_EXIT();
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       CPU_SR_Restore
    247          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    248          #endif
    249          
    250          
    251          /*$PAGE*/
    252          /*
    253          *********************************************************************************************************
    254          *                                            CPU_NameGet()
    255          *
    256          * Description : Get CPU host name.
    257          *
    258          * Argument(s) : p_name      Pointer to an ASCII character array that will receive the return CPU host 
    259          *                               name ASCII string from this function (see Note #1).
    260          *
    261          *               p_err       Pointer to variable that will receive the return error code from this function :
    262          *
    263          *                               CPU_ERR_NONE                    CPU host name successfully returned.
    264          *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
    265          *
    266          * Return(s)   : none.
    267          *
    268          * Caller(s)   : Application.
    269          *
    270          *               This function is a CPU module application interface (API) function & MAY be called by
    271          *               application function(s).
    272          *
    273          * Note(s)     : (1) The size of the ASCII character array that will receive the return CPU host name 
    274          *                   ASCII string :
    275          *
    276          *                   (a) MUST   be greater than or equal to the current CPU host name's ASCII string 
    277          *                           size including the terminating NULL character;
    278          *                   (b) SHOULD be greater than or equal to CPU_CFG_NAME_SIZE
    279          *********************************************************************************************************
    280          */
    281          
    282          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    283          void  CPU_NameGet (CPU_CHAR  *p_name,
    284                             CPU_ERR   *p_err)
    285          {
   \                     CPU_NameGet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    286              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    287          
    288          
    289              if (p_name == (CPU_CHAR *)0) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD102             BNE.N    ??CPU_NameGet_0
    290                 *p_err = CPU_ERR_NULL_PTR;
   \   0000000C   0x200A             MOVS     R0,#+10
   \   0000000E   0x8028             STRH     R0,[R5, #+0]
    291                  return;
   \   00000010   0xE00B             B.N      ??CPU_NameGet_1
    292              }
    293          
    294              CPU_CRITICAL_ENTER();
   \                     ??CPU_NameGet_0:
   \   00000012   0x.... 0x....      BL       CPU_SR_Save
   \   00000016   0x0006             MOVS     R6,R0
    295              Str_Copy((CPU_CHAR *) p_name,
    296                       (CPU_CHAR *)&CPU_Name[0]);
   \   00000018   0x....             LDR.N    R1,??DataTable4
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       Str_Copy
    297              CPU_CRITICAL_EXIT();
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x.... 0x....      BL       CPU_SR_Restore
    298          
    299             *p_err = CPU_ERR_NONE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x8028             STRH     R0,[R5, #+0]
    300          }
   \                     ??CPU_NameGet_1:
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    301          #endif
    302          
    303          
    304          /*$PAGE*/
    305          /*
    306          *********************************************************************************************************
    307          *                                            CPU_NameSet()
    308          *
    309          * Description : Set CPU host name.
    310          *
    311          * Argument(s) : p_name      Pointer to CPU host name to set.
    312          *
    313          *               p_err       Pointer to variable that will receive the return error code from this function :
    314          *
    315          *                               CPU_ERR_NONE                    CPU host name successfully set.
    316          *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
    317          *                               CPU_ERR_NAME_SIZE               Invalid CPU host name size (see Note #1).
    318          *
    319          * Return(s)   : none.
    320          *
    321          * Caller(s)   : Application.
    322          *
    323          *               This function is a CPU module application interface (API) function & MAY be called by
    324          *               application function(s).
    325          *
    326          * Note(s)     : (1) 'p_name' ASCII string size, including the terminating NULL character, MUST be less
    327          *                    than or equal to CPU_CFG_NAME_SIZE.
    328          *********************************************************************************************************
    329          */
    330          
    331          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    332          void  CPU_NameSet (CPU_CHAR  *p_name,
    333                             CPU_ERR   *p_err)
    334          {
   \                     CPU_NameSet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    335              CPU_SIZE_T  len;
    336              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
    337          
    338          
    339              if (p_name == (CPU_CHAR *)0) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD102             BNE.N    ??CPU_NameSet_0
    340                 *p_err = CPU_ERR_NULL_PTR;
   \   0000000C   0x200A             MOVS     R0,#+10
   \   0000000E   0x8028             STRH     R0,[R5, #+0]
    341                  return;
   \   00000010   0xE014             B.N      ??CPU_NameSet_1
    342              }
    343          
    344              len = Str_Len(p_name);
   \                     ??CPU_NameSet_0:
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       Str_Len
   \   00000018   0x0006             MOVS     R6,R0
    345              if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
   \   0000001A   0x2E10             CMP      R6,#+16
   \   0000001C   0xD20C             BCS.N    ??CPU_NameSet_2
    346                  CPU_CRITICAL_ENTER();
   \   0000001E   0x.... 0x....      BL       CPU_SR_Save
   \   00000022   0x0007             MOVS     R7,R0
    347                  Str_Copy((CPU_CHAR *)&CPU_Name[0],                      /* ... copy cfg name to CPU host name.                  */
    348                           (CPU_CHAR *) p_name);
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0x....             LDR.N    R0,??DataTable4
   \   00000028   0x.... 0x....      BL       Str_Copy
    349                  CPU_CRITICAL_EXIT();
   \   0000002C   0x0038             MOVS     R0,R7
   \   0000002E   0x.... 0x....      BL       CPU_SR_Restore
    350                 *p_err = CPU_ERR_NONE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x8028             STRH     R0,[R5, #+0]
   \   00000036   0xE001             B.N      ??CPU_NameSet_3
    351          
    352              } else {
    353                 *p_err = CPU_ERR_NAME_SIZE;
   \                     ??CPU_NameSet_2:
   \   00000038   0x2064             MOVS     R0,#+100
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
    354              }
    355          }
   \                     ??CPU_NameSet_3:
   \                     ??CPU_NameSet_1:
   \   0000003C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    356          #endif
    357          
    358          
    359          /*$PAGE*/
    360          /*
    361          *********************************************************************************************************
    362          *                                            CPU_TS_Get()
    363          *
    364          * Description : Get current CPU timestamp.
    365          *
    366          * Argument(s) : p_ts_lo     Pointer to timestamp variable that will receive the current CPU timestamp's 
    367          *                               lower half (in timestamp timer counts), if available.
    368          *
    369          *               p_ts_hi     Pointer to timestamp variable that will receive the current CPU timestamp's 
    370          *                               upper half (in timestamp timer counts), if available.
    371          *
    372          * Return(s)   : none.
    373          *
    374          * Caller(s)   : Application.
    375          *
    376          *               This function is a CPU module application interface (API) function & MAY be called by
    377          *               application function(s).
    378          *
    379          * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by 
    380          *                   either of the following equations :
    381          *
    382          *                       (a) Time measured  =  Number timer counts  *  Timer period
    383          *
    384          *                               where
    385          *
    386          *                                   Number timer counts     Number of timer counts measured 
    387          *                                   Timer period            Timer's period in some units of 
    388          *                                                               (fractional) seconds
    389          *                                   Time measured           Amount of time measured, in same 
    390          *                                                               units of (fractional) seconds 
    391          *                                                               as the Timer period
    392          *
    393          *                                              Number timer counts
    394          *                       (b) Time measured  =  ---------------------
    395          *                                                Timer frequency
    396          *
    397          *                               where
    398          *
    399          *                                   Number timer counts     Number of timer counts measured 
    400          *                                   Timer frequency         Timer's frequency in some units 
    401          *                                                               of counts per second
    402          *                                   Time measured           Amount of time measured, in seconds
    403          *
    404          *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
    405          *********************************************************************************************************
    406          */
    407          
    408          #if (CPU_CFG_TS_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    409          void  CPU_TS_Get (CPU_TS  *p_ts_lo,
    410                            CPU_TS  *p_ts_hi)
    411          {
   \                     CPU_TS_Get:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    412              CPU_TS_UpdateHandler(p_ts_lo, p_ts_hi);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       CPU_TS_UpdateHandler
    413          }
   \   0000000E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    414          #endif
    415          
    416          
    417          /*$PAGE*/
    418          /*
    419          *********************************************************************************************************
    420          *                                           CPU_TS_GetLo()
    421          *
    422          * Description : Get current CPU timestamp, lower-half only.
    423          *
    424          * Argument(s) : none.
    425          *
    426          * Return(s)   : Current CPU timestamp's lower half (in timestamp timer counts).
    427          *
    428          * Caller(s)   : Application.
    429          *
    430          *               This function is a CPU module application interface (API) function & MAY be called by
    431          *               application function(s).
    432          *
    433          * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by 
    434          *                   either of the following equations :
    435          *
    436          *                       (a) Time measured  =  Number timer counts  *  Timer period
    437          *
    438          *                               where
    439          *
    440          *                                   Number timer counts     Number of timer counts measured 
    441          *                                   Timer period            Timer's period in some units of 
    442          *                                                               (fractional) seconds
    443          *                                   Time measured           Amount of time measured, in same 
    444          *                                                               units of (fractional) seconds 
    445          *                                                               as the Timer period
    446          *
    447          *                                              Number timer counts
    448          *                       (b) Time measured  =  ---------------------
    449          *                                                Timer frequency
    450          *
    451          *                               where
    452          *
    453          *                                   Number timer counts     Number of timer counts measured 
    454          *                                   Timer frequency         Timer's frequency in some units 
    455          *                                                               of counts per second
    456          *                                   Time measured           Amount of time measured, in seconds
    457          *
    458          *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
    459          *********************************************************************************************************
    460          */
    461          
    462          #if (CPU_CFG_TS_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    463          CPU_TS  CPU_TS_GetLo (void)
    464          {
   \                     CPU_TS_GetLo:
   \   00000000   0xB580             PUSH     {R7,LR}
    465              CPU_TS  ts_lo;
    466          
    467          
    468              CPU_TS_UpdateHandler((CPU_TS *)&ts_lo,
    469                                   (CPU_TS *) 0);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      BL       CPU_TS_UpdateHandler
    470          
    471              return (ts_lo);
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    472          }
    473          #endif
    474          
    475          
    476          /*$PAGE*/
    477          /*
    478          *********************************************************************************************************
    479          *                                           CPU_TS_Update()
    480          *
    481          * Description : Update current CPU timestamp. 
    482          *
    483          * Argument(s) : none.
    484          *
    485          * Return(s)   : none.
    486          *
    487          * Caller(s)   : Application/BSP periodic time handler (see Note #1).
    488          *
    489          * Note(s)     : (1) (a) CPU timestamp MUST be updated periodically by some application (or BSP) time 
    490          *                       handler in order to (adequately) maintain the CPU timestamp time.
    491          *
    492          *                   (b) CPU timestamp MUST be updated more frequently than timestamp timer overflows; 
    493          *                       otherwise, CPU timestamp will lose time.
    494          *
    495          *                       See also 'CPU_TS_UpdateHandler()  Note #2'.
    496          *********************************************************************************************************
    497          */
    498          
    499          #if (CPU_CFG_TS_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    500          void  CPU_TS_Update (void)
    501          {
   \                     CPU_TS_Update:
   \   00000000   0xB580             PUSH     {R7,LR}
    502              CPU_TS_UpdateHandler((CPU_TS *)0,
    503                                   (CPU_TS *)0);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       CPU_TS_UpdateHandler
    504          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    505          #endif
    506          
    507          
    508          /*$PAGE*/
    509          /*
    510          *********************************************************************************************************
    511          *                                     CPU_IntDisMeasMaxCurReset()
    512          *
    513          * Description : Reset current maximum interrupts disabled time.
    514          *
    515          * Argument(s) : none.
    516          *
    517          * Return(s)   : Maximum interrupts disabled time (in timestamp timer counts) before resetting.
    518          *
    519          *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()    Note #2c'
    520          *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_to_uSec()  Note #2'.
    521          *
    522          * Caller(s)   : Application.
    523          *
    524          *               This function is a CPU module application interface (API) function & MAY be called 
    525          *               by application function(s).
    526          *
    527          * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCurRaw_cnts' MUST ALWAYS be accessed 
    528          *                   exclusively with interrupts disabled -- but NOT with critical sections.
    529          *********************************************************************************************************
    530          */
    531          
    532          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    533          CPU_TS  CPU_IntDisMeasMaxCurReset (void)
    534          {
    535              CPU_TS  time_max_cnts;
    536              CPU_SR_ALLOC();
    537          
    538          
    539              time_max_cnts                = CPU_IntDisMeasMaxCurGet();
    540              CPU_INT_DIS();
    541              CPU_IntDisMeasMaxCurRaw_cnts = 0;
    542              CPU_INT_EN();
    543          
    544              return (time_max_cnts);
    545          }
    546          #endif
    547          
    548          
    549          /*$PAGE*/
    550          /*
    551          *********************************************************************************************************
    552          *                                      CPU_IntDisMeasMaxCurGet()
    553          *
    554          * Description : Get current maximum interrupts disabled time.
    555          *
    556          * Argument(s) : none.
    557          *
    558          * Return(s)   : Current maximum interrupts disabled time (in timestamp timer counts).
    559          *
    560          *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()    Note #2c'
    561          *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_to_uSec()  Note #2'.
    562          *
    563          * Caller(s)   : CPU_IntDisMeasMaxCurReset(),
    564          *               Application.
    565          *
    566          *               This function is a CPU module application interface (API) function & MAY be called 
    567          *               by application function(s).
    568          *
    569          * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCurRaw_cnts' MUST ALWAYS be accessed 
    570          *                   exclusively with interrupts disabled -- but NOT with critical sections.
    571          *********************************************************************************************************
    572          */
    573          
    574          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    575          CPU_TS  CPU_IntDisMeasMaxCurGet (void)
    576          {
    577              CPU_TS  time_max_cnts;
    578              CPU_TS  time_max_cnts_raw;
    579              CPU_SR_ALLOC();
    580          
    581          
    582              CPU_INT_DIS();
    583              time_max_cnts_raw = CPU_IntDisMeasMaxCurRaw_cnts;
    584              CPU_INT_EN();
    585              time_max_cnts     = CPU_IntDisMeasMaxCalc(time_max_cnts_raw);
    586          
    587              return (time_max_cnts);
    588          }
    589          #endif
    590          
    591          
    592          /*$PAGE*/
    593          /*
    594          *********************************************************************************************************
    595          *                                       CPU_IntDisMeasMaxGet()
    596          *
    597          * Description : Get (non-resetable) maximum interrupts disabled time.
    598          *
    599          * Argument(s) : none.
    600          *
    601          * Return(s)   : (Non-resetable) maximum interrupts disabled time (in timestamp timer counts).
    602          *
    603          *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()    Note #2c'
    604          *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_to_uSec()  Note #2'.
    605          *
    606          * Caller(s)   : CPU_IntDisMeasInit(),
    607          *               Application.
    608          *
    609          *               This function is a CPU module application interface (API) function & MAY be called 
    610          *               by application function(s).
    611          *
    612          * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxRaw_cnts' MUST ALWAYS be accessed 
    613          *                   exclusively with interrupts disabled -- but NOT with critical sections.
    614          *********************************************************************************************************
    615          */
    616          
    617          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    618          CPU_TS  CPU_IntDisMeasMaxGet (void)
    619          {
    620              CPU_TS  time_max_cnts;
    621              CPU_TS  time_max_cnts_raw;
    622              CPU_SR_ALLOC();
    623          
    624          
    625              CPU_INT_DIS();
    626              time_max_cnts_raw = CPU_IntDisMeasMaxRaw_cnts;
    627              CPU_INT_EN();
    628              time_max_cnts     = CPU_IntDisMeasMaxCalc(time_max_cnts_raw);
    629          
    630              return (time_max_cnts);
    631          }
    632          #endif
    633          
    634          
    635          /*$PAGE*/
    636          /*
    637          *********************************************************************************************************
    638          *                                        CPU_IntDisMeasStart()
    639          *
    640          * Description : Start interrupts disabled time measurement.
    641          *
    642          * Argument(s) : none.
    643          *
    644          * Return(s)   : none.
    645          *
    646          * Caller(s)   : CPU_CRITICAL_ENTER().
    647          *
    648          *               This function is an INTERNAL CPU module function & MUST NOT be called by application 
    649          *               function(s).
    650          *
    651          * Note(s)     : none.
    652          *********************************************************************************************************
    653          */
    654          
    655          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    656          void  CPU_IntDisMeasStart (void)
    657          {
    658              if (CPU_IntDisNestCtr == 0) {                                   /* If ints NOT yet dis'd, ...                       */
    659                  CPU_IntDisMeasStartRaw_cnts = CPU_TS_TmrRd();               /* ... get ints dis'd start time.                   */
    660              }
    661              CPU_IntDisNestCtr++;
    662          }
    663          #endif
    664          
    665          
    666          /*$PAGE*/
    667          /*
    668          *********************************************************************************************************
    669          *                                        CPU_IntDisMeasStop()
    670          *
    671          * Description : Stop interrupts disabled time measurement.
    672          *
    673          * Argument(s) : none.
    674          *
    675          * Return(s)   : none.
    676          *
    677          * Caller(s)   : CPU_CRITICAL_EXIT().
    678          *
    679          *               This function is an INTERNAL CPU module function & MUST NOT be called by application 
    680          *               function(s).
    681          *
    682          * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code 
    683          *                       during critical sections is calculated by the following equations :
    684          *
    685          *                       (1) When interrupts disabled time measurements are disabled :
    686          *
    687          *
    688          *                               |   CRITICAL  |                           |   CRITICAL  |
    689          *                               |<- SECTION ->|                           |<- SECTION ->|
    690          *                               |    ENTER    |                           |    EXIT     |
    691          *
    692          *                            Disable                                    Enable
    693          *                           Interrupts                                Interrupts
    694          *
    695          *                               ||           ||                           ||           ||
    696          *                               ||           ||                           ||           ||
    697          *                               ||       |   ||<------------------------->||       |   ||
    698          *                               ||       |<->||             |             ||<----->|   ||
    699          *                               ||       | | ||             |             ||   |   |   ||
    700          *                                        | |                |                  |   |
    701          *                                   interrupts            time                 interrupts
    702          *                                    disabled                 interrupts       |enabled
    703          *                                          |                   disabled        |
    704          *                                          |              (via application)    |
    705          *                                       time                                 time
    706          *                                           interrupts                           interrupts
    707          *                                         disabled ovrhd                        enabled ovrhd
    708          *
    709          *
    710          *                           (A) time            =  [ time            -  time           ]  -  time
    711          *                                   interrupts     [     interrupts         interrupts ]         total
    712          *                                    disabled      [      enabled            disabled  ]         ovrhd
    713          *                               (via application)
    714          *
    715          *
    716          *                           (B) time       =  time              +  time
    717          *                                   total         interrupts           interrupts
    718          *                                   ovrhd        enabled ovrhd       disabled ovrhd
    719          *
    720          *
    721          *                                   where
    722          *
    723          *                                           time                    time interrupts are disabled between 
    724          *                                               interrupts              first critical section enter & 
    725          *                                                disabled               last  critical section exit (i.e. 
    726          *                                           (via application)           minus total overhead time)
    727          *
    728          *                                           time                    time when interrupts are disabled
    729          *                                               interrupts
    730          *                                                disabled
    731          *
    732          *                                           time                    time when interrupts are  enabled
    733          *                                               interrupts
    734          *                                                enabled
    735          *
    736          *
    737          *                                           time                    total overhead time to disable/enable 
    738          *                                               total                   interrupts during critical section 
    739          *                                               ovrhd                   enter & exit
    740          *
    741          *                                           time                    total overhead time to disable interrupts
    742          *                                               interrupts              during critical section enter
    743          *                                             disabled ovrhd
    744          *
    745          *                                           time                    total overhead time to enable  interrupts
    746          *                                               interrupts              during critical section exit
    747          *                                              enabled ovrhd
    748          *
    749          *$PAGE*
    750          *
    751          *                       (2) When interrupts disabled time measurements are enabled :
    752          *
    753          *
    754          *        |                                    |                           |                                       |
    755          *        |<----- CRITICAL SECTION ENTER ----->|                           |<------- CRITICAL SECTION EXIT ------->|
    756          *        |                                    |                           |                                       |
    757          *
    758          *                   Time                                                 Time
    759          *     Disable    Measurement                                          Measurement                  Enable
    760          *    Interrupts     Start                                                Stop                    Interrupts
    761          *
    762          *        ||           |                      ||                           ||                         |           ||
    763          *        ||           |                      ||                           ||                         |           ||
    764          *        ||           |        |             ||<------------------------->||               |         |           ||
    765          *        ||       |   |        |<----------->||             |             ||<------------->|         |       |   ||
    766          *        ||       |   |        |      |      ||             |             ||       |       |         |       |   ||
    767          *                 |            |      |                     |                      |       |                 |
    768          *            interrupts       get     |                   time                     |      get            interrupts
    769          *             disabled    start time  |                       interrupts           |   stop time          enabled
    770          *                            meas     |                        disabled            |     meas
    771          *                                   time                  (via application)      time
    772          *                                       start meas                                   stop meas
    773          *                                         ovrhd                                        ovrhd
    774          *
    775          *
    776          *                                                   [ time      -  time      ]  -  time
    777          *                                                   [     stop         start ]         total meas
    778          *                                                   [     meas         meas  ]           ovrhd
    779          *                           (A) time            =  -----------------------------------------------
    780          *                                   interrupts                       nbr scaled
    781          *                                    disabled                          shifts
    782          *                               (via application)                   2
    783          *
    784          *
    785          *                           (B) time            =  time            +  time
    786          *                                   total meas         start meas         stop meas
    787          *                                     ovrhd              ovrhd              ovrhd
    788          *
    789          *
    790          *                                   where
    791          *
    792          *                                           time                    time interrupts are disabled between first 
    793          *                                               interrupts              critical section enter & last critical 
    794          *                                                disabled               section exit (i.e. minus measurement 
    795          *                                           (via application)           overhead time; however, this does NOT 
    796          *                                                                       include any overhead time to disable 
    797          *                                                                       or enable interrupts during critical 
    798          *                                                                       section enter & exit)
    799          *
    800          *                                           time                    time of disable interrupts start time 
    801          *                                               start                   measurement (in raw, scaled timer 
    802          *                                               meas                    counts)
    803          *
    804          *                                           time                    time of disable interrupts stop  time 
    805          *                                               stop                    measurement (in raw, scaled timer 
    806          *                                               meas                    counts)
    807          *
    808          *
    809          *                                           time                    total overhead time to start/stop disabled 
    810          *                                               total meas              interrupts time measurements (in raw, 
    811          *                                                 ovrhd                 scaled timer counts)
    812          *
    813          *                                           time                    total overhead time after getting start 
    814          *                                               start meas              time until end of start measurement 
    815          *                                                 ovrhd                 function (in raw, scaled timer counts)
    816          *
    817          *                                           time                    total overhead time from beginning of stop 
    818          *                                               stop meas               measurement function until after getting 
    819          *                                                 ovrhd                 stop time (in raw, scaled timer counts)
    820          *
    821          *                                           nbr scaled              number of left bit-shifts, if any, to scale 
    822          *                                             shifts                    timer to (32-bit) 'CPU_TS' data type 
    823          *                                                                       (see also 'cpu_core.h  CPU_TS_TmrRd()  
    824          *                                                                        Note #2a1')
    825          *
    826          *$PAGE*
    827          *                   (b) (1) (A) In order to correctly handle unsigned subtraction overflows of start times 
    828          *                               from stop times, timestamp timer count values MUST be scaled to (32-bit) 
    829          *                               'CPU_TS' data type.
    830          *
    831          *                               See 'cpu_core.h  CPU_TS_TmrRd()  Note #2a'.
    832          *
    833          *                           (B) Since unsigned subtraction of start times from stop times assumes increasing 
    834          *                               values, timestamp timer count values MUST increase with each time count.
    835          *
    836          *                               See 'cpu_core.h  CPU_TS_TmrRd()  Note #2b'.
    837          *
    838          *                       (2) (A) To expedite & reduce interrupts disabled time measurement overhead; only the 
    839          *                               subtraction of the raw, scaled start times from stop times is performed.
    840          *
    841          *                           (B) The final calculations to subtract the interrupts disabled time measurement 
    842          *                               overhead AND to convert from raw, scaled timer counts to normalized timestamp 
    843          *                               timer counts are performed asynchronously in appropriate API functions.
    844          *
    845          *                               See also 'CPU_IntDisMeasMaxCalc()  Note #1b'.
    846          *********************************************************************************************************
    847          */
    848          
    849          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    850          void  CPU_IntDisMeasStop (void)
    851          {
    852              CPU_TS  time_ints_disd_cnts;
    853          
    854          
    855              CPU_IntDisNestCtr--;
    856              if (CPU_IntDisNestCtr == 0) {                                   /* If ints NO longer dis'd,        ...              */
    857                  CPU_IntDisMeasStopRaw_cnts = CPU_TS_TmrRd();                /* ... get  ints dis'd stop time & ...              */
    858                                                                              /* ... calc ints dis'd tot  time (see Note #1b2A).  */
    859                  time_ints_disd_cnts        = CPU_IntDisMeasStopRaw_cnts -
    860                                               CPU_IntDisMeasStartRaw_cnts;
    861                                                                              /* Calc max ints dis'd times.                       */
    862                  if (CPU_IntDisMeasMaxCurRaw_cnts < time_ints_disd_cnts) {
    863                      CPU_IntDisMeasMaxCurRaw_cnts = time_ints_disd_cnts;
    864                  }
    865                  if (CPU_IntDisMeasMaxRaw_cnts    < time_ints_disd_cnts) {
    866                      CPU_IntDisMeasMaxRaw_cnts    = time_ints_disd_cnts;
    867                  }
    868              }
    869          }
    870          #endif
    871          
    872          
    873          /*$PAGE*/
    874          /*
    875          *********************************************************************************************************
    876          *                                         CPU_CntLeadZeros()
    877          *
    878          * Description : Count the number of contiguous, most-significant, leading zero bits in a data value.
    879          *
    880          * Argument(s) : val         Data value to count leading zero bits.
    881          *
    882          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val', if NO errors.
    883          *
    884          *               0,                                                                  otherwise.
    885          *
    886          * Caller(s)   : Application.
    887          *
    888          *               This function is an INTERNAL CPU module function but MAY be called by application function(s).
    889          *
    890          * Note(s)     : (1) (a) Supports the following data value sizes :
    891          *
    892          *                       (1)  8-bits
    893          *                       (2) 16-bits
    894          *                       (3) 32-bits
    895          *
    896          *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
    897          *
    898          *                   (b) (1) For  8-bit values :
    899          *
    900          *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
    901          *                                  ---  ---  ---  ---  ---  ---  ---  ---    ---------------
    902          *                                   1    x    x    x    x    x    x    x            0
    903          *                                   0    1    x    x    x    x    x    x            1
    904          *                                   0    0    1    x    x    x    x    x            2
    905          *                                   0    0    0    1    x    x    x    x            3
    906          *                                   0    0    0    0    1    x    x    x            4
    907          *                                   0    0    0    0    0    1    x    x            5
    908          *                                   0    0    0    0    0    0    1    x            6
    909          *                                   0    0    0    0    0    0    0    1            7
    910          *                                   0    0    0    0    0    0    0    0            8
    911          *
    912          *
    913          *                       (2) For 16-bit values :
    914          *
    915          *                             b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
    916          *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
    917          *                              1    x    x         x    x    x    x    x            0
    918          *                              0    1    x         x    x    x    x    x            1
    919          *                              0    0    1         x    x    x    x    x            2
    920          *                              :    :    :         :    :    :    :    :            :
    921          *                              :    :    :         :    :    :    :    :            :
    922          *                              0    0    0         1    x    x    x    x           11
    923          *                              0    0    0         0    1    x    x    x           12
    924          *                              0    0    0         0    0    1    x    x           13
    925          *                              0    0    0         0    0    0    1    x           14
    926          *                              0    0    0         0    0    0    0    1           15
    927          *                              0    0    0         0    0    0    0    0           16
    928          *
    929          *
    930          *                       (3) For 32-bit values :
    931          *
    932          *                             b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
    933          *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
    934          *                              1    x    x         x    x    x    x    x            0
    935          *                              0    1    x         x    x    x    x    x            1
    936          *                              0    0    1         x    x    x    x    x            2
    937          *                              :    :    :         :    :    :    :    :            :
    938          *                              :    :    :         :    :    :    :    :            :
    939          *                              0    0    0         1    x    x    x    x           27
    940          *                              0    0    0         0    1    x    x    x           28
    941          *                              0    0    0         0    0    1    x    x           29
    942          *                              0    0    0         0    0    0    1    x           30
    943          *                              0    0    0         0    0    0    0    1           31
    944          *                              0    0    0         0    0    0    0    0           32
    945          *
    946          *
    947          *                       See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
    948          *********************************************************************************************************
    949          */
    950          /*$PAGE*/
    951          #ifndef   CPU_CFG_LEAD_ZEROS_ASM_PRESENT
    952          CPU_DATA  CPU_CntLeadZeros (CPU_DATA  val)
    953          {
    954              CPU_DATA    nbr_lead_zeros_msb;
    955              CPU_DATA    nbr_lead_zeros_tbl;
    956              CPU_DATA    nbr_lead_zeros_tot;
    957              CPU_INT08U  nbr_shift;
    958              CPU_INT08U  ix;
    959          
    960          
    961          #if   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_08)                       /* ---------------  8-BIT DATA VAL ---------------- */
    962                                                                              /* Chk bits [07:00] :            ...                */
    963              nbr_shift          =  0;                                        /* ... right-shift 'val'  0 bits ...                */
    964              nbr_lead_zeros_msb =  0;                                        /* ... & nbr msb lead zeros =  0.                   */
    965          
    966          
    967          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)                       /* --------------- 16-BIT DATA VAL ---------------- */
    968              if (val > 0x00FFL) {                                            /* Chk bits [15:08] :            ...                */
    969                  nbr_shift          =  8;                                    /* ... right-shift 'val'  8 bits ...                */
    970                  nbr_lead_zeros_msb =  0;                                    /* ... & nbr msb lead zeros =  0.                   */
    971          
    972              } else {                                                        /* Chk bits [07:00] :            ...                */
    973                  nbr_shift          =  0;                                    /* ... right-shift 'val'  0 bits ...                */
    974                  nbr_lead_zeros_msb =  8;                                    /* ... & nbr msb lead zeros =  0.                   */
    975              }
    976          
    977          
    978          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)                       /* --------------- 32-BIT DATA VAL ---------------- */
    979              if (val > 0x0000FFFFL) {
    980                  if (val > 0x00FFFFFFL) {                                    /* Chk bits [31:24] :            ...                */
    981                      nbr_shift          = 24;                                /* ... right-shift 'val' 24 bits ...                */
    982                      nbr_lead_zeros_msb =  0;                                /* ... & nbr msb lead zeros =  0.                   */
    983          
    984                  } else {                                                    /* Chk bits [23:16] :            ...                */
    985                      nbr_shift          = 16;                                /* ... right-shift 'val' 16 bits ...                */
    986                      nbr_lead_zeros_msb =  8;                                /* ... & nbr msb lead zeros =  8.                   */
    987                  }
    988          
    989              } else {
    990                  if (val > 0x000000FFL) {                                    /* Chk bits [15:08] :            ...                */
    991                      nbr_shift          =  8;                                /* ... right-shift 'val'  8 bits ...                */
    992                      nbr_lead_zeros_msb = 16;                                /* ... & nbr msb lead zeros = 16.                   */
    993          
    994                  } else {                                                    /* Chk bits [07:00] :            ...                */
    995                      nbr_shift          =  0;                                /* ... right-shift 'val'  0 bits ...                */
    996                      nbr_lead_zeros_msb = 24;                                /* ... & nbr msb lead zeros = 24.                   */
    997                  }
    998              }
    999          
   1000          
   1001          #else                                                               /* See Note #1a.                                    */
   1002              return (0);
   1003          #endif
   1004          
   1005          
   1006                                                                              /* ------------- CALC NBR LEAD ZEROS -------------- */
   1007              ix                 = (CPU_INT08U)(val >> nbr_shift) & 0xFF;     /* Calc lookup tbl ix.                              */
   1008              nbr_lead_zeros_tbl = (CPU_DATA  ) CPU_CntLeadZerosTbl[ix];      /* Get  lookup tbl nbr lead zeros.                  */
   1009              nbr_lead_zeros_tot = (CPU_DATA  ) nbr_lead_zeros_msb +          /* Calc        tot nbr lead zeros.                  */
   1010                                                nbr_lead_zeros_tbl;
   1011          
   1012          
   1013              return (nbr_lead_zeros_tot);
   1014          }
   1015          #endif
   1016          
   1017          
   1018          /*$PAGE*/
   1019          /*
   1020          *********************************************************************************************************
   1021          *********************************************************************************************************
   1022          *                                           LOCAL FUNCTIONS
   1023          *********************************************************************************************************
   1024          *********************************************************************************************************
   1025          */
   1026          
   1027          /*
   1028          *********************************************************************************************************
   1029          *                                           CPU_NameInit()
   1030          *
   1031          * Description : Initialize CPU Name.
   1032          *
   1033          * Argument(s) : none.
   1034          *
   1035          * Return(s)   : none.
   1036          *
   1037          * Caller(s)   : CPU_Init().
   1038          *
   1039          * Note(s)     : none.
   1040          *********************************************************************************************************
   1041          */
   1042          
   1043          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1044          static  void  CPU_NameInit (void)
   1045          {
   \                     CPU_NameInit:
   \   00000000   0xB580             PUSH     {R7,LR}
   1046              CPU_NameClr();
   \   00000002   0x.... 0x....      BL       CPU_NameClr
   1047          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1048          #endif
   1049          
   1050          
   1051          /*$PAGE*/
   1052          /*
   1053          *********************************************************************************************************
   1054          *                                            CPU_TS_Init()
   1055          *
   1056          * Description : (1) Initialize CPU timestamp :
   1057          *
   1058          *                   (a) Initialize/start CPU timestamp timer                            See Note #1
   1059          *                   (b) Initialize       CPU timestamp controls
   1060          *
   1061          *
   1062          * Argument(s) : none.
   1063          *
   1064          * Return(s)   : none.
   1065          *
   1066          * Caller(s)   : CPU_Init().
   1067          *
   1068          * Note(s)     : (1) CPU_TS_TmrInit() SHOULD precede calls to all other CPU timestamp functions; 
   1069          *                   otherwise, invalid time measurements may be calculated/returned.
   1070          *
   1071          *                   See also 'CPU_Init()  Note #3a'.
   1072          *********************************************************************************************************
   1073          */
   1074          
   1075          #if ((CPU_CFG_TS_TMR_EN == DEF_ENABLED) || \
   1076               (CPU_CFG_TS_EN     == DEF_ENABLED)) 

   \                                 In section .text, align 2, keep-with-next
   1077          static  void  CPU_TS_Init (void)
   1078          {
   \                     CPU_TS_Init:
   \   00000000   0xB580             PUSH     {R7,LR}
   1079          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
   1080              CPU_TS_TmrNbrShifts = CPU_TS_TmrInit();                     /* Init & start ts tmr (see Note #1).                   */
   \   00000002   0x.... 0x....      BL       CPU_TS_TmrInit
   \   00000006   0x....             LDR.N    R1,??DataTable4_1
   \   00000008   0x8008             STRH     R0,[R1, #+0]
   1081          #endif
   1082          
   1083          #if (CPU_CFG_TS_EN == DEF_ENABLED)
   1084              CPU_TS_Lo   = 0;                                            /* Init cur  ts (lo half).                              */
   \   0000000A   0x....             LDR.N    R0,??DataTable4_2
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   1085              CPU_TS_Hi   = 0;                                            /* Init cur  ts (hi half).                              */
   \   00000010   0x....             LDR.N    R0,??DataTable4_3
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6001             STR      R1,[R0, #+0]
   1086              CPU_TS_Prev = CPU_TS_TmrRd();                               /* Init prev ts.                                        */
   \   00000016   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000001A   0x....             LDR.N    R1,??DataTable4_4
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1087          #endif
   1088          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
   1089          #endif
   1090          
   1091          
   1092          /*$PAGE*/
   1093          /*
   1094          *********************************************************************************************************
   1095          *                                       CPU_TS_UpdateHandler()
   1096          *
   1097          * Description : Update current CPU timestamp. 
   1098          *
   1099          * Argument(s) : p_ts_lo     Pointer to timestamp variable that will receive the current CPU timestamp's 
   1100          *                               lower half (in timestamp timer counts), if available.
   1101          *
   1102          *               p_ts_hi     Pointer to timestamp variable that will receive the current CPU timestamp's 
   1103          *                               upper half (in timestamp timer counts), if available.
   1104          *
   1105          * Return(s)   : none.
   1106          *
   1107          * Caller(s)   : CPU_TS_Update(),
   1108          *               CPU_TS_Get(),
   1109          *               CPU_TS_GetLo().
   1110          *
   1111          * Note(s)     : (1) After initialization, 'CPU_TS_Lo', 'CPU_TS_Hi', & 'CPU_TS_Prev' MUST ALWAYS be accessed 
   1112          *                   AND updated exclusively with interrupts disabled -- but NOT with critical sections.
   1113          *
   1114          *               (2) CPU timestamp MUST be updated more frequently than timestamp timer overflows; otherwise, 
   1115          *                   CPU timestamp will lose time.
   1116          *
   1117          *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c2'.
   1118          *********************************************************************************************************
   1119          */
   1120          
   1121          #if (CPU_CFG_TS_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1122          static  void  CPU_TS_UpdateHandler (CPU_TS  *p_ts_lo,
   1123                                              CPU_TS  *p_ts_hi)
   1124          {
   \                     CPU_TS_UpdateHandler:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1125              CPU_TS  ts_cur;
   1126              CPU_TS  ts_delta;
   1127              CPU_TS  ts_lo;
   1128              CPU_TS  ts_hi;
   1129              CPU_SR_ALLOC();
   \   00000008   0xF05F 0x0A00      MOVS     R10,#+0
   1130          
   1131          
   1132              ts_cur     = CPU_TS_TmrRd();                                /* Get   cur   ts (in ts tmr cnts).                     */
   \   0000000C   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000010   0x0006             MOVS     R6,R0
   1133          
   1134              CPU_INT_DIS();
   \   00000012   0x.... 0x....      BL       CPU_SR_Save
   \   00000016   0x4682             MOV      R10,R0
   1135              ts_delta   = ts_cur - CPU_TS_Prev;                          /* Calc  delta ts.                                      */
   \   00000018   0x....             LDR.N    R0,??DataTable4_4
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1A30             SUBS     R0,R6,R0
   \   0000001E   0x0007             MOVS     R7,R0
   1136              ts_delta >>= CPU_TS_TmrNbrShifts;                           /* Shift delta ts tmr cnts.                             */
   \   00000020   0x....             LDR.N    R0,??DataTable4_1
   \   00000022   0x8800             LDRH     R0,[R0, #+0]
   \   00000024   0x40C7             LSRS     R7,R7,R0
   1137          
   1138              CPU_TS_Lo    += ts_delta;                                   /*    Inc lo ts by delta ts tmr cnts.                   */
   \   00000026   0x....             LDR.N    R0,??DataTable4_2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x1838             ADDS     R0,R7,R0
   \   0000002C   0x....             LDR.N    R1,??DataTable4_2
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   1139              if (CPU_TS_Lo < ts_delta) {                                 /* If inc ovf'd, ..                                     */
   \   00000030   0x....             LDR.N    R0,??DataTable4_2
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x42B8             CMP      R0,R7
   \   00000036   0xD204             BCS.N    ??CPU_TS_UpdateHandler_0
   1140                  CPU_TS_Hi++;                                            /* .. inc hi ts.                                        */
   \   00000038   0x....             LDR.N    R0,??DataTable4_3
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x....             LDR.N    R1,??DataTable4_3
   \   00000040   0x6008             STR      R0,[R1, #+0]
   1141              }
   1142          
   1143              CPU_TS_Prev = ts_cur;                                       /* Save  cur ts for next update.                        */
   \                     ??CPU_TS_UpdateHandler_0:
   \   00000042   0x....             LDR.N    R0,??DataTable4_4
   \   00000044   0x6006             STR      R6,[R0, #+0]
   1144              ts_lo       = CPU_TS_Lo;
   \   00000046   0x....             LDR.N    R0,??DataTable4_2
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x4680             MOV      R8,R0
   1145              ts_hi       = CPU_TS_Hi;
   \   0000004C   0x....             LDR.N    R0,??DataTable4_3
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x4681             MOV      R9,R0
   1146              CPU_INT_EN();
   \   00000052   0x4650             MOV      R0,R10
   \   00000054   0x.... 0x....      BL       CPU_SR_Restore
   1147          
   1148                                                                          /* If req'd, rtn ts.                                    */
   1149              if (p_ts_lo != (CPU_TS *)0) {
   \   00000058   0x2C00             CMP      R4,#+0
   \   0000005A   0xD001             BEQ.N    ??CPU_TS_UpdateHandler_1
   1150                 *p_ts_lo  = (CPU_TS  )ts_lo;
   \   0000005C   0xF8C4 0x8000      STR      R8,[R4, #+0]
   1151              }
   1152              if (p_ts_hi != (CPU_TS *)0) {
   \                     ??CPU_TS_UpdateHandler_1:
   \   00000060   0x2D00             CMP      R5,#+0
   \   00000062   0xD001             BEQ.N    ??CPU_TS_UpdateHandler_2
   1153                 *p_ts_hi  = (CPU_TS  )ts_hi;
   \   00000064   0xF8C5 0x9000      STR      R9,[R5, #+0]
   1154              }
   1155          }
   \                     ??CPU_TS_UpdateHandler_2:
   \   00000068   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     CPU_Name

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     CPU_TS_TmrNbrShifts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     CPU_TS_Lo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     CPU_TS_Hi

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     CPU_TS_Prev
   1156          #endif
   1157          
   1158          
   1159          /*$PAGE*/
   1160          /*
   1161          *********************************************************************************************************
   1162          *                                        CPU_IntDisMeasInit()
   1163          *
   1164          * Description : (1) Initialize interrupts disabled time measurements feature :
   1165          *
   1166          *                   (a) Initialize interrupts disabled time measurement controls
   1167          *                   (b) Calculate  interrupts disabled time measurement overhead
   1168          *
   1169          *
   1170          * Argument(s) : none.
   1171          *
   1172          * Return(s)   : none.
   1173          *
   1174          * Caller(s)   : CPU_Init().
   1175          *
   1176          * Note(s)     : (2) CPU_IntDisMeasInit() SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
   1177          *                   & other CPU interrupts disabled time measurement functions; otherwise, invalid interrupts 
   1178          *                   disabled time measurements may be calculated/returned.
   1179          *
   1180          *                   See also 'CPU_Init()  Note #3b'.
   1181          *
   1182          *               (3) (a) (1) Interrupts disabled time measurement overhead performed multiple times to calculate 
   1183          *                           a rounded average with better accuracy, hopefully of +/- one timer count.
   1184          *
   1185          *                       (2) However, a single overhead time measurement is recommended, even for instruction-
   1186          *                           cache-enabled CPUs, since critical sections are NOT typically called within 
   1187          *                           instruction-cached loops.  Thus, a single non-cached/non-averaged time measurement 
   1188          *                           is a more realistic overhead for the majority of non-cached interrupts disabled 
   1189          *                           time measurements.
   1190          *
   1191          *                   (b) Interrupts MUST be disabled while measuring the interrupts disabled time measurement 
   1192          *                       overhead; otherwise, overhead measurements could be interrupted which would incorrectly 
   1193          *                       calculate an inflated overhead time which would then incorrectly calculate deflated 
   1194          *                       interrupts disabled times.
   1195          *********************************************************************************************************
   1196          */
   1197          
   1198          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
   1199          static  void  CPU_IntDisMeasInit (void)
   1200          {
   1201              CPU_TS      time_meas_tot_cnts;
   1202              CPU_INT16U  i;
   1203              CPU_SR_ALLOC();
   1204          
   1205                                                                          /* ----------- INIT INT DIS TIME MEAS CTRLS ----------- */
   1206              CPU_IntDisNestCtr            = 0;
   1207              CPU_IntDisMeasStartRaw_cnts  = 0;
   1208              CPU_IntDisMeasStopRaw_cnts   = 0;
   1209              CPU_IntDisMeasMaxCurRaw_cnts = 0;
   1210              CPU_IntDisMeasMaxRaw_cnts    = 0;
   1211              CPU_IntDisMeasOvrhdRaw_cnts  = 0;
   1212          
   1213                                                                          /* ----------- CALC INT DIS TIME MEAS OVRHD ----------- */
   1214              time_meas_tot_cnts = 0;
   1215              CPU_INT_DIS();                                              /* Ints MUST be dis'd for ovrhd calc (see Note #3b).    */
   1216              for (i = 0; i < CPU_CFG_INT_DIS_MEAS_OVRHD_NBR; i++) {
   1217                  CPU_IntDisMeasMaxCurRaw_cnts = 0;
   1218                  CPU_IntDisMeasStart();                                  /* Perform multiple consecutive start/stop time meas's  */
   1219                  CPU_IntDisMeasStop();
   1220                  time_meas_tot_cnts += CPU_IntDisMeasMaxCurRaw_cnts;     /* ...       & sum time meas max's                  ... */
   1221              }
   1222                                                                          /* ... to calc avg time meas ovrhd (see Note #3a).      */
   1223              CPU_IntDisMeasOvrhdRaw_cnts  = (time_meas_tot_cnts + (CPU_CFG_INT_DIS_MEAS_OVRHD_NBR / 2))
   1224                                                                 /  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR;
   1225              CPU_IntDisMeasMaxCurRaw_cnts =  0;                          /* Reset max ints dis'd times.                          */
   1226              CPU_IntDisMeasMaxRaw_cnts    =  0;
   1227              CPU_INT_EN();
   1228          }
   1229          #endif
   1230          
   1231          
   1232          /*$PAGE*/
   1233          /*
   1234          *********************************************************************************************************
   1235          *                                       CPU_IntDisMeasMaxCalc()
   1236          *
   1237          * Description : Calculate maximum interrupts disabled time.
   1238          *
   1239          * Argument(s) : none.
   1240          *
   1241          * Return(s)   : Maximum interrupts disabled time (in timestamp timer counts).
   1242          *
   1243          * Caller(s)   : CPU_IntDisMeasMaxCurGet(),
   1244          *               CPU_IntDisMeasMaxGet().
   1245          *
   1246          * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code 
   1247          *                       during critical sections is calculated by the following equations :
   1248          *
   1249          *
   1250          *                                               [ time      -  time      ]  -  time
   1251          *                                               [     stop         start ]         total meas
   1252          *                                               [     meas         meas  ]           ovrhd
   1253          *                       (1) time            =  -----------------------------------------------
   1254          *                               interrupts                       nbr scaled
   1255          *                                disabled                          shifts
   1256          *                           (via application)                   2
   1257          *
   1258          *
   1259          *                       (2) time            =  time            +  time
   1260          *                               total meas         start meas         stop meas
   1261          *                                 ovrhd              ovrhd              ovrhd
   1262          *
   1263          *
   1264          *                               where
   1265          *
   1266          *                                       time                    time interrupts are disabled between 
   1267          *                                           interrupts              first critical section enter & 
   1268          *                                            disabled               last  critical section exit minus 
   1269          *                                       (via application)           time measurement overhead
   1270          *
   1271          *                                       time                    time of disable interrupts start time 
   1272          *                                           start                   measurement (in raw, scaled timer 
   1273          *                                           meas                    counts)
   1274          *
   1275          *                                       time                    time of disable interrupts stop  time 
   1276          *                                           stop                    measurement (in raw, scaled timer 
   1277          *                                           meas                    counts)
   1278          *
   1279          *                                       time                    total overhead time to start/stop disabled 
   1280          *                                           total meas              interrupts time measurements (in raw, 
   1281          *                                             ovrhd                 scaled timer counts)
   1282          *
   1283          *                                       time                    total overhead time after getting start 
   1284          *                                           start meas              time until end of start measurement 
   1285          *                                             ovrhd                 function (in raw, scaled timer counts)
   1286          *
   1287          *                                       time                    total overhead time from beginning of stop 
   1288          *                                           stop meas               measurement function until after getting 
   1289          *                                             ovrhd                 stop time (in raw, scaled timer counts)
   1290          *
   1291          *                                       nbr scaled              number of left bit-shifts, if any, to 
   1292          *                                         shifts                    scale timer to (32-bit) 'CPU_TS' 
   1293          *                                                                   data type (see also 'cpu_core.h  
   1294          *                                                                   CPU_TS_TmrRd()  Note #2a1')
   1295          *
   1296          *
   1297          *                   (b) To expedite & reduce interrupts disabled time measurement overhead, the final 
   1298          *                       calculations to subtract the interrupts disabled time measurement overhead AND 
   1299          *                       to convert from raw, scaled timer counts to normalized timestamp timer counts 
   1300          *                       are performed asynchronously in API functions.
   1301          *
   1302          *                       See also 'CPU_IntDisMeasStop()  Note #1b2'.
   1303          *$PAGE*
   1304          *                   (c) The amount of time interrupts are disabled is calculated by either of the 
   1305          *                       following equations :
   1306          *
   1307          *                       (1) Interrupts disabled time  =  Number timer counts  *  Timer period
   1308          *
   1309          *                               where
   1310          *
   1311          *                                   Number timer counts             Number of timer counts measured 
   1312          *                                   Timer period                    Timer's period in some units of 
   1313          *                                                                       (fractional) seconds
   1314          *                                   Interrupts disabled time        Amount of time interrupts are 
   1315          *                                                                       disabled, in same units of 
   1316          *                                                                       (fractional) seconds as the 
   1317          *                                                                       Timer period
   1318          *
   1319          *                                                         Number timer counts
   1320          *                       (2) Interrupts disabled time  =  ---------------------
   1321          *                                                           Timer frequency
   1322          *
   1323          *                               where
   1324          *
   1325          *                                   Number timer counts             Number of timer counts measured 
   1326          *                                   Timer frequency                 Timer's frequency in some units 
   1327          *                                                                       of counts per second
   1328          *                                   Interrupts disabled time        Amount of time interrupts are 
   1329          *                                                                       disabled, in seconds
   1330          *
   1331          *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()    Note #2c'
   1332          *                              & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_to_uSec()  Note #2'.
   1333          *
   1334          *               (2) Although it is not typical, it is possible for an interrupts disabled time 
   1335          *                   measurement to be less than the interrupts disabled time measurement overhead; 
   1336          *                   especially if the overhead was calculated with a single, non-cached measurement 
   1337          *                   & critical sections are called within instruction-cached loops.
   1338          *********************************************************************************************************
   1339          */
   1340          
   1341          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
   1342          static  CPU_TS  CPU_IntDisMeasMaxCalc (CPU_TS  time_max_cnts_raw)
   1343          {
   1344              CPU_TS  time_max_cnts;
   1345          
   1346          
   1347              time_max_cnts = time_max_cnts_raw;
   1348              if (time_max_cnts >  CPU_IntDisMeasOvrhdRaw_cnts) {         /* If       max ints dis'd time >  ovrhd time, ...      */
   1349                  time_max_cnts -= CPU_IntDisMeasOvrhdRaw_cnts;           /* ... adj  max ints dis'd time by ovrhd time; ...      */
   1350              } else {                                                    /* ... else max ints dis'd time <  ovrhd time, ...      */
   1351                  time_max_cnts  = 0;                                     /* ... clr  max ints dis'd time (see Note #2).          */
   1352              }
   1353          
   1354              time_max_cnts >>= CPU_TS_TmrNbrShifts;                      /* Shift    max ints dis'd time.                        */
   1355          
   1356              return (time_max_cnts);
   1357          }
   1358          #endif
   1359          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CPU_Init
         8   -> CPU_NameInit
         8   -> CPU_TS_Init
       8   CPU_NameClr
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> Mem_Clr
      16   CPU_NameGet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> Str_Copy
       8   CPU_NameInit
         8   -> CPU_NameClr
      24   CPU_NameSet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> Str_Copy
        24   -> Str_Len
      16   CPU_TS_Get
        16   -> CPU_TS_UpdateHandler
       8   CPU_TS_GetLo
         8   -> CPU_TS_UpdateHandler
       8   CPU_TS_Init
         8   -> CPU_TS_TmrInit
         8   -> CPU_TS_TmrRd
       8   CPU_TS_Update
         8   -> CPU_TS_UpdateHandler
      32   CPU_TS_UpdateHandler
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_TS_TmrRd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
      12  CPU_Init
      16  CPU_Name
      26  CPU_NameClr
      44  CPU_NameGet
       8  CPU_NameInit
      62  CPU_NameSet
      16  CPU_TS_Get
      14  CPU_TS_GetLo
       4  CPU_TS_Hi
      32  CPU_TS_Init
       4  CPU_TS_Lo
       4  CPU_TS_Prev
       2  CPU_TS_TmrNbrShifts
      12  CPU_TS_Update
     108  CPU_TS_UpdateHandler

 
  30 bytes in section .bss
 354 bytes in section .text
 
 354 bytes of CODE memory
  30 bytes of DATA memory

Errors: none
Warnings: none
