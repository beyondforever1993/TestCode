###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      26/Mar/2017  12:36:53 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\桌面\RTU_1.2\FatFs\fs_diskio.c               #
#    Command line =  D:\wangfan2\桌面\RTU_1.2\FatFs\fs_diskio.c -lCN          #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\List\ -o      #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\Obj\          #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\桌面\RTU_1.2\project\iar\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\ADC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RTC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\TILT\ -I  #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RDLevel\  #
#                    -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RS232\ #
#                     -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\OS-v2 #
#                    \ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\Vibr #
#                    ationString\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\ #
#                    ..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\ucos2\uCOS-II #
#                    \Source\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\u #
#                    cos2\uC-LIB\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\ #
#                    ..\ucos2\uC-CPU\ -I D:\wangfan2\桌面\RTU_1.2\project\iar #
#                    \..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I                #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\cmsis\Drivers #
#                    \source\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\c #
#                    msis\Drivers\include\ -I D:\wangfan2\桌面\RTU_1.2\projec #
#                    t\iar\..\..\app\ -I D:\wangfan2\桌面\RTU_1.2\project\iar #
#                    \..\..\uC-Probe\Target\Plugins\uCOS-II\ -I               #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Workspaces\ -I                            #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Source\ -I D:\wangfan2\桌面\RTU_1.2\proje #
#                    ct\iar\..\..\uC-Probe\Target\Communication\Generic\Sourc #
#                    e\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Prob #
#                    e\Target\Communication\Generic\RS-232\Source\ -I         #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\Ports\NXP\LPC17xx\ -I    #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\OS\uCOS-II\ -I           #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\cmsis\Core\CM #
#                    3\CoreSupport\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\. #
#                    .\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\ -I  #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\DEVI #
#                    CE_BT\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\Hua #
#                    ceApp\DEVICE_COM\ -I D:\wangfan2\桌面\RTU_1.2\project\ia #
#                    r\..\..\HuaceApp\DEVICE_GPRS\ -I                         #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\DEVI #
#                    CE_GPS\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\Hu #
#                    aceApp\DEVICE_RADIO\ -I D:\wangfan2\桌面\RTU_1.2\project #
#                    \iar\..\..\HuaceApp\iap\ -I                              #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\FatFs\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\USB\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\bsp\spi_flash #
#                    \ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp #
#                    \LED\ -On --use_c++_inline                               #
#    List file    =  D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\List\fs_diski #
#                    o.lst                                                    #
#    Object file  =  D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\Obj\fs_diskio #
#                    .o                                                       #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\桌面\RTU_1.2\FatFs\fs_diskio.c
      1          /*-----------------------------------------------------------------------*/
      2          /* Low level disk I/O module                                             */
      3          /* (C) Copyright 2007,2008                                               */
      4          /* Martin Thomas, Lorenz Aebi                                            */
      5          /*-----------------------------------------------------------------------*/
      6          /* This is a LPC23xx/24xx MCI disk I/O module                            */
      7          /*-----------------------------------------------------------------------*/
      8          
      9          // Add Multi Block Write by Lorenz Aebi 2008
     10          // Bugfix from Marco Ziegert 20090823
     11          //#define DISKIO_DEBUG
     12          // #define DISKIO_DUMPSTAT
     13          //#define DISKIO_DEBUGR
     14          //#define DISKIO_DEBUGW
     15          #include <Global.h>
     16          #include "mcu_regs.h"
     17          #include "lpc_types.h"
     18          #include "lpc177x_8x_systick.h"
     19          #include "lpc177x_8x_mci.h"
     20          #include "sd_spi_mode.h"
     21          #include "dma.h"
     22          #include <string.h>
     23          #include  <stdlib.h>
     24          #include  <stdio.h>
     25          #include "diskio.h"
     26          #include "arm_comm.h"            //XULIANG 2011-11-09
     27          #include "includes.h"
     28          

   \                                 In section .data, align 1
     29          static volatile DSTATUS Stat = STA_NOINIT;	/* Disk status */
   \                     Stat:
   \   00000000   0x01               DC8 1
     30          

   \                                 In section .bss, align 4
     31          static uint8_t csd[16]; /* cached csd */
   \                     csd:
   \   00000000                      DS8 16
     32          

   \                                 In section .bss, align 4
     33          static uint8_t sd_status[16]; /* cached 16 MS-uint8_ts from SD_STATUS (ACMD13) */
   \                     sd_status:
   \   00000000                      DS8 16
     34          
     35          
     36          extern volatile DWORD MCI_CardType;
     37          extern volatile DWORD MCI_Block_End_Flag;
     38          
     39          /*-----------------------------------------------------------------------*/
     40          /* Initialize a Drive                                                    */
     41          

   \                                 In section .text, align 2, keep-with-next
     42          DSTATUS disk_initialize (
     43                                   uint8_t drv				/* Physical drive nmuber (0..) */
     44                                     )
     45          {
   \                     disk_initialize:
   \   00000000   0x0001             MOVS     R1,R0
     46            if ( drv != 0 ) return STA_NOINIT;
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD001             BEQ.N    ??disk_initialize_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE007             B.N      ??disk_initialize_1
     47          
     48            Stat &= ~STA_NOINIT;
   \                     ??disk_initialize_0:
   \   0000000C   0x....             LDR.N    R0,??DataTable5
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000014   0x....             LDR.N    R2,??DataTable5
   \   00000016   0x7010             STRB     R0,[R2, #+0]
     49          
     50            return Stat;
   \   00000018   0x....             LDR.N    R0,??DataTable5
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \                     ??disk_initialize_1:
   \   0000001C   0x4770             BX       LR               ;; return
     51          }
     52          
     53          /*-----------------------------------------------------------------------*/
     54          /* Return Disk Status                                                    */
     55          

   \                                 In section .text, align 2, keep-with-next
     56          DSTATUS disk_status (
     57                               uint8_t drv		/* Physical drive nmuber (0..) */
     58                                 )
     59          {
   \                     disk_status:
   \   00000000   0x0001             MOVS     R1,R0
     60            if ( drv != 0 ) return STA_NOINIT;
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD001             BEQ.N    ??disk_status_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE007             B.N      ??disk_status_1
     61          
     62            Stat &= ~STA_NOINIT;
   \                     ??disk_status_0:
   \   0000000C   0x....             LDR.N    R0,??DataTable5
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000014   0x....             LDR.N    R2,??DataTable5
   \   00000016   0x7010             STRB     R0,[R2, #+0]
     63          
     64            return Stat;
   \   00000018   0x....             LDR.N    R0,??DataTable5
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \                     ??disk_status_1:
   \   0000001C   0x4770             BX       LR               ;; return
     65          }
     66          
     67          /*-----------------------------------------------------------------------*/
     68          /* Read Sector(s)                                                        */
     69          

   \                                 In section .text, align 2, keep-with-next
     70          DRESULT disk_read (
     71                             uint8_t drv,		/* Physical drive number (0..) */
     72                             uint8_t *buff,		/* Data buffer to store read data */
     73                             DWORD sector,	/* Sector number (LBA) */
     74                             uint8_t count		/* Sector count (1..255) */
     75                               )
     76          {
   \                     disk_read:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
     77            if (drv || !count) return RES_PARERR;
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD102             BNE.N    ??disk_read_0
   \   00000010   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD101             BNE.N    ??disk_read_1
   \                     ??disk_read_0:
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0xE00C             B.N      ??disk_read_2
     78          
     79            if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_read_1:
   \   0000001A   0x....             LDR.N    R0,??DataTable5
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD501             BPL.N    ??disk_read_3
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE006             B.N      ??disk_read_2
     80          
     81            MMC_ReadBlock_S(buff,sector,count);
   \                     ??disk_read_3:
   \   00000026   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000028   0x003A             MOVS     R2,R7
   \   0000002A   0x0031             MOVS     R1,R6
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       MMC_ReadBlock_S
     82          
     83            return RES_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??disk_read_2:
   \   00000034   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     84          }
     85          
     86          /*-----------------------------------------------------------------------*/
     87          /* Write Sector(s)                                                       */
     88          
     89          #if _READONLY == 0

   \                                 In section .text, align 2, keep-with-next
     90          DRESULT disk_write (
     91                              uint8_t drv,			/* Physical drive number (0..) */
     92                              const uint8_t *buff,	/* Data to be written */
     93                              DWORD sector,		/* Sector number (LBA) */
     94                              uint8_t count			/* Sector count (1..255) */
     95                                )
     96          {
   \                     disk_write:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
     97            if (drv || !count)
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD102             BNE.N    ??disk_write_0
   \   00000010   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD101             BNE.N    ??disk_write_1
     98              return RES_PARERR;
   \                     ??disk_write_0:
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0xE012             B.N      ??disk_write_2
     99          
    100            if (Stat & STA_NOINIT)
   \                     ??disk_write_1:
   \   0000001A   0x....             LDR.N    R0,??DataTable5
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD501             BPL.N    ??disk_write_3
    101              return RES_NOTRDY;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE00C             B.N      ??disk_write_2
    102          
    103            if (Stat & STA_PROTECT)
   \                     ??disk_write_3:
   \   00000026   0x....             LDR.N    R0,??DataTable5
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x0740             LSLS     R0,R0,#+29
   \   0000002C   0xD501             BPL.N    ??disk_write_4
    104              return RES_WRPRT;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE006             B.N      ??disk_write_2
    105          
    106            MMC_WriteBlock_S((Int8U *)buff,sector,count);
   \                     ??disk_write_4:
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x003A             MOVS     R2,R7
   \   00000036   0x0031             MOVS     R1,R6
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       MMC_WriteBlock_S
    107          
    108            return RES_OK;
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??disk_write_2:
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    109          
    110          #endif /* _READONLY */
    111          
    112          }
    113          
    114          /*-----------------------------------------------------------------------*/
    115          /* Miscellaneous Functions                                               */
    116          

   \                                 In section .text, align 2, keep-with-next
    117          DRESULT disk_ioctl (
    118                              uint8_t drv,		/* Physical drive nmuber (0..) */
    119                              uint8_t ctrl,		/* Control code */
    120                              void *buff		/* Buffer to send/receive control data */
    121                                )
    122          {
   \                     disk_ioctl:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
    123            DRESULT res;
    124            uint8_t n; // buffered csd[16];
    125            DWORD csize;
    126          
    127            if (drv) return RES_PARERR;
   \   00000004   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000006   0x2B00             CMP      R3,#+0
   \   00000008   0xD001             BEQ.N    ??disk_ioctl_0
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xE09B             B.N      ??disk_ioctl_1
    128            if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_ioctl_0:
   \   0000000E   0x....             LDR.N    R0,??DataTable5
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x07C0             LSLS     R0,R0,#+31
   \   00000014   0xD501             BPL.N    ??disk_ioctl_2
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0xE095             B.N      ??disk_ioctl_1
    129          
    130            res = RES_ERROR;
   \                     ??disk_ioctl_2:
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x0004             MOVS     R4,R0
    131          
    132            switch (ctrl)
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD005             BEQ.N    ??disk_ioctl_3
   \   00000024   0x2902             CMP      R1,#+2
   \   00000026   0xD006             BEQ.N    ??disk_ioctl_4
   \   00000028   0xD30B             BCC.N    ??disk_ioctl_5
   \   0000002A   0x2903             CMP      R1,#+3
   \   0000002C   0xD045             BEQ.N    ??disk_ioctl_6
   \   0000002E   0xE086             B.N      ??disk_ioctl_7
    133            {
    134            case CTRL_SYNC :	          /* Flush dirty buffer if present */
    135              res = RES_OK;
   \                     ??disk_ioctl_3:
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0004             MOVS     R4,R0
    136              break;
   \   00000034   0xE085             B.N      ??disk_ioctl_8
    137            case GET_SECTOR_SIZE :	  /* Get sectors on the disk (WORD) */
    138              *(WORD*)buff = 512;
   \                     ??disk_ioctl_4:
   \   00000036   0xF44F 0x7000      MOV      R0,#+512
   \   0000003A   0x8010             STRH     R0,[R2, #+0]
    139              res = RES_OK;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x0004             MOVS     R4,R0
    140              break;
   \   00000040   0xE07F             B.N      ??disk_ioctl_8
    141            case GET_SECTOR_COUNT :	  /* Get number of sectors on the disk (WORD) */
    142              if ((csd[0] >> 6) == 1)
   \                     ??disk_ioctl_5:
   \   00000042   0x....             LDR.N    R0,??DataTable5_1
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x0980             LSRS     R0,R0,#+6
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD10A             BNE.N    ??disk_ioctl_9
    143              {	/* SDC ver 2.00 */
    144                csize = csd[9] + ((WORD)csd[8] << 8) + 1;
   \   00000050   0x....             LDR.N    R0,??DataTable5_1
   \   00000052   0x7A40             LDRB     R0,[R0, #+9]
   \   00000054   0x....             LDR.N    R7,??DataTable5_1
   \   00000056   0x7A3F             LDRB     R7,[R7, #+8]
   \   00000058   0xEB10 0x2007      ADDS     R0,R0,R7, LSL #+8
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \   0000005E   0x0006             MOVS     R6,R0
    145                *(DWORD*)buff = (DWORD)csize << 10;
   \   00000060   0x02B0             LSLS     R0,R6,#+10
   \   00000062   0x6010             STR      R0,[R2, #+0]
   \   00000064   0xE026             B.N      ??disk_ioctl_10
    146              }
    147              else
    148              {	/* MMC or SDC ver 1.XX */
    149                n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
   \                     ??disk_ioctl_9:
   \   00000066   0x....             LDR.N    R0,??DataTable5_1
   \   00000068   0x7940             LDRB     R0,[R0, #+5]
   \   0000006A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000006E   0x....             LDR.N    R7,??DataTable5_1
   \   00000070   0x7ABF             LDRB     R7,[R7, #+10]
   \   00000072   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000074   0xEB10 0x10D7      ADDS     R0,R0,R7, LSR #+7
   \   00000078   0x....             LDR.N    R7,??DataTable5_1
   \   0000007A   0x7A7F             LDRB     R7,[R7, #+9]
   \   0000007C   0xF017 0x0703      ANDS     R7,R7,#0x3
   \   00000080   0xEB10 0x0047      ADDS     R0,R0,R7, LSL #+1
   \   00000084   0x1C80             ADDS     R0,R0,#+2
   \   00000086   0x0005             MOVS     R5,R0
    150                csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
   \   00000088   0x....             LDR.N    R0,??DataTable5_1
   \   0000008A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x0980             LSRS     R0,R0,#+6
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x....             LDR.N    R7,??DataTable5_1
   \   00000094   0x79FF             LDRB     R7,[R7, #+7]
   \   00000096   0xEB10 0x0087      ADDS     R0,R0,R7, LSL #+2
   \   0000009A   0x....             LDR.N    R7,??DataTable5_1
   \   0000009C   0x79BF             LDRB     R7,[R7, #+6]
   \   0000009E   0xF017 0x0703      ANDS     R7,R7,#0x3
   \   000000A2   0xEB10 0x2087      ADDS     R0,R0,R7, LSL #+10
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   \   000000A8   0x0006             MOVS     R6,R0
    151                *(DWORD*)buff = (DWORD)csize << (n - 9);
   \   000000AA   0xF1B5 0x0009      SUBS     R0,R5,#+9
   \   000000AE   0xFA16 0xF000      LSLS     R0,R6,R0
   \   000000B2   0x6010             STR      R0,[R2, #+0]
    152              }
    153              res = RES_OK;
   \                     ??disk_ioctl_10:
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x0004             MOVS     R4,R0
    154              break;
   \   000000B8   0xE043             B.N      ??disk_ioctl_8
    155            case GET_BLOCK_SIZE :	/* Get erase block size in unit of sectors (DWORD) */
    156              if (MCI_CardType == MCI_SDSC_V2_CARD)
   \                     ??disk_ioctl_6:
   \   000000BA   0x....             LDR.N    R0,??DataTable5_2
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x2802             CMP      R0,#+2
   \   000000C0   0xD109             BNE.N    ??disk_ioctl_11
    157              { /* SDC ver 2.00 - use cached  Read SD status */
    158          
    159                // TODO - untested!
    160                *(DWORD*)buff = 16UL << (sd_status[10] >> 4);
   \   000000C2   0x2010             MOVS     R0,#+16
   \   000000C4   0x....             LDR.N    R7,??DataTable5_3
   \   000000C6   0x7ABF             LDRB     R7,[R7, #+10]
   \   000000C8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000CA   0x093F             LSRS     R7,R7,#+4
   \   000000CC   0x40B8             LSLS     R0,R0,R7
   \   000000CE   0x6010             STR      R0,[R2, #+0]
    161                res = RES_OK;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x0004             MOVS     R4,R0
   \   000000D4   0xE032             B.N      ??disk_ioctl_12
    162              }
    163              else
    164              {
    165                if (MCI_CardType == MCI_SDSC_V1_CARD)
   \                     ??disk_ioctl_11:
   \   000000D6   0x....             LDR.N    R0,??DataTable5_2
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD113             BNE.N    ??disk_ioctl_13
    166                {/* SDC ver 1.XX */
    167                  *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
   \   000000DE   0x....             LDR.N    R0,??DataTable5_1
   \   000000E0   0x7A80             LDRB     R0,[R0, #+10]
   \   000000E2   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   000000E6   0x....             LDR.N    R7,??DataTable5_1
   \   000000E8   0x7AFF             LDRB     R7,[R7, #+11]
   \   000000EA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000EC   0x09FF             LSRS     R7,R7,#+7
   \   000000EE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F0   0xEB17 0x0040      ADDS     R0,R7,R0, LSL #+1
   \   000000F4   0x1C40             ADDS     R0,R0,#+1
   \   000000F6   0x....             LDR.N    R7,??DataTable5_1
   \   000000F8   0x7B7F             LDRB     R7,[R7, #+13]
   \   000000FA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000FC   0x09BF             LSRS     R7,R7,#+6
   \   000000FE   0x1E7F             SUBS     R7,R7,#+1
   \   00000100   0x40B8             LSLS     R0,R0,R7
   \   00000102   0x6010             STR      R0,[R2, #+0]
   \   00000104   0xE018             B.N      ??disk_ioctl_14
    168                }
    169                else
    170                {/* MMC */
    171                  *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
   \                     ??disk_ioctl_13:
   \   00000106   0x....             LDR.N    R0,??DataTable5_1
   \   00000108   0x7A80             LDRB     R0,[R0, #+10]
   \   0000010A   0xF3C0 0x0084      UBFX     R0,R0,#+2,#+5
   \   0000010E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000110   0x1C40             ADDS     R0,R0,#+1
   \   00000112   0x....             LDR.N    R7,??DataTable5_1
   \   00000114   0x7AFF             LDRB     R7,[R7, #+11]
   \   00000116   0xF017 0x0703      ANDS     R7,R7,#0x3
   \   0000011A   0x.... 0x....      LDR.W    R12,??DataTable5_1
   \   0000011E   0xF89C 0xC00B      LDRB     R12,[R12, #+11]
   \   00000122   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000126   0xEA5F 0x1C5C      LSRS     R12,R12,#+5
   \   0000012A   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   0000012E   0xEB1C 0x07C7      ADDS     R7,R12,R7, LSL #+3
   \   00000132   0x1C7F             ADDS     R7,R7,#+1
   \   00000134   0x4378             MULS     R0,R7,R0
   \   00000136   0x6010             STR      R0,[R2, #+0]
    172                }
    173                res = RES_OK;
   \                     ??disk_ioctl_14:
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x0004             MOVS     R4,R0
    174              }
    175              break;
   \                     ??disk_ioctl_12:
   \   0000013C   0xE001             B.N      ??disk_ioctl_8
    176          
    177            default:
    178              res = RES_PARERR;
   \                     ??disk_ioctl_7:
   \   0000013E   0x2004             MOVS     R0,#+4
   \   00000140   0x0004             MOVS     R4,R0
    179            }
    180          
    181            return res;
   \                     ??disk_ioctl_8:
   \   00000142   0x0020             MOVS     R0,R4
   \   00000144   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_ioctl_1:
   \   00000146   0xBCF0             POP      {R4-R7}
   \   00000148   0x4770             BX       LR               ;; return
    182          }
    183          
    184          

   \                                 In section .text, align 2, keep-with-next
    185          DWORD get_fattime (void)
    186          {
   \                     get_fattime:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    187          
    188            if(g_Gps.bTimeValid)//时间有效
   \   00000002   0x....             LDR.N    R0,??DataTable5_4
   \   00000004   0xF890 0x0056      LDRB     R0,[R0, #+86]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD039             BEQ.N    ??get_fattime_0
    189            {
    190              return   ((DWORD)(g_Gps.y - 1980) << 25)
    191                | ((DWORD)g_Gps.m << 21)
    192                  | ((DWORD)g_Gps.d << 16)
    193                    | ((DWORD)(g_Gps.Second/3600%24) << 11)
    194                      | ((DWORD)(g_Gps.Second%3600/60) << 5)
    195                        | ((DWORD)(g_Gps.Second%3600%60) >> 1);
   \   0000000C   0x....             LDR.N    R0,??DataTable5_4
   \   0000000E   0x6CC0             LDR      R0,[R0, #+76]
   \   00000010   0xF44F 0x6161      MOV      R1,#+3600
   \   00000014   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000018   0x2118             MOVS     R1,#+24
   \   0000001A   0x....             LDR.N    R2,??DataTable5_4
   \   0000001C   0x6CD2             LDR      R2,[R2, #+76]
   \   0000001E   0xF44F 0x6361      MOV      R3,#+3600
   \   00000022   0x....             LDR.N    R4,??DataTable5_4
   \   00000024   0x6CE4             LDR      R4,[R4, #+76]
   \   00000026   0xF44F 0x6561      MOV      R5,#+3600
   \   0000002A   0xFBB4 0xF6F5      UDIV     R6,R4,R5
   \   0000002E   0xFB05 0x4416      MLS      R4,R5,R6,R4
   \   00000032   0x253C             MOVS     R5,#+60
   \   00000034   0x....             LDR.N    R6,??DataTable5_4
   \   00000036   0xF8B6 0x6050      LDRH     R6,[R6, #+80]
   \   0000003A   0xF2A6 0x76BC      SUBW     R6,R6,#+1980
   \   0000003E   0x....             LDR.N    R7,??DataTable5_4
   \   00000040   0xF897 0x7052      LDRB     R7,[R7, #+82]
   \   00000044   0x057F             LSLS     R7,R7,#+21
   \   00000046   0xEA57 0x6646      ORRS     R6,R7,R6, LSL #+25
   \   0000004A   0x....             LDR.N    R7,??DataTable5_4
   \   0000004C   0xF897 0x7053      LDRB     R7,[R7, #+83]
   \   00000050   0xEA56 0x4607      ORRS     R6,R6,R7, LSL #+16
   \   00000054   0xFBB0 0xF7F1      UDIV     R7,R0,R1
   \   00000058   0xFB01 0x0017      MLS      R0,R1,R7,R0
   \   0000005C   0xEA56 0x20C0      ORRS     R0,R6,R0, LSL #+11
   \   00000060   0xFBB2 0xF1F3      UDIV     R1,R2,R3
   \   00000064   0xFB03 0x2111      MLS      R1,R3,R1,R2
   \   00000068   0x223C             MOVS     R2,#+60
   \   0000006A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000006E   0xEA50 0x1041      ORRS     R0,R0,R1, LSL #+5
   \   00000072   0xFBB4 0xF1F5      UDIV     R1,R4,R5
   \   00000076   0xFB05 0x4111      MLS      R1,R5,R1,R4
   \   0000007A   0xEA50 0x0051      ORRS     R0,R0,R1, LSR #+1
   \   0000007E   0xE000             B.N      ??get_fattime_1
    196            }
    197            else
    198              return 0;
   \                     ??get_fattime_0:
   \   00000080   0x2000             MOVS     R0,#+0
   \                     ??get_fattime_1:
   \   00000082   0xBCF0             POP      {R4-R7}
   \   00000084   0x4770             BX       LR               ;; return
    199          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     csd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     MCI_CardType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     sd_status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     g_Gps

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   disk_initialize
      16   disk_ioctl
      24   disk_read
        24   -> MMC_ReadBlock_S
       0   disk_status
      24   disk_write
        24   -> MMC_WriteBlock_S
      16   get_fattime


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       1  Stat
      16  csd
      30  disk_initialize
     330  disk_ioctl
      54  disk_read
      30  disk_status
      66  disk_write
     134  get_fattime
      16  sd_status

 
  32 bytes in section .bss
   1 byte  in section .data
 664 bytes in section .text
 
 664 bytes of CODE memory
  33 bytes of DATA memory

Errors: none
Warnings: none
