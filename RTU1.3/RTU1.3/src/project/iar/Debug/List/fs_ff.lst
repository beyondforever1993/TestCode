###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:39 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\FatFs\fs_ #
#                    ff.c                                                     #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\FatFs\fs_ #
#                    ff.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\Debug\List\ -o                              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\fs_ff.lst                                  #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\fs_ff.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\FatFs\fs_ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.10c                (C)ChaN, 2014
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a generic FAT file system module for small embedded systems.
      5          / This is a free software that opened for education, research and commercial
      6          / developments under license policy of following terms.
      7          /
      8          /  Copyright (C) 2014, ChaN, all right reserved.
      9          /
     10          / * The FatFs module is a free software and there is NO WARRANTY.
     11          / * No restriction on use. You can use, modify and redistribute it for
     12          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     13          / * Redistributions of source code must retain the above copyright notice.
     14          /
     15          /-----------------------------------------------------------------------------/
     16          / Feb 26,'06 R0.00  Prototype.
     17          /
     18          / Apr 29,'06 R0.01  First stable version.
     19          /
     20          / Jun 01,'06 R0.02  Added FAT12 support.
     21          /                   Removed unbuffered mode.
     22          /                   Fixed a problem on small (<32M) partition.
     23          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     24          /
     25          / Sep 22,'06 R0.03  Added f_rename().
     26          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     27          / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
     28          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     29          /
     30          / Feb 04,'07 R0.04  Supported multiple drive system.
     31          /                   Changed some interfaces for multiple drive system.
     32          /                   Changed f_mountdrv() to f_mount().
     33          /                   Added f_mkfs().
     34          / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
     35          /                   Added a capability of extending file size to f_lseek().
     36          /                   Added minimization level 3.
     37          /                   Fixed an endian sensitive code in f_mkfs().
     38          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     39          /                   Added FSINFO support.
     40          /                   Fixed DBCS name can result FR_INVALID_NAME.
     41          /                   Fixed short seek (<= csize) collapses the file object.
     42          /
     43          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     44          /                   Fixed f_mkfs() on FAT32 creates incorrect FSINFO.
     45          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     46          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     47          /                   Fixed off by one error at FAT sub-type determination.
     48          /                   Fixed btr in f_read() can be mistruncated.
     49          /                   Fixed cached sector is not flushed when create and close without write.
     50          /
     51          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     52          /                   Improved performance of f_lseek() on moving to the same or following cluster.
     53          /
     54          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
     55          /                   Added long file name feature.
     56          /                   Added multiple code page feature.
     57          /                   Added re-entrancy for multitask operation.
     58          /                   Added auto cluster size selection to f_mkfs().
     59          /                   Added rewind option to f_readdir().
     60          /                   Changed result code of critical errors.
     61          /                   Renamed string functions to avoid name collision.
     62          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     63          /                   Added multiple sector size feature.
     64          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     65          /                   Fixed wrong cache control in f_lseek().
     66          /                   Added relative path feature.
     67          /                   Added f_chdir() and f_chdrive().
     68          /                   Added proper case conversion to extended character.
     69          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
     70          /                   Fixed f_unlink() fails to remove a sub-directory on _FS_RPATH.
     71          /                   Fixed name matching error on the 13 character boundary.
     72          /                   Added a configuration option, _LFN_UNICODE.
     73          /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
     74          /
     75          / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
     76          /                   Added file lock feature. (_FS_SHARE)
     77          /                   Added fast seek feature. (_USE_FASTSEEK)
     78          /                   Changed some types on the API, XCHAR->TCHAR.
     79          /                   Changed .fname in the FILINFO structure on Unicode cfg.
     80          /                   String functions support UTF-8 encoding files on Unicode cfg.
     81          / Aug 16,'10 R0.08a Added f_getcwd().
     82          /                   Added sector erase feature. (_USE_ERASE)
     83          /                   Moved file lock semaphore table from fs object to the bss.
     84          /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
     85          /                   Fixed f_mkfs() creates wrong FAT32 volume.
     86          / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
     87          /                   f_lseek() reports required table size on creating CLMP.
     88          /                   Extended format syntax of f_printf().
     89          /                   Ignores duplicated directory separators in given path name.
     90          /
     91          / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to complete the multiple partition feature.
     92          /                   Added f_fdisk().
     93          / Aug 27,'12 R0.09a Changed f_open() and f_opendir() reject null object pointer to avoid crash.
     94          /                   Changed option name _FS_SHARE to _FS_LOCK.
     95          /                   Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
     96          / Jan 24,'13 R0.09b Added f_setlabel() and f_getlabel().
     97          /
     98          / Oct 02,'13 R0.10  Added selection of character encoding on the file. (_STRF_ENCODE)
     99          /                   Added f_closedir().
    100          /                   Added forced full FAT scan for f_getfree(). (_FS_NOFSINFO)
    101          /                   Added forced mount feature with changes of f_mount().
    102          /                   Improved behavior of volume auto detection.
    103          /                   Improved write throughput of f_puts() and f_printf().
    104          /                   Changed argument of f_chdrive(), f_mkfs(), disk_read() and disk_write().
    105          /                   Fixed f_write() can be truncated when the file size is close to 4GB.
    106          /                   Fixed f_open(), f_mkdir() and f_setlabel() can return incorrect error code.
    107          / Jan 15,'14 R0.10a Added arbitrary strings as drive number in the path name. (_STR_VOLUME_ID)
    108          /                   Added a configuration option of minimum sector size. (_MIN_SS)
    109          /                   2nd argument of f_rename() can have a drive number and it will be ignored.
    110          /                   Fixed f_mount() with forced mount fails when drive number is >= 1.
    111          /                   Fixed f_close() invalidates the file object without volume lock.
    112          /                   Fixed f_closedir() returns but the volume lock is left acquired.
    113          /                   Fixed creation of an entry with LFN fails on too many SFN collisions.
    114          / May 19,'14 R0.10b Fixed a hard error in the disk I/O layer can collapse the directory entry.
    115          /                   Fixed LFN entry is not deleted on delete/rename an object with lossy converted SFN.
    116          / Nov 09,'14 R0.10c Added a configuration option for the platforms without RTC. (_FS_NORTC)
    117          /                   Fixed volume label created by Mac OS X cannot be retrieved with f_getlabel().
    118          /                   Fixed a potential problem of FAT access that can appear on disk error.
    119          /                   Fixed null pointer dereference on attempting to delete the root direcotry.
    120          /---------------------------------------------------------------------------*/
    121          
    122          #include "ff.h"			/* Declarations of FatFs API */
    123          #include "diskio.h"		/* Declarations of disk I/O functions */
    124          
    125          
    126          
    127          
    128          /*--------------------------------------------------------------------------
    129          
    130             Module Private Definitions
    131          
    132          ---------------------------------------------------------------------------*/
    133          
    134          #if _FATFS != 80376	/* Revision ID */
    135          #error Wrong include file (ff.h).
    136          #endif
    137          
    138          
    139          /* Reentrancy related */
    140          #if _FS_REENTRANT
    141          #if _USE_LFN == 1
    142          #error Static LFN work area cannot be used at thread-safe configuration
    143          #endif
    144          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
    145          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
    146          #else
    147          #define	ENTER_FF(fs)
    148          #define LEAVE_FF(fs, res)	return res
    149          #endif
    150          
    151          #define	ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
    152          
    153          
    154          /* Definitions of sector size */
    155          #if (_MAX_SS < _MIN_SS) || (_MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096) || (_MIN_SS != 512 && _MIN_SS != 1024 && _MIN_SS != 2048 && _MIN_SS != 4096)
    156          #error Wrong sector size configuration
    157          #endif
    158          #if _MAX_SS == _MIN_SS
    159          #define	SS(fs)	((UINT)_MAX_SS)	/* Fixed sector size */
    160          #else
    161          #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
    162          #endif
    163          
    164          
    165          /* Timestamp feature */
    166          #if _FS_NORTC
    167          #define GET_FATTIME()	((DWORD)_NORTC_YEAR << 25 | (DWORD)_NORTC_MON << 21 | (DWORD)_NORTC_MDAY << 16)
    168          #else
    169          #define GET_FATTIME()	get_fattime()
    170          #endif
    171          
    172          
    173          /* File access control feature */
    174          #if _FS_LOCK
    175          #if _FS_READONLY
    176          #error _FS_LOCK must be 0 at read-only configuration
    177          #endif
    178          typedef struct {
    179          	FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
    180          	DWORD clu;		/* Object ID 2, directory (0:root) */
    181          	WORD idx;		/* Object ID 3, directory index */
    182          	WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
    183          } FILESEM;
    184          #endif
    185          
    186          
    187          
    188          /* DBCS code ranges and SBCS extend character conversion table */
    189          
    190          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
    191          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
    192          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
    193          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
    194          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
    195          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
    196          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
    197          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
    198          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
    199          
    200          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
    201          #define _DF1S	0x81
    202          #define _DF1E	0xFE
    203          #define _DS1S	0x40
    204          #define _DS1E	0x7E
    205          #define _DS2S	0x80
    206          #define _DS2E	0xFE
    207          
    208          #elif _CODE_PAGE == 949	/* Korean */
    209          #define _DF1S	0x81
    210          #define _DF1E	0xFE
    211          #define _DS1S	0x41
    212          #define _DS1E	0x5A
    213          #define _DS2S	0x61
    214          #define _DS2E	0x7A
    215          #define _DS3S	0x81
    216          #define _DS3E	0xFE
    217          
    218          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    219          #define _DF1S	0x81
    220          #define _DF1E	0xFE
    221          #define _DS1S	0x40
    222          #define _DS1E	0x7E
    223          #define _DS2S	0xA1
    224          #define _DS2E	0xFE
    225          
    226          #elif _CODE_PAGE == 437	/* U.S. (OEM) */
    227          #define _DF1S	0
    228          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    229          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    230          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    231          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    232          
    233          #elif _CODE_PAGE == 720	/* Arabic (OEM) */
    234          #define _DF1S	0
    235          #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    236          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    237          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    238          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    239          
    240          #elif _CODE_PAGE == 737	/* Greek (OEM) */
    241          #define _DF1S	0
    242          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    243          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    244          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    245          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    246          
    247          #elif _CODE_PAGE == 775	/* Baltic (OEM) */
    248          #define _DF1S	0
    249          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    250          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    251          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    252          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    253          
    254          #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
    255          #define _DF1S	0
    256          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    257          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    258          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    259          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    260          
    261          #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
    262          #define _DF1S	0
    263          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
    264          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    265          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    266          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    267          
    268          #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
    269          #define _DF1S	0
    270          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    271          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    272          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    273          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    274          
    275          #elif _CODE_PAGE == 857	/* Turkish (OEM) */
    276          #define _DF1S	0
    277          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    278          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    279          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    280          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    281          
    282          #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
    283          #define _DF1S	0
    284          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    285          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    286          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    287          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    288          
    289          #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
    290          #define _DF1S	0
    291          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    292          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    293          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    294          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    295          
    296          #elif _CODE_PAGE == 866	/* Russian (OEM) */
    297          #define _DF1S	0
    298          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    299          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    300          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    301          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    302          
    303          #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
    304          #define _DF1S	0
    305          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    306          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    307          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    308          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    309          
    310          #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
    311          #define _DF1S	0
    312          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    313          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
    314          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    315          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    316          
    317          #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
    318          #define _DF1S	0
    319          #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    320          				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
    321          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    322          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
    323          
    324          #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
    325          #define _DF1S	0
    326          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
    327          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    328          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    329          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    330          
    331          #elif _CODE_PAGE == 1253 /* Greek (Windows) */
    332          #define _DF1S	0
    333          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    334          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    335          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
    336          				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
    337          
    338          #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
    339          #define _DF1S	0
    340          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    341          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    342          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    343          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    344          
    345          #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
    346          #define _DF1S	0
    347          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    348          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    349          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    350          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    351          
    352          #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
    353          #define _DF1S	0
    354          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    355          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    356          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    357          				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
    358          
    359          #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
    360          #define _DF1S	0
    361          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    362          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
    363          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    364          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    365          
    366          #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
    367          #define _DF1S	0
    368          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
    369          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    370          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    371          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
    372          
    373          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    374          #if _USE_LFN
    375          #error Cannot use LFN feature without valid code page.
    376          #endif
    377          #define _DF1S	0
    378          
    379          #else
    380          #error Unknown code page
    381          
    382          #endif
    383          
    384          
    385          /* Character code support macros */
    386          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    387          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    388          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    389          
    390          #if _DF1S		/* Code page is DBCS */
    391          
    392          #ifdef _DF2S	/* Two 1st byte areas */
    393          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    394          #else			/* One 1st byte area */
    395          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    396          #endif
    397          
    398          #ifdef _DS3S	/* Three 2nd byte areas */
    399          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    400          #else			/* Two 2nd byte areas */
    401          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    402          #endif
    403          
    404          #else			/* Code page is SBCS */
    405          
    406          #define IsDBCS1(c)	0
    407          #define IsDBCS2(c)	0
    408          
    409          #endif /* _DF1S */
    410          
    411          
    412          /* Name status flags */
    413          #define NSFLAG		11		/* Index of name status byte in fn[] */
    414          #define NS_LOSS		0x01	/* Out of 8.3 format */
    415          #define NS_LFN		0x02	/* Force to create LFN entry */
    416          #define NS_LAST		0x04	/* Last segment */
    417          #define NS_BODY		0x08	/* Lower case flag (body) */
    418          #define NS_EXT		0x10	/* Lower case flag (ext) */
    419          #define NS_DOT		0x20	/* Dot entry */
    420          
    421          
    422          /* FAT sub-type boundaries (Differ from specs but correct for real DOS/Windows) */
    423          #define MIN_FAT16	4086U	/* Minimum number of clusters as FAT16 */
    424          #define	MIN_FAT32	65526U	/* Minimum number of clusters as FAT32 */
    425          
    426          
    427          /* FatFs refers the members in the FAT structures as byte array instead of
    428          / structure member because the structure is not binary compatible between
    429          / different platforms */
    430          
    431          #define BS_jmpBoot			0		/* x86 jump instruction (3) */
    432          #define BS_OEMName			3		/* OEM name (8) */
    433          #define BPB_BytsPerSec		11		/* Sector size [byte] (2) */
    434          #define BPB_SecPerClus		13		/* Cluster size [sector] (1) */
    435          #define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (2) */
    436          #define BPB_NumFATs			16		/* Number of FAT copies (1) */
    437          #define BPB_RootEntCnt		17		/* Number of root directory entries for FAT12/16 (2) */
    438          #define BPB_TotSec16		19		/* Volume size [sector] (2) */
    439          #define BPB_Media			21		/* Media descriptor (1) */
    440          #define BPB_FATSz16			22		/* FAT size [sector] (2) */
    441          #define BPB_SecPerTrk		24		/* Track size [sector] (2) */
    442          #define BPB_NumHeads		26		/* Number of heads (2) */
    443          #define BPB_HiddSec			28		/* Number of special hidden sectors (4) */
    444          #define BPB_TotSec32		32		/* Volume size [sector] (4) */
    445          #define BS_DrvNum			36		/* Physical drive number (2) */
    446          #define BS_BootSig			38		/* Extended boot signature (1) */
    447          #define BS_VolID			39		/* Volume serial number (4) */
    448          #define BS_VolLab			43		/* Volume label (8) */
    449          #define BS_FilSysType		54		/* File system type (1) */
    450          #define BPB_FATSz32			36		/* FAT size [sector] (4) */
    451          #define BPB_ExtFlags		40		/* Extended flags (2) */
    452          #define BPB_FSVer			42		/* File system version (2) */
    453          #define BPB_RootClus		44		/* Root directory first cluster (4) */
    454          #define BPB_FSInfo			48		/* Offset of FSINFO sector (2) */
    455          #define BPB_BkBootSec		50		/* Offset of backup boot sector (2) */
    456          #define BS_DrvNum32			64		/* Physical drive number (2) */
    457          #define BS_BootSig32		66		/* Extended boot signature (1) */
    458          #define BS_VolID32			67		/* Volume serial number (4) */
    459          #define BS_VolLab32			71		/* Volume label (8) */
    460          #define BS_FilSysType32		82		/* File system type (1) */
    461          #define	FSI_LeadSig			0		/* FSI: Leading signature (4) */
    462          #define	FSI_StrucSig		484		/* FSI: Structure signature (4) */
    463          #define	FSI_Free_Count		488		/* FSI: Number of free clusters (4) */
    464          #define	FSI_Nxt_Free		492		/* FSI: Last allocated cluster (4) */
    465          #define MBR_Table			446		/* MBR: Partition table offset (2) */
    466          #define	SZ_PTE				16		/* MBR: Size of a partition table entry */
    467          #define BS_55AA				510		/* Signature word (2) */
    468          
    469          #define	DIR_Name			0		/* Short file name (11) */
    470          #define	DIR_Attr			11		/* Attribute (1) */
    471          #define	DIR_NTres			12		/* NT flag (1) */
    472          #define DIR_CrtTimeTenth	13		/* Created time sub-second (1) */
    473          #define	DIR_CrtTime			14		/* Created time (2) */
    474          #define	DIR_CrtDate			16		/* Created date (2) */
    475          #define DIR_LstAccDate		18		/* Last accessed date (2) */
    476          #define	DIR_FstClusHI		20		/* Higher 16-bit of first cluster (2) */
    477          #define	DIR_WrtTime			22		/* Modified time (2) */
    478          #define	DIR_WrtDate			24		/* Modified date (2) */
    479          #define	DIR_FstClusLO		26		/* Lower 16-bit of first cluster (2) */
    480          #define	DIR_FileSize		28		/* File size (4) */
    481          #define	LDIR_Ord			0		/* LFN entry order and LLE flag (1) */
    482          #define	LDIR_Attr			11		/* LFN attribute (1) */
    483          #define	LDIR_Type			12		/* LFN type (1) */
    484          #define	LDIR_Chksum			13		/* Sum of corresponding SFN entry */
    485          #define	LDIR_FstClusLO		26		/* Filled by zero (0) */
    486          #define	SZ_DIR				32		/* Size of a directory entry */
    487          #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
    488          #define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
    489          #define	NDDE				0x05	/* Replacement of the character collides with DDE */
    490          
    491          
    492          
    493          
    494          /*------------------------------------------------------------*/
    495          /* Module private work area                                   */
    496          /*------------------------------------------------------------*/
    497          /* Remark: Uninitialized variables with static duration are
    498          /  guaranteed zero/null at start-up. If not, either the linker
    499          /  or start-up routine being used is out of ANSI-C standard.
    500          */
    501          
    502          #if _VOLUMES < 1 || _VOLUMES > 9
    503          #error Wrong _VOLUMES setting
    504          #endif

   \                                 In section .bss, align 4
    505          static FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
   \                     FatFs:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
    506          static WORD Fsid;				/* File system mount ID */
   \                     Fsid:
   \   00000000                      DS8 2
    507          
    508          #if _FS_RPATH && _VOLUMES >= 2
    509          static BYTE CurrVol;			/* Current drive */
    510          #endif
    511          
    512          #if _FS_LOCK
    513          static FILESEM Files[_FS_LOCK];	/* Open object lock semaphores */
    514          #endif
    515          
    516          #if _USE_LFN == 0			/* Non LFN feature */
    517          #define	DEF_NAMEBUF			BYTE sfn[12]
    518          #define INIT_BUF(dobj)		(dobj).fn = sfn
    519          #define	FREE_BUF()
    520          #else
    521          #if _MAX_LFN < 12 || _MAX_LFN > 255
    522          #error Wrong _MAX_LFN setting
    523          #endif
    524          #if _USE_LFN == 1			/* LFN feature with static working buffer */

   \                                 In section .bss, align 4
    525          static WCHAR LfnBuf[_MAX_LFN+1];
   \                     LfnBuf:
   \   00000000                      DS8 512
    526          #define	DEF_NAMEBUF			BYTE sfn[12]
    527          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    528          #define	FREE_BUF()
    529          #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
    530          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
    531          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
    532          #define	FREE_BUF()
    533          #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
    534          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
    535          #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); (dobj).lfn = lfn; (dobj).fn = sfn; }
    536          #define	FREE_BUF()			ff_memfree(lfn)
    537          #else
    538          #error Wrong _USE_LFN setting
    539          #endif
    540          #endif
    541          
    542          #ifdef _EXCVT

   \                                 In section .rodata, align 4
    543          static const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for extended characters */
   \                     ExCvt:
   \   00000000   0x80 0x9A          DC8 128, 154, 144, 65, 142, 65, 143, 128, 69, 69, 69, 73, 73, 73, 142
   \              0x90 0x41    
   \              0x8E 0x41    
   \              0x8F 0x80    
   \              0x45 0x45    
   \              0x45 0x49    
   \              0x49 0x49    
   \              0x8E         
   \   0000000F   0x8F 0x90          DC8 143, 144, 146, 146, 79, 153, 79, 85, 85, 89, 153, 154, 155, 156
   \              0x92 0x92    
   \              0x4F 0x99    
   \              0x4F 0x55    
   \              0x55 0x59    
   \              0x99 0x9A    
   \              0x9B 0x9C    
   \   0000001D   0x9D 0x9E          DC8 157, 158, 159, 65, 73, 79, 85, 165, 165, 166, 167, 168, 169, 170
   \              0x9F 0x41    
   \              0x49 0x4F    
   \              0x55 0xA5    
   \              0xA5 0xA6    
   \              0xA7 0xA8    
   \              0xA9 0xAA    
   \   0000002B   0xAB 0xAC          DC8 171, 172, 33, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184
   \              0x21 0xAE    
   \              0xAF 0xB0    
   \              0xB1 0xB2    
   \              0xB3 0xB4    
   \              0xB5 0xB6    
   \              0xB7 0xB8    
   \   00000039   0xB9 0xBA          DC8 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197
   \              0xBB 0xBC    
   \              0xBD 0xBE    
   \              0xBF 0xC0    
   \              0xC1 0xC2    
   \              0xC3 0xC4    
   \              0xC5         
   \   00000046   0xC6 0xC7          DC8 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210
   \              0xC8 0xC9    
   \              0xCA 0xCB    
   \              0xCC 0xCD    
   \              0xCE 0xCF    
   \              0xD0 0xD1    
   \              0xD2         
   \   00000053   0xD3 0xD4          DC8 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223
   \              0xD5 0xD6    
   \              0xD7 0xD8    
   \              0xD9 0xDA    
   \              0xDB 0xDC    
   \              0xDD 0xDE    
   \              0xDF         
   \   00000060   0xE0 0xE1          DC8 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236
   \              0xE2 0xE3    
   \              0xE4 0xE5    
   \              0xE6 0xE7    
   \              0xE8 0xE9    
   \              0xEA 0xEB    
   \              0xEC         
   \   0000006D   0xED 0xEE          DC8 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249
   \              0xEF 0xF0    
   \              0xF1 0xF2    
   \              0xF3 0xF4    
   \              0xF5 0xF6    
   \              0xF7 0xF8    
   \              0xF9         
   \   0000007A   0xFA 0xFB          DC8 250, 251, 252, 253, 254, 255
   \              0xFC 0xFD    
   \              0xFE 0xFF    
    544          #endif
    545          
    546          
    547          
    548          
    549          
    550          
    551          /*--------------------------------------------------------------------------
    552          
    553             Module Private Functions
    554          
    555          ---------------------------------------------------------------------------*/
    556          
    557          
    558          /*-----------------------------------------------------------------------*/
    559          /* String functions                                                      */
    560          /*-----------------------------------------------------------------------*/
    561          
    562          /* Copy memory to memory */

   \                                 In section .text, align 2, keep-with-next
    563          static
    564          void mem_cpy (void* dst, const void* src, UINT cnt) {
   \                     mem_cpy:
   \   00000000   0xB430             PUSH     {R4,R5}
    565          	BYTE *d = (BYTE*)dst;
   \   00000002   0x0003             MOVS     R3,R0
    566          	const BYTE *s = (const BYTE*)src;
   \   00000004   0x000C             MOVS     R4,R1
    567          
    568          #if _WORD_ACCESS == 1
    569          	while (cnt >= sizeof (int)) {
    570          		*(int*)d = *(int*)s;
    571          		d += sizeof (int); s += sizeof (int);
    572          		cnt -= sizeof (int);
    573          	}
    574          #endif
    575          	while (cnt--)
   \                     ??mem_cpy_0:
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x1E6A             SUBS     R2,R5,#+1
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD004             BEQ.N    ??mem_cpy_1
    576          		*d++ = *s++;
   \   0000000E   0x7825             LDRB     R5,[R4, #+0]
   \   00000010   0x701D             STRB     R5,[R3, #+0]
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0xE7F6             B.N      ??mem_cpy_0
    577          }
   \                     ??mem_cpy_1:
   \   00000018   0xBC30             POP      {R4,R5}
   \   0000001A   0x4770             BX       LR               ;; return
    578          
    579          /* Fill memory */

   \                                 In section .text, align 2, keep-with-next
    580          static
    581          void mem_set (void* dst, int val, UINT cnt) {
   \                     mem_set:
   \   00000000   0xB410             PUSH     {R4}
    582          	BYTE *d = (BYTE*)dst;
   \   00000002   0x0003             MOVS     R3,R0
    583          
    584          	while (cnt--)
   \                     ??mem_set_0:
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0x1E62             SUBS     R2,R4,#+1
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD002             BEQ.N    ??mem_set_1
    585          		*d++ = (BYTE)val;
   \   0000000C   0x7019             STRB     R1,[R3, #+0]
   \   0000000E   0x1C5B             ADDS     R3,R3,#+1
   \   00000010   0xE7F8             B.N      ??mem_set_0
    586          }
   \                     ??mem_set_1:
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x4770             BX       LR               ;; return
    587          
    588          /* Compare memory to memory */

   \                                 In section .text, align 2, keep-with-next
    589          static
    590          int mem_cmp (const void* dst, const void* src, UINT cnt) {
   \                     mem_cmp:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    591          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
   \   00000004   0x001C             MOVS     R4,R3
   \   00000006   0x000D             MOVS     R5,R1
    592          	int r = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    593          
    594          	while (cnt-- && (r = *d++ - *s++) == 0) ;
   \                     ??mem_cmp_0:
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x1E72             SUBS     R2,R6,#+1
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD006             BEQ.N    ??mem_cmp_1
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x782E             LDRB     R6,[R5, #+0]
   \   00000016   0x1B80             SUBS     R0,R0,R6
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD0F4             BEQ.N    ??mem_cmp_0
    595          	return r;
   \                     ??mem_cmp_1:
   \   00000020   0xBC70             POP      {R4-R6}
   \   00000022   0x4770             BX       LR               ;; return
    596          }
    597          
    598          /* Check if chr is contained in the string */

   \                                 In section .text, align 2, keep-with-next
    599          static
    600          int chk_chr (const char* str, int chr) {
    601          	while (*str && *str != chr) str++;
   \                     chk_chr:
   \                     ??chk_chr_0:
   \   00000000   0x7802             LDRB     R2,[R0, #+0]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD004             BEQ.N    ??chk_chr_1
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x428A             CMP      R2,R1
   \   0000000A   0xD001             BEQ.N    ??chk_chr_1
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0xE7F7             B.N      ??chk_chr_0
    602          	return *str;
   \                     ??chk_chr_1:
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x4770             BX       LR               ;; return
    603          }
    604          
    605          
    606          
    607          
    608          /*-----------------------------------------------------------------------*/
    609          /* Request/Release grant to access the volume                            */
    610          /*-----------------------------------------------------------------------*/
    611          #if _FS_REENTRANT
    612          static
    613          int lock_fs (
    614          	FATFS* fs		/* File system object */
    615          )
    616          {
    617          	return ff_req_grant(fs->sobj);
    618          }
    619          
    620          
    621          static
    622          void unlock_fs (
    623          	FATFS* fs,		/* File system object */
    624          	FRESULT res		/* Result code to be returned */
    625          )
    626          {
    627          	if (fs &&
    628          		res != FR_NOT_ENABLED &&
    629          		res != FR_INVALID_DRIVE &&
    630          		res != FR_INVALID_OBJECT &&
    631          		res != FR_TIMEOUT) {
    632          		ff_rel_grant(fs->sobj);
    633          	}
    634          }
    635          #endif
    636          
    637          
    638          
    639          
    640          /*-----------------------------------------------------------------------*/
    641          /* File lock control functions                                           */
    642          /*-----------------------------------------------------------------------*/
    643          #if _FS_LOCK
    644          
    645          static
    646          FRESULT chk_lock (	/* Check if the file can be accessed */
    647          	DIR* dp,		/* Directory object pointing the file to be checked */
    648          	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
    649          )
    650          {
    651          	UINT i, be;
    652          
    653          	/* Search file semaphore table */
    654          	for (i = be = 0; i < _FS_LOCK; i++) {
    655          		if (Files[i].fs) {	/* Existing entry */
    656          			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
    657          				Files[i].clu == dp->sclust &&
    658          				Files[i].idx == dp->index) break;
    659          		} else {			/* Blank entry */
    660          			be = 1;
    661          		}
    662          	}
    663          	if (i == _FS_LOCK)	/* The object is not opened */
    664          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
    665          
    666          	/* The object has been opened. Reject any open against writing file and all write mode open */
    667          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
    668          }
    669          
    670          
    671          static
    672          int enq_lock (void)	/* Check if an entry is available for a new object */
    673          {
    674          	UINT i;
    675          
    676          	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    677          	return (i == _FS_LOCK) ? 0 : 1;
    678          }
    679          
    680          
    681          static
    682          UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
    683          	DIR* dp,	/* Directory object pointing the file to register or increment */
    684          	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    685          )
    686          {
    687          	UINT i;
    688          
    689          
    690          	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
    691          		if (Files[i].fs == dp->fs &&
    692          			Files[i].clu == dp->sclust &&
    693          			Files[i].idx == dp->index) break;
    694          	}
    695          
    696          	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
    697          		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    698          		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
    699          		Files[i].fs = dp->fs;
    700          		Files[i].clu = dp->sclust;
    701          		Files[i].idx = dp->index;
    702          		Files[i].ctr = 0;
    703          	}
    704          
    705          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
    706          
    707          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
    708          
    709          	return i + 1;
    710          }
    711          
    712          
    713          static
    714          FRESULT dec_lock (	/* Decrement object open counter */
    715          	UINT i			/* Semaphore index (1..) */
    716          )
    717          {
    718          	WORD n;
    719          	FRESULT res;
    720          
    721          
    722          	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
    723          		n = Files[i].ctr;
    724          		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
    725          		if (n) n--;					/* Decrement read mode open count */
    726          		Files[i].ctr = n;
    727          		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
    728          		res = FR_OK;
    729          	} else {
    730          		res = FR_INT_ERR;			/* Invalid index nunber */
    731          	}
    732          	return res;
    733          }
    734          
    735          
    736          static
    737          void clear_lock (	/* Clear lock entries of the volume */
    738          	FATFS *fs
    739          )
    740          {
    741          	UINT i;
    742          
    743          	for (i = 0; i < _FS_LOCK; i++) {
    744          		if (Files[i].fs == fs) Files[i].fs = 0;
    745          	}
    746          }
    747          #endif
    748          
    749          
    750          
    751          
    752          /*-----------------------------------------------------------------------*/
    753          /* Move/Flush disk access window in the file system object               */
    754          /*-----------------------------------------------------------------------*/
    755          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    756          static
    757          FRESULT sync_window (
    758          	FATFS* fs		/* File system object */
    759          )
    760          {
   \                     sync_window:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    761          	DWORD wsect;
    762          	UINT nf;
    763          	FRESULT res = FR_OK;
   \   00000004   0x2700             MOVS     R7,#+0
    764          
    765          
    766          	if (fs->wflag) {	/* Write back the sector if it is dirty */
   \   00000006   0x7920             LDRB     R0,[R4, #+4]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD023             BEQ.N    ??sync_window_0
    767          		wsect = fs->winsect;	/* Current sector number */
   \   0000000C   0x6B20             LDR      R0,[R4, #+48]
   \   0000000E   0x0005             MOVS     R5,R0
    768          		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x002A             MOVS     R2,R5
   \   00000014   0xF114 0x0134      ADDS     R1,R4,#+52
   \   00000018   0x7860             LDRB     R0,[R4, #+1]
   \   0000001A   0x.... 0x....      BL       disk_write
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD002             BEQ.N    ??sync_window_1
    769          			res = FR_DISK_ERR;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x0007             MOVS     R7,R0
   \   00000026   0xE015             B.N      ??sync_window_0
    770          		} else {
    771          			fs->wflag = 0;
   \                     ??sync_window_1:
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7120             STRB     R0,[R4, #+4]
    772          			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
   \   0000002C   0x6A60             LDR      R0,[R4, #+36]
   \   0000002E   0x1A28             SUBS     R0,R5,R0
   \   00000030   0x69E1             LDR      R1,[R4, #+28]
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD20E             BCS.N    ??sync_window_0
    773          				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
   \   00000036   0x78E0             LDRB     R0,[R4, #+3]
   \   00000038   0x0006             MOVS     R6,R0
   \                     ??sync_window_2:
   \   0000003A   0x2E02             CMP      R6,#+2
   \   0000003C   0xD30A             BCC.N    ??sync_window_0
    774          					wsect += fs->fsize;
   \   0000003E   0x69E0             LDR      R0,[R4, #+28]
   \   00000040   0x1945             ADDS     R5,R0,R5
    775          					disk_write(fs->drv, fs->win, wsect, 1);
   \   00000042   0x2301             MOVS     R3,#+1
   \   00000044   0x002A             MOVS     R2,R5
   \   00000046   0xF114 0x0134      ADDS     R1,R4,#+52
   \   0000004A   0x7860             LDRB     R0,[R4, #+1]
   \   0000004C   0x.... 0x....      BL       disk_write
    776          				}
   \   00000050   0x1E76             SUBS     R6,R6,#+1
   \   00000052   0xE7F2             B.N      ??sync_window_2
    777          			}
    778          		}
    779          	}
    780          	return res;
   \                     ??sync_window_0:
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    781          }
    782          #endif
    783          
    784          

   \                                 In section .text, align 2, keep-with-next
    785          static
    786          FRESULT move_window (
    787          	FATFS* fs,		/* File system object */
    788          	DWORD sector	/* Sector number to make appearance in the fs->win[] */
    789          )
    790          {
   \                     move_window:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    791          	FRESULT res = FR_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    792          
    793          
    794          	if (sector != fs->winsect) {	/* Window offset changed? */
   \   00000008   0x6B20             LDR      R0,[R4, #+48]
   \   0000000A   0x4285             CMP      R5,R0
   \   0000000C   0xD015             BEQ.N    ??move_window_0
    795          #if !_FS_READONLY
    796          		res = sync_window(fs);		/* Write-back changes */
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       sync_window
   \   00000014   0x0006             MOVS     R6,R0
    797          #endif
    798          		if (res == FR_OK) {			/* Fill sector window with new data */
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD10E             BNE.N    ??move_window_0
    799          			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0x002A             MOVS     R2,R5
   \   00000020   0xF114 0x0134      ADDS     R1,R4,#+52
   \   00000024   0x7860             LDRB     R0,[R4, #+1]
   \   00000026   0x.... 0x....      BL       disk_read
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD004             BEQ.N    ??move_window_1
    800          				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
   \   0000002E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000032   0x0005             MOVS     R5,R0
    801          				res = FR_DISK_ERR;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x0006             MOVS     R6,R0
    802          			}
    803          			fs->winsect = sector;
   \                     ??move_window_1:
   \   00000038   0x6325             STR      R5,[R4, #+48]
    804          		}
    805          	}
    806          	return res;
   \                     ??move_window_0:
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    807          }
    808          
    809          
    810          
    811          
    812          /*-----------------------------------------------------------------------*/
    813          /* Synchronize file system and strage device                             */
    814          /*-----------------------------------------------------------------------*/
    815          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    816          static
    817          FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
    818          	FATFS* fs		/* File system object */
    819          )
    820          {
   \                     sync_fs:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    821          	FRESULT res;
    822          
    823          
    824          	res = sync_window(fs);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       sync_window
   \   0000000A   0x0005             MOVS     R5,R0
    825          	if (res == FR_OK) {
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD15F             BNE.N    ??sync_fs_0
    826          		/* Update FSINFO sector if needed */
    827          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xD153             BNE.N    ??sync_fs_1
   \   00000018   0x7960             LDRB     R0,[R4, #+5]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD150             BNE.N    ??sync_fs_1
    828          			/* Create FSINFO structure */
    829          			mem_set(fs->win, 0, SS(fs));
   \   0000001E   0xF44F 0x7200      MOV      R2,#+512
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF114 0x0034      ADDS     R0,R4,#+52
   \   00000028   0x.... 0x....      BL       mem_set
    830          			ST_WORD(fs->win+BS_55AA, 0xAA55);
   \   0000002C   0x2055             MOVS     R0,#+85
   \   0000002E   0xF884 0x0232      STRB     R0,[R4, #+562]
   \   00000032   0x20AA             MOVS     R0,#+170
   \   00000034   0xF884 0x0233      STRB     R0,[R4, #+563]
    831          			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   \   00000038   0x2052             MOVS     R0,#+82
   \   0000003A   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000003E   0x2052             MOVS     R0,#+82
   \   00000040   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000044   0x2061             MOVS     R0,#+97
   \   00000046   0xF884 0x0036      STRB     R0,[R4, #+54]
   \   0000004A   0x2041             MOVS     R0,#+65
   \   0000004C   0xF884 0x0037      STRB     R0,[R4, #+55]
    832          			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   \   00000050   0x2072             MOVS     R0,#+114
   \   00000052   0xF884 0x0218      STRB     R0,[R4, #+536]
   \   00000056   0x2072             MOVS     R0,#+114
   \   00000058   0xF884 0x0219      STRB     R0,[R4, #+537]
   \   0000005C   0x2041             MOVS     R0,#+65
   \   0000005E   0xF884 0x021A      STRB     R0,[R4, #+538]
   \   00000062   0x2061             MOVS     R0,#+97
   \   00000064   0xF884 0x021B      STRB     R0,[R4, #+539]
    833          			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   \   00000068   0x6920             LDR      R0,[R4, #+16]
   \   0000006A   0xF884 0x021C      STRB     R0,[R4, #+540]
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000072   0x0A00             LSRS     R0,R0,#+8
   \   00000074   0xF884 0x021D      STRB     R0,[R4, #+541]
   \   00000078   0x6920             LDR      R0,[R4, #+16]
   \   0000007A   0x0C00             LSRS     R0,R0,#+16
   \   0000007C   0xF884 0x021E      STRB     R0,[R4, #+542]
   \   00000080   0x6920             LDR      R0,[R4, #+16]
   \   00000082   0x0E00             LSRS     R0,R0,#+24
   \   00000084   0xF884 0x021F      STRB     R0,[R4, #+543]
    834          			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   \   00000088   0x68E0             LDR      R0,[R4, #+12]
   \   0000008A   0xF884 0x0220      STRB     R0,[R4, #+544]
   \   0000008E   0x68E0             LDR      R0,[R4, #+12]
   \   00000090   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000092   0x0A00             LSRS     R0,R0,#+8
   \   00000094   0xF884 0x0221      STRB     R0,[R4, #+545]
   \   00000098   0x68E0             LDR      R0,[R4, #+12]
   \   0000009A   0x0C00             LSRS     R0,R0,#+16
   \   0000009C   0xF884 0x0222      STRB     R0,[R4, #+546]
   \   000000A0   0x68E0             LDR      R0,[R4, #+12]
   \   000000A2   0x0E00             LSRS     R0,R0,#+24
   \   000000A4   0xF884 0x0223      STRB     R0,[R4, #+547]
    835          			/* Write it into the FSINFO sector */
    836          			fs->winsect = fs->volbase + 1;
   \   000000A8   0x6A20             LDR      R0,[R4, #+32]
   \   000000AA   0x1C40             ADDS     R0,R0,#+1
   \   000000AC   0x6320             STR      R0,[R4, #+48]
    837          			disk_write(fs->drv, fs->win, fs->winsect, 1);
   \   000000AE   0x2301             MOVS     R3,#+1
   \   000000B0   0x6B22             LDR      R2,[R4, #+48]
   \   000000B2   0xF114 0x0134      ADDS     R1,R4,#+52
   \   000000B6   0x7860             LDRB     R0,[R4, #+1]
   \   000000B8   0x.... 0x....      BL       disk_write
    838          			fs->fsi_flag = 0;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7160             STRB     R0,[R4, #+5]
    839          		}
    840          		/* Make sure that no pending write process in the physical drive */
    841          		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   \                     ??sync_fs_1:
   \   000000C0   0x2200             MOVS     R2,#+0
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x7860             LDRB     R0,[R4, #+1]
   \   000000C6   0x.... 0x....      BL       disk_ioctl
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD001             BEQ.N    ??sync_fs_0
    842          			res = FR_DISK_ERR;
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x0005             MOVS     R5,R0
    843          	}
    844          
    845          	return res;
   \                     ??sync_fs_0:
   \   000000D2   0x0028             MOVS     R0,R5
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    846          }
    847          #endif
    848          
    849          
    850          
    851          
    852          /*-----------------------------------------------------------------------*/
    853          /* Get sector# from cluster#                                             */
    854          /*-----------------------------------------------------------------------*/
    855          /* Hidden API for hacks and disk tools */
    856          

   \                                 In section .text, align 2, keep-with-next
    857          DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
    858          	FATFS* fs,		/* File system object */
    859          	DWORD clst		/* Cluster# to be converted */
    860          )
    861          {
   \                     clust2sect:
   \   00000000   0x0002             MOVS     R2,R0
    862          	clst -= 2;
   \   00000002   0x1E89             SUBS     R1,R1,#+2
    863          	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
   \   00000004   0x6990             LDR      R0,[R2, #+24]
   \   00000006   0x1E80             SUBS     R0,R0,#+2
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xD301             BCC.N    ??clust2sect_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE003             B.N      ??clust2sect_1
    864          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0:
   \   00000010   0x7890             LDRB     R0,[R2, #+2]
   \   00000012   0x6AD2             LDR      R2,[R2, #+44]
   \   00000014   0xFB00 0x2001      MLA      R0,R0,R1,R2
   \                     ??clust2sect_1:
   \   00000018   0x4770             BX       LR               ;; return
    865          }
    866          
    867          
    868          
    869          
    870          /*-----------------------------------------------------------------------*/
    871          /* FAT access - Read value of a FAT entry                                */
    872          /*-----------------------------------------------------------------------*/
    873          /* Hidden API for hacks and disk tools */
    874          

   \                                 In section .text, align 2, keep-with-next
    875          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
    876          	FATFS* fs,	/* File system object */
    877          	DWORD clst	/* FAT item index (cluster#) to get the value */
    878          )
    879          {
   \                     get_fat:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    880          	UINT wc, bc;
    881          	BYTE *p;
    882          	DWORD val;
    883          
    884          
    885          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000008   0x2D02             CMP      R5,#+2
   \   0000000A   0xD302             BCC.N    ??get_fat_0
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD302             BCC.N    ??get_fat_1
    886          		val = 1;	/* Internal error */
   \                     ??get_fat_0:
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x4681             MOV      R9,R0
   \   00000016   0xE07E             B.N      ??get_fat_2
    887          
    888          	} else {
    889          		val = 0xFFFFFFFF;	/* Default value falls on disk error */
   \                     ??get_fat_1:
   \   00000018   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000001C   0x4681             MOV      R9,R0
    890          
    891          		switch (fs->fs_type) {
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD004             BEQ.N    ??get_fat_3
   \   00000024   0xD375             BCC.N    ??get_fat_4
   \   00000026   0x2803             CMP      R0,#+3
   \   00000028   0xD04F             BEQ.N    ??get_fat_5
   \   0000002A   0xD333             BCC.N    ??get_fat_6
   \   0000002C   0xE071             B.N      ??get_fat_4
    892          		case FS_FAT12 :
    893          			bc = (UINT)clst; bc += bc / 2;
   \                     ??get_fat_3:
   \   0000002E   0x002F             MOVS     R7,R5
   \   00000030   0xEB17 0x0757      ADDS     R7,R7,R7, LSR #+1
    894          			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   \   00000034   0x6A60             LDR      R0,[R4, #+36]
   \   00000036   0xEB10 0x2157      ADDS     R1,R0,R7, LSR #+9
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       move_window
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD168             BNE.N    ??get_fat_2
    895          			wc = fs->win[bc++ % SS(fs)];
   \                     ??get_fat_7:
   \   00000044   0xF44F 0x7000      MOV      R0,#+512
   \   00000048   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   0000004C   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   00000050   0x1908             ADDS     R0,R1,R4
   \   00000052   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000056   0x0006             MOVS     R6,R0
   \   00000058   0x1C7F             ADDS     R7,R7,#+1
    896          			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   \   0000005A   0x6A60             LDR      R0,[R4, #+36]
   \   0000005C   0xEB10 0x2157      ADDS     R1,R0,R7, LSR #+9
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       move_window
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD155             BNE.N    ??get_fat_2
    897          			wc |= fs->win[bc % SS(fs)] << 8;
   \                     ??get_fat_8:
   \   0000006A   0xF44F 0x7000      MOV      R0,#+512
   \   0000006E   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   00000072   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   00000076   0x1908             ADDS     R0,R1,R4
   \   00000078   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   0000007C   0xEA56 0x2600      ORRS     R6,R6,R0, LSL #+8
    898          			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
   \   00000080   0x07E8             LSLS     R0,R5,#+31
   \   00000082   0xD502             BPL.N    ??get_fat_9
   \   00000084   0xEA5F 0x1916      LSRS     R9,R6,#+4
   \   00000088   0xE003             B.N      ??get_fat_10
   \                     ??get_fat_9:
   \   0000008A   0xEA5F 0x5906      LSLS     R9,R6,#+20       ;; ZeroExtS R9,R6,#+20,#+20
   \   0000008E   0xEA5F 0x5919      LSRS     R9,R9,#+20
    899          			break;
   \                     ??get_fat_10:
   \   00000092   0xE040             B.N      ??get_fat_2
    900          
    901          		case FS_FAT16 :
    902          			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
   \                     ??get_fat_6:
   \   00000094   0x6A60             LDR      R0,[R4, #+36]
   \   00000096   0xEB10 0x2115      ADDS     R1,R0,R5, LSR #+8
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       move_window
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD138             BNE.N    ??get_fat_2
    903          			p = &fs->win[clst * 2 % SS(fs)];
   \                     ??get_fat_11:
   \   000000A4   0x0068             LSLS     R0,R5,#+1
   \   000000A6   0xF44F 0x7100      MOV      R1,#+512
   \   000000AA   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000AE   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000B2   0x1910             ADDS     R0,R2,R4
   \   000000B4   0x3034             ADDS     R0,R0,#+52
   \   000000B6   0x4680             MOV      R8,R0
    904          			val = LD_WORD(p);
   \   000000B8   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   000000BC   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   000000C0   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000C4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C6   0x4681             MOV      R9,R0
    905          			break;
   \   000000C8   0xE025             B.N      ??get_fat_2
    906          
    907          		case FS_FAT32 :
    908          			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
   \                     ??get_fat_5:
   \   000000CA   0x6A60             LDR      R0,[R4, #+36]
   \   000000CC   0xEB10 0x11D5      ADDS     R1,R0,R5, LSR #+7
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       move_window
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD11D             BNE.N    ??get_fat_2
    909          			p = &fs->win[clst * 4 % SS(fs)];
   \                     ??get_fat_12:
   \   000000DA   0x00A8             LSLS     R0,R5,#+2
   \   000000DC   0xF44F 0x7100      MOV      R1,#+512
   \   000000E0   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000E4   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000E8   0x1910             ADDS     R0,R2,R4
   \   000000EA   0x3034             ADDS     R0,R0,#+52
   \   000000EC   0x4680             MOV      R8,R0
    910          			val = LD_DWORD(p) & 0x0FFFFFFF;
   \   000000EE   0xF898 0x0003      LDRB     R0,[R8, #+3]
   \   000000F2   0xF898 0x1002      LDRB     R1,[R8, #+2]
   \   000000F6   0x0409             LSLS     R1,R1,#+16
   \   000000F8   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000000FC   0xF898 0x1001      LDRB     R1,[R8, #+1]
   \   00000100   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000104   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   00000108   0x4308             ORRS     R0,R1,R0
   \   0000010A   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   0000010C   0x0900             LSRS     R0,R0,#+4
   \   0000010E   0x4681             MOV      R9,R0
    911          			break;
   \   00000110   0xE001             B.N      ??get_fat_2
    912          
    913          		default:
    914          			val = 1;	/* Internal error */
   \                     ??get_fat_4:
   \   00000112   0x2001             MOVS     R0,#+1
   \   00000114   0x4681             MOV      R9,R0
    915          		}
    916          	}
    917          
    918          	return val;
   \                     ??get_fat_2:
   \   00000116   0x4648             MOV      R0,R9
   \   00000118   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    919          }
    920          
    921          
    922          
    923          
    924          /*-----------------------------------------------------------------------*/
    925          /* FAT access - Change value of a FAT entry                              */
    926          /*-----------------------------------------------------------------------*/
    927          /* Hidden API for hacks and disk tools */
    928          
    929          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    930          FRESULT put_fat (
    931          	FATFS* fs,	/* File system object */
    932          	DWORD clst,	/* FAT item index (cluster#) to be set */
    933          	DWORD val	/* New value to mark the cluster */
    934          )
    935          {
   \                     put_fat:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    936          	UINT bc;
    937          	BYTE *p;
    938          	FRESULT res;
    939          
    940          
    941          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   0000000A   0x2D02             CMP      R5,#+2
   \   0000000C   0xD302             BCC.N    ??put_fat_0
   \   0000000E   0x69A0             LDR      R0,[R4, #+24]
   \   00000010   0x4285             CMP      R5,R0
   \   00000012   0xD302             BCC.N    ??put_fat_1
    942          		res = FR_INT_ERR;
   \                     ??put_fat_0:
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x4681             MOV      R9,R0
   \   00000018   0xE0A4             B.N      ??put_fat_2
    943          
    944          	} else {
    945          		switch (fs->fs_type) {
   \                     ??put_fat_1:
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD005             BEQ.N    ??put_fat_3
   \   00000020   0xF0C0 0x809E      BCC.W    ??put_fat_4
   \   00000024   0x2803             CMP      R0,#+3
   \   00000026   0xD06F             BEQ.N    ??put_fat_5
   \   00000028   0xD34E             BCC.N    ??put_fat_6
   \   0000002A   0xE099             B.N      ??put_fat_4
    946          		case FS_FAT12 :
    947          			bc = (UINT)clst; bc += bc / 2;
   \                     ??put_fat_3:
   \   0000002C   0x002F             MOVS     R7,R5
   \   0000002E   0xEB17 0x0757      ADDS     R7,R7,R7, LSR #+1
    948          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   00000032   0x6A60             LDR      R0,[R4, #+36]
   \   00000034   0xEB10 0x2157      ADDS     R1,R0,R7, LSR #+9
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       move_window
   \   0000003E   0x4681             MOV      R9,R0
    949          			if (res != FR_OK) break;
   \   00000040   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000044   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000048   0xF040 0x808C      BNE.W    ??put_fat_2
    950          			p = &fs->win[bc++ % SS(fs)];
   \                     ??put_fat_7:
   \   0000004C   0xF44F 0x7000      MOV      R0,#+512
   \   00000050   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   00000054   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   00000058   0x1908             ADDS     R0,R1,R4
   \   0000005A   0x3034             ADDS     R0,R0,#+52
   \   0000005C   0x4680             MOV      R8,R0
   \   0000005E   0x1C7F             ADDS     R7,R7,#+1
    951          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   \   00000060   0x07E8             LSLS     R0,R5,#+31
   \   00000062   0xD506             BPL.N    ??put_fat_8
   \   00000064   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000068   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000006C   0xEA50 0x1006      ORRS     R0,R0,R6, LSL #+4
   \   00000070   0xE000             B.N      ??put_fat_9
   \                     ??put_fat_8:
   \   00000072   0x0030             MOVS     R0,R6
   \                     ??put_fat_9:
   \   00000074   0xF888 0x0000      STRB     R0,[R8, #+0]
    952          			fs->wflag = 1;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x7120             STRB     R0,[R4, #+4]
    953          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000007C   0x6A60             LDR      R0,[R4, #+36]
   \   0000007E   0xEB10 0x2157      ADDS     R1,R0,R7, LSR #+9
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       move_window
   \   00000088   0x4681             MOV      R9,R0
    954          			if (res != FR_OK) break;
   \   0000008A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000008E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000092   0xD167             BNE.N    ??put_fat_2
    955          			p = &fs->win[bc % SS(fs)];
   \                     ??put_fat_10:
   \   00000094   0xF44F 0x7000      MOV      R0,#+512
   \   00000098   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   0000009C   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   000000A0   0x1908             ADDS     R0,R1,R4
   \   000000A2   0x3034             ADDS     R0,R0,#+52
   \   000000A4   0x4680             MOV      R8,R0
    956          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   000000A6   0x07E8             LSLS     R0,R5,#+31
   \   000000A8   0xD501             BPL.N    ??put_fat_11
   \   000000AA   0x0930             LSRS     R0,R6,#+4
   \   000000AC   0xE007             B.N      ??put_fat_12
   \                     ??put_fat_11:
   \   000000AE   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000B2   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   000000B6   0x0A31             LSRS     R1,R6,#+8
   \   000000B8   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   000000BC   0x4308             ORRS     R0,R1,R0
   \                     ??put_fat_12:
   \   000000BE   0xF888 0x0000      STRB     R0,[R8, #+0]
    957          			fs->wflag = 1;
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0x7120             STRB     R0,[R4, #+4]
    958          			break;
   \   000000C6   0xE04D             B.N      ??put_fat_2
    959          
    960          		case FS_FAT16 :
    961          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_6:
   \   000000C8   0x6A60             LDR      R0,[R4, #+36]
   \   000000CA   0xEB10 0x2115      ADDS     R1,R0,R5, LSR #+8
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       move_window
   \   000000D4   0x4681             MOV      R9,R0
    962          			if (res != FR_OK) break;
   \   000000D6   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000DA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000DE   0xD141             BNE.N    ??put_fat_2
    963          			p = &fs->win[clst * 2 % SS(fs)];
   \                     ??put_fat_13:
   \   000000E0   0x0068             LSLS     R0,R5,#+1
   \   000000E2   0xF44F 0x7100      MOV      R1,#+512
   \   000000E6   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000EA   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000EE   0x1910             ADDS     R0,R2,R4
   \   000000F0   0x3034             ADDS     R0,R0,#+52
   \   000000F2   0x4680             MOV      R8,R0
    964          			ST_WORD(p, (WORD)val);
   \   000000F4   0xF888 0x6000      STRB     R6,[R8, #+0]
   \   000000F8   0x0030             MOVS     R0,R6
   \   000000FA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000FC   0x0A00             LSRS     R0,R0,#+8
   \   000000FE   0xF888 0x0001      STRB     R0,[R8, #+1]
    965          			fs->wflag = 1;
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0x7120             STRB     R0,[R4, #+4]
    966          			break;
   \   00000106   0xE02D             B.N      ??put_fat_2
    967          
    968          		case FS_FAT32 :
    969          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_5:
   \   00000108   0x6A60             LDR      R0,[R4, #+36]
   \   0000010A   0xEB10 0x11D5      ADDS     R1,R0,R5, LSR #+7
   \   0000010E   0x0020             MOVS     R0,R4
   \   00000110   0x.... 0x....      BL       move_window
   \   00000114   0x4681             MOV      R9,R0
    970          			if (res != FR_OK) break;
   \   00000116   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000011A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000011E   0xD121             BNE.N    ??put_fat_2
    971          			p = &fs->win[clst * 4 % SS(fs)];
   \                     ??put_fat_14:
   \   00000120   0x00A8             LSLS     R0,R5,#+2
   \   00000122   0xF44F 0x7100      MOV      R1,#+512
   \   00000126   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   0000012A   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000012E   0x1910             ADDS     R0,R2,R4
   \   00000130   0x3034             ADDS     R0,R0,#+52
   \   00000132   0x4680             MOV      R8,R0
    972          			val |= LD_DWORD(p) & 0xF0000000;
   \   00000134   0xF898 0x0003      LDRB     R0,[R8, #+3]
   \   00000138   0x0600             LSLS     R0,R0,#+24
   \   0000013A   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
   \   0000013E   0x4306             ORRS     R6,R0,R6
    973          			ST_DWORD(p, val);
   \   00000140   0xF888 0x6000      STRB     R6,[R8, #+0]
   \   00000144   0x0030             MOVS     R0,R6
   \   00000146   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000148   0x0A00             LSRS     R0,R0,#+8
   \   0000014A   0xF888 0x0001      STRB     R0,[R8, #+1]
   \   0000014E   0x0C30             LSRS     R0,R6,#+16
   \   00000150   0xF888 0x0002      STRB     R0,[R8, #+2]
   \   00000154   0x0E30             LSRS     R0,R6,#+24
   \   00000156   0xF888 0x0003      STRB     R0,[R8, #+3]
    974          			fs->wflag = 1;
   \   0000015A   0x2001             MOVS     R0,#+1
   \   0000015C   0x7120             STRB     R0,[R4, #+4]
    975          			break;
   \   0000015E   0xE001             B.N      ??put_fat_2
    976          
    977          		default :
    978          			res = FR_INT_ERR;
   \                     ??put_fat_4:
   \   00000160   0x2002             MOVS     R0,#+2
   \   00000162   0x4681             MOV      R9,R0
    979          		}
    980          	}
    981          
    982          	return res;
   \                     ??put_fat_2:
   \   00000164   0x4648             MOV      R0,R9
   \   00000166   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000168   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    983          }
    984          #endif /* !_FS_READONLY */
    985          
    986          
    987          
    988          
    989          /*-----------------------------------------------------------------------*/
    990          /* FAT handling - Remove a cluster chain                                 */
    991          /*-----------------------------------------------------------------------*/
    992          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    993          static
    994          FRESULT remove_chain (
    995          	FATFS* fs,			/* File system object */
    996          	DWORD clst			/* Cluster# to remove a chain from */
    997          )
    998          {
   \                     remove_chain:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    999          	FRESULT res;
   1000          	DWORD nxt;
   1001          #if _USE_TRIM
   1002          	DWORD scl = clst, ecl = clst, rt[2];
   1003          #endif
   1004          
   1005          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000006   0x2D02             CMP      R5,#+2
   \   00000008   0xD302             BCC.N    ??remove_chain_0
   \   0000000A   0x69A0             LDR      R0,[R4, #+24]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD302             BCC.N    ??remove_chain_1
   1006          		res = FR_INT_ERR;
   \                     ??remove_chain_0:
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x0006             MOVS     R6,R0
   \   00000014   0xE02C             B.N      ??remove_chain_2
   1007          
   1008          	} else {
   1009          		res = FR_OK;
   \                     ??remove_chain_1:
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0006             MOVS     R6,R0
   1010          		while (clst < fs->n_fatent) {			/* Not a last link? */
   \                     ??remove_chain_3:
   \   0000001A   0x69A0             LDR      R0,[R4, #+24]
   \   0000001C   0x4285             CMP      R5,R0
   \   0000001E   0xD227             BCS.N    ??remove_chain_2
   1011          			nxt = get_fat(fs, clst);			/* Get cluster status */
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       get_fat
   \   00000028   0x0007             MOVS     R7,R0
   1012          			if (nxt == 0) break;				/* Empty cluster? */
   \   0000002A   0x2F00             CMP      R7,#+0
   \   0000002C   0xD020             BEQ.N    ??remove_chain_2
   1013          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
   \                     ??remove_chain_4:
   \   0000002E   0x2F01             CMP      R7,#+1
   \   00000030   0xD102             BNE.N    ??remove_chain_5
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x0006             MOVS     R6,R0
   \   00000036   0xE01B             B.N      ??remove_chain_2
   1014          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   \                     ??remove_chain_5:
   \   00000038   0xF117 0x0F01      CMN      R7,#+1
   \   0000003C   0xD102             BNE.N    ??remove_chain_6
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x0006             MOVS     R6,R0
   \   00000042   0xE015             B.N      ??remove_chain_2
   1015          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
   \                     ??remove_chain_6:
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       put_fat
   \   0000004E   0x0006             MOVS     R6,R0
   1016          			if (res != FR_OK) break;
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD10C             BNE.N    ??remove_chain_2
   1017          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
   \                     ??remove_chain_7:
   \   00000056   0x6920             LDR      R0,[R4, #+16]
   \   00000058   0xF110 0x0F01      CMN      R0,#+1
   \   0000005C   0xD006             BEQ.N    ??remove_chain_8
   1018          				fs->free_clust++;
   \   0000005E   0x6920             LDR      R0,[R4, #+16]
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0x6120             STR      R0,[R4, #+16]
   1019          				fs->fsi_flag |= 1;
   \   00000064   0x7960             LDRB     R0,[R4, #+5]
   \   00000066   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000006A   0x7160             STRB     R0,[R4, #+5]
   1020          			}
   1021          #if _USE_TRIM
   1022          			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
   1023          				ecl = nxt;
   1024          			} else {				/* End of contiguous clusters */
   1025          				rt[0] = clust2sect(fs, scl);					/* Start sector */
   1026          				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
   1027          				disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Erase the block */
   1028          				scl = ecl = nxt;
   1029          			}
   1030          #endif
   1031          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_8:
   \   0000006C   0x003D             MOVS     R5,R7
   \   0000006E   0xE7D4             B.N      ??remove_chain_3
   1032          		}
   1033          	}
   1034          
   1035          	return res;
   \                     ??remove_chain_2:
   \   00000070   0x0030             MOVS     R0,R6
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1036          }
   1037          #endif
   1038          
   1039          
   1040          
   1041          
   1042          /*-----------------------------------------------------------------------*/
   1043          /* FAT handling - Stretch or Create a cluster chain                      */
   1044          /*-----------------------------------------------------------------------*/
   1045          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1046          static
   1047          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
   1048          	FATFS* fs,			/* File system object */
   1049          	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
   1050          )
   1051          {
   \                     create_chain:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1052          	DWORD cs, ncl, scl;
   1053          	FRESULT res;
   1054          
   1055          
   1056          	if (clst == 0) {		/* Create a new chain */
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD10A             BNE.N    ??create_chain_0
   1057          		scl = fs->last_clust;			/* Get suggested start point */
   \   0000000C   0x68E0             LDR      R0,[R4, #+12]
   \   0000000E   0x4680             MOV      R8,R0
   1058          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   00000010   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000014   0xD002             BEQ.N    ??create_chain_1
   \   00000016   0x69A0             LDR      R0,[R4, #+24]
   \   00000018   0x4580             CMP      R8,R0
   \   0000001A   0xD316             BCC.N    ??create_chain_2
   \                     ??create_chain_1:
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x4680             MOV      R8,R0
   \   00000020   0xE013             B.N      ??create_chain_2
   1059          	}
   1060          	else {					/* Stretch the current chain */
   1061          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_0:
   \   00000022   0x0029             MOVS     R1,R5
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       get_fat
   \   0000002A   0x0006             MOVS     R6,R0
   1062          		if (cs < 2) return 1;			/* Invalid value */
   \   0000002C   0x2E02             CMP      R6,#+2
   \   0000002E   0xD201             BCS.N    ??create_chain_3
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE058             B.N      ??create_chain_4
   1063          		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
   \                     ??create_chain_3:
   \   00000034   0xF116 0x0F01      CMN      R6,#+1
   \   00000038   0xD101             BNE.N    ??create_chain_5
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0xE053             B.N      ??create_chain_4
   1064          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   \                     ??create_chain_5:
   \   0000003E   0x69A0             LDR      R0,[R4, #+24]
   \   00000040   0x4286             CMP      R6,R0
   \   00000042   0xD201             BCS.N    ??create_chain_6
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0xE04E             B.N      ??create_chain_4
   1065          		scl = clst;
   \                     ??create_chain_6:
   \   00000048   0x46A8             MOV      R8,R5
   1066          	}
   1067          
   1068          	ncl = scl;				/* Start cluster */
   \                     ??create_chain_2:
   \   0000004A   0x4647             MOV      R7,R8
   1069          	for (;;) {
   1070          		ncl++;							/* Next cluster */
   \                     ??create_chain_7:
   \   0000004C   0x1C7F             ADDS     R7,R7,#+1
   1071          		if (ncl >= fs->n_fatent) {		/* Check wrap around */
   \   0000004E   0x69A0             LDR      R0,[R4, #+24]
   \   00000050   0x4287             CMP      R7,R0
   \   00000052   0xD305             BCC.N    ??create_chain_8
   1072          			ncl = 2;
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x0007             MOVS     R7,R0
   1073          			if (ncl > scl) return 0;	/* No free cluster */
   \   00000058   0x45B8             CMP      R8,R7
   \   0000005A   0xD201             BCS.N    ??create_chain_8
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE042             B.N      ??create_chain_4
   1074          		}
   1075          		cs = get_fat(fs, ncl);			/* Get the cluster status */
   \                     ??create_chain_8:
   \   00000060   0x0039             MOVS     R1,R7
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       get_fat
   \   00000068   0x0006             MOVS     R6,R0
   1076          		if (cs == 0) break;				/* Found a free cluster */
   \   0000006A   0x2E00             CMP      R6,#+0
   \   0000006C   0xD10C             BNE.N    ??create_chain_9
   1077          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1078          			return cs;
   1079          		if (ncl == scl) return 0;		/* No free cluster */
   1080          	}
   1081          
   1082          	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   \   0000006E   0xF07F 0x4270      MVNS     R2,#-268435456
   \   00000072   0x0039             MOVS     R1,R7
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       put_fat
   \   0000007A   0x4681             MOV      R9,R0
   1083          	if (res == FR_OK && clst != 0) {
   \   0000007C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000080   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000084   0xD113             BNE.N    ??create_chain_10
   \   00000086   0xE00A             B.N      ??create_chain_11
   \                     ??create_chain_9:
   \   00000088   0xF116 0x0F01      CMN      R6,#+1
   \   0000008C   0xD001             BEQ.N    ??create_chain_12
   \   0000008E   0x2E01             CMP      R6,#+1
   \   00000090   0xD101             BNE.N    ??create_chain_13
   \                     ??create_chain_12:
   \   00000092   0x0030             MOVS     R0,R6
   \   00000094   0xE027             B.N      ??create_chain_4
   \                     ??create_chain_13:
   \   00000096   0x4547             CMP      R7,R8
   \   00000098   0xD1D8             BNE.N    ??create_chain_7
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE023             B.N      ??create_chain_4
   \                     ??create_chain_11:
   \   0000009E   0x2D00             CMP      R5,#+0
   \   000000A0   0xD005             BEQ.N    ??create_chain_10
   1084          		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   \   000000A2   0x003A             MOVS     R2,R7
   \   000000A4   0x0029             MOVS     R1,R5
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x.... 0x....      BL       put_fat
   \   000000AC   0x4681             MOV      R9,R0
   1085          	}
   1086          	if (res == FR_OK) {
   \                     ??create_chain_10:
   \   000000AE   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000B2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000B6   0xD10C             BNE.N    ??create_chain_14
   1087          		fs->last_clust = ncl;			/* Update FSINFO */
   \   000000B8   0x60E7             STR      R7,[R4, #+12]
   1088          		if (fs->free_clust != 0xFFFFFFFF) {
   \   000000BA   0x6920             LDR      R0,[R4, #+16]
   \   000000BC   0xF110 0x0F01      CMN      R0,#+1
   \   000000C0   0xD010             BEQ.N    ??create_chain_15
   1089          			fs->free_clust--;
   \   000000C2   0x6920             LDR      R0,[R4, #+16]
   \   000000C4   0x1E40             SUBS     R0,R0,#+1
   \   000000C6   0x6120             STR      R0,[R4, #+16]
   1090          			fs->fsi_flag |= 1;
   \   000000C8   0x7960             LDRB     R0,[R4, #+5]
   \   000000CA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000CE   0x7160             STRB     R0,[R4, #+5]
   \   000000D0   0xE008             B.N      ??create_chain_15
   1091          		}
   1092          	} else {
   1093          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_14:
   \   000000D2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D6   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000DA   0xD102             BNE.N    ??create_chain_16
   \   000000DC   0xF05F 0x37FF      MOVS     R7,#-1
   \   000000E0   0xE000             B.N      ??create_chain_15
   \                     ??create_chain_16:
   \   000000E2   0x2701             MOVS     R7,#+1
   1094          	}
   1095          
   1096          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_15:
   \   000000E4   0x0038             MOVS     R0,R7
   \                     ??create_chain_4:
   \   000000E6   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1097          }
   1098          #endif /* !_FS_READONLY */
   1099          
   1100          
   1101          
   1102          
   1103          /*-----------------------------------------------------------------------*/
   1104          /* FAT handling - Convert offset into cluster with link map table        */
   1105          /*-----------------------------------------------------------------------*/
   1106          
   1107          #if _USE_FASTSEEK
   1108          static
   1109          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   1110          	FIL* fp,		/* Pointer to the file object */
   1111          	DWORD ofs		/* File offset to be converted to cluster# */
   1112          )
   1113          {
   1114          	DWORD cl, ncl, *tbl;
   1115          
   1116          
   1117          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   1118          	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
   1119          	for (;;) {
   1120          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1121          		if (!ncl) return 0;		/* End of table? (error) */
   1122          		if (cl < ncl) break;	/* In this fragment? */
   1123          		cl -= ncl; tbl++;		/* Next fragment */
   1124          	}
   1125          	return cl + *tbl;	/* Return the cluster number */
   1126          }
   1127          #endif	/* _USE_FASTSEEK */
   1128          
   1129          
   1130          
   1131          
   1132          /*-----------------------------------------------------------------------*/
   1133          /* Directory handling - Set directory index                              */
   1134          /*-----------------------------------------------------------------------*/
   1135          

   \                                 In section .text, align 2, keep-with-next
   1136          static
   1137          FRESULT dir_sdi (
   1138          	DIR* dp,		/* Pointer to directory object */
   1139          	UINT idx		/* Index of directory table */
   1140          )
   1141          {
   \                     dir_sdi:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1142          	DWORD clst, sect;
   1143          	UINT ic;
   1144          
   1145          
   1146          	dp->index = (WORD)idx;	/* Current index */
   \   00000008   0x80E5             STRH     R5,[R4, #+6]
   1147          	clst = dp->sclust;		/* Table start cluster (0:root) */
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0x0006             MOVS     R6,R0
   1148          	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
   \   0000000E   0x2E01             CMP      R6,#+1
   \   00000010   0xD003             BEQ.N    ??dir_sdi_0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6980             LDR      R0,[R0, #+24]
   \   00000016   0x4286             CMP      R6,R0
   \   00000018   0xD301             BCC.N    ??dir_sdi_1
   1149          		return FR_INT_ERR;
   \                     ??dir_sdi_0:
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE047             B.N      ??dir_sdi_2
   1150          	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \                     ??dir_sdi_1:
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD106             BNE.N    ??dir_sdi_3
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2803             CMP      R0,#+3
   \   00000028   0xD102             BNE.N    ??dir_sdi_3
   1151          		clst = dp->fs->dirbase;
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6A80             LDR      R0,[R0, #+40]
   \   0000002E   0x0006             MOVS     R6,R0
   1152          
   1153          	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
   \                     ??dir_sdi_3:
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD109             BNE.N    ??dir_sdi_4
   1154          		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x8900             LDRH     R0,[R0, #+8]
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD301             BCC.N    ??dir_sdi_5
   1155          			return FR_INT_ERR;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE036             B.N      ??dir_sdi_2
   1156          		sect = dp->fs->dirbase;
   \                     ??dir_sdi_5:
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6A80             LDR      R0,[R0, #+40]
   \   00000044   0x0007             MOVS     R7,R0
   \   00000046   0xE01F             B.N      ??dir_sdi_6
   1157          	}
   1158          	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
   1159          		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
   \                     ??dir_sdi_4:
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x7880             LDRB     R0,[R0, #+2]
   \   0000004C   0x0100             LSLS     R0,R0,#+4
   \   0000004E   0x4680             MOV      R8,R0
   1160          		while (idx >= ic) {	/* Follow cluster chain */
   \                     ??dir_sdi_7:
   \   00000050   0x4545             CMP      R5,R8
   \   00000052   0xD314             BCC.N    ??dir_sdi_8
   1161          			clst = get_fat(dp->fs, clst);				/* Get next cluster */
   \   00000054   0x0031             MOVS     R1,R6
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       get_fat
   \   0000005C   0x0006             MOVS     R6,R0
   1162          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   \   0000005E   0xF116 0x0F01      CMN      R6,#+1
   \   00000062   0xD101             BNE.N    ??dir_sdi_9
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xE022             B.N      ??dir_sdi_2
   1163          			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
   \                     ??dir_sdi_9:
   \   00000068   0x2E02             CMP      R6,#+2
   \   0000006A   0xD303             BCC.N    ??dir_sdi_10
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6980             LDR      R0,[R0, #+24]
   \   00000070   0x4286             CMP      R6,R0
   \   00000072   0xD301             BCC.N    ??dir_sdi_11
   1164          				return FR_INT_ERR;
   \                     ??dir_sdi_10:
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0xE01A             B.N      ??dir_sdi_2
   1165          			idx -= ic;
   \                     ??dir_sdi_11:
   \   00000078   0xEBB5 0x0508      SUBS     R5,R5,R8
   \   0000007C   0xE7E8             B.N      ??dir_sdi_7
   1166          		}
   1167          		sect = clust2sect(dp->fs, clst);
   \                     ??dir_sdi_8:
   \   0000007E   0x0031             MOVS     R1,R6
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       clust2sect
   \   00000086   0x0007             MOVS     R7,R0
   1168          	}
   1169          	dp->clust = clst;	/* Current cluster# */
   \                     ??dir_sdi_6:
   \   00000088   0x60E6             STR      R6,[R4, #+12]
   1170          	if (!sect) return FR_INT_ERR;
   \   0000008A   0x2F00             CMP      R7,#+0
   \   0000008C   0xD101             BNE.N    ??dir_sdi_12
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0xE00D             B.N      ??dir_sdi_2
   1171          	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
   \                     ??dir_sdi_12:
   \   00000092   0xEB17 0x1015      ADDS     R0,R7,R5, LSR #+4
   \   00000096   0x6120             STR      R0,[R4, #+16]
   1172          	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   \   00000098   0x2010             MOVS     R0,#+16
   \   0000009A   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   0000009E   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   000000A8   0x3034             ADDS     R0,R0,#+52
   \   000000AA   0x6160             STR      R0,[R4, #+20]
   1173          
   1174          	return FR_OK;
   \   000000AC   0x2000             MOVS     R0,#+0
   \                     ??dir_sdi_2:
   \   000000AE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1175          }
   1176          
   1177          
   1178          
   1179          
   1180          /*-----------------------------------------------------------------------*/
   1181          /* Directory handling - Move directory table index next                  */
   1182          /*-----------------------------------------------------------------------*/
   1183          

   \                                 In section .text, align 2, keep-with-next
   1184          static
   1185          FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
   1186          	DIR* dp,		/* Pointer to the directory object */
   1187          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1188          )
   1189          {
   \                     dir_next:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1190          	DWORD clst;
   1191          	UINT i;
   1192          
   1193          
   1194          	i = dp->index + 1;
   \   00000008   0x88E0             LDRH     R0,[R4, #+6]
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   \   0000000C   0x0007             MOVS     R7,R0
   1195          	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
   \   0000000E   0x0438             LSLS     R0,R7,#+16
   \   00000010   0xD002             BEQ.N    ??dir_next_0
   \   00000012   0x6920             LDR      R0,[R4, #+16]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??dir_next_1
   1196          		return FR_NO_FILE;
   \                     ??dir_next_0:
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xE084             B.N      ??dir_next_2
   1197          
   1198          	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
   \                     ??dir_next_1:
   \   0000001C   0x2010             MOVS     R0,#+16
   \   0000001E   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   00000022   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD171             BNE.N    ??dir_next_3
   1199          		dp->sect++;					/* Next sector */
   \   0000002A   0x6920             LDR      R0,[R4, #+16]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x6120             STR      R0,[R4, #+16]
   1200          
   1201          		if (!dp->clust) {		/* Static table */
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD105             BNE.N    ??dir_next_4
   1202          			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x8900             LDRH     R0,[R0, #+8]
   \   0000003A   0x4287             CMP      R7,R0
   \   0000003C   0xD367             BCC.N    ??dir_next_3
   1203          				return FR_NO_FILE;
   \   0000003E   0x2004             MOVS     R0,#+4
   \   00000040   0xE071             B.N      ??dir_next_2
   1204          		}
   1205          		else {					/* Dynamic table */
   1206          			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_4:
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x7880             LDRB     R0,[R0, #+2]
   \   00000046   0x1E40             SUBS     R0,R0,#+1
   \   00000048   0xEA10 0x1F17      TST      R0,R7, LSR #+4
   \   0000004C   0xD15F             BNE.N    ??dir_next_3
   1207          				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
   \   0000004E   0x68E1             LDR      R1,[R4, #+12]
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       get_fat
   \   00000056   0x0006             MOVS     R6,R0
   1208          				if (clst <= 1) return FR_INT_ERR;
   \   00000058   0x2E02             CMP      R6,#+2
   \   0000005A   0xD201             BCS.N    ??dir_next_5
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0xE062             B.N      ??dir_next_2
   1209          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_5:
   \   00000060   0xF116 0x0F01      CMN      R6,#+1
   \   00000064   0xD101             BNE.N    ??dir_next_6
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xE05D             B.N      ??dir_next_2
   1210          				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
   \                     ??dir_next_6:
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6980             LDR      R0,[R0, #+24]
   \   0000006E   0x4286             CMP      R6,R0
   \   00000070   0xD347             BCC.N    ??dir_next_7
   1211          #if !_FS_READONLY
   1212          					UINT c;
   1213          					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
   \   00000072   0x2D00             CMP      R5,#+0
   \   00000074   0xD101             BNE.N    ??dir_next_8
   \   00000076   0x2004             MOVS     R0,#+4
   \   00000078   0xE055             B.N      ??dir_next_2
   1214          					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
   \                     ??dir_next_8:
   \   0000007A   0x68E1             LDR      R1,[R4, #+12]
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x.... 0x....      BL       create_chain
   \   00000082   0x0006             MOVS     R6,R0
   1215          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \   00000084   0x2E00             CMP      R6,#+0
   \   00000086   0xD101             BNE.N    ??dir_next_9
   \   00000088   0x2007             MOVS     R0,#+7
   \   0000008A   0xE04C             B.N      ??dir_next_2
   1216          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_9:
   \   0000008C   0x2E01             CMP      R6,#+1
   \   0000008E   0xD101             BNE.N    ??dir_next_10
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0xE048             B.N      ??dir_next_2
   1217          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_10:
   \   00000094   0xF116 0x0F01      CMN      R6,#+1
   \   00000098   0xD101             BNE.N    ??dir_next_11
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xE043             B.N      ??dir_next_2
   1218          					/* Clean-up stretched table */
   1219          					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
   \                     ??dir_next_11:
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x.... 0x....      BL       sync_window
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD001             BEQ.N    ??dir_next_12
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xE03C             B.N      ??dir_next_2
   1220          					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
   \                     ??dir_next_12:
   \   000000AC   0xF44F 0x7200      MOV      R2,#+512
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x3034             ADDS     R0,R0,#+52
   \   000000B6   0x.... 0x....      BL       mem_set
   1221          					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
   \   000000BA   0x0031             MOVS     R1,R6
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x.... 0x....      BL       clust2sect
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x6308             STR      R0,[R1, #+48]
   1222          					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x4680             MOV      R8,R0
   \                     ??dir_next_13:
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x7880             LDRB     R0,[R0, #+2]
   \   000000CE   0x4580             CMP      R8,R0
   \   000000D0   0xD211             BCS.N    ??dir_next_14
   1223          						dp->fs->wflag = 1;
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x2101             MOVS     R1,#+1
   \   000000D6   0x7101             STRB     R1,[R0, #+4]
   1224          						if (sync_window(dp->fs)) return FR_DISK_ERR;
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x.... 0x....      BL       sync_window
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD001             BEQ.N    ??dir_next_15
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xE01F             B.N      ??dir_next_2
   1225          						dp->fs->winsect++;
   \                     ??dir_next_15:
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6B00             LDR      R0,[R0, #+48]
   \   000000EA   0x1C40             ADDS     R0,R0,#+1
   \   000000EC   0x6821             LDR      R1,[R4, #+0]
   \   000000EE   0x6308             STR      R0,[R1, #+48]
   1226          					}
   \   000000F0   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000F4   0xE7E9             B.N      ??dir_next_13
   1227          					dp->fs->winsect -= c;						/* Rewind window offset */
   \                     ??dir_next_14:
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x6B00             LDR      R0,[R0, #+48]
   \   000000FA   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000000FE   0x6821             LDR      R1,[R4, #+0]
   \   00000100   0x6308             STR      R0,[R1, #+48]
   1228          #else
   1229          					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
   1230          					return FR_NO_FILE;							/* Report EOT */
   1231          #endif
   1232          				}
   1233          				dp->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_7:
   \   00000102   0x60E6             STR      R6,[R4, #+12]
   1234          				dp->sect = clust2sect(dp->fs, clst);
   \   00000104   0x0031             MOVS     R1,R6
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x.... 0x....      BL       clust2sect
   \   0000010C   0x6120             STR      R0,[R4, #+16]
   1235          			}
   1236          		}
   1237          	}
   1238          
   1239          	dp->index = (WORD)i;	/* Current index */
   \                     ??dir_next_3:
   \   0000010E   0x80E7             STRH     R7,[R4, #+6]
   1240          	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Current entry in the window */
   \   00000110   0x2010             MOVS     R0,#+16
   \   00000112   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   00000116   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   00000120   0x3034             ADDS     R0,R0,#+52
   \   00000122   0x6160             STR      R0,[R4, #+20]
   1241          
   1242          	return FR_OK;
   \   00000124   0x2000             MOVS     R0,#+0
   \                     ??dir_next_2:
   \   00000126   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1243          }
   1244          
   1245          
   1246          
   1247          
   1248          /*-----------------------------------------------------------------------*/
   1249          /* Directory handling - Reserve directory entry                          */
   1250          /*-----------------------------------------------------------------------*/
   1251          
   1252          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1253          static
   1254          FRESULT dir_alloc (
   1255          	DIR* dp,	/* Pointer to the directory object */
   1256          	UINT nent	/* Number of contiguous entries to allocate (1-21) */
   1257          )
   1258          {
   \                     dir_alloc:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1259          	FRESULT res;
   1260          	UINT n;
   1261          
   1262          
   1263          	res = dir_sdi(dp, 0);
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       dir_sdi
   \   0000000E   0x0006             MOVS     R6,R0
   1264          	if (res == FR_OK) {
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD11F             BNE.N    ??dir_alloc_0
   1265          		n = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0007             MOVS     R7,R0
   1266          		do {
   1267          			res = move_window(dp->fs, dp->sect);
   \                     ??dir_alloc_1:
   \   0000001A   0x6921             LDR      R1,[R4, #+16]
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       move_window
   \   00000022   0x0006             MOVS     R6,R0
   1268          			if (res != FR_OK) break;
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD115             BNE.N    ??dir_alloc_0
   1269          			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a free entry? */
   \                     ??dir_alloc_2:
   \   0000002A   0x6960             LDR      R0,[R4, #+20]
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x28E5             CMP      R0,#+229
   \   00000030   0xD003             BEQ.N    ??dir_alloc_3
   \   00000032   0x6960             LDR      R0,[R4, #+20]
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD103             BNE.N    ??dir_alloc_4
   1270          				if (++n == nent) break;	/* A block of contiguous free entries is found */
   \                     ??dir_alloc_3:
   \   0000003A   0x1C7F             ADDS     R7,R7,#+1
   \   0000003C   0x42AF             CMP      R7,R5
   \   0000003E   0xD102             BNE.N    ??dir_alloc_5
   \   00000040   0xE009             B.N      ??dir_alloc_0
   1271          			} else {
   1272          				n = 0;					/* Not a blank entry. Restart to search */
   \                     ??dir_alloc_4:
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0007             MOVS     R7,R0
   1273          			}
   1274          			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
   \                     ??dir_alloc_5:
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       dir_next
   \   0000004E   0x0006             MOVS     R6,R0
   1275          		} while (res == FR_OK);
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD0E1             BEQ.N    ??dir_alloc_1
   1276          	}
   1277          	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
   \                     ??dir_alloc_0:
   \   00000056   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000058   0x2E04             CMP      R6,#+4
   \   0000005A   0xD101             BNE.N    ??dir_alloc_6
   \   0000005C   0x2007             MOVS     R0,#+7
   \   0000005E   0x0006             MOVS     R6,R0
   1278          	return res;
   \                     ??dir_alloc_6:
   \   00000060   0x0030             MOVS     R0,R6
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1279          }
   1280          #endif
   1281          
   1282          
   1283          
   1284          
   1285          /*-----------------------------------------------------------------------*/
   1286          /* Directory handling - Load/Store start cluster number                  */
   1287          /*-----------------------------------------------------------------------*/
   1288          

   \                                 In section .text, align 2, keep-with-next
   1289          static
   1290          DWORD ld_clust (
   1291          	FATFS* fs,	/* Pointer to the fs object */
   1292          	BYTE* dir	/* Pointer to the directory entry */
   1293          )
   1294          {
   \                     ld_clust:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
   1295          	DWORD cl;
   1296          
   1297          	cl = LD_WORD(dir+DIR_FstClusLO);
   \   00000004   0x7ECB             LDRB     R3,[R1, #+27]
   \   00000006   0x7E8C             LDRB     R4,[R1, #+26]
   \   00000008   0xEA54 0x2303      ORRS     R3,R4,R3, LSL #+8
   \   0000000C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000E   0x0018             MOVS     R0,R3
   1298          	if (fs->fs_type == FS_FAT32)
   \   00000010   0x7813             LDRB     R3,[R2, #+0]
   \   00000012   0x2B03             CMP      R3,#+3
   \   00000014   0xD106             BNE.N    ??ld_clust_0
   1299          		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
   \   00000016   0x7D4B             LDRB     R3,[R1, #+21]
   \   00000018   0x7D0C             LDRB     R4,[R1, #+20]
   \   0000001A   0xEA54 0x2303      ORRS     R3,R4,R3, LSL #+8
   \   0000001E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000020   0xEA50 0x4003      ORRS     R0,R0,R3, LSL #+16
   1300          
   1301          	return cl;
   \                     ??ld_clust_0:
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return
   1302          }
   1303          
   1304          
   1305          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1306          static
   1307          void st_clust (
   1308          	BYTE* dir,	/* Pointer to the directory entry */
   1309          	DWORD cl	/* Value to be set */
   1310          )
   1311          {
   1312          	ST_WORD(dir+DIR_FstClusLO, cl);
   \                     st_clust:
   \   00000000   0x7681             STRB     R1,[R0, #+26]
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000006   0x0A12             LSRS     R2,R2,#+8
   \   00000008   0x76C2             STRB     R2,[R0, #+27]
   1313          	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   \   0000000A   0x0C0A             LSRS     R2,R1,#+16
   \   0000000C   0x7502             STRB     R2,[R0, #+20]
   \   0000000E   0x0C0A             LSRS     R2,R1,#+16
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x0A12             LSRS     R2,R2,#+8
   \   00000014   0x7542             STRB     R2,[R0, #+21]
   1314          }
   \   00000016   0x4770             BX       LR               ;; return
   1315          #endif
   1316          
   1317          
   1318          
   1319          
   1320          /*-----------------------------------------------------------------------*/
   1321          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1322          /*-----------------------------------------------------------------------*/
   1323          #if _USE_LFN
   1324          static

   \                                 In section .rodata, align 4
   1325          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN characters in the directory entry */
   \                     LfnOfs:
   \   00000000   0x01 0x03          DC8 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30, 0, 0, 0
   \              0x05 0x07    
   \              0x09 0x0E    
   \              0x10 0x12    
   \              0x14 0x16    
   \              0x18 0x1C    
   \              0x1E 0x00    
   \              0x00 0x00    
   1326          
   1327          

   \                                 In section .text, align 2, keep-with-next
   1328          static
   1329          int cmp_lfn (			/* 1:Matched, 0:Not matched */
   1330          	WCHAR* lfnbuf,		/* Pointer to the LFN to be compared */
   1331          	BYTE* dir			/* Pointer to the directory entry containing a part of LFN */
   1332          )
   1333          {
   \                     cmp_lfn:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1334          	UINT i, s;
   1335          	WCHAR wc, uc;
   1336          
   1337          
   1338          	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x210D             MOVS     R1,#+13
   \   00000012   0x4348             MULS     R0,R1,R0
   \   00000014   0x0006             MOVS     R6,R0
   1339          	s = 0; wc = 1;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0007             MOVS     R7,R0
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4680             MOV      R8,R0
   1340          	do {
   1341          		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
   \                     ??cmp_lfn_0:
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000022   0x5C38             LDRB     R0,[R7, R0]
   \   00000024   0x1940             ADDS     R0,R0,R5
   \   00000026   0x7840             LDRB     R0,[R0, #+1]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000002C   0x5C79             LDRB     R1,[R7, R1]
   \   0000002E   0x5D49             LDRB     R1,[R1, R5]
   \   00000030   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000034   0x4681             MOV      R9,R0
   1342          		if (wc) {	/* Last character has not been processed */
   \   00000036   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000003A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003E   0xD012             BEQ.N    ??cmp_lfn_1
   1343          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   \   00000040   0x4648             MOV      R0,R9
   \   00000042   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000044   0x.... 0x....      BL       ff_wtoupper
   \   00000048   0x4680             MOV      R8,R0
   1344          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   \   0000004A   0x2EFF             CMP      R6,#+255
   \   0000004C   0xD209             BCS.N    ??cmp_lfn_2
   \   0000004E   0xF834 0x0016      LDRH     R0,[R4, R6, LSL #+1]
   \   00000052   0x.... 0x....      BL       ff_wtoupper
   \   00000056   0x1C76             ADDS     R6,R6,#+1
   \   00000058   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000005C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005E   0x4580             CMP      R8,R0
   \   00000060   0xD009             BEQ.N    ??cmp_lfn_3
   1345          				return 0;				/* Not matched */
   \                     ??cmp_lfn_2:
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE019             B.N      ??cmp_lfn_4
   1346          		} else {
   1347          			if (uc != 0xFFFF) return 0;	/* Check filler */
   \                     ??cmp_lfn_1:
   \   00000066   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000006A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000006E   0x4581             CMP      R9,R0
   \   00000070   0xD001             BEQ.N    ??cmp_lfn_3
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE011             B.N      ??cmp_lfn_4
   1348          		}
   1349          	} while (++s < 13);				/* Repeat until all characters in the entry are checked */
   \                     ??cmp_lfn_3:
   \   00000076   0x1C7F             ADDS     R7,R7,#+1
   \   00000078   0x2F0D             CMP      R7,#+13
   \   0000007A   0xD3D0             BCC.N    ??cmp_lfn_0
   1350          
   1351          	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   \   0000007C   0x7828             LDRB     R0,[R5, #+0]
   \   0000007E   0x0640             LSLS     R0,R0,#+25
   \   00000080   0xD50A             BPL.N    ??cmp_lfn_5
   \   00000082   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000086   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000008A   0xD005             BEQ.N    ??cmp_lfn_5
   \   0000008C   0xF834 0x0016      LDRH     R0,[R4, R6, LSL #+1]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD001             BEQ.N    ??cmp_lfn_5
   1352          		return 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE000             B.N      ??cmp_lfn_4
   1353          
   1354          	return 1;						/* The part of LFN matched */
   \                     ??cmp_lfn_5:
   \   00000098   0x2001             MOVS     R0,#+1
   \                     ??cmp_lfn_4:
   \   0000009A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1355          }
   1356          
   1357          
   1358          

   \                                 In section .text, align 2, keep-with-next
   1359          static
   1360          int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
   1361          	WCHAR* lfnbuf,		/* Pointer to the Unicode-LFN buffer */
   1362          	BYTE* dir			/* Pointer to the directory entry */
   1363          )
   1364          {
   \                     pick_lfn:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0002             MOVS     R2,R0
   1365          	UINT i, s;
   1366          	WCHAR wc, uc;
   1367          
   1368          
   1369          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x270D             MOVS     R7,#+13
   \   0000000E   0x4378             MULS     R0,R7,R0
   \   00000010   0x0003             MOVS     R3,R0
   1370          
   1371          	s = 0; wc = 1;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0004             MOVS     R4,R0
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x0005             MOVS     R5,R0
   1372          	do {
   1373          		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
   \                     ??pick_lfn_0:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000001E   0x5C20             LDRB     R0,[R4, R0]
   \   00000020   0x1840             ADDS     R0,R0,R1
   \   00000022   0x7840             LDRB     R0,[R0, #+1]
   \   00000024   0x.... 0x....      LDR.W    R7,??DataTable4
   \   00000028   0x5DE7             LDRB     R7,[R4, R7]
   \   0000002A   0x5C7F             LDRB     R7,[R7, R1]
   \   0000002C   0xEA57 0x2000      ORRS     R0,R7,R0, LSL #+8
   \   00000030   0x0006             MOVS     R6,R0
   1374          		if (wc) {	/* Last character has not been processed */
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD008             BEQ.N    ??pick_lfn_1
   1375          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   \   00000038   0x2BFF             CMP      R3,#+255
   \   0000003A   0xD301             BCC.N    ??pick_lfn_2
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE019             B.N      ??pick_lfn_3
   1376          			lfnbuf[i++] = wc = uc;			/* Store it */
   \                     ??pick_lfn_2:
   \   00000040   0x0035             MOVS     R5,R6
   \   00000042   0xF822 0x6013      STRH     R6,[R2, R3, LSL #+1]
   \   00000046   0x1C5B             ADDS     R3,R3,#+1
   \   00000048   0xE006             B.N      ??pick_lfn_4
   1377          		} else {
   1378          			if (uc != 0xFFFF) return 0;		/* Check filler */
   \                     ??pick_lfn_1:
   \   0000004A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004C   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000050   0x4286             CMP      R6,R0
   \   00000052   0xD001             BEQ.N    ??pick_lfn_4
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE00D             B.N      ??pick_lfn_3
   1379          		}
   1380          	} while (++s < 13);						/* Read all character in the entry */
   \                     ??pick_lfn_4:
   \   00000058   0x1C64             ADDS     R4,R4,#+1
   \   0000005A   0x2C0D             CMP      R4,#+13
   \   0000005C   0xD3DD             BCC.N    ??pick_lfn_0
   1381          
   1382          	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
   \   0000005E   0x7808             LDRB     R0,[R1, #+0]
   \   00000060   0x0640             LSLS     R0,R0,#+25
   \   00000062   0xD506             BPL.N    ??pick_lfn_5
   1383          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   \   00000064   0x2BFF             CMP      R3,#+255
   \   00000066   0xD301             BCC.N    ??pick_lfn_6
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE003             B.N      ??pick_lfn_3
   1384          		lfnbuf[i] = 0;
   \                     ??pick_lfn_6:
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF822 0x0013      STRH     R0,[R2, R3, LSL #+1]
   1385          	}
   1386          
   1387          	return 1;
   \                     ??pick_lfn_5:
   \   00000072   0x2001             MOVS     R0,#+1
   \                     ??pick_lfn_3:
   \   00000074   0xBCF0             POP      {R4-R7}
   \   00000076   0x4770             BX       LR               ;; return
   1388          }
   1389          
   1390          
   1391          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1392          static
   1393          void fit_lfn (
   1394          	const WCHAR* lfnbuf,	/* Pointer to the LFN buffer */
   1395          	BYTE* dir,				/* Pointer to the directory entry */
   1396          	BYTE ord,				/* LFN order (1-20) */
   1397          	BYTE sum				/* SFN sum */
   1398          )
   1399          {
   \                     fit_lfn:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1400          	UINT i, s;
   1401          	WCHAR wc;
   1402          
   1403          
   1404          	dir[LDIR_Chksum] = sum;			/* Set check sum */
   \   00000002   0x734B             STRB     R3,[R1, #+13]
   1405          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   \   00000004   0x270F             MOVS     R7,#+15
   \   00000006   0x72CF             STRB     R7,[R1, #+11]
   1406          	dir[LDIR_Type] = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0x730F             STRB     R7,[R1, #+12]
   1407          	ST_WORD(dir+LDIR_FstClusLO, 0);
   \   0000000C   0x2700             MOVS     R7,#+0
   \   0000000E   0x768F             STRB     R7,[R1, #+26]
   \   00000010   0x2700             MOVS     R7,#+0
   \   00000012   0x76CF             STRB     R7,[R1, #+27]
   1408          
   1409          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x1E57             SUBS     R7,R2,#+1
   \   00000018   0xF05F 0x0C0D      MOVS     R12,#+13
   \   0000001C   0xFB0C 0xF707      MUL      R7,R12,R7
   \   00000020   0x003C             MOVS     R4,R7
   1410          	s = wc = 0;
   \   00000022   0x2700             MOVS     R7,#+0
   \   00000024   0x003E             MOVS     R6,R7
   \   00000026   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000028   0x003D             MOVS     R5,R7
   1411          	do {
   1412          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
   \                     ??fit_lfn_0:
   \   0000002A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002C   0xF64F 0x77FF      MOVW     R7,#+65535
   \   00000030   0x42BE             CMP      R6,R7
   \   00000032   0xD003             BEQ.N    ??fit_lfn_1
   \   00000034   0xF830 0x7014      LDRH     R7,[R0, R4, LSL #+1]
   \   00000038   0x003E             MOVS     R6,R7
   \   0000003A   0x1C64             ADDS     R4,R4,#+1
   1413          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   \                     ??fit_lfn_1:
   \   0000003C   0x.... 0x....      LDR.W    R7,??DataTable4
   \   00000040   0x5DEF             LDRB     R7,[R5, R7]
   \   00000042   0x547E             STRB     R6,[R7, R1]
   \   00000044   0x.... 0x....      LDR.W    R7,??DataTable4
   \   00000048   0x5DEF             LDRB     R7,[R5, R7]
   \   0000004A   0x187F             ADDS     R7,R7,R1
   \   0000004C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004E   0xEA5F 0x2C16      LSRS     R12,R6,#+8
   \   00000052   0xF887 0xC001      STRB     R12,[R7, #+1]
   1414          		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
   \   00000056   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD102             BNE.N    ??fit_lfn_2
   \   0000005C   0xF64F 0x77FF      MOVW     R7,#+65535
   \   00000060   0x003E             MOVS     R6,R7
   1415          	} while (++s < 13);
   \                     ??fit_lfn_2:
   \   00000062   0x1C6D             ADDS     R5,R5,#+1
   \   00000064   0x2D0D             CMP      R5,#+13
   \   00000066   0xD3E0             BCC.N    ??fit_lfn_0
   1416          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
   \   00000068   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000006A   0xF64F 0x77FF      MOVW     R7,#+65535
   \   0000006E   0x42BE             CMP      R6,R7
   \   00000070   0xD003             BEQ.N    ??fit_lfn_3
   \   00000072   0xF830 0x7014      LDRH     R7,[R0, R4, LSL #+1]
   \   00000076   0x2F00             CMP      R7,#+0
   \   00000078   0xD101             BNE.N    ??fit_lfn_4
   \                     ??fit_lfn_3:
   \   0000007A   0xF052 0x0240      ORRS     R2,R2,#0x40
   1417          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   \                     ??fit_lfn_4:
   \   0000007E   0x700A             STRB     R2,[R1, #+0]
   1418          }
   \   00000080   0xBCF0             POP      {R4-R7}
   \   00000082   0x4770             BX       LR               ;; return
   1419          
   1420          #endif
   1421          #endif
   1422          
   1423          
   1424          
   1425          
   1426          /*-----------------------------------------------------------------------*/
   1427          /* Create numbered name                                                  */
   1428          /*-----------------------------------------------------------------------*/
   1429          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   1430          static
   1431          void gen_numname (
   1432          	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
   1433          	const BYTE* src,	/* Pointer to SFN */
   1434          	const WCHAR* lfn,	/* Pointer to LFN */
   1435          	UINT seq			/* Sequence number */
   1436          )
   1437          {
   \                     gen_numname:
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x469A             MOV      R10,R3
   1438          	BYTE ns[8], c;
   1439          	UINT i, j;
   1440          
   1441          
   1442          	mem_cpy(dst, src, 11);
   \   0000000C   0x220B             MOVS     R2,#+11
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       mem_cpy
   1443          
   1444          	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   \   00000016   0xF1BA 0x0F06      CMP      R10,#+6
   \   0000001A   0xD31C             BCC.N    ??gen_numname_0
   1445          		WCHAR wc;
   1446          		DWORD sr = seq;
   \   0000001C   0x4651             MOV      R1,R10
   1447          
   1448          		while (*lfn) {	/* Create a CRC */
   \                     ??gen_numname_1:
   \   0000001E   0x8832             LDRH     R2,[R6, #+0]
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD017             BEQ.N    ??gen_numname_2
   1449          			wc = *lfn++;
   \   00000024   0x8832             LDRH     R2,[R6, #+0]
   \   00000026   0x0010             MOVS     R0,R2
   \   00000028   0x1CB6             ADDS     R6,R6,#+2
   1450          			for (i = 0; i < 16; i++) {
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x4690             MOV      R8,R2
   \                     ??gen_numname_3:
   \   0000002E   0xF1B8 0x0F10      CMP      R8,#+16
   \   00000032   0xD2F4             BCS.N    ??gen_numname_1
   1451          				sr = (sr << 1) + (wc & 1);
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0xF010 0x0201      ANDS     R2,R0,#0x1
   \   0000003A   0xEB12 0x0141      ADDS     R1,R2,R1, LSL #+1
   1452          				wc >>= 1;
   \   0000003E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000040   0x0840             LSRS     R0,R0,#+1
   1453          				if (sr & 0x10000) sr ^= 0x11021;
   \   00000042   0x03CA             LSLS     R2,R1,#+15
   \   00000044   0xD503             BPL.N    ??gen_numname_4
   \   00000046   0xF481 0x3188      EOR      R1,R1,#0x11000
   \   0000004A   0xF091 0x0121      EORS     R1,R1,#0x21
   1454          			}
   \                     ??gen_numname_4:
   \   0000004E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000052   0xE7EC             B.N      ??gen_numname_3
   1455          		}
   1456          		seq = (UINT)sr;
   \                     ??gen_numname_2:
   \   00000054   0x468A             MOV      R10,R1
   1457          	}
   1458          
   1459          	/* itoa (hexdecimal) */
   1460          	i = 7;
   \                     ??gen_numname_0:
   \   00000056   0x2007             MOVS     R0,#+7
   \   00000058   0x4680             MOV      R8,R0
   1461          	do {
   1462          		c = (seq % 16) + '0';
   \                     ??gen_numname_5:
   \   0000005A   0x2010             MOVS     R0,#+16
   \   0000005C   0xFBBA 0xF1F0      UDIV     R1,R10,R0
   \   00000060   0xFB01 0xA110      MLS      R1,R1,R0,R10
   \   00000064   0xF111 0x0030      ADDS     R0,R1,#+48
   \   00000068   0x0007             MOVS     R7,R0
   1463          		if (c > '9') c += 7;
   \   0000006A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006C   0x2F3A             CMP      R7,#+58
   \   0000006E   0xDB00             BLT.N    ??gen_numname_6
   \   00000070   0x1DFF             ADDS     R7,R7,#+7
   1464          		ns[i--] = c;
   \                     ??gen_numname_6:
   \   00000072   0xA800             ADD      R0,SP,#+0
   \   00000074   0xF808 0x7000      STRB     R7,[R8, R0]
   \   00000078   0xF1B8 0x0801      SUBS     R8,R8,#+1
   1465          		seq /= 16;
   \   0000007C   0xEA5F 0x1A1A      LSRS     R10,R10,#+4
   1466          	} while (seq);
   \   00000080   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000084   0xD1E9             BNE.N    ??gen_numname_5
   1467          	ns[i] = '~';
   \   00000086   0xA800             ADD      R0,SP,#+0
   \   00000088   0x217E             MOVS     R1,#+126
   \   0000008A   0xF808 0x1000      STRB     R1,[R8, R0]
   1468          
   1469          	/* Append the number */
   1470          	for (j = 0; j < i && dst[j] != ' '; j++) {
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x4681             MOV      R9,R0
   \                     ??gen_numname_7:
   \   00000092   0x45C1             CMP      R9,R8
   \   00000094   0xD206             BCS.N    ??gen_numname_8
   \   00000096   0xF819 0x0004      LDRB     R0,[R9, R4]
   \   0000009A   0x2820             CMP      R0,#+32
   \   0000009C   0xD002             BEQ.N    ??gen_numname_8
   1471          		if (IsDBCS1(dst[j])) {
   \   0000009E   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000A2   0xE7F6             B.N      ??gen_numname_7
   1472          			if (j == i - 1) break;
   1473          			j++;
   1474          		}
   1475          	}
   1476          	do {
   1477          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   \                     ??gen_numname_8:
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0xF110 0x0901      ADDS     R9,R0,#+1
   \   000000AA   0xF1B8 0x0F08      CMP      R8,#+8
   \   000000AE   0xD205             BCS.N    ??gen_numname_9
   \   000000B0   0xA900             ADD      R1,SP,#+0
   \   000000B2   0xF818 0x1001      LDRB     R1,[R8, R1]
   \   000000B6   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000BA   0xE000             B.N      ??gen_numname_10
   \                     ??gen_numname_9:
   \   000000BC   0x2120             MOVS     R1,#+32
   \                     ??gen_numname_10:
   \   000000BE   0x5501             STRB     R1,[R0, R4]
   1478          	} while (j < 8);
   \   000000C0   0xF1B9 0x0F08      CMP      R9,#+8
   \   000000C4   0xD3EE             BCC.N    ??gen_numname_8
   1479          }
   \   000000C6   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   1480          #endif
   1481          
   1482          
   1483          
   1484          
   1485          /*-----------------------------------------------------------------------*/
   1486          /* Calculate sum of an SFN                                               */
   1487          /*-----------------------------------------------------------------------*/
   1488          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   1489          static
   1490          BYTE sum_sfn (
   1491          	const BYTE* dir		/* Pointer to the SFN entry */
   1492          )
   1493          {
   \                     sum_sfn:
   \   00000000   0x0001             MOVS     R1,R0
   1494          	BYTE sum = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   1495          	UINT n = 11;
   \   00000004   0x220B             MOVS     R2,#+11
   1496          
   1497          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   \                     ??sum_sfn_0:
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x01C3             LSLS     R3,R0,#+7
   \   0000000A   0xEB13 0x0050      ADDS     R0,R3,R0, LSR #+1
   \   0000000E   0x780B             LDRB     R3,[R1, #+0]
   \   00000010   0x1818             ADDS     R0,R3,R0
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x1E52             SUBS     R2,R2,#+1
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1F5             BNE.N    ??sum_sfn_0
   1498          	return sum;
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x4770             BX       LR               ;; return
   1499          }
   1500          #endif
   1501          
   1502          
   1503          
   1504          
   1505          /*-----------------------------------------------------------------------*/
   1506          /* Directory handling - Find an object in the directory                  */
   1507          /*-----------------------------------------------------------------------*/
   1508          

   \                                 In section .text, align 2, keep-with-next
   1509          static
   1510          FRESULT dir_find (
   1511          	DIR* dp			/* Pointer to the directory object linked to the file name */
   1512          )
   1513          {
   \                     dir_find:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1514          	FRESULT res;
   1515          	BYTE c, *dir;
   1516          #if _USE_LFN
   1517          	BYTE a, ord, sum;
   1518          #endif
   1519          
   1520          	res = dir_sdi(dp, 0);			/* Rewind directory object */
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       dir_sdi
   \   0000000E   0x4682             MOV      R10,R0
   1521          	if (res != FR_OK) return res;
   \   00000010   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000014   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000018   0xD002             BEQ.N    ??dir_find_0
   \   0000001A   0x4650             MOV      R0,R10
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xE078             B.N      ??dir_find_1
   1522          
   1523          #if _USE_LFN
   1524          	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   \                     ??dir_find_0:
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0x4681             MOV      R9,R0
   \   00000024   0x4680             MOV      R8,R0
   \   00000026   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000002A   0x8420             STRH     R0,[R4, #+32]
   1525          #endif
   1526          	do {
   1527          		res = move_window(dp->fs, dp->sect);
   \                     ??dir_find_2:
   \   0000002C   0x6921             LDR      R1,[R4, #+16]
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       move_window
   \   00000034   0x4682             MOV      R10,R0
   1528          		if (res != FR_OK) break;
   \   00000036   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000003A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000003E   0xD166             BNE.N    ??dir_find_3
   1529          		dir = dp->dir;					/* Ptr to the directory entry of current index */
   \                     ??dir_find_4:
   \   00000040   0x6960             LDR      R0,[R4, #+20]
   \   00000042   0x0006             MOVS     R6,R0
   1530          		c = dir[DIR_Name];
   \   00000044   0x7830             LDRB     R0,[R6, #+0]
   \   00000046   0x0005             MOVS     R5,R0
   1531          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD102             BNE.N    ??dir_find_5
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x4682             MOV      R10,R0
   \   00000052   0xE05C             B.N      ??dir_find_3
   1532          #if _USE_LFN	/* LFN configuration */
   1533          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_find_5:
   \   00000054   0x7AF0             LDRB     R0,[R6, #+11]
   \   00000056   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000005A   0x0007             MOVS     R7,R0
   1534          		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2DE5             CMP      R5,#+229
   \   00000060   0xD004             BEQ.N    ??dir_find_6
   \   00000062   0x0738             LSLS     R0,R7,#+28
   \   00000064   0xD508             BPL.N    ??dir_find_7
   \   00000066   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000068   0x2F0F             CMP      R7,#+15
   \   0000006A   0xD005             BEQ.N    ??dir_find_7
   1535          			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   \                     ??dir_find_6:
   \   0000006C   0x20FF             MOVS     R0,#+255
   \   0000006E   0x4680             MOV      R8,R0
   \   00000070   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000074   0x8420             STRH     R0,[R4, #+32]
   \   00000076   0xE040             B.N      ??dir_find_8
   1536          		} else {
   1537          			if (a == AM_LFN) {			/* An LFN entry is found */
   \                     ??dir_find_7:
   \   00000078   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007A   0x2F0F             CMP      R7,#+15
   \   0000007C   0xD121             BNE.N    ??dir_find_9
   1538          				if (dp->lfn) {
   \   0000007E   0x69E0             LDR      R0,[R4, #+28]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD03A             BEQ.N    ??dir_find_8
   1539          					if (c & LLE) {		/* Is it start of LFN sequence? */
   \   00000084   0x0668             LSLS     R0,R5,#+25
   \   00000086   0xD506             BPL.N    ??dir_find_10
   1540          						sum = dir[LDIR_Chksum];
   \   00000088   0x7B70             LDRB     R0,[R6, #+13]
   \   0000008A   0x4681             MOV      R9,R0
   1541          						c &= ~LLE; ord = c;	/* LFN start order */
   \   0000008C   0xF015 0x05BF      ANDS     R5,R5,#0xBF
   \   00000090   0x46A8             MOV      R8,R5
   1542          						dp->lfn_idx = dp->index;	/* Start index of LFN */
   \   00000092   0x88E0             LDRH     R0,[R4, #+6]
   \   00000094   0x8420             STRH     R0,[R4, #+32]
   1543          					}
   1544          					/* Check validity of the LFN entry and compare it with given name */
   1545          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
   \                     ??dir_find_10:
   \   00000096   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000098   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009C   0x4545             CMP      R5,R8
   \   0000009E   0xD10D             BNE.N    ??dir_find_11
   \   000000A0   0x7B70             LDRB     R0,[R6, #+13]
   \   000000A2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000A6   0x4581             CMP      R9,R0
   \   000000A8   0xD108             BNE.N    ??dir_find_11
   \   000000AA   0x0031             MOVS     R1,R6
   \   000000AC   0x69E0             LDR      R0,[R4, #+28]
   \   000000AE   0x.... 0x....      BL       cmp_lfn
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD002             BEQ.N    ??dir_find_11
   \   000000B6   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   000000BA   0xE001             B.N      ??dir_find_12
   \                     ??dir_find_11:
   \   000000BC   0xF04F 0x08FF      MOV      R8,#+255
   \                     ??dir_find_12:
   \   000000C0   0xE01B             B.N      ??dir_find_8
   1546          				}
   1547          			} else {					/* An SFN entry is found */
   1548          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   \                     ??dir_find_9:
   \   000000C2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000CA   0xD106             BNE.N    ??dir_find_13
   \   000000CC   0x0030             MOVS     R0,R6
   \   000000CE   0x.... 0x....      BL       sum_sfn
   \   000000D2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D6   0x4581             CMP      R9,R0
   \   000000D8   0xD019             BEQ.N    ??dir_find_3
   1549          				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
   \                     ??dir_find_13:
   \   000000DA   0x69A0             LDR      R0,[R4, #+24]
   \   000000DC   0x7AC0             LDRB     R0,[R0, #+11]
   \   000000DE   0x07C0             LSLS     R0,R0,#+31
   \   000000E0   0xD406             BMI.N    ??dir_find_14
   \   000000E2   0x220B             MOVS     R2,#+11
   \   000000E4   0x69A1             LDR      R1,[R4, #+24]
   \   000000E6   0x0030             MOVS     R0,R6
   \   000000E8   0x.... 0x....      BL       mem_cmp
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD00E             BEQ.N    ??dir_find_3
   1550          				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   \                     ??dir_find_14:
   \   000000F0   0x20FF             MOVS     R0,#+255
   \   000000F2   0x4680             MOV      R8,R0
   \   000000F4   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000F8   0x8420             STRH     R0,[R4, #+32]
   1551          			}
   1552          		}
   1553          #else		/* Non LFN configuration */
   1554          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
   1555          			break;
   1556          #endif
   1557          		res = dir_next(dp, 0);		/* Next entry */
   \                     ??dir_find_8:
   \   000000FA   0x2100             MOVS     R1,#+0
   \   000000FC   0x0020             MOVS     R0,R4
   \   000000FE   0x.... 0x....      BL       dir_next
   \   00000102   0x4682             MOV      R10,R0
   1558          	} while (res == FR_OK);
   \   00000104   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000108   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000010C   0xD08E             BEQ.N    ??dir_find_2
   1559          
   1560          	return res;
   \                     ??dir_find_3:
   \   0000010E   0x4650             MOV      R0,R10
   \   00000110   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??dir_find_1:
   \   00000112   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1561          }
   1562          
   1563          
   1564          
   1565          
   1566          /*-----------------------------------------------------------------------*/
   1567          /* Read an object from the directory                                     */
   1568          /*-----------------------------------------------------------------------*/
   1569          #if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   1570          static
   1571          FRESULT dir_read (
   1572          	DIR* dp,		/* Pointer to the directory object */
   1573          	int vol			/* Filtered by 0:file/directory or 1:volume label */
   1574          )
   1575          {
   \                     dir_read:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1576          	FRESULT res;
   1577          	BYTE a, c, *dir;
   1578          #if _USE_LFN
   1579          	BYTE ord = 0xFF, sum = 0xFF;
   \   00000008   0xF04F 0x0AFF      MOV      R10,#+255
   \   0000000C   0xF04F 0x0BFF      MOV      R11,#+255
   1580          #endif
   1581          
   1582          	res = FR_NO_FILE;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0x0006             MOVS     R6,R0
   1583          	while (dp->sect) {
   \                     ??dir_read_0:
   \   00000014   0x6920             LDR      R0,[R4, #+16]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD06A             BEQ.N    ??dir_read_1
   1584          		res = move_window(dp->fs, dp->sect);
   \   0000001A   0x6921             LDR      R1,[R4, #+16]
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       move_window
   \   00000022   0x0006             MOVS     R6,R0
   1585          		if (res != FR_OK) break;
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD162             BNE.N    ??dir_read_1
   1586          		dir = dp->dir;					/* Ptr to the directory entry of current index */
   \                     ??dir_read_2:
   \   0000002A   0x6960             LDR      R0,[R4, #+20]
   \   0000002C   0x4681             MOV      R9,R0
   1587          		c = dir[DIR_Name];
   \   0000002E   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000032   0x4680             MOV      R8,R0
   1588          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000034   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000038   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003C   0xD102             BNE.N    ??dir_read_3
   \   0000003E   0x2004             MOVS     R0,#+4
   \   00000040   0x0006             MOVS     R6,R0
   \   00000042   0xE055             B.N      ??dir_read_1
   1589          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_read_3:
   \   00000044   0xF899 0x000B      LDRB     R0,[R9, #+11]
   \   00000048   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000004C   0x0007             MOVS     R7,R0
   1590          #if _USE_LFN	/* LFN configuration */
   1591          		if (c == DDE || (!_FS_RPATH && c == '.') || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
   \   0000004E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000052   0xF1B8 0x0FE5      CMP      R8,#+229
   \   00000056   0xD00A             BEQ.N    ??dir_read_4
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0xF037 0x0020      BICS     R0,R7,#0x20
   \   0000005E   0x2808             CMP      R0,#+8
   \   00000060   0xD101             BNE.N    ??dir_read_5
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xE000             B.N      ??dir_read_6
   \                     ??dir_read_5:
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??dir_read_6:
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x42A8             CMP      R0,R5
   \   0000006C   0xD002             BEQ.N    ??dir_read_7
   1592          			ord = 0xFF;
   \                     ??dir_read_4:
   \   0000006E   0x20FF             MOVS     R0,#+255
   \   00000070   0x4682             MOV      R10,R0
   \   00000072   0xE035             B.N      ??dir_read_8
   1593          		} else {
   1594          			if (a == AM_LFN) {			/* An LFN entry is found */
   \                     ??dir_read_7:
   \   00000074   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000076   0x2F0F             CMP      R7,#+15
   \   00000078   0xD122             BNE.N    ??dir_read_9
   1595          				if (c & LLE) {			/* Is it start of LFN sequence? */
   \   0000007A   0xEA5F 0x6048      LSLS     R0,R8,#+25
   \   0000007E   0xD507             BPL.N    ??dir_read_10
   1596          					sum = dir[LDIR_Chksum];
   \   00000080   0xF899 0x000D      LDRB     R0,[R9, #+13]
   \   00000084   0x4683             MOV      R11,R0
   1597          					c &= ~LLE; ord = c;
   \   00000086   0xF018 0x08BF      ANDS     R8,R8,#0xBF
   \   0000008A   0x46C2             MOV      R10,R8
   1598          					dp->lfn_idx = dp->index;
   \   0000008C   0x88E0             LDRH     R0,[R4, #+6]
   \   0000008E   0x8420             STRH     R0,[R4, #+32]
   1599          				}
   1600          				/* Check LFN validity and capture it */
   1601          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
   \                     ??dir_read_10:
   \   00000090   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000094   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000098   0x45D0             CMP      R8,R10
   \   0000009A   0xD10E             BNE.N    ??dir_read_11
   \   0000009C   0xF899 0x000D      LDRB     R0,[R9, #+13]
   \   000000A0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A4   0x4583             CMP      R11,R0
   \   000000A6   0xD108             BNE.N    ??dir_read_11
   \   000000A8   0x4649             MOV      R1,R9
   \   000000AA   0x69E0             LDR      R0,[R4, #+28]
   \   000000AC   0x.... 0x....      BL       pick_lfn
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD002             BEQ.N    ??dir_read_11
   \   000000B4   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   000000B8   0xE001             B.N      ??dir_read_12
   \                     ??dir_read_11:
   \   000000BA   0xF04F 0x0AFF      MOV      R10,#+255
   \                     ??dir_read_12:
   \   000000BE   0xE00F             B.N      ??dir_read_8
   1602          			} else {					/* An SFN entry is found */
   1603          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   \                     ??dir_read_9:
   \   000000C0   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000C4   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000C8   0xD106             BNE.N    ??dir_read_13
   \   000000CA   0x4648             MOV      R0,R9
   \   000000CC   0x.... 0x....      BL       sum_sfn
   \   000000D0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000D4   0x4583             CMP      R11,R0
   \   000000D6   0xD002             BEQ.N    ??dir_read_14
   1604          					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
   \                     ??dir_read_13:
   \   000000D8   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000DC   0x8420             STRH     R0,[R4, #+32]
   1605          				break;
   \                     ??dir_read_14:
   \   000000DE   0xE007             B.N      ??dir_read_1
   1606          			}
   1607          		}
   1608          #else		/* Non LFN configuration */
   1609          		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
   1610          			break;
   1611          #endif
   1612          		res = dir_next(dp, 0);				/* Next entry */
   \                     ??dir_read_8:
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0x.... 0x....      BL       dir_next
   \   000000E8   0x0006             MOVS     R6,R0
   1613          		if (res != FR_OK) break;
   \   000000EA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EC   0x2E00             CMP      R6,#+0
   \   000000EE   0xD091             BEQ.N    ??dir_read_0
   1614          	}
   1615          
   1616          	if (res != FR_OK) dp->sect = 0;
   \                     ??dir_read_1:
   \   000000F0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F2   0x2E00             CMP      R6,#+0
   \   000000F4   0xD001             BEQ.N    ??dir_read_15
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x6120             STR      R0,[R4, #+16]
   1617          
   1618          	return res;
   \                     ??dir_read_15:
   \   000000FA   0x0030             MOVS     R0,R6
   \   000000FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1619          }
   1620          #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
   1621          
   1622          
   1623          
   1624          
   1625          /*-----------------------------------------------------------------------*/
   1626          /* Register an object to the directory                                   */
   1627          /*-----------------------------------------------------------------------*/
   1628          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1629          static
   1630          FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
   1631          	DIR* dp				/* Target directory with object name to be created */
   1632          )
   1633          {
   \                     dir_register:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   1634          	FRESULT res;
   1635          #if _USE_LFN	/* LFN configuration */
   1636          	UINT n, nent;
   1637          	BYTE sn[12], *fn, sum;
   1638          	WCHAR *lfn;
   1639          
   1640          
   1641          	fn = dp->fn; lfn = dp->lfn;
   \   00000008   0x69A0             LDR      R0,[R4, #+24]
   \   0000000A   0x4680             MOV      R8,R0
   \   0000000C   0x69E0             LDR      R0,[R4, #+28]
   \   0000000E   0x4682             MOV      R10,R0
   1642          	mem_cpy(sn, fn, 12);
   \   00000010   0x220C             MOVS     R2,#+12
   \   00000012   0x4641             MOV      R1,R8
   \   00000014   0xA800             ADD      R0,SP,#+0
   \   00000016   0x.... 0x....      BL       mem_cpy
   1643          
   1644          	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
   \   0000001A   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   0000001E   0x0680             LSLS     R0,R0,#+26
   \   00000020   0xD501             BPL.N    ??dir_register_0
   1645          		return FR_INVALID_NAME;
   \   00000022   0x2006             MOVS     R0,#+6
   \   00000024   0xE096             B.N      ??dir_register_1
   1646          
   1647          	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   \                     ??dir_register_0:
   \   00000026   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   0000002A   0x07C0             LSLS     R0,R0,#+31
   \   0000002C   0xD527             BPL.N    ??dir_register_2
   1648          		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF888 0x000B      STRB     R0,[R8, #+11]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x61E0             STR      R0,[R4, #+28]
   1649          		for (n = 1; n < 100; n++) {
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x0006             MOVS     R6,R0
   \                     ??dir_register_3:
   \   0000003C   0x2E64             CMP      R6,#+100
   \   0000003E   0xD20E             BCS.N    ??dir_register_4
   1650          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   \   00000040   0x0033             MOVS     R3,R6
   \   00000042   0x4652             MOV      R2,R10
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0x.... 0x....      BL       gen_numname
   1651          			res = dir_find(dp);				/* Check if the name collides with existing SFN */
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       dir_find
   \   00000052   0x0005             MOVS     R5,R0
   1652          			if (res != FR_OK) break;
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD101             BNE.N    ??dir_register_4
   1653          		}
   \                     ??dir_register_5:
   \   0000005A   0x1C76             ADDS     R6,R6,#+1
   \   0000005C   0xE7EE             B.N      ??dir_register_3
   1654          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   \                     ??dir_register_4:
   \   0000005E   0x2E64             CMP      R6,#+100
   \   00000060   0xD101             BNE.N    ??dir_register_6
   \   00000062   0x2007             MOVS     R0,#+7
   \   00000064   0xE076             B.N      ??dir_register_1
   1655          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   \                     ??dir_register_6:
   \   00000066   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000068   0x2D04             CMP      R5,#+4
   \   0000006A   0xD002             BEQ.N    ??dir_register_7
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0xE070             B.N      ??dir_register_1
   1656          		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
   \                     ??dir_register_7:
   \   00000072   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000076   0xF888 0x000B      STRB     R0,[R8, #+11]
   \   0000007A   0xF8C4 0xA01C      STR      R10,[R4, #+28]
   1657          	}
   1658          
   1659          	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
   \                     ??dir_register_2:
   \   0000007E   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000082   0x0780             LSLS     R0,R0,#+30
   \   00000084   0xD50E             BPL.N    ??dir_register_8
   1660          		for (n = 0; lfn[n]; n++) ;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x0006             MOVS     R6,R0
   \                     ??dir_register_9:
   \   0000008A   0xF83A 0x0016      LDRH     R0,[R10, R6, LSL #+1]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD001             BEQ.N    ??dir_register_10
   \   00000092   0x1C76             ADDS     R6,R6,#+1
   \   00000094   0xE7F9             B.N      ??dir_register_9
   1661          		nent = (n + 25) / 13;
   \                     ??dir_register_10:
   \   00000096   0xF116 0x0019      ADDS     R0,R6,#+25
   \   0000009A   0x210D             MOVS     R1,#+13
   \   0000009C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000A0   0x0007             MOVS     R7,R0
   \   000000A2   0xE001             B.N      ??dir_register_11
   1662          	} else {						/* Otherwise allocate an entry for an SFN  */
   1663          		nent = 1;
   \                     ??dir_register_8:
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x0007             MOVS     R7,R0
   1664          	}
   1665          	res = dir_alloc(dp, nent);		/* Allocate entries */
   \                     ??dir_register_11:
   \   000000A8   0x0039             MOVS     R1,R7
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       dir_alloc
   \   000000B0   0x0005             MOVS     R5,R0
   1666          
   1667          	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x2D00             CMP      R5,#+0
   \   000000B6   0xD12D             BNE.N    ??dir_register_12
   \   000000B8   0x1E7F             SUBS     R7,R7,#+1
   \   000000BA   0x2F00             CMP      R7,#+0
   \   000000BC   0xD02A             BEQ.N    ??dir_register_12
   1668          		res = dir_sdi(dp, dp->index - nent);
   \   000000BE   0x88E0             LDRH     R0,[R4, #+6]
   \   000000C0   0x1BC1             SUBS     R1,R0,R7
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x.... 0x....      BL       dir_sdi
   \   000000C8   0x0005             MOVS     R5,R0
   1669          		if (res == FR_OK) {
   \   000000CA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CC   0x2D00             CMP      R5,#+0
   \   000000CE   0xD121             BNE.N    ??dir_register_12
   1670          			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
   \   000000D0   0x69A0             LDR      R0,[R4, #+24]
   \   000000D2   0x.... 0x....      BL       sum_sfn
   \   000000D6   0x4681             MOV      R9,R0
   1671          			do {					/* Store LFN entries in bottom first */
   1672          				res = move_window(dp->fs, dp->sect);
   \                     ??dir_register_13:
   \   000000D8   0x6921             LDR      R1,[R4, #+16]
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x.... 0x....      BL       move_window
   \   000000E0   0x0005             MOVS     R5,R0
   1673          				if (res != FR_OK) break;
   \   000000E2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E4   0x2D00             CMP      R5,#+0
   \   000000E6   0xD115             BNE.N    ??dir_register_12
   1674          				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
   \                     ??dir_register_14:
   \   000000E8   0x464B             MOV      R3,R9
   \   000000EA   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000EC   0x003A             MOVS     R2,R7
   \   000000EE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F0   0x6961             LDR      R1,[R4, #+20]
   \   000000F2   0x69E0             LDR      R0,[R4, #+28]
   \   000000F4   0x.... 0x....      BL       fit_lfn
   1675          				dp->fs->wflag = 1;
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x2101             MOVS     R1,#+1
   \   000000FC   0x7101             STRB     R1,[R0, #+4]
   1676          				res = dir_next(dp, 0);	/* Next entry */
   \   000000FE   0x2100             MOVS     R1,#+0
   \   00000100   0x0020             MOVS     R0,R4
   \   00000102   0x.... 0x....      BL       dir_next
   \   00000106   0x0005             MOVS     R5,R0
   1677          			} while (res == FR_OK && --nent);
   \   00000108   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010A   0x2D00             CMP      R5,#+0
   \   0000010C   0xD102             BNE.N    ??dir_register_12
   \   0000010E   0x1E7F             SUBS     R7,R7,#+1
   \   00000110   0x2F00             CMP      R7,#+0
   \   00000112   0xD1E1             BNE.N    ??dir_register_13
   1678          		}
   1679          	}
   1680          #else	/* Non LFN configuration */
   1681          	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
   1682          #endif
   1683          
   1684          	if (res == FR_OK) {				/* Set SFN entry */
   \                     ??dir_register_12:
   \   00000114   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000116   0x2D00             CMP      R5,#+0
   \   00000118   0xD11A             BNE.N    ??dir_register_15
   1685          		res = move_window(dp->fs, dp->sect);
   \   0000011A   0x6921             LDR      R1,[R4, #+16]
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x.... 0x....      BL       move_window
   \   00000122   0x0005             MOVS     R5,R0
   1686          		if (res == FR_OK) {
   \   00000124   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000126   0x2D00             CMP      R5,#+0
   \   00000128   0xD112             BNE.N    ??dir_register_15
   1687          			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
   \   0000012A   0x2220             MOVS     R2,#+32
   \   0000012C   0x2100             MOVS     R1,#+0
   \   0000012E   0x6960             LDR      R0,[R4, #+20]
   \   00000130   0x.... 0x....      BL       mem_set
   1688          			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
   \   00000134   0x220B             MOVS     R2,#+11
   \   00000136   0x69A1             LDR      R1,[R4, #+24]
   \   00000138   0x6960             LDR      R0,[R4, #+20]
   \   0000013A   0x.... 0x....      BL       mem_cpy
   1689          #if _USE_LFN
   1690          			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
   \   0000013E   0x69A0             LDR      R0,[R4, #+24]
   \   00000140   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000142   0xF010 0x0018      ANDS     R0,R0,#0x18
   \   00000146   0x6961             LDR      R1,[R4, #+20]
   \   00000148   0x7308             STRB     R0,[R1, #+12]
   1691          #endif
   1692          			dp->fs->wflag = 1;
   \   0000014A   0x6820             LDR      R0,[R4, #+0]
   \   0000014C   0x2101             MOVS     R1,#+1
   \   0000014E   0x7101             STRB     R1,[R0, #+4]
   1693          		}
   1694          	}
   1695          
   1696          	return res;
   \                     ??dir_register_15:
   \   00000150   0x0028             MOVS     R0,R5
   \   00000152   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??dir_register_1:
   \   00000154   0xB004             ADD      SP,SP,#+16
   \   00000156   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1697          }
   1698          #endif /* !_FS_READONLY */
   1699          
   1700          
   1701          
   1702          
   1703          /*-----------------------------------------------------------------------*/
   1704          /* Remove an object from the directory                                   */
   1705          /*-----------------------------------------------------------------------*/
   1706          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In section .text, align 2, keep-with-next
   1707          static
   1708          FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
   1709          	DIR* dp				/* Directory object pointing the entry to be removed */
   1710          )
   1711          {
   \                     dir_remove:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1712          	FRESULT res;
   1713          #if _USE_LFN	/* LFN configuration */
   1714          	UINT i;
   1715          
   1716          	i = dp->index;	/* SFN index */
   \   00000004   0x88E0             LDRH     R0,[R4, #+6]
   \   00000006   0x0006             MOVS     R6,R0
   1717          	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
   \   00000008   0x8C20             LDRH     R0,[R4, #+32]
   \   0000000A   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD101             BNE.N    ??dir_remove_0
   \   00000012   0x0031             MOVS     R1,R6
   \   00000014   0xE000             B.N      ??dir_remove_1
   \                     ??dir_remove_0:
   \   00000016   0x8C21             LDRH     R1,[R4, #+32]
   \                     ??dir_remove_1:
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       dir_sdi
   \   0000001E   0x0005             MOVS     R5,R0
   1718          	if (res == FR_OK) {
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD122             BNE.N    ??dir_remove_2
   1719          		do {
   1720          			res = move_window(dp->fs, dp->sect);
   \                     ??dir_remove_3:
   \   00000026   0x6921             LDR      R1,[R4, #+16]
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       move_window
   \   0000002E   0x0005             MOVS     R5,R0
   1721          			if (res != FR_OK) break;
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD115             BNE.N    ??dir_remove_4
   1722          			mem_set(dp->dir, 0, SZ_DIR);	/* Clear and mark the entry "deleted" */
   \                     ??dir_remove_5:
   \   00000036   0x2220             MOVS     R2,#+32
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x6960             LDR      R0,[R4, #+20]
   \   0000003C   0x.... 0x....      BL       mem_set
   1723          			*dp->dir = DDE;
   \   00000040   0x6960             LDR      R0,[R4, #+20]
   \   00000042   0x21E5             MOVS     R1,#+229
   \   00000044   0x7001             STRB     R1,[R0, #+0]
   1724          			dp->fs->wflag = 1;
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x7101             STRB     R1,[R0, #+4]
   1725          			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   \   0000004C   0x88E0             LDRH     R0,[R4, #+6]
   \   0000004E   0x42B0             CMP      R0,R6
   \   00000050   0xD207             BCS.N    ??dir_remove_4
   1726          			res = dir_next(dp, 0);		/* Next entry */
   \                     ??dir_remove_6:
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       dir_next
   \   0000005A   0x0005             MOVS     R5,R0
   1727          		} while (res == FR_OK);
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD0E1             BEQ.N    ??dir_remove_3
   1728          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   \                     ??dir_remove_4:
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x2D04             CMP      R5,#+4
   \   00000066   0xD101             BNE.N    ??dir_remove_2
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0x0005             MOVS     R5,R0
   1729          	}
   1730          
   1731          #else			/* Non LFN configuration */
   1732          	res = dir_sdi(dp, dp->index);
   1733          	if (res == FR_OK) {
   1734          		res = move_window(dp->fs, dp->sect);
   1735          		if (res == FR_OK) {
   1736          			mem_set(dp->dir, 0, SZ_DIR);	/* Clear and mark the entry "deleted" */
   1737          			*dp->dir = DDE;
   1738          			dp->fs->wflag = 1;
   1739          		}
   1740          	}
   1741          #endif
   1742          
   1743          	return res;
   \                     ??dir_remove_2:
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
   1744          }
   1745          #endif /* !_FS_READONLY */
   1746          
   1747          
   1748          
   1749          
   1750          /*-----------------------------------------------------------------------*/
   1751          /* Get file information from directory entry                             */
   1752          /*-----------------------------------------------------------------------*/
   1753          #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   1754          static
   1755          void get_fileinfo (		/* No return code */
   1756          	DIR* dp,			/* Pointer to the directory object */
   1757          	FILINFO* fno	 	/* Pointer to the file information to be filled */
   1758          )
   1759          {
   \                     get_fileinfo:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1760          	UINT i;
   1761          	TCHAR *p, c;
   1762          
   1763          
   1764          	p = fno->fname;
   \   00000008   0xF205 0x0009      ADDW     R0,R5,#+9
   \   0000000C   0x4680             MOV      R8,R0
   1765          	if (dp->sect) {		/* Get SFN */
   \   0000000E   0x6920             LDR      R0,[R4, #+16]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD041             BEQ.N    ??get_fileinfo_0
   1766          		BYTE *dir = dp->dir;
   \   00000014   0x6960             LDR      R0,[R4, #+20]
   1767          
   1768          		i = 0;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x000F             MOVS     R7,R1
   1769          		while (i < 11) {		/* Copy name body and extension */
   \                     ??get_fileinfo_1:
   \   0000001A   0x2F0B             CMP      R7,#+11
   \   0000001C   0xD225             BCS.N    ??get_fileinfo_2
   1770          			c = (TCHAR)dir[i++];
   \   0000001E   0x5C39             LDRB     R1,[R7, R0]
   \   00000020   0x000E             MOVS     R6,R1
   \   00000022   0x1C7F             ADDS     R7,R7,#+1
   1771          			if (c == ' ') continue;			/* Skip padding spaces */
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E20             CMP      R6,#+32
   \   00000028   0xD0F7             BEQ.N    ??get_fileinfo_1
   1772          			if (c == NDDE) c = (TCHAR)DDE;	/* Restore replaced DDE character */
   \                     ??get_fileinfo_3:
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E05             CMP      R6,#+5
   \   0000002E   0xD101             BNE.N    ??get_fileinfo_4
   \   00000030   0x21E5             MOVS     R1,#+229
   \   00000032   0x000E             MOVS     R6,R1
   1773          			if (i == 9) *p++ = '.';			/* Insert a . if extension is exist */
   \                     ??get_fileinfo_4:
   \   00000034   0x2F09             CMP      R7,#+9
   \   00000036   0xD104             BNE.N    ??get_fileinfo_5
   \   00000038   0x212E             MOVS     R1,#+46
   \   0000003A   0xF888 0x1000      STRB     R1,[R8, #+0]
   \   0000003E   0xF118 0x0801      ADDS     R8,R8,#+1
   1774          #if _USE_LFN
   1775          			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
   \                     ??get_fileinfo_5:
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x2E41             CMP      R6,#+65
   \   00000046   0xDB0B             BLT.N    ??get_fileinfo_6
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E5B             CMP      R6,#+91
   \   0000004C   0xDA08             BGE.N    ??get_fileinfo_6
   \   0000004E   0x2F09             CMP      R7,#+9
   \   00000050   0xD301             BCC.N    ??get_fileinfo_7
   \   00000052   0x2110             MOVS     R1,#+16
   \   00000054   0xE000             B.N      ??get_fileinfo_8
   \                     ??get_fileinfo_7:
   \   00000056   0x2108             MOVS     R1,#+8
   \                     ??get_fileinfo_8:
   \   00000058   0x7B02             LDRB     R2,[R0, #+12]
   \   0000005A   0x420A             TST      R2,R1
   \   0000005C   0xD000             BEQ.N    ??get_fileinfo_6
   1776          				c += 0x20;			/* To lower */
   \   0000005E   0x3620             ADDS     R6,R6,#+32
   1777          #if _LFN_UNICODE
   1778          			if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dir[i]))
   1779          				c = c << 8 | dir[i++];
   1780          			c = ff_convert(c, 1);	/* OEM -> Unicode */
   1781          			if (!c) c = '?';
   1782          #endif
   1783          #endif
   1784          			*p++ = c;
   \                     ??get_fileinfo_6:
   \   00000060   0xF888 0x6000      STRB     R6,[R8, #+0]
   \   00000064   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000068   0xE7D7             B.N      ??get_fileinfo_1
   1785          		}
   1786          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \                     ??get_fileinfo_2:
   \   0000006A   0x7AC1             LDRB     R1,[R0, #+11]
   \   0000006C   0x7229             STRB     R1,[R5, #+8]
   1787          		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   \   0000006E   0x7FC1             LDRB     R1,[R0, #+31]
   \   00000070   0x7F82             LDRB     R2,[R0, #+30]
   \   00000072   0x0412             LSLS     R2,R2,#+16
   \   00000074   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   00000078   0x7F42             LDRB     R2,[R0, #+29]
   \   0000007A   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   0000007E   0x7F02             LDRB     R2,[R0, #+28]
   \   00000080   0x4311             ORRS     R1,R2,R1
   \   00000082   0x6029             STR      R1,[R5, #+0]
   1788          		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
   \   00000084   0x7E41             LDRB     R1,[R0, #+25]
   \   00000086   0x7E02             LDRB     R2,[R0, #+24]
   \   00000088   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000008C   0x80A9             STRH     R1,[R5, #+4]
   1789          		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
   \   0000008E   0x7DC1             LDRB     R1,[R0, #+23]
   \   00000090   0x7D80             LDRB     R0,[R0, #+22]
   \   00000092   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000096   0x80E8             STRH     R0,[R5, #+6]
   1790          	}
   1791          	*p = 0;		/* Terminate SFN string by a \0 */
   \                     ??get_fileinfo_0:
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF888 0x0000      STRB     R0,[R8, #+0]
   1792          
   1793          #if _USE_LFN
   1794          	if (fno->lfname) {
   \   0000009E   0x69A8             LDR      R0,[R5, #+24]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD034             BEQ.N    ??get_fileinfo_9
   1795          		WCHAR w, *lfn;
   1796          
   1797          		i = 0; p = fno->lfname;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x0007             MOVS     R7,R0
   \   000000A8   0x69A8             LDR      R0,[R5, #+24]
   \   000000AA   0x4680             MOV      R8,R0
   1798          		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
   \   000000AC   0x6920             LDR      R0,[R4, #+16]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD02A             BEQ.N    ??get_fileinfo_10
   \   000000B2   0x69E8             LDR      R0,[R5, #+28]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD027             BEQ.N    ??get_fileinfo_10
   \   000000B8   0x8C20             LDRH     R0,[R4, #+32]
   \   000000BA   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xD022             BEQ.N    ??get_fileinfo_10
   1799          			lfn = dp->lfn;
   \   000000C2   0x69E0             LDR      R0,[R4, #+28]
   \   000000C4   0x4682             MOV      R10,R0
   1800          			while ((w = *lfn++) != 0) {		/* Get an LFN character */
   \                     ??get_fileinfo_11:
   \   000000C6   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \   000000CA   0xF11A 0x0A02      ADDS     R10,R10,#+2
   \   000000CE   0x4681             MOV      R9,R0
   \   000000D0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD018             BEQ.N    ??get_fileinfo_10
   1801          #if !_LFN_UNICODE
   1802          				w = ff_convert(w, 0);		/* Unicode -> OEM */
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0x4648             MOV      R0,R9
   \   000000DA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DC   0x.... 0x....      BL       ff_convert
   \   000000E0   0x4681             MOV      R9,R0
   1803          				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
   \   000000E2   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000E6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000EA   0xD102             BNE.N    ??get_fileinfo_12
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x0007             MOVS     R7,R0
   \   000000F0   0xE00A             B.N      ??get_fileinfo_10
   1804          				if (_DF1S && w >= 0x100)	/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   1805          					p[i++] = (TCHAR)(w >> 8);
   1806          #endif
   1807          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
   \                     ??get_fileinfo_12:
   \   000000F2   0x69E8             LDR      R0,[R5, #+28]
   \   000000F4   0x1E40             SUBS     R0,R0,#+1
   \   000000F6   0x4287             CMP      R7,R0
   \   000000F8   0xD302             BCC.N    ??get_fileinfo_13
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x0007             MOVS     R7,R0
   \   000000FE   0xE003             B.N      ??get_fileinfo_10
   1808          				p[i++] = (TCHAR)w;
   \                     ??get_fileinfo_13:
   \   00000100   0xF807 0x9008      STRB     R9,[R7, R8]
   \   00000104   0x1C7F             ADDS     R7,R7,#+1
   \   00000106   0xE7DE             B.N      ??get_fileinfo_11
   1809          			}
   1810          		}
   1811          		p[i] = 0;	/* Terminate LFN string by a \0 */
   \                     ??get_fileinfo_10:
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xF807 0x0008      STRB     R0,[R7, R8]
   1812          	}
   1813          #endif
   1814          }
   \                     ??get_fileinfo_9:
   \   0000010E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1815          #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2*/
   1816          
   1817          
   1818          
   1819          
   1820          /*-----------------------------------------------------------------------*/
   1821          /* Pick a segment and create the object name in directory form           */
   1822          /*-----------------------------------------------------------------------*/
   1823          

   \                                 In section .text, align 2, keep-with-next
   1824          static
   1825          FRESULT create_name (
   1826          	DIR* dp,			/* Pointer to the directory object */
   1827          	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
   1828          )
   1829          {
   \                     create_name:
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   1830          #if _USE_LFN	/* LFN configuration */
   1831          	BYTE b, cf;
   1832          	WCHAR w, *lfn;
   1833          	UINT i, ni, si, di;
   1834          	const TCHAR *p;
   1835          
   1836          	/* Create LFN in Unicode */
   1837          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   \   00000006   0x9802             LDR      R0,[SP, #+8]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0006             MOVS     R6,R0
   \                     ??create_name_0:
   \   0000000C   0x7830             LDRB     R0,[R6, #+0]
   \   0000000E   0x282F             CMP      R0,#+47
   \   00000010   0xD002             BEQ.N    ??create_name_1
   \   00000012   0x7830             LDRB     R0,[R6, #+0]
   \   00000014   0x285C             CMP      R0,#+92
   \   00000016   0xD101             BNE.N    ??create_name_2
   \                     ??create_name_1:
   \   00000018   0x1C76             ADDS     R6,R6,#+1
   \   0000001A   0xE7F7             B.N      ??create_name_0
   1838          	lfn = dp->lfn;
   \                     ??create_name_2:
   \   0000001C   0x9801             LDR      R0,[SP, #+4]
   \   0000001E   0x69C0             LDR      R0,[R0, #+28]
   \   00000020   0x0005             MOVS     R5,R0
   1839          	si = di = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4681             MOV      R9,R0
   \   00000026   0x4682             MOV      R10,R0
   1840          	for (;;) {
   1841          		w = p[si++];					/* Get a character */
   \                     ??create_name_3:
   \   00000028   0xF81A 0x0006      LDRB     R0,[R10, R6]
   \   0000002C   0x0007             MOVS     R7,R0
   \   0000002E   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1842          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   \   00000032   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000034   0x2F20             CMP      R7,#+32
   \   00000036   0xDB05             BLT.N    ??create_name_4
   \   00000038   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003A   0x2F2F             CMP      R7,#+47
   \   0000003C   0xD002             BEQ.N    ??create_name_4
   \   0000003E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000040   0x2F5C             CMP      R7,#+92
   \   00000042   0xD107             BNE.N    ??create_name_5
   1843          		if (di >= _MAX_LFN)				/* Reject too long name */
   1844          			return FR_INVALID_NAME;
   1845          #if !_LFN_UNICODE
   1846          		w &= 0xFF;
   1847          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1848          			b = (BYTE)p[si++];			/* Get 2nd byte */
   1849          			if (!IsDBCS2(b))
   1850          				return FR_INVALID_NAME;	/* Reject invalid sequence */
   1851          			//w = (w << 8) + b;			/* Create a DBC */
   1852          		}
   1853          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   1854          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   1855          #endif
   1856          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
   1857          			return FR_INVALID_NAME;
   1858          		lfn[di++] = w;					/* Store the Unicode character */
   1859          	}
   1860          	*path = &p[si];						/* Return pointer to the next segment */
   \                     ??create_name_4:
   \   00000044   0xEB1A 0x0006      ADDS     R0,R10,R6
   \   00000048   0x9902             LDR      R1,[SP, #+8]
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   1861          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   0000004C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000004E   0x2F20             CMP      R7,#+32
   \   00000050   0xDA26             BGE.N    ??create_name_6
   \   00000052   0xE022             B.N      ??create_name_7
   \                     ??create_name_5:
   \   00000054   0xF1B9 0x0FFF      CMP      R9,#+255
   \   00000058   0xD301             BCC.N    ??create_name_8
   \   0000005A   0x2006             MOVS     R0,#+6
   \   0000005C   0xE12F             B.N      ??create_name_9
   \                     ??create_name_8:
   \   0000005E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x.... 0x....      BL       ff_convert
   \   0000006A   0x0007             MOVS     R7,R0
   \   0000006C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD101             BNE.N    ??create_name_10
   \   00000072   0x2006             MOVS     R0,#+6
   \   00000074   0xE123             B.N      ??create_name_9
   \                     ??create_name_10:
   \   00000076   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000078   0x2F80             CMP      R7,#+128
   \   0000007A   0xDA09             BGE.N    ??create_name_11
   \   0000007C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000007E   0x0039             MOVS     R1,R7
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable7
   \   00000084   0x.... 0x....      BL       chk_chr
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD001             BEQ.N    ??create_name_11
   \   0000008C   0x2006             MOVS     R0,#+6
   \   0000008E   0xE116             B.N      ??create_name_9
   \                     ??create_name_11:
   \   00000090   0xF825 0x7019      STRH     R7,[R5, R9, LSL #+1]
   \   00000094   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000098   0xE7C6             B.N      ??create_name_3
   \                     ??create_name_7:
   \   0000009A   0xF05F 0x0B04      MOVS     R11,#+4
   \   0000009E   0xE001             B.N      ??create_name_12
   \                     ??create_name_6:
   \   000000A0   0xF05F 0x0B00      MOVS     R11,#+0
   1862          #if _FS_RPATH
   1863          	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
   1864          		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
   \                     ??create_name_12:
   \   000000A4   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000A8   0xD105             BNE.N    ??create_name_13
   \   000000AA   0xEB15 0x0049      ADDS     R0,R5,R9, LSL #+1
   \   000000AE   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   000000B2   0x282E             CMP      R0,#+46
   \   000000B4   0xD00E             BEQ.N    ??create_name_14
   \                     ??create_name_13:
   \   000000B6   0xF1B9 0x0F02      CMP      R9,#+2
   \   000000BA   0xD127             BNE.N    ??create_name_15
   \   000000BC   0xEB15 0x0049      ADDS     R0,R5,R9, LSL #+1
   \   000000C0   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   000000C4   0x282E             CMP      R0,#+46
   \   000000C6   0xD121             BNE.N    ??create_name_15
   \   000000C8   0xEB15 0x0049      ADDS     R0,R5,R9, LSL #+1
   \   000000CC   0xF830 0x0C04      LDRH     R0,[R0, #-4]
   \   000000D0   0x282E             CMP      R0,#+46
   \   000000D2   0xD11B             BNE.N    ??create_name_15
   1865          		lfn[di] = 0;
   \                     ??create_name_14:
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF825 0x0019      STRH     R0,[R5, R9, LSL #+1]
   1866          		for (i = 0; i < 11; i++)
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x4680             MOV      R8,R0
   \                     ??create_name_16:
   \   000000DE   0xF1B8 0x0F0B      CMP      R8,#+11
   \   000000E2   0xD20B             BCS.N    ??create_name_17
   1867          			dp->fn[i] = (i < di) ? '.' : ' ';
   \   000000E4   0x45C8             CMP      R8,R9
   \   000000E6   0xD201             BCS.N    ??create_name_18
   \   000000E8   0x202E             MOVS     R0,#+46
   \   000000EA   0xE000             B.N      ??create_name_19
   \                     ??create_name_18:
   \   000000EC   0x2020             MOVS     R0,#+32
   \                     ??create_name_19:
   \   000000EE   0x9901             LDR      R1,[SP, #+4]
   \   000000F0   0x6989             LDR      R1,[R1, #+24]
   \   000000F2   0xF808 0x0001      STRB     R0,[R8, R1]
   \   000000F6   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000FA   0xE7F0             B.N      ??create_name_16
   1868          		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   \                     ??create_name_17:
   \   000000FC   0x9801             LDR      R0,[SP, #+4]
   \   000000FE   0x6980             LDR      R0,[R0, #+24]
   \   00000100   0xF05B 0x0120      ORRS     R1,R11,#0x20
   \   00000104   0xF808 0x1000      STRB     R1,[R8, R0]
   1869          		return FR_OK;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xE0D8             B.N      ??create_name_9
   1870          	}
   1871          #endif
   1872          	while (di) {						/* Strip trailing spaces and dots */
   \                     ??create_name_15:
   \   0000010C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000110   0xD00D             BEQ.N    ??create_name_20
   1873          		w = lfn[di-1];
   \   00000112   0xEB15 0x0049      ADDS     R0,R5,R9, LSL #+1
   \   00000116   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   0000011A   0x0007             MOVS     R7,R0
   1874          		if (w != ' ' && w != '.') break;
   \   0000011C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000011E   0x2F20             CMP      R7,#+32
   \   00000120   0xD002             BEQ.N    ??create_name_21
   \   00000122   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000124   0x2F2E             CMP      R7,#+46
   \   00000126   0xD102             BNE.N    ??create_name_20
   1875          		di--;
   \                     ??create_name_21:
   \   00000128   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   0000012C   0xE7EE             B.N      ??create_name_15
   1876          	}
   1877          	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   \                     ??create_name_20:
   \   0000012E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000132   0xD101             BNE.N    ??create_name_22
   \   00000134   0x2006             MOVS     R0,#+6
   \   00000136   0xE0C2             B.N      ??create_name_9
   1878          
   1879          	lfn[di] = 0;						/* LFN is created */
   \                     ??create_name_22:
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xF825 0x0019      STRH     R0,[R5, R9, LSL #+1]
   1880          
   1881          	/* Create SFN in directory form */
   1882          	mem_set(dp->fn, ' ', 11);
   \   0000013E   0x220B             MOVS     R2,#+11
   \   00000140   0x2120             MOVS     R1,#+32
   \   00000142   0x9801             LDR      R0,[SP, #+4]
   \   00000144   0x6980             LDR      R0,[R0, #+24]
   \   00000146   0x.... 0x....      BL       mem_set
   1883          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0x4682             MOV      R10,R0
   \                     ??create_name_23:
   \   0000014E   0xF835 0x001A      LDRH     R0,[R5, R10, LSL #+1]
   \   00000152   0x2820             CMP      R0,#+32
   \   00000154   0xD003             BEQ.N    ??create_name_24
   \   00000156   0xF835 0x001A      LDRH     R0,[R5, R10, LSL #+1]
   \   0000015A   0x282E             CMP      R0,#+46
   \   0000015C   0xD102             BNE.N    ??create_name_25
   \                     ??create_name_24:
   \   0000015E   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   00000162   0xE7F4             B.N      ??create_name_23
   1884          	if (si) cf |= NS_LOSS | NS_LFN;
   \                     ??create_name_25:
   \   00000164   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000168   0xD001             BEQ.N    ??create_name_26
   \   0000016A   0xF05B 0x0B03      ORRS     R11,R11,#0x3
   1885          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   \                     ??create_name_26:
   \   0000016E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000172   0xD008             BEQ.N    ??create_name_27
   \   00000174   0xEB15 0x0049      ADDS     R0,R5,R9, LSL #+1
   \   00000178   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   0000017C   0x282E             CMP      R0,#+46
   \   0000017E   0xD002             BEQ.N    ??create_name_27
   \   00000180   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   00000184   0xE7F3             B.N      ??create_name_26
   1886          
   1887          	b = i = 0; ni = 8;
   \                     ??create_name_27:
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0x4680             MOV      R8,R0
   \   0000018A   0x0004             MOVS     R4,R0
   \   0000018C   0x2008             MOVS     R0,#+8
   \   0000018E   0x9000             STR      R0,[SP, #+0]
   1888          	for (;;) {
   1889          		w = lfn[si++];					/* Get an LFN character */
   \                     ??create_name_28:
   \   00000190   0xF835 0x001A      LDRH     R0,[R5, R10, LSL #+1]
   \   00000194   0x0007             MOVS     R7,R0
   \   00000196   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1890          		if (!w) break;					/* Break on end of the LFN */
   \   0000019A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000019C   0x2F00             CMP      R7,#+0
   \   0000019E   0xD05F             BEQ.N    ??create_name_29
   1891          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   \                     ??create_name_30:
   \   000001A0   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001A2   0x2F20             CMP      R7,#+32
   \   000001A4   0xD004             BEQ.N    ??create_name_31
   \   000001A6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001A8   0x2F2E             CMP      R7,#+46
   \   000001AA   0xD104             BNE.N    ??create_name_32
   \   000001AC   0x45CA             CMP      R10,R9
   \   000001AE   0xD002             BEQ.N    ??create_name_32
   1892          			cf |= NS_LOSS | NS_LFN; continue;
   \                     ??create_name_31:
   \   000001B0   0xF05B 0x0B03      ORRS     R11,R11,#0x3
   \   000001B4   0xE7EC             B.N      ??create_name_28
   1893          		}
   1894          
   1895          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   \                     ??create_name_32:
   \   000001B6   0x9800             LDR      R0,[SP, #+0]
   \   000001B8   0x4580             CMP      R8,R0
   \   000001BA   0xD201             BCS.N    ??create_name_33
   \   000001BC   0x45CA             CMP      R10,R9
   \   000001BE   0xD112             BNE.N    ??create_name_34
   1896          			if (ni == 11) {				/* Long extension */
   \                     ??create_name_33:
   \   000001C0   0x9800             LDR      R0,[SP, #+0]
   \   000001C2   0x280B             CMP      R0,#+11
   \   000001C4   0xD102             BNE.N    ??create_name_35
   1897          				cf |= NS_LOSS | NS_LFN; break;
   \   000001C6   0xF05B 0x0B03      ORRS     R11,R11,#0x3
   \   000001CA   0xE049             B.N      ??create_name_29
   1898          			}
   1899          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   \                     ??create_name_35:
   \   000001CC   0x45CA             CMP      R10,R9
   \   000001CE   0xD001             BEQ.N    ??create_name_36
   \   000001D0   0xF05B 0x0B03      ORRS     R11,R11,#0x3
   1900          			if (si > di) break;			/* No extension */
   \                     ??create_name_36:
   \   000001D4   0x45D1             CMP      R9,R10
   \   000001D6   0xD343             BCC.N    ??create_name_29
   1901          			si = di; i = 8; ni = 11;	/* Enter extension section */
   \                     ??create_name_37:
   \   000001D8   0x46CA             MOV      R10,R9
   \   000001DA   0x2008             MOVS     R0,#+8
   \   000001DC   0x4680             MOV      R8,R0
   \   000001DE   0x200B             MOVS     R0,#+11
   \   000001E0   0x9000             STR      R0,[SP, #+0]
   1902          			b <<= 2; continue;
   \   000001E2   0x00A4             LSLS     R4,R4,#+2
   \   000001E4   0xE7D4             B.N      ??create_name_28
   1903          		}
   1904          
   1905          		if (w >= 0x80) {				/* Non ASCII character */
   \                     ??create_name_34:
   \   000001E6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001E8   0x2F80             CMP      R7,#+128
   \   000001EA   0xDB10             BLT.N    ??create_name_38
   1906          #ifdef _EXCVT
   1907          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   \   000001EC   0x2100             MOVS     R1,#+0
   \   000001EE   0x0038             MOVS     R0,R7
   \   000001F0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001F2   0x.... 0x....      BL       ff_convert
   \   000001F6   0x0007             MOVS     R7,R0
   1908          			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
   \   000001F8   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001FA   0x2F00             CMP      R7,#+0
   \   000001FC   0xD005             BEQ.N    ??create_name_39
   \   000001FE   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   00000204   0x1838             ADDS     R0,R7,R0
   \   00000206   0xF810 0x7C80      LDRB     R7,[R0, #-128]
   1909          #else
   1910          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1911          #endif
   1912          			cf |= NS_LFN;				/* Force create LFN entry */
   \                     ??create_name_39:
   \   0000020A   0xF05B 0x0B02      ORRS     R11,R11,#0x2
   1913          		}
   1914          
   1915          		if (_DF1S && w >= 0x100) {		/* Double byte character (always false on SBCS cfg) */
   1916          			if (i >= ni - 1) {
   1917          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1918          			}
   1919          			dp->fn[i++] = (BYTE)(w >> 8);
   1920          		} else {						/* Single byte character */
   1921          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
   \                     ??create_name_38:
   \   0000020E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000210   0x2F00             CMP      R7,#+0
   \   00000212   0xD007             BEQ.N    ??create_name_40
   \   00000214   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000216   0x0039             MOVS     R1,R7
   \   00000218   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   0000021C   0x.... 0x....      BL       chk_chr
   \   00000220   0x2800             CMP      R0,#+0
   \   00000222   0xD004             BEQ.N    ??create_name_41
   1922          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   \                     ??create_name_40:
   \   00000224   0x205F             MOVS     R0,#+95
   \   00000226   0x0007             MOVS     R7,R0
   \   00000228   0xF05B 0x0B03      ORRS     R11,R11,#0x3
   \   0000022C   0xE011             B.N      ??create_name_42
   1923          			} else {
   1924          				if (IsUpper(w)) {		/* ASCII large capital */
   \                     ??create_name_41:
   \   0000022E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000230   0x2F41             CMP      R7,#+65
   \   00000232   0xDB05             BLT.N    ??create_name_43
   \   00000234   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000236   0x2F5B             CMP      R7,#+91
   \   00000238   0xDA02             BGE.N    ??create_name_43
   1925          					b |= 2;
   \   0000023A   0xF054 0x0402      ORRS     R4,R4,#0x2
   \   0000023E   0xE008             B.N      ??create_name_42
   1926          				} else {
   1927          					if (IsLower(w)) {	/* ASCII small capital */
   \                     ??create_name_43:
   \   00000240   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000242   0x2F61             CMP      R7,#+97
   \   00000244   0xDB05             BLT.N    ??create_name_42
   \   00000246   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000248   0x2F7B             CMP      R7,#+123
   \   0000024A   0xDA02             BGE.N    ??create_name_42
   1928          						b |= 1; w -= 0x20;
   \   0000024C   0xF054 0x0401      ORRS     R4,R4,#0x1
   \   00000250   0x3F20             SUBS     R7,R7,#+32
   1929          					}
   1930          				}
   1931          			}
   1932          		}
   1933          		dp->fn[i++] = (BYTE)w;
   \                     ??create_name_42:
   \   00000252   0x9801             LDR      R0,[SP, #+4]
   \   00000254   0x6980             LDR      R0,[R0, #+24]
   \   00000256   0xF808 0x7000      STRB     R7,[R8, R0]
   \   0000025A   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000025E   0xE797             B.N      ??create_name_28
   1934          	}
   1935          
   1936          	if (dp->fn[0] == DDE) dp->fn[0] = NDDE;	/* If the first character collides with deleted mark, replace it with 0x05 */
   \                     ??create_name_29:
   \   00000260   0x9801             LDR      R0,[SP, #+4]
   \   00000262   0x6980             LDR      R0,[R0, #+24]
   \   00000264   0x7800             LDRB     R0,[R0, #+0]
   \   00000266   0x28E5             CMP      R0,#+229
   \   00000268   0xD103             BNE.N    ??create_name_44
   \   0000026A   0x9801             LDR      R0,[SP, #+4]
   \   0000026C   0x6980             LDR      R0,[R0, #+24]
   \   0000026E   0x2105             MOVS     R1,#+5
   \   00000270   0x7001             STRB     R1,[R0, #+0]
   1937          
   1938          	if (ni == 8) b <<= 2;
   \                     ??create_name_44:
   \   00000272   0x9800             LDR      R0,[SP, #+0]
   \   00000274   0x2808             CMP      R0,#+8
   \   00000276   0xD100             BNE.N    ??create_name_45
   \   00000278   0x00A4             LSLS     R4,R4,#+2
   1939          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   \                     ??create_name_45:
   \   0000027A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000027C   0xF014 0x000C      ANDS     R0,R4,#0xC
   \   00000280   0x280C             CMP      R0,#+12
   \   00000282   0xD004             BEQ.N    ??create_name_46
   \   00000284   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000286   0xF014 0x0003      ANDS     R0,R4,#0x3
   \   0000028A   0x2803             CMP      R0,#+3
   \   0000028C   0xD101             BNE.N    ??create_name_47
   1940          		cf |= NS_LFN;
   \                     ??create_name_46:
   \   0000028E   0xF05B 0x0B02      ORRS     R11,R11,#0x2
   1941          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
   \                     ??create_name_47:
   \   00000292   0xEA5F 0x708B      LSLS     R0,R11,#+30
   \   00000296   0xD40D             BMI.N    ??create_name_48
   1942          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   \   00000298   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000029A   0xF014 0x0003      ANDS     R0,R4,#0x3
   \   0000029E   0x2801             CMP      R0,#+1
   \   000002A0   0xD101             BNE.N    ??create_name_49
   \   000002A2   0xF05B 0x0B10      ORRS     R11,R11,#0x10
   1943          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   \                     ??create_name_49:
   \   000002A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002A8   0xF014 0x000C      ANDS     R0,R4,#0xC
   \   000002AC   0x2804             CMP      R0,#+4
   \   000002AE   0xD101             BNE.N    ??create_name_48
   \   000002B0   0xF05B 0x0B08      ORRS     R11,R11,#0x8
   1944          	}
   1945          
   1946          	dp->fn[NSFLAG] = cf;	/* SFN is created */
   \                     ??create_name_48:
   \   000002B4   0x9801             LDR      R0,[SP, #+4]
   \   000002B6   0x6980             LDR      R0,[R0, #+24]
   \   000002B8   0xF880 0xB00B      STRB     R11,[R0, #+11]
   1947          
   1948          	return FR_OK;
   \   000002BC   0x2000             MOVS     R0,#+0
   \                     ??create_name_9:
   \   000002BE   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   1949          
   1950          
   1951          #else	/* Non-LFN configuration */
   1952          	BYTE b, c, d, *sfn;
   1953          	UINT ni, si, i;
   1954          	const char *p;
   1955          
   1956          	/* Create file name in directory form */
   1957          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   1958          	sfn = dp->fn;
   1959          	mem_set(sfn, ' ', 11);
   1960          	si = i = b = 0; ni = 8;
   1961          #if _FS_RPATH
   1962          	if (p[si] == '.') { /* Is this a dot entry? */
   1963          		for (;;) {
   1964          			c = (BYTE)p[si++];
   1965          			if (c != '.' || si >= 3) break;
   1966          			sfn[i++] = c;
   1967          		}
   1968          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   1969          		*path = &p[si];									/* Return pointer to the next segment */
   1970          		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   1971          		return FR_OK;
   1972          	}
   1973          #endif
   1974          	for (;;) {
   1975          		c = (BYTE)p[si++];
   1976          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1977          		if (c == '.' || i >= ni) {
   1978          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   1979          			i = 8; ni = 11;
   1980          			b <<= 2; continue;
   1981          		}
   1982          		if (c >= 0x80) {				/* Extended character? */
   1983          			b |= 3;						/* Eliminate NT flag */
   1984          #ifdef _EXCVT
   1985          			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
   1986          #else
   1987          #if !_DF1S
   1988          			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
   1989          #endif
   1990          #endif
   1991          		}
   1992          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1993          			d = (BYTE)p[si++];			/* Get 2nd byte */
   1994          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   1995          				return FR_INVALID_NAME;
   1996          			sfn[i++] = c;
   1997          			sfn[i++] = d;
   1998          		} else {						/* Single byte code */
   1999          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   2000          				return FR_INVALID_NAME;
   2001          			if (IsUpper(c)) {			/* ASCII large capital? */
   2002          				b |= 2;
   2003          			} else {
   2004          				if (IsLower(c)) {		/* ASCII small capital? */
   2005          					b |= 1; c -= 0x20;
   2006          				}
   2007          			}
   2008          			sfn[i++] = c;
   2009          		}
   2010          	}
   2011          	*path = &p[si];						/* Return pointer to the next segment */
   2012          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   2013          
   2014          	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   2015          	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first character collides with DDE, replace it with 0x05 */
   2016          
   2017          	if (ni == 8) b <<= 2;
   2018          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   2019          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   2020          
   2021          	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
   2022          
   2023          	return FR_OK;
   2024          #endif
   2025          }
   2026          
   2027          
   2028          
   2029          
   2030          /*-----------------------------------------------------------------------*/
   2031          /* Follow a file path                                                    */
   2032          /*-----------------------------------------------------------------------*/
   2033          

   \                                 In section .text, align 2, keep-with-next
   2034          static
   2035          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   2036          	DIR* dp,			/* Directory object to return last directory and found object */
   2037          	const TCHAR* path	/* Full-path string to find a file or directory */
   2038          )
   2039          {
   \                     follow_path:
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2040          	FRESULT res;
   2041          	BYTE *dir, ns;
   2042          
   2043          
   2044          #if _FS_RPATH
   2045          	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
   \   00000004   0x9800             LDR      R0,[SP, #+0]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x282F             CMP      R0,#+47
   \   0000000A   0xD003             BEQ.N    ??follow_path_0
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x285C             CMP      R0,#+92
   \   00000012   0xD105             BNE.N    ??follow_path_1
   2046          		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
   \                     ??follow_path_0:
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x60A0             STR      R0,[R4, #+8]
   \   0000001E   0xE002             B.N      ??follow_path_2
   2047          	} else {								/* No heading separator */
   2048          		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
   \                     ??follow_path_1:
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6940             LDR      R0,[R0, #+20]
   \   00000024   0x60A0             STR      R0,[R4, #+8]
   2049          	}
   2050          #else
   2051          	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
   2052          		path++;
   2053          	dp->sclust = 0;							/* Always start from the root directory */
   2054          #endif
   2055          
   2056          	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
   \                     ??follow_path_2:
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2820             CMP      R0,#+32
   \   0000002C   0xD207             BCS.N    ??follow_path_3
   2057          		res = dir_sdi(dp, 0);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       dir_sdi
   \   00000036   0x0005             MOVS     R5,R0
   2058          		dp->dir = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6160             STR      R0,[R4, #+20]
   \   0000003C   0xE034             B.N      ??follow_path_4
   2059          	} else {								/* Follow path */
   2060          		for (;;) {
   2061          			res = create_name(dp, &path);	/* Get a segment name of the path */
   \                     ??follow_path_3:
   \   0000003E   0xA900             ADD      R1,SP,#+0
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       create_name
   \   00000046   0x0005             MOVS     R5,R0
   2062          			if (res != FR_OK) break;
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD12C             BNE.N    ??follow_path_4
   2063          			res = dir_find(dp);				/* Find an object with the sagment name */
   \                     ??follow_path_5:
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       dir_find
   \   00000054   0x0005             MOVS     R5,R0
   2064          			ns = dp->fn[NSFLAG];
   \   00000056   0x69A0             LDR      R0,[R4, #+24]
   \   00000058   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000005A   0x0007             MOVS     R7,R0
   2065          			if (res != FR_OK) {				/* Failed to find the object */
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD012             BEQ.N    ??follow_path_6
   2066          				if (res == FR_NO_FILE) {	/* Object is not found */
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x2D04             CMP      R5,#+4
   \   00000066   0xD10E             BNE.N    ??follow_path_7
   2067          					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
   \   00000068   0x06B8             LSLS     R0,R7,#+26
   \   0000006A   0xD508             BPL.N    ??follow_path_8
   2068          						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x60A0             STR      R0,[R4, #+8]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x6160             STR      R0,[R4, #+20]
   2069          						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
   \   00000074   0x0778             LSLS     R0,R7,#+29
   \   00000076   0xD5E2             BPL.N    ??follow_path_3
   2070          						res = FR_OK;					/* Ended at the root directroy. Function completed. */
   \                     ??follow_path_9:
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x0005             MOVS     R5,R0
   \   0000007C   0xE003             B.N      ??follow_path_7
   2071          					} else {							/* Could not find the object */
   2072          						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
   \                     ??follow_path_8:
   \   0000007E   0x0778             LSLS     R0,R7,#+29
   \   00000080   0xD401             BMI.N    ??follow_path_7
   \   00000082   0x2005             MOVS     R0,#+5
   \   00000084   0x0005             MOVS     R5,R0
   2073          					}
   2074          				}
   2075          				break;
   \                     ??follow_path_7:
   \   00000086   0xE00F             B.N      ??follow_path_4
   2076          			}
   2077          			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
   \                     ??follow_path_6:
   \   00000088   0x0778             LSLS     R0,R7,#+29
   \   0000008A   0xD40D             BMI.N    ??follow_path_4
   2078          			dir = dp->dir;						/* Follow the sub-directory */
   \                     ??follow_path_10:
   \   0000008C   0x6960             LDR      R0,[R4, #+20]
   \   0000008E   0x0006             MOVS     R6,R0
   2079          			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
   \   00000090   0x7AF0             LDRB     R0,[R6, #+11]
   \   00000092   0x06C0             LSLS     R0,R0,#+27
   \   00000094   0xD402             BMI.N    ??follow_path_11
   2080          				res = FR_NO_PATH; break;
   \   00000096   0x2005             MOVS     R0,#+5
   \   00000098   0x0005             MOVS     R5,R0
   \   0000009A   0xE005             B.N      ??follow_path_4
   2081          			}
   2082          			dp->sclust = ld_clust(dp->fs, dir);
   \                     ??follow_path_11:
   \   0000009C   0x0031             MOVS     R1,R6
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x.... 0x....      BL       ld_clust
   \   000000A4   0x60A0             STR      R0,[R4, #+8]
   \   000000A6   0xE7CA             B.N      ??follow_path_3
   2083          		}
   2084          	}
   2085          
   2086          	return res;
   \                     ??follow_path_4:
   \   000000A8   0x0028             MOVS     R0,R5
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2087          }
   2088          
   2089          
   2090          
   2091          
   2092          /*-----------------------------------------------------------------------*/
   2093          /* Get logical drive number from path name                               */
   2094          /*-----------------------------------------------------------------------*/
   2095          

   \                                 In section .text, align 2, keep-with-next
   2096          static
   2097          int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
   2098          	const TCHAR** path	/* Pointer to pointer to the path name */
   2099          )
   2100          {
   \                     get_ldnumber:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0001             MOVS     R1,R0
   2101          	const TCHAR *tp, *tt;
   2102          	UINT i;
   2103          	int vol = -1;
   \   00000004   0xF05F 0x30FF      MOVS     R0,#-1
   2104          
   2105          
   2106          	if (*path) {	/* If the pointer is not a null */
   \   00000008   0x680D             LDR      R5,[R1, #+0]
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD01E             BEQ.N    ??get_ldnumber_0
   2107          		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
   \   0000000E   0x680D             LDR      R5,[R1, #+0]
   \   00000010   0x002B             MOVS     R3,R5
   \                     ??get_ldnumber_1:
   \   00000012   0x781D             LDRB     R5,[R3, #+0]
   \   00000014   0x2D20             CMP      R5,#+32
   \   00000016   0xD304             BCC.N    ??get_ldnumber_2
   \   00000018   0x781D             LDRB     R5,[R3, #+0]
   \   0000001A   0x2D3A             CMP      R5,#+58
   \   0000001C   0xD001             BEQ.N    ??get_ldnumber_2
   \   0000001E   0x1C5B             ADDS     R3,R3,#+1
   \   00000020   0xE7F7             B.N      ??get_ldnumber_1
   2108          		if (*tt == ':') {	/* If a ':' is exist in the path name */
   \                     ??get_ldnumber_2:
   \   00000022   0x781D             LDRB     R5,[R3, #+0]
   \   00000024   0x2D3A             CMP      R5,#+58
   \   00000026   0xD10F             BNE.N    ??get_ldnumber_3
   2109          			tp = *path;
   \   00000028   0x680D             LDR      R5,[R1, #+0]
   \   0000002A   0x002A             MOVS     R2,R5
   2110          			i = *tp++ - '0';
   \   0000002C   0x7815             LDRB     R5,[R2, #+0]
   \   0000002E   0x3D30             SUBS     R5,R5,#+48
   \   00000030   0x002C             MOVS     R4,R5
   \   00000032   0x1C52             ADDS     R2,R2,#+1
   2111          			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
   \   00000034   0x2C0A             CMP      R4,#+10
   \   00000036   0xD206             BCS.N    ??get_ldnumber_4
   \   00000038   0x429A             CMP      R2,R3
   \   0000003A   0xD104             BNE.N    ??get_ldnumber_4
   2112          				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD102             BNE.N    ??get_ldnumber_4
   2113          					vol = (int)i;
   \   00000040   0x0020             MOVS     R0,R4
   2114          					*path = ++tt;
   \   00000042   0x1C5B             ADDS     R3,R3,#+1
   \   00000044   0x600B             STR      R3,[R1, #+0]
   2115          				}
   2116          			} else {	/* No numeric drive number */
   2117          #if _STR_VOLUME_ID		/* Find string drive id */
   2118          				static const char* const str[] = {_VOLUME_STRS};
   2119          				const char *sp;
   2120          				char c;
   2121          				TCHAR tc;
   2122          
   2123          				i = 0; tt++;
   2124          				do {
   2125          					sp = str[i]; tp = *path;
   2126          					do {	/* Compare a string drive id with path name */
   2127          						c = *sp++; tc = *tp++;
   2128          						if (IsLower(tc)) tc -= 0x20;
   2129          					} while (c && (TCHAR)c == tc);
   2130          				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
   2131          				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   2132          					vol = (int)i;
   2133          					*path = tt;
   2134          				}
   2135          #endif
   2136          			}
   2137          			return vol;
   \                     ??get_ldnumber_4:
   \   00000046   0xE001             B.N      ??get_ldnumber_5
   2138          		}
   2139          #if _FS_RPATH && _VOLUMES >= 2
   2140          		vol = CurrVol;	/* Current drive */
   2141          #else
   2142          		vol = 0;		/* Drive 0 */
   \                     ??get_ldnumber_3:
   \   00000048   0x2500             MOVS     R5,#+0
   \   0000004A   0x0028             MOVS     R0,R5
   2143          #endif
   2144          	}
   2145          	return vol;
   \                     ??get_ldnumber_0:
   \                     ??get_ldnumber_5:
   \   0000004C   0xBC30             POP      {R4,R5}
   \   0000004E   0x4770             BX       LR               ;; return
   2146          }
   2147          
   2148          
   2149          
   2150          
   2151          /*-----------------------------------------------------------------------*/
   2152          /* Load a sector and check if it is an FAT boot sector                   */
   2153          /*-----------------------------------------------------------------------*/
   2154          

   \                                 In section .text, align 2, keep-with-next
   2155          static
   2156          BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
   2157          	FATFS* fs,	/* File system object */
   2158          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   2159          )
   2160          {
   \                     check_fs:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2161          	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7120             STRB     R0,[R4, #+4]
   \   0000000A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000E   0x6320             STR      R0,[R4, #+48]
   2162          	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       move_window
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??check_fs_0
   2163          		return 3;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xE02D             B.N      ??check_fs_1
   2164          
   2165          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0:
   \   00000020   0xF894 0x0233      LDRB     R0,[R4, #+563]
   \   00000024   0xF894 0x1232      LDRB     R1,[R4, #+562]
   \   00000028   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0xF64A 0x2155      MOVW     R1,#+43605
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD001             BEQ.N    ??check_fs_2
   2166          		return 2;
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0xE020             B.N      ??check_fs_1
   2167          
   2168          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
   \                     ??check_fs_2:
   \   0000003A   0xF894 0x006C      LDRB     R0,[R4, #+108]
   \   0000003E   0xF894 0x106B      LDRB     R1,[R4, #+107]
   \   00000042   0x0209             LSLS     R1,R1,#+8
   \   00000044   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000048   0xF894 0x106A      LDRB     R1,[R4, #+106]
   \   0000004C   0x4308             ORRS     R0,R1,R0
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x544146
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD101             BNE.N    ??check_fs_3
   2169          		return 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE010             B.N      ??check_fs_1
   2170          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \                     ??check_fs_3:
   \   0000005A   0xF894 0x0088      LDRB     R0,[R4, #+136]
   \   0000005E   0xF894 0x1087      LDRB     R1,[R4, #+135]
   \   00000062   0x0209             LSLS     R1,R1,#+8
   \   00000064   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000068   0xF894 0x1086      LDRB     R1,[R4, #+134]
   \   0000006C   0x4308             ORRS     R0,R1,R0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x544146
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xD101             BNE.N    ??check_fs_4
   2171          		return 0;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE000             B.N      ??check_fs_1
   2172          
   2173          	return 1;
   \                     ??check_fs_4:
   \   0000007A   0x2001             MOVS     R0,#+1
   \                     ??check_fs_1:
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2174          }
   2175          
   2176          
   2177          
   2178          
   2179          /*-----------------------------------------------------------------------*/
   2180          /* Find logical drive and check if the volume is mounted                 */
   2181          /*-----------------------------------------------------------------------*/
   2182          

   \                                 In section .text, align 2, keep-with-next
   2183          static
   2184          FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
   2185          	FATFS** rfs,		/* Pointer to pointer to the found file system object */
   2186          	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
   2187          	BYTE wmode			/* !=0: Check write protection for write access */
   2188          )
   2189          {
   \                     find_volume:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   2190          	BYTE fmt;
   2191          	int vol;
   2192          	DSTATUS stat;
   2193          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
   2194          	WORD nrsv;
   2195          	FATFS *fs;
   2196          
   2197          
   2198          	/* Get logical drive number from the path name */
   2199          	*rfs = 0;
   \   00000006   0x9808             LDR      R0,[SP, #+32]
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   2200          	vol = get_ldnumber(path);
   \   0000000C   0x9809             LDR      R0,[SP, #+36]
   \   0000000E   0x.... 0x....      BL       get_ldnumber
   \   00000012   0x9003             STR      R0,[SP, #+12]
   2201          	if (vol < 0) return FR_INVALID_DRIVE;
   \   00000014   0x9803             LDR      R0,[SP, #+12]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD501             BPL.N    ??find_volume_0
   \   0000001A   0x200B             MOVS     R0,#+11
   \   0000001C   0xE20F             B.N      ??find_volume_1
   2202          
   2203          	/* Check if the file system object is valid or not */
   2204          	fs = FatFs[vol];					/* Get pointer to the file system object */
   \                     ??find_volume_0:
   \   0000001E   0x9803             LDR      R0,[SP, #+12]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \   00000024   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000028   0x4681             MOV      R9,R0
   2205          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   \   0000002A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002E   0xD101             BNE.N    ??find_volume_2
   \   00000030   0x200C             MOVS     R0,#+12
   \   00000032   0xE204             B.N      ??find_volume_1
   2206          
   2207          	ENTER_FF(fs);						/* Lock the volume */
   2208          	*rfs = fs;							/* Return pointer to the file system object */
   \                     ??find_volume_2:
   \   00000034   0x9808             LDR      R0,[SP, #+32]
   \   00000036   0xF8C0 0x9000      STR      R9,[R0, #+0]
   2209          
   2210          	if (fs->fs_type) {					/* If the volume has been mounted */
   \   0000003A   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD010             BEQ.N    ??find_volume_3
   2211          		stat = disk_status(fs->drv);
   \   00000042   0xF899 0x0001      LDRB     R0,[R9, #+1]
   \   00000046   0x.... 0x....      BL       disk_status
   \   0000004A   0x0004             MOVS     R4,R0
   2212          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
   \   0000004C   0x07E0             LSLS     R0,R4,#+31
   \   0000004E   0xD409             BMI.N    ??find_volume_3
   2213          			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   00000050   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD003             BEQ.N    ??find_volume_4
   \   00000058   0x0760             LSLS     R0,R4,#+29
   \   0000005A   0xD501             BPL.N    ??find_volume_4
   2214          				return FR_WRITE_PROTECTED;
   \   0000005C   0x200A             MOVS     R0,#+10
   \   0000005E   0xE1EE             B.N      ??find_volume_1
   2215          			return FR_OK;				/* The file system object is valid */
   \                     ??find_volume_4:
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE1EC             B.N      ??find_volume_1
   2216          		}
   2217          	}
   2218          
   2219          	/* The file system object is not valid. */
   2220          	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2221          
   2222          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??find_volume_3:
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF889 0x0000      STRB     R0,[R9, #+0]
   2223          	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   \   0000006A   0x9803             LDR      R0,[SP, #+12]
   \   0000006C   0xF889 0x0001      STRB     R0,[R9, #+1]
   2224          	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   \   00000070   0xF899 0x0001      LDRB     R0,[R9, #+1]
   \   00000074   0x.... 0x....      BL       disk_initialize
   \   00000078   0x0004             MOVS     R4,R0
   2225          	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   \   0000007A   0x07E0             LSLS     R0,R4,#+31
   \   0000007C   0xD501             BPL.N    ??find_volume_5
   2226          		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0xE1DD             B.N      ??find_volume_1
   2227          	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??find_volume_5:
   \   00000082   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD003             BEQ.N    ??find_volume_6
   \   0000008A   0x0760             LSLS     R0,R4,#+29
   \   0000008C   0xD501             BPL.N    ??find_volume_6
   2228          		return FR_WRITE_PROTECTED;
   \   0000008E   0x200A             MOVS     R0,#+10
   \   00000090   0xE1D5             B.N      ??find_volume_1
   2229          #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
   2230          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
   2231          		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
   2232          #endif
   2233          	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
   2234          	bsect = 0;
   \                     ??find_volume_6:
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x0005             MOVS     R5,R0
   2235          	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
   \   00000096   0x0029             MOVS     R1,R5
   \   00000098   0x4648             MOV      R0,R9
   \   0000009A   0x.... 0x....      BL       check_fs
   \   0000009E   0x4682             MOV      R10,R0
   2236          	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
   \   000000A0   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000A4   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000A8   0xD13B             BNE.N    ??find_volume_7
   2237          		UINT i;
   2238          		DWORD br[4];
   2239          
   2240          		for (i = 0; i < 4; i++) {			/* Get partition offset */
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x4683             MOV      R11,R0
   \                     ??find_volume_8:
   \   000000AE   0xF1BB 0x0F04      CMP      R11,#+4
   \   000000B2   0xD218             BCS.N    ??find_volume_9
   2241          			BYTE *pt = fs->win+MBR_Table + i * SZ_PTE;
   \   000000B4   0xEB19 0x100B      ADDS     R0,R9,R11, LSL #+4
   \   000000B8   0xF200 0x10F2      ADDW     R0,R0,#+498
   2242          			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
   \   000000BC   0x7901             LDRB     R1,[R0, #+4]
   \   000000BE   0x2900             CMP      R1,#+0
   \   000000C0   0xD00A             BEQ.N    ??find_volume_10
   \   000000C2   0x7AC1             LDRB     R1,[R0, #+11]
   \   000000C4   0x7A82             LDRB     R2,[R0, #+10]
   \   000000C6   0x0412             LSLS     R2,R2,#+16
   \   000000C8   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   000000CC   0x7A42             LDRB     R2,[R0, #+9]
   \   000000CE   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000000D2   0x7A00             LDRB     R0,[R0, #+8]
   \   000000D4   0x4308             ORRS     R0,R0,R1
   \   000000D6   0xE000             B.N      ??find_volume_11
   \                     ??find_volume_10:
   \   000000D8   0x2000             MOVS     R0,#+0
   \                     ??find_volume_11:
   \   000000DA   0xA904             ADD      R1,SP,#+16
   \   000000DC   0xF841 0x002B      STR      R0,[R1, R11, LSL #+2]
   2243          		}
   \   000000E0   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000000E4   0xE7E3             B.N      ??find_volume_8
   2244          		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
   \                     ??find_volume_9:
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x4683             MOV      R11,R0
   2245          		if (i) i--;
   \   000000EA   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000EE   0xD001             BEQ.N    ??find_volume_12
   \   000000F0   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   2246          		do {								/* Find an FAT volume */
   2247          			bsect = br[i];
   \                     ??find_volume_12:
   \   000000F4   0xA804             ADD      R0,SP,#+16
   \   000000F6   0xF850 0x002B      LDR      R0,[R0, R11, LSL #+2]
   \   000000FA   0x0005             MOVS     R5,R0
   2248          			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
   \   000000FC   0x2D00             CMP      R5,#+0
   \   000000FE   0xD004             BEQ.N    ??find_volume_13
   \   00000100   0x0029             MOVS     R1,R5
   \   00000102   0x4648             MOV      R0,R9
   \   00000104   0x.... 0x....      BL       check_fs
   \   00000108   0xE000             B.N      ??find_volume_14
   \                     ??find_volume_13:
   \   0000010A   0x2002             MOVS     R0,#+2
   \                     ??find_volume_14:
   \   0000010C   0x4682             MOV      R10,R0
   2249          		} while (!LD2PT(vol) && fmt && ++i < 4);
   \   0000010E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000112   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000116   0xD004             BEQ.N    ??find_volume_7
   \   00000118   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   0000011C   0xF1BB 0x0F04      CMP      R11,#+4
   \   00000120   0xD3E8             BCC.N    ??find_volume_12
   2250          	}
   2251          	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
   \                     ??find_volume_7:
   \   00000122   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000126   0xF1BA 0x0F03      CMP      R10,#+3
   \   0000012A   0xD101             BNE.N    ??find_volume_15
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0xE186             B.N      ??find_volume_1
   2252          	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   \                     ??find_volume_15:
   \   00000130   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000134   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000138   0xD001             BEQ.N    ??find_volume_16
   \   0000013A   0x200D             MOVS     R0,#+13
   \   0000013C   0xE17F             B.N      ??find_volume_1
   2253          
   2254          	/* An FAT volume is found. Following code initializes the file system object */
   2255          
   2256          	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   \                     ??find_volume_16:
   \   0000013E   0xF899 0x0040      LDRB     R0,[R9, #+64]
   \   00000142   0xF899 0x103F      LDRB     R1,[R9, #+63]
   \   00000146   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000014A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000014C   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000150   0xD001             BEQ.N    ??find_volume_17
   2257          		return FR_NO_FILESYSTEM;
   \   00000152   0x200D             MOVS     R0,#+13
   \   00000154   0xE173             B.N      ??find_volume_1
   2258          
   2259          	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   \                     ??find_volume_17:
   \   00000156   0xF899 0x004B      LDRB     R0,[R9, #+75]
   \   0000015A   0xF899 0x104A      LDRB     R1,[R9, #+74]
   \   0000015E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000162   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000164   0x0006             MOVS     R6,R0
   2260          	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   \   00000166   0x2E00             CMP      R6,#+0
   \   00000168   0xD10E             BNE.N    ??find_volume_18
   \   0000016A   0xF899 0x005B      LDRB     R0,[R9, #+91]
   \   0000016E   0xF899 0x105A      LDRB     R1,[R9, #+90]
   \   00000172   0x0409             LSLS     R1,R1,#+16
   \   00000174   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000178   0xF899 0x1059      LDRB     R1,[R9, #+89]
   \   0000017C   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000180   0xF899 0x1058      LDRB     R1,[R9, #+88]
   \   00000184   0x4308             ORRS     R0,R1,R0
   \   00000186   0x0006             MOVS     R6,R0
   2261          	fs->fsize = fasize;
   \                     ??find_volume_18:
   \   00000188   0xF8C9 0x601C      STR      R6,[R9, #+28]
   2262          
   2263          	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
   \   0000018C   0xF899 0x0044      LDRB     R0,[R9, #+68]
   \   00000190   0xF889 0x0003      STRB     R0,[R9, #+3]
   2264          	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
   \   00000194   0xF899 0x0003      LDRB     R0,[R9, #+3]
   \   00000198   0x2801             CMP      R0,#+1
   \   0000019A   0xD005             BEQ.N    ??find_volume_19
   \   0000019C   0xF899 0x0003      LDRB     R0,[R9, #+3]
   \   000001A0   0x2802             CMP      R0,#+2
   \   000001A2   0xD001             BEQ.N    ??find_volume_19
   2265          		return FR_NO_FILESYSTEM;
   \   000001A4   0x200D             MOVS     R0,#+13
   \   000001A6   0xE14A             B.N      ??find_volume_1
   2266          	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
   \                     ??find_volume_19:
   \   000001A8   0xF899 0x0003      LDRB     R0,[R9, #+3]
   \   000001AC   0x4346             MULS     R6,R0,R6
   2267          
   2268          	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
   \   000001AE   0xF899 0x0041      LDRB     R0,[R9, #+65]
   \   000001B2   0xF889 0x0002      STRB     R0,[R9, #+2]
   2269          	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
   \   000001B6   0xF899 0x0002      LDRB     R0,[R9, #+2]
   \   000001BA   0x2800             CMP      R0,#+0
   \   000001BC   0xD006             BEQ.N    ??find_volume_20
   \   000001BE   0xF899 0x0002      LDRB     R0,[R9, #+2]
   \   000001C2   0xF899 0x1002      LDRB     R1,[R9, #+2]
   \   000001C6   0x1E49             SUBS     R1,R1,#+1
   \   000001C8   0x4208             TST      R0,R1
   \   000001CA   0xD001             BEQ.N    ??find_volume_21
   2270          		return FR_NO_FILESYSTEM;
   \                     ??find_volume_20:
   \   000001CC   0x200D             MOVS     R0,#+13
   \   000001CE   0xE136             B.N      ??find_volume_1
   2271          
   2272          	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   \                     ??find_volume_21:
   \   000001D0   0xF899 0x0046      LDRB     R0,[R9, #+70]
   \   000001D4   0xF899 0x1045      LDRB     R1,[R9, #+69]
   \   000001D8   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000001DC   0xF8A9 0x0008      STRH     R0,[R9, #+8]
   2273          	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
   \   000001E0   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \   000001E4   0x2110             MOVS     R1,#+16
   \   000001E6   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000001EA   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000001EE   0x2A00             CMP      R2,#+0
   \   000001F0   0xD001             BEQ.N    ??find_volume_22
   2274          		return FR_NO_FILESYSTEM;
   \   000001F2   0x200D             MOVS     R0,#+13
   \   000001F4   0xE123             B.N      ??find_volume_1
   2275          
   2276          	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   \                     ??find_volume_22:
   \   000001F6   0xF899 0x0048      LDRB     R0,[R9, #+72]
   \   000001FA   0xF899 0x1047      LDRB     R1,[R9, #+71]
   \   000001FE   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000202   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000204   0x9000             STR      R0,[SP, #+0]
   2277          	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   \   00000206   0x9800             LDR      R0,[SP, #+0]
   \   00000208   0x2800             CMP      R0,#+0
   \   0000020A   0xD10E             BNE.N    ??find_volume_23
   \   0000020C   0xF899 0x0057      LDRB     R0,[R9, #+87]
   \   00000210   0xF899 0x1056      LDRB     R1,[R9, #+86]
   \   00000214   0x0409             LSLS     R1,R1,#+16
   \   00000216   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000021A   0xF899 0x1055      LDRB     R1,[R9, #+85]
   \   0000021E   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000222   0xF899 0x1054      LDRB     R1,[R9, #+84]
   \   00000226   0x4308             ORRS     R0,R1,R0
   \   00000228   0x9000             STR      R0,[SP, #+0]
   2278          
   2279          	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   \                     ??find_volume_23:
   \   0000022A   0xF899 0x0043      LDRB     R0,[R9, #+67]
   \   0000022E   0xF899 0x1042      LDRB     R1,[R9, #+66]
   \   00000232   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000236   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   2280          	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
   \   0000023A   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   0000023E   0x2800             CMP      R0,#+0
   \   00000240   0xD101             BNE.N    ??find_volume_24
   \   00000242   0x200D             MOVS     R0,#+13
   \   00000244   0xE0FB             B.N      ??find_volume_1
   2281          
   2282          	/* Determine the FAT sub type */
   2283          	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
   \                     ??find_volume_24:
   \   00000246   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   0000024A   0x1830             ADDS     R0,R6,R0
   \   0000024C   0xF8B9 0x1008      LDRH     R1,[R9, #+8]
   \   00000250   0xEB10 0x1011      ADDS     R0,R0,R1, LSR #+4
   \   00000254   0x9002             STR      R0,[SP, #+8]
   2284          	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   \   00000256   0x9800             LDR      R0,[SP, #+0]
   \   00000258   0x9902             LDR      R1,[SP, #+8]
   \   0000025A   0x4288             CMP      R0,R1
   \   0000025C   0xD201             BCS.N    ??find_volume_25
   \   0000025E   0x200D             MOVS     R0,#+13
   \   00000260   0xE0ED             B.N      ??find_volume_1
   2285          	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   \                     ??find_volume_25:
   \   00000262   0x9800             LDR      R0,[SP, #+0]
   \   00000264   0x9902             LDR      R1,[SP, #+8]
   \   00000266   0x1A40             SUBS     R0,R0,R1
   \   00000268   0xF899 0x1002      LDRB     R1,[R9, #+2]
   \   0000026C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000270   0x0007             MOVS     R7,R0
   2286          	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   \   00000272   0x2F00             CMP      R7,#+0
   \   00000274   0xD101             BNE.N    ??find_volume_26
   \   00000276   0x200D             MOVS     R0,#+13
   \   00000278   0xE0E1             B.N      ??find_volume_1
   2287          	fmt = FS_FAT12;
   \                     ??find_volume_26:
   \   0000027A   0x2001             MOVS     R0,#+1
   \   0000027C   0x4682             MOV      R10,R0
   2288          	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   0000027E   0xF640 0x70F6      MOVW     R0,#+4086
   \   00000282   0x4287             CMP      R7,R0
   \   00000284   0xD301             BCC.N    ??find_volume_27
   \   00000286   0x2002             MOVS     R0,#+2
   \   00000288   0x4682             MOV      R10,R0
   2289          	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??find_volume_27:
   \   0000028A   0xF64F 0x70F6      MOVW     R0,#+65526
   \   0000028E   0x4287             CMP      R7,R0
   \   00000290   0xD301             BCC.N    ??find_volume_28
   \   00000292   0x2003             MOVS     R0,#+3
   \   00000294   0x4682             MOV      R10,R0
   2290          
   2291          	/* Boundaries and Limits */
   2292          	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   \                     ??find_volume_28:
   \   00000296   0x1CB8             ADDS     R0,R7,#+2
   \   00000298   0xF8C9 0x0018      STR      R0,[R9, #+24]
   2293          	fs->volbase = bsect;								/* Volume start sector */
   \   0000029C   0xF8C9 0x5020      STR      R5,[R9, #+32]
   2294          	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   \   000002A0   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   000002A4   0x1940             ADDS     R0,R0,R5
   \   000002A6   0xF8C9 0x0024      STR      R0,[R9, #+36]
   2295          	fs->database = bsect + sysect;						/* Data start sector */
   \   000002AA   0x9802             LDR      R0,[SP, #+8]
   \   000002AC   0x1940             ADDS     R0,R0,R5
   \   000002AE   0xF8C9 0x002C      STR      R0,[R9, #+44]
   2296          	if (fmt == FS_FAT32) {
   \   000002B2   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000002B6   0xF1BA 0x0F03      CMP      R10,#+3
   \   000002BA   0xD11A             BNE.N    ??find_volume_29
   2297          		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   \   000002BC   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \   000002C0   0x2800             CMP      R0,#+0
   \   000002C2   0xD001             BEQ.N    ??find_volume_30
   \   000002C4   0x200D             MOVS     R0,#+13
   \   000002C6   0xE0BA             B.N      ??find_volume_1
   2298          		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   \                     ??find_volume_30:
   \   000002C8   0xF899 0x0063      LDRB     R0,[R9, #+99]
   \   000002CC   0xF899 0x1062      LDRB     R1,[R9, #+98]
   \   000002D0   0x0409             LSLS     R1,R1,#+16
   \   000002D2   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000002D6   0xF899 0x1061      LDRB     R1,[R9, #+97]
   \   000002DA   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000002DE   0xF899 0x1060      LDRB     R1,[R9, #+96]
   \   000002E2   0x4308             ORRS     R0,R1,R0
   \   000002E4   0xF8C9 0x0028      STR      R0,[R9, #+40]
   2299          		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
   \   000002E8   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \   000002EC   0x0080             LSLS     R0,R0,#+2
   \   000002EE   0x4680             MOV      R8,R0
   \   000002F0   0xE01E             B.N      ??find_volume_31
   2300          	} else {
   2301          		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   \                     ??find_volume_29:
   \   000002F2   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \   000002F6   0x2800             CMP      R0,#+0
   \   000002F8   0xD101             BNE.N    ??find_volume_32
   \   000002FA   0x200D             MOVS     R0,#+13
   \   000002FC   0xE09F             B.N      ??find_volume_1
   2302          		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   \                     ??find_volume_32:
   \   000002FE   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   00000302   0x1830             ADDS     R0,R6,R0
   \   00000304   0xF8C9 0x0028      STR      R0,[R9, #+40]
   2303          		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
   2304          			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   00000308   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000030C   0xF1BA 0x0F02      CMP      R10,#+2
   \   00000310   0xD104             BNE.N    ??find_volume_33
   \   00000312   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \   00000316   0xEA5F 0x0840      LSLS     R8,R0,#+1
   \   0000031A   0xE009             B.N      ??find_volume_31
   \                     ??find_volume_33:
   \   0000031C   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \   00000320   0x2103             MOVS     R1,#+3
   \   00000322   0x4348             MULS     R0,R1,R0
   \   00000324   0xF899 0x1018      LDRB     R1,[R9, #+24]
   \   00000328   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   0000032C   0xEB11 0x0850      ADDS     R8,R1,R0, LSR #+1
   2305          	}
   2306          	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
   \                     ??find_volume_31:
   \   00000330   0xF8D9 0x001C      LDR      R0,[R9, #+28]
   \   00000334   0xF208 0x11FF      ADDW     R1,R8,#+511
   \   00000338   0xEBB0 0x2F51      CMP      R0,R1, LSR #+9
   \   0000033C   0xD201             BCS.N    ??find_volume_34
   2307          		return FR_NO_FILESYSTEM;
   \   0000033E   0x200D             MOVS     R0,#+13
   \   00000340   0xE07D             B.N      ??find_volume_1
   2308          
   2309          #if !_FS_READONLY
   2310          	/* Initialize cluster allocation information */
   2311          	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
   \                     ??find_volume_34:
   \   00000342   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000346   0xF8C9 0x0010      STR      R0,[R9, #+16]
   \   0000034A   0xF8C9 0x000C      STR      R0,[R9, #+12]
   2312          
   2313          	/* Get fsinfo if available */
   2314          	fs->fsi_flag = 0x80;
   \   0000034E   0x2080             MOVS     R0,#+128
   \   00000350   0xF889 0x0005      STRB     R0,[R9, #+5]
   2315          #if (_FS_NOFSINFO & 3) != 3
   2316          	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
   2317          		&& LD_WORD(fs->win+BPB_FSInfo) == 1
   2318          		&& move_window(fs, bsect + 1) == FR_OK)
   \   00000354   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000358   0xF1BA 0x0F03      CMP      R10,#+3
   \   0000035C   0xD160             BNE.N    ??find_volume_35
   \   0000035E   0xF899 0x0065      LDRB     R0,[R9, #+101]
   \   00000362   0xF899 0x1064      LDRB     R1,[R9, #+100]
   \   00000366   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000036A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000036C   0x2801             CMP      R0,#+1
   \   0000036E   0xD157             BNE.N    ??find_volume_35
   \   00000370   0x1C69             ADDS     R1,R5,#+1
   \   00000372   0x4648             MOV      R0,R9
   \   00000374   0x.... 0x....      BL       move_window
   \   00000378   0x2800             CMP      R0,#+0
   \   0000037A   0xD151             BNE.N    ??find_volume_35
   2319          	{
   2320          		fs->fsi_flag = 0;
   \   0000037C   0x2000             MOVS     R0,#+0
   \   0000037E   0xF889 0x0005      STRB     R0,[R9, #+5]
   2321          		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
   2322          			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
   2323          			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
   \   00000382   0xF899 0x0233      LDRB     R0,[R9, #+563]
   \   00000386   0xF899 0x1232      LDRB     R1,[R9, #+562]
   \   0000038A   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000038E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000390   0xF64A 0x2155      MOVW     R1,#+43605
   \   00000394   0x4288             CMP      R0,R1
   \   00000396   0xD143             BNE.N    ??find_volume_35
   \   00000398   0xF899 0x0037      LDRB     R0,[R9, #+55]
   \   0000039C   0xF899 0x1036      LDRB     R1,[R9, #+54]
   \   000003A0   0x0409             LSLS     R1,R1,#+16
   \   000003A2   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000003A6   0xF899 0x1035      LDRB     R1,[R9, #+53]
   \   000003AA   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000003AE   0xF899 0x1034      LDRB     R1,[R9, #+52]
   \   000003B2   0x4308             ORRS     R0,R1,R0
   \   000003B4   0x.... 0x....      LDR.W    R1,??DataTable11  ;; 0x41615252
   \   000003B8   0x4288             CMP      R0,R1
   \   000003BA   0xD131             BNE.N    ??find_volume_35
   \   000003BC   0xF899 0x021B      LDRB     R0,[R9, #+539]
   \   000003C0   0xF899 0x121A      LDRB     R1,[R9, #+538]
   \   000003C4   0x0409             LSLS     R1,R1,#+16
   \   000003C6   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000003CA   0xF899 0x1219      LDRB     R1,[R9, #+537]
   \   000003CE   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000003D2   0xF899 0x1218      LDRB     R1,[R9, #+536]
   \   000003D6   0x4308             ORRS     R0,R1,R0
   \   000003D8   0x.... 0x....      LDR.W    R1,??DataTable11_1  ;; 0x61417272
   \   000003DC   0x4288             CMP      R0,R1
   \   000003DE   0xD11F             BNE.N    ??find_volume_35
   2324          		{
   2325          #if (_FS_NOFSINFO & 1) == 0
   2326          			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   \   000003E0   0xF899 0x021F      LDRB     R0,[R9, #+543]
   \   000003E4   0xF899 0x121E      LDRB     R1,[R9, #+542]
   \   000003E8   0x0409             LSLS     R1,R1,#+16
   \   000003EA   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000003EE   0xF899 0x121D      LDRB     R1,[R9, #+541]
   \   000003F2   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000003F6   0xF899 0x121C      LDRB     R1,[R9, #+540]
   \   000003FA   0x4308             ORRS     R0,R1,R0
   \   000003FC   0xF8C9 0x0010      STR      R0,[R9, #+16]
   2327          #endif
   2328          #if (_FS_NOFSINFO & 2) == 0
   2329          			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   \   00000400   0xF899 0x0223      LDRB     R0,[R9, #+547]
   \   00000404   0xF899 0x1222      LDRB     R1,[R9, #+546]
   \   00000408   0x0409             LSLS     R1,R1,#+16
   \   0000040A   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000040E   0xF899 0x1221      LDRB     R1,[R9, #+545]
   \   00000412   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000416   0xF899 0x1220      LDRB     R1,[R9, #+544]
   \   0000041A   0x4308             ORRS     R0,R1,R0
   \   0000041C   0xF8C9 0x000C      STR      R0,[R9, #+12]
   2330          #endif
   2331          		}
   2332          	}
   2333          #endif
   2334          #endif
   2335          	fs->fs_type = fmt;	/* FAT sub-type */
   \                     ??find_volume_35:
   \   00000420   0xF889 0xA000      STRB     R10,[R9, #+0]
   2336          	fs->id = ++Fsid;	/* File system mount ID */
   \   00000424   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000428   0x8800             LDRH     R0,[R0, #+0]
   \   0000042A   0x1C40             ADDS     R0,R0,#+1
   \   0000042C   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000430   0x8008             STRH     R0,[R1, #+0]
   \   00000432   0xF8A9 0x0006      STRH     R0,[R9, #+6]
   2337          #if _FS_RPATH
   2338          	fs->cdir = 0;		/* Set current directory to root */
   \   00000436   0x2000             MOVS     R0,#+0
   \   00000438   0xF8C9 0x0014      STR      R0,[R9, #+20]
   2339          #endif
   2340          #if _FS_LOCK			/* Clear file lock semaphores */
   2341          	clear_lock(fs);
   2342          #endif
   2343          
   2344          	return FR_OK;
   \   0000043C   0x2000             MOVS     R0,#+0
   \                     ??find_volume_1:
   \   0000043E   0xB00B             ADD      SP,SP,#+44
   \   00000440   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2345          }
   2346          
   2347          
   2348          
   2349          
   2350          /*-----------------------------------------------------------------------*/
   2351          /* Check if the file/directory object is valid or not                    */
   2352          /*-----------------------------------------------------------------------*/
   2353          

   \                                 In section .text, align 2, keep-with-next
   2354          static
   2355          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   2356          	void* obj		/* Pointer to the object FIL/DIR to check validity */
   2357          )
   2358          {
   \                     validate:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2359          	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
   \   00000004   0x0025             MOVS     R5,R4
   2360          
   2361          
   2362          	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD00B             BEQ.N    ??validate_0
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD008             BEQ.N    ??validate_0
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??validate_0
   \   00000018   0x6828             LDR      R0,[R5, #+0]
   \   0000001A   0x88C0             LDRH     R0,[R0, #+6]
   \   0000001C   0x88A9             LDRH     R1,[R5, #+4]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD001             BEQ.N    ??validate_1
   2363          		return FR_INVALID_OBJECT;
   \                     ??validate_0:
   \   00000022   0x2009             MOVS     R0,#+9
   \   00000024   0xE008             B.N      ??validate_2
   2364          
   2365          	ENTER_FF(fil->fs);		/* Lock file system */
   2366          
   2367          	if (disk_status(fil->fs->drv) & STA_NOINIT)
   \                     ??validate_1:
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x7840             LDRB     R0,[R0, #+1]
   \   0000002A   0x.... 0x....      BL       disk_status
   \   0000002E   0x07C0             LSLS     R0,R0,#+31
   \   00000030   0xD501             BPL.N    ??validate_3
   2368          		return FR_NOT_READY;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xE000             B.N      ??validate_2
   2369          
   2370          	return FR_OK;
   \                     ??validate_3:
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??validate_2:
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2371          }
   2372          
   2373          
   2374          
   2375          
   2376          /*--------------------------------------------------------------------------
   2377          
   2378             Public Functions
   2379          
   2380          --------------------------------------------------------------------------*/
   2381          
   2382          
   2383          
   2384          /*-----------------------------------------------------------------------*/
   2385          /* Mount/Unmount a Logical Drive                                         */
   2386          /*-----------------------------------------------------------------------*/
   2387          

   \                                 In section .text, align 2, keep-with-next
   2388          FRESULT f_mount (
   2389          	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
   2390          	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
   2391          	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
   2392          )
   2393          {
   \                     f_mount:
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0014             MOVS     R4,R2
   2394          	FATFS *cfs;
   2395          	int vol;
   2396          	FRESULT res;
   2397          	const TCHAR *rp = path;
   \   00000006   0x9802             LDR      R0,[SP, #+8]
   \   00000008   0x9000             STR      R0,[SP, #+0]
   2398          
   2399          
   2400          	vol = get_ldnumber(&rp);
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x.... 0x....      BL       get_ldnumber
   \   00000010   0x0006             MOVS     R6,R0
   2401          	if (vol < 0) return FR_INVALID_DRIVE;
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD501             BPL.N    ??f_mount_0
   \   00000016   0x200B             MOVS     R0,#+11
   \   00000018   0xE023             B.N      ??f_mount_1
   2402          	cfs = FatFs[vol];					/* Pointer to fs object */
   \                     ??f_mount_0:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000001E   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000022   0x0005             MOVS     R5,R0
   2403          
   2404          	if (cfs) {
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD001             BEQ.N    ??f_mount_2
   2405          #if _FS_LOCK
   2406          		clear_lock(cfs);
   2407          #endif
   2408          #if _FS_REENTRANT						/* Discard sync object of the current volume */
   2409          		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
   2410          #endif
   2411          		cfs->fs_type = 0;				/* Clear old fs object */
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7028             STRB     R0,[R5, #+0]
   2412          	}
   2413          
   2414          	if (fs) {
   \                     ??f_mount_2:
   \   0000002C   0x9801             LDR      R0,[SP, #+4]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD002             BEQ.N    ??f_mount_3
   2415          		fs->fs_type = 0;				/* Clear new fs object */
   \   00000032   0x9801             LDR      R0,[SP, #+4]
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x7001             STRB     R1,[R0, #+0]
   2416          #if _FS_REENTRANT						/* Create sync object for the new volume */
   2417          		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
   2418          #endif
   2419          	}
   2420          	FatFs[vol] = fs;					/* Register new fs object */
   \                     ??f_mount_3:
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000003C   0x9901             LDR      R1,[SP, #+4]
   \   0000003E   0xF840 0x1026      STR      R1,[R0, R6, LSL #+2]
   2421          
   2422          	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
   \   00000042   0x9801             LDR      R0,[SP, #+4]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD002             BEQ.N    ??f_mount_4
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x2C01             CMP      R4,#+1
   \   0000004C   0xD001             BEQ.N    ??f_mount_5
   \                     ??f_mount_4:
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE007             B.N      ??f_mount_1
   2423          
   2424          	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
   \                     ??f_mount_5:
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0xA902             ADD      R1,SP,#+8
   \   00000056   0xA801             ADD      R0,SP,#+4
   \   00000058   0x.... 0x....      BL       find_volume
   \   0000005C   0x0007             MOVS     R7,R0
   2425          	LEAVE_FF(fs, res);
   \   0000005E   0x0038             MOVS     R0,R7
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_mount_1:
   \   00000062   0xBDFE             POP      {R1-R7,PC}       ;; return
   2426          }
   2427          
   2428          
   2429          
   2430          
   2431          /*-----------------------------------------------------------------------*/
   2432          /* Open or Create a File                                                 */
   2433          /*-----------------------------------------------------------------------*/
   2434          

   \                                 In section .text, align 2, keep-with-next
   2435          FRESULT f_open (
   2436          	FIL* fp,			/* Pointer to the blank file object */
   2437          	const TCHAR* path,	/* Pointer to the file name */
   2438          	BYTE mode			/* Access mode and file open mode flags */
   2439          )
   2440          {
   \                     f_open:
   \   00000000   0xE92D 0x43F2      PUSH     {R1,R4-R9,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x0015             MOVS     R5,R2
   2441          	FRESULT res;
   2442          	DIR dj;
   2443          	BYTE *dir;
   2444          	DEF_NAMEBUF;
   2445          
   2446          
   2447          	if (!fp) return FR_INVALID_OBJECT;
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??f_open_0
   \   0000000E   0x2009             MOVS     R0,#+9
   \   00000010   0xE0BC             B.N      ??f_open_1
   2448          	fp->fs = 0;			/* Clear file object */
   \                     ??f_open_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6020             STR      R0,[R4, #+0]
   2449          
   2450          	/* Get logical drive number */
   2451          #if !_FS_READONLY
   2452          	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   00000016   0xF015 0x051F      ANDS     R5,R5,#0x1F
   2453          	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
   \   0000001A   0xF015 0x02FE      ANDS     R2,R5,#0xFE
   \   0000001E   0xA90C             ADD      R1,SP,#+48
   \   00000020   0xA800             ADD      R0,SP,#+0
   \   00000022   0x.... 0x....      BL       find_volume
   \   00000026   0x0006             MOVS     R6,R0
   2454          #else
   2455          	mode &= FA_READ;
   2456          	res = find_volume(&dj.fs, &path, 0);
   2457          #endif
   2458          	if (res == FR_OK) {
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xF040 0x80AC      BNE.W    ??f_open_2
   2459          		INIT_BUF(dj);
   \   00000030   0xA809             ADD      R0,SP,#+36
   \   00000032   0x9006             STR      R0,[SP, #+24]
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000038   0x9007             STR      R0,[SP, #+28]
   2460          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000003A   0x990C             LDR      R1,[SP, #+48]
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       follow_path
   \   00000042   0x0006             MOVS     R6,R0
   2461          		dir = dj.dir;
   \   00000044   0x9805             LDR      R0,[SP, #+20]
   \   00000046   0x0007             MOVS     R7,R0
   2462          #if !_FS_READONLY	/* R/W configuration */
   2463          		if (res == FR_OK) {
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xD103             BNE.N    ??f_open_3
   2464          			if (!dir)	/* Default directory itself */
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD101             BNE.N    ??f_open_3
   2465          				res = FR_INVALID_NAME;
   \   00000052   0x2006             MOVS     R0,#+6
   \   00000054   0x0006             MOVS     R6,R0
   2466          #if _FS_LOCK
   2467          			else
   2468          				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2469          #endif
   2470          		}
   2471          		/* Create or Open a file */
   2472          		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \                     ??f_open_3:
   \   00000056   0x201C             MOVS     R0,#+28
   \   00000058   0x4205             TST      R5,R0
   \   0000005A   0xD05B             BEQ.N    ??f_open_4
   2473          			DWORD dw, cl;
   2474          
   2475          			if (res != FR_OK) {					/* No file, create new */
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x2E00             CMP      R6,#+0
   \   00000060   0xD00B             BEQ.N    ??f_open_5
   2476          				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   \   00000062   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000064   0x2E04             CMP      R6,#+4
   \   00000066   0xD103             BNE.N    ??f_open_6
   2477          #if _FS_LOCK
   2478          					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   2479          #else
   2480          					res = dir_register(&dj);
   \   00000068   0xA800             ADD      R0,SP,#+0
   \   0000006A   0x.... 0x....      BL       dir_register
   \   0000006E   0x0006             MOVS     R6,R0
   2481          #endif
   2482          				mode |= FA_CREATE_ALWAYS;		/* File is created */
   \                     ??f_open_6:
   \   00000070   0xF055 0x0508      ORRS     R5,R5,#0x8
   2483          				dir = dj.dir;					/* New entry */
   \   00000074   0x9805             LDR      R0,[SP, #+20]
   \   00000076   0x0007             MOVS     R7,R0
   \   00000078   0xE00A             B.N      ??f_open_7
   2484          			}
   2485          			else {								/* Any object is already existing */
   2486          				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   \                     ??f_open_5:
   \   0000007A   0x7AF8             LDRB     R0,[R7, #+11]
   \   0000007C   0x2111             MOVS     R1,#+17
   \   0000007E   0x4208             TST      R0,R1
   \   00000080   0xD002             BEQ.N    ??f_open_8
   2487          					res = FR_DENIED;
   \   00000082   0x2007             MOVS     R0,#+7
   \   00000084   0x0006             MOVS     R6,R0
   \   00000086   0xE003             B.N      ??f_open_7
   2488          				} else {
   2489          					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   \                     ??f_open_8:
   \   00000088   0x0768             LSLS     R0,R5,#+29
   \   0000008A   0xD501             BPL.N    ??f_open_7
   2490          						res = FR_EXIST;
   \   0000008C   0x2008             MOVS     R0,#+8
   \   0000008E   0x0006             MOVS     R6,R0
   2491          				}
   2492          			}
   2493          			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   \                     ??f_open_7:
   \   00000090   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000092   0x2E00             CMP      R6,#+0
   \   00000094   0xD14E             BNE.N    ??f_open_9
   \   00000096   0x0728             LSLS     R0,R5,#+28
   \   00000098   0xD54C             BPL.N    ??f_open_9
   2494          				dw = GET_FATTIME();				/* Created time */
   \   0000009A   0x.... 0x....      BL       get_fattime
   \   0000009E   0x4680             MOV      R8,R0
   2495          				ST_DWORD(dir+DIR_CrtTime, dw);
   \   000000A0   0xF887 0x800E      STRB     R8,[R7, #+14]
   \   000000A4   0x4640             MOV      R0,R8
   \   000000A6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A8   0x0A00             LSRS     R0,R0,#+8
   \   000000AA   0x73F8             STRB     R0,[R7, #+15]
   \   000000AC   0xEA5F 0x4018      LSRS     R0,R8,#+16
   \   000000B0   0x7438             STRB     R0,[R7, #+16]
   \   000000B2   0xEA5F 0x6018      LSRS     R0,R8,#+24
   \   000000B6   0x7478             STRB     R0,[R7, #+17]
   2496          				dir[DIR_Attr] = 0;				/* Reset attribute */
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x72F8             STRB     R0,[R7, #+11]
   2497          				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7738             STRB     R0,[R7, #+28]
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x7778             STRB     R0,[R7, #+29]
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x77B8             STRB     R0,[R7, #+30]
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x77F8             STRB     R0,[R7, #+31]
   2498          				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
   \   000000CC   0x0039             MOVS     R1,R7
   \   000000CE   0x9800             LDR      R0,[SP, #+0]
   \   000000D0   0x.... 0x....      BL       ld_clust
   \   000000D4   0x4681             MOV      R9,R0
   2499          				st_clust(dir, 0);				/* cluster = 0 */
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0x0038             MOVS     R0,R7
   \   000000DA   0x.... 0x....      BL       st_clust
   2500          				dj.fs->wflag = 1;
   \   000000DE   0x9800             LDR      R0,[SP, #+0]
   \   000000E0   0x2101             MOVS     R1,#+1
   \   000000E2   0x7101             STRB     R1,[R0, #+4]
   2501          				if (cl) {						/* Remove the cluster chain if exist */
   \   000000E4   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000E8   0xD024             BEQ.N    ??f_open_9
   2502          					dw = dj.fs->winsect;
   \   000000EA   0x9800             LDR      R0,[SP, #+0]
   \   000000EC   0x6B00             LDR      R0,[R0, #+48]
   \   000000EE   0x4680             MOV      R8,R0
   2503          					res = remove_chain(dj.fs, cl);
   \   000000F0   0x4649             MOV      R1,R9
   \   000000F2   0x9800             LDR      R0,[SP, #+0]
   \   000000F4   0x.... 0x....      BL       remove_chain
   \   000000F8   0x0006             MOVS     R6,R0
   2504          					if (res == FR_OK) {
   \   000000FA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000FC   0x2E00             CMP      R6,#+0
   \   000000FE   0xD119             BNE.N    ??f_open_9
   2505          						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   00000100   0x9800             LDR      R0,[SP, #+0]
   \   00000102   0xF1B9 0x0101      SUBS     R1,R9,#+1
   \   00000106   0x60C1             STR      R1,[R0, #+12]
   2506          						res = move_window(dj.fs, dw);
   \   00000108   0x4641             MOV      R1,R8
   \   0000010A   0x9800             LDR      R0,[SP, #+0]
   \   0000010C   0x.... 0x....      BL       move_window
   \   00000110   0x0006             MOVS     R6,R0
   \   00000112   0xE00F             B.N      ??f_open_9
   2507          					}
   2508          				}
   2509          			}
   2510          		}
   2511          		else {	/* Open an existing file */
   2512          			if (res == FR_OK) {					/* Follow succeeded */
   \                     ??f_open_4:
   \   00000114   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000116   0x2E00             CMP      R6,#+0
   \   00000118   0xD10C             BNE.N    ??f_open_9
   2513          				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
   \   0000011A   0x7AF8             LDRB     R0,[R7, #+11]
   \   0000011C   0x06C0             LSLS     R0,R0,#+27
   \   0000011E   0xD502             BPL.N    ??f_open_10
   2514          					res = FR_NO_FILE;
   \   00000120   0x2004             MOVS     R0,#+4
   \   00000122   0x0006             MOVS     R6,R0
   \   00000124   0xE006             B.N      ??f_open_9
   2515          				} else {
   2516          					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   \                     ??f_open_10:
   \   00000126   0x07A8             LSLS     R0,R5,#+30
   \   00000128   0xD504             BPL.N    ??f_open_9
   \   0000012A   0x7AF8             LDRB     R0,[R7, #+11]
   \   0000012C   0x07C0             LSLS     R0,R0,#+31
   \   0000012E   0xD501             BPL.N    ??f_open_9
   2517          						res = FR_DENIED;
   \   00000130   0x2007             MOVS     R0,#+7
   \   00000132   0x0006             MOVS     R6,R0
   2518          				}
   2519          			}
   2520          		}
   2521          		if (res == FR_OK) {
   \                     ??f_open_9:
   \   00000134   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000136   0x2E00             CMP      R6,#+0
   \   00000138   0xD107             BNE.N    ??f_open_11
   2522          			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
   \   0000013A   0x0728             LSLS     R0,R5,#+28
   \   0000013C   0xD501             BPL.N    ??f_open_12
   2523          				mode |= FA__WRITTEN;
   \   0000013E   0xF055 0x0520      ORRS     R5,R5,#0x20
   2524          			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
   \                     ??f_open_12:
   \   00000142   0x9800             LDR      R0,[SP, #+0]
   \   00000144   0x6B00             LDR      R0,[R0, #+48]
   \   00000146   0x61E0             STR      R0,[R4, #+28]
   2525          			fp->dir_ptr = dir;
   \   00000148   0x6227             STR      R7,[R4, #+32]
   2526          #if _FS_LOCK
   2527          			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2528          			if (!fp->lockid) res = FR_INT_ERR;
   2529          #endif
   2530          		}
   2531          
   2532          #else				/* R/O configuration */
   2533          		if (res == FR_OK) {					/* Follow succeeded */
   2534          			dir = dj.dir;
   2535          			if (!dir) {						/* Current directory itself */
   2536          				res = FR_INVALID_NAME;
   2537          			} else {
   2538          				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
   2539          					res = FR_NO_FILE;
   2540          			}
   2541          		}
   2542          #endif
   2543          		FREE_BUF();
   2544          
   2545          		if (res == FR_OK) {
   \                     ??f_open_11:
   \   0000014A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000014C   0x2E00             CMP      R6,#+0
   \   0000014E   0xD11B             BNE.N    ??f_open_2
   2546          			fp->flag = mode;					/* File access mode */
   \   00000150   0x71A5             STRB     R5,[R4, #+6]
   2547          			fp->err = 0;						/* Clear error flag */
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0x71E0             STRB     R0,[R4, #+7]
   2548          			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
   \   00000156   0x0039             MOVS     R1,R7
   \   00000158   0x9800             LDR      R0,[SP, #+0]
   \   0000015A   0x.... 0x....      BL       ld_clust
   \   0000015E   0x6120             STR      R0,[R4, #+16]
   2549          			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   \   00000160   0x7FF8             LDRB     R0,[R7, #+31]
   \   00000162   0x7FB9             LDRB     R1,[R7, #+30]
   \   00000164   0x0409             LSLS     R1,R1,#+16
   \   00000166   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000016A   0x7F79             LDRB     R1,[R7, #+29]
   \   0000016C   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000170   0x7F39             LDRB     R1,[R7, #+28]
   \   00000172   0x4308             ORRS     R0,R1,R0
   \   00000174   0x60E0             STR      R0,[R4, #+12]
   2550          			fp->fptr = 0;						/* File pointer */
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0x60A0             STR      R0,[R4, #+8]
   2551          			fp->dsect = 0;
   \   0000017A   0x2000             MOVS     R0,#+0
   \   0000017C   0x61A0             STR      R0,[R4, #+24]
   2552          #if _USE_FASTSEEK
   2553          			fp->cltbl = 0;						/* Normal seek mode */
   2554          #endif
   2555          			fp->fs = dj.fs;	 					/* Validate file object */
   \   0000017E   0x9800             LDR      R0,[SP, #+0]
   \   00000180   0x6020             STR      R0,[R4, #+0]
   2556          			fp->id = fp->fs->id;
   \   00000182   0x6820             LDR      R0,[R4, #+0]
   \   00000184   0x88C0             LDRH     R0,[R0, #+6]
   \   00000186   0x80A0             STRH     R0,[R4, #+4]
   2557          		}
   2558          	}
   2559          
   2560          	LEAVE_FF(dj.fs, res);
   \                     ??f_open_2:
   \   00000188   0x0030             MOVS     R0,R6
   \   0000018A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_open_1:
   \   0000018C   0xB00D             ADD      SP,SP,#+52
   \   0000018E   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2561          }
   2562          
   2563          
   2564          
   2565          
   2566          /*-----------------------------------------------------------------------*/
   2567          /* Read File                                                             */
   2568          /*-----------------------------------------------------------------------*/
   2569          

   \                                 In section .text, align 2, keep-with-next
   2570          FRESULT f_read (
   2571          	FIL* fp, 		/* Pointer to the file object */
   2572          	void* buff,		/* Pointer to data buffer */
   2573          	UINT btr,		/* Number of bytes to read */
   2574          	UINT* br		/* Pointer to number of bytes read */
   2575          )
   2576          {
   \                     f_read:
   \   00000000   0xE92D 0x4FFA      PUSH     {R1,R3-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x0015             MOVS     R5,R2
   2577          	FRESULT res;
   2578          	DWORD clst, sect, remain;
   2579          	UINT rcnt, cc;
   2580          	BYTE csect, *rbuff = (BYTE*)buff;
   \   0000000A   0xF8DD 0xB00C      LDR      R11,[SP, #+12]
   2581          
   2582          
   2583          	*br = 0;	/* Clear read byte counter */
   \   0000000E   0x9804             LDR      R0,[SP, #+16]
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6001             STR      R1,[R0, #+0]
   2584          
   2585          	res = validate(fp);							/* Check validity */
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       validate
   \   0000001A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2586          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   0000001E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD002             BEQ.N    ??f_read_0
   \   00000026   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000002A   0xE0E0             B.N      ??f_read_1
   2587          	if (fp->err)								/* Check error */
   \                     ??f_read_0:
   \   0000002C   0x79E0             LDRB     R0,[R4, #+7]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??f_read_2
   2588          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   \   00000032   0x79E0             LDRB     R0,[R4, #+7]
   \   00000034   0xE0DB             B.N      ??f_read_1
   2589          	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   \                     ??f_read_2:
   \   00000036   0x79A0             LDRB     R0,[R4, #+6]
   \   00000038   0x07C0             LSLS     R0,R0,#+31
   \   0000003A   0xD401             BMI.N    ??f_read_3
   2590          		LEAVE_FF(fp->fs, FR_DENIED);
   \   0000003C   0x2007             MOVS     R0,#+7
   \   0000003E   0xE0D6             B.N      ??f_read_1
   2591          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_3:
   \   00000040   0x68E0             LDR      R0,[R4, #+12]
   \   00000042   0x68A1             LDR      R1,[R4, #+8]
   \   00000044   0x1A40             SUBS     R0,R0,R1
   \   00000046   0x9000             STR      R0,[SP, #+0]
   2592          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x42A8             CMP      R0,R5
   \   0000004C   0xD201             BCS.N    ??f_read_4
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
   \   00000050   0x0005             MOVS     R5,R0
   2593          
   2594          	for ( ;  btr;								/* Repeat until all data read */
   \                     ??f_read_4:
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xF000 0x80CA      BEQ.W    ??f_read_5
   2595          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   2596          		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   \   00000058   0x68A0             LDR      R0,[R4, #+8]
   \   0000005A   0xF44F 0x7100      MOV      R1,#+512
   \   0000005E   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000062   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000066   0x2A00             CMP      R2,#+0
   \   00000068   0xF040 0x8096      BNE.W    ??f_read_6
   2597          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   \   0000006C   0x68A0             LDR      R0,[R4, #+8]
   \   0000006E   0x0A40             LSRS     R0,R0,#+9
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x7889             LDRB     R1,[R1, #+2]
   \   00000074   0x1E49             SUBS     R1,R1,#+1
   \   00000076   0x4008             ANDS     R0,R1,R0
   \   00000078   0x4682             MOV      R10,R0
   2598          			if (!csect) {						/* On the cluster boundary? */
   \   0000007A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000007E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000082   0xD118             BNE.N    ??f_read_7
   2599          				if (fp->fptr == 0) {			/* On the top of the file? */
   \   00000084   0x68A0             LDR      R0,[R4, #+8]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD102             BNE.N    ??f_read_8
   2600          					clst = fp->sclust;			/* Follow from the origin */
   \   0000008A   0x6920             LDR      R0,[R4, #+16]
   \   0000008C   0x0006             MOVS     R6,R0
   \   0000008E   0xE004             B.N      ??f_read_9
   2601          				} else {						/* Middle or end of the file */
   2602          #if _USE_FASTSEEK
   2603          					if (fp->cltbl)
   2604          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2605          					else
   2606          #endif
   2607          						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   \                     ??f_read_8:
   \   00000090   0x6961             LDR      R1,[R4, #+20]
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      BL       get_fat
   \   00000098   0x0006             MOVS     R6,R0
   2608          				}
   2609          				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   \                     ??f_read_9:
   \   0000009A   0x2E02             CMP      R6,#+2
   \   0000009C   0xD203             BCS.N    ??f_read_10
   \   0000009E   0x2002             MOVS     R0,#+2
   \   000000A0   0x71E0             STRB     R0,[R4, #+7]
   \   000000A2   0x2002             MOVS     R0,#+2
   \   000000A4   0xE0A3             B.N      ??f_read_1
   2610          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_read_10:
   \   000000A6   0xF116 0x0F01      CMN      R6,#+1
   \   000000AA   0xD103             BNE.N    ??f_read_11
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x71E0             STRB     R0,[R4, #+7]
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xE09C             B.N      ??f_read_1
   2611          				fp->clust = clst;				/* Update current cluster */
   \                     ??f_read_11:
   \   000000B4   0x6166             STR      R6,[R4, #+20]
   2612          			}
   2613          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   \                     ??f_read_7:
   \   000000B6   0x6961             LDR      R1,[R4, #+20]
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x.... 0x....      BL       clust2sect
   \   000000BE   0x0007             MOVS     R7,R0
   2614          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   \   000000C0   0x2F00             CMP      R7,#+0
   \   000000C2   0xD103             BNE.N    ??f_read_12
   \   000000C4   0x2002             MOVS     R0,#+2
   \   000000C6   0x71E0             STRB     R0,[R4, #+7]
   \   000000C8   0x2002             MOVS     R0,#+2
   \   000000CA   0xE090             B.N      ??f_read_1
   2615          			sect += csect;
   \                     ??f_read_12:
   \   000000CC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000D0   0xEB1A 0x0707      ADDS     R7,R10,R7
   2616          			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   \   000000D4   0x0A68             LSRS     R0,R5,#+9
   \   000000D6   0x4681             MOV      R9,R0
   2617          			if (cc) {							/* Read maximum contiguous sectors directly */
   \   000000D8   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000DC   0xD035             BEQ.N    ??f_read_13
   2618          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x7880             LDRB     R0,[R0, #+2]
   \   000000E2   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000E6   0xEB19 0x010A      ADDS     R1,R9,R10
   \   000000EA   0x4288             CMP      R0,R1
   \   000000EC   0xD206             BCS.N    ??f_read_14
   2619          					cc = fp->fs->csize - csect;
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x7880             LDRB     R0,[R0, #+2]
   \   000000F2   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000F6   0xEBB0 0x000A      SUBS     R0,R0,R10
   \   000000FA   0x4681             MOV      R9,R0
   2620          				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
   \                     ??f_read_14:
   \   000000FC   0x464B             MOV      R3,R9
   \   000000FE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000100   0x003A             MOVS     R2,R7
   \   00000102   0x4659             MOV      R1,R11
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x7840             LDRB     R0,[R0, #+1]
   \   00000108   0x.... 0x....      BL       disk_read
   \   0000010C   0x2800             CMP      R0,#+0
   \   0000010E   0xD003             BEQ.N    ??f_read_15
   2621          					ABORT(fp->fs, FR_DISK_ERR);
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0x71E0             STRB     R0,[R4, #+7]
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0xE06A             B.N      ??f_read_1
   2622          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   2623          #if _FS_TINY
   2624          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
   2625          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   2626          #else
   2627          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   \                     ??f_read_15:
   \   00000118   0x79A0             LDRB     R0,[R4, #+6]
   \   0000011A   0x0640             LSLS     R0,R0,#+25
   \   0000011C   0xD50F             BPL.N    ??f_read_16
   \   0000011E   0x69A0             LDR      R0,[R4, #+24]
   \   00000120   0x1BC0             SUBS     R0,R0,R7
   \   00000122   0x4548             CMP      R0,R9
   \   00000124   0xD20B             BCS.N    ??f_read_16
   2628          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   \   00000126   0xF44F 0x7200      MOV      R2,#+512
   \   0000012A   0xF114 0x0124      ADDS     R1,R4,#+36
   \   0000012E   0x69A0             LDR      R0,[R4, #+24]
   \   00000130   0x1BC0             SUBS     R0,R0,R7
   \   00000132   0xF44F 0x7300      MOV      R3,#+512
   \   00000136   0xFB03 0xB000      MLA      R0,R3,R0,R11
   \   0000013A   0x.... 0x....      BL       mem_cpy
   2629          #endif
   2630          #endif
   2631          				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   \                     ??f_read_16:
   \   0000013E   0xF44F 0x7000      MOV      R0,#+512
   \   00000142   0xFB00 0xF009      MUL      R0,R0,R9
   \   00000146   0x4680             MOV      R8,R0
   2632          				continue;
   \   00000148   0xE041             B.N      ??f_read_17
   2633          			}
   2634          #if !_FS_TINY
   2635          			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   \                     ??f_read_13:
   \   0000014A   0x69A0             LDR      R0,[R4, #+24]
   \   0000014C   0x42B8             CMP      R0,R7
   \   0000014E   0xD022             BEQ.N    ??f_read_18
   2636          #if !_FS_READONLY
   2637          				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   \   00000150   0x79A0             LDRB     R0,[R4, #+6]
   \   00000152   0x0640             LSLS     R0,R0,#+25
   \   00000154   0xD511             BPL.N    ??f_read_19
   2638          					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   00000156   0x2301             MOVS     R3,#+1
   \   00000158   0x69A2             LDR      R2,[R4, #+24]
   \   0000015A   0xF114 0x0124      ADDS     R1,R4,#+36
   \   0000015E   0x6820             LDR      R0,[R4, #+0]
   \   00000160   0x7840             LDRB     R0,[R0, #+1]
   \   00000162   0x.... 0x....      BL       disk_write
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD003             BEQ.N    ??f_read_20
   2639          						ABORT(fp->fs, FR_DISK_ERR);
   \   0000016A   0x2001             MOVS     R0,#+1
   \   0000016C   0x71E0             STRB     R0,[R4, #+7]
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0xE03D             B.N      ??f_read_1
   2640          					fp->flag &= ~FA__DIRTY;
   \                     ??f_read_20:
   \   00000172   0x79A0             LDRB     R0,[R4, #+6]
   \   00000174   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000178   0x71A0             STRB     R0,[R4, #+6]
   2641          				}
   2642          #endif
   2643          				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   \                     ??f_read_19:
   \   0000017A   0x2301             MOVS     R3,#+1
   \   0000017C   0x003A             MOVS     R2,R7
   \   0000017E   0xF114 0x0124      ADDS     R1,R4,#+36
   \   00000182   0x6820             LDR      R0,[R4, #+0]
   \   00000184   0x7840             LDRB     R0,[R0, #+1]
   \   00000186   0x.... 0x....      BL       disk_read
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD003             BEQ.N    ??f_read_18
   2644          					ABORT(fp->fs, FR_DISK_ERR);
   \   0000018E   0x2001             MOVS     R0,#+1
   \   00000190   0x71E0             STRB     R0,[R4, #+7]
   \   00000192   0x2001             MOVS     R0,#+1
   \   00000194   0xE02B             B.N      ??f_read_1
   2645          			}
   2646          #endif
   2647          			fp->dsect = sect;
   \                     ??f_read_18:
   \   00000196   0x61A7             STR      R7,[R4, #+24]
   2648          		}
   2649          		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   \                     ??f_read_6:
   \   00000198   0x68A0             LDR      R0,[R4, #+8]
   \   0000019A   0xF44F 0x7100      MOV      R1,#+512
   \   0000019E   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000001A2   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000001A6   0xF5D2 0x7000      RSBS     R0,R2,#+512
   \   000001AA   0x4680             MOV      R8,R0
   2650          		if (rcnt > btr) rcnt = btr;
   \   000001AC   0x4545             CMP      R5,R8
   \   000001AE   0xD200             BCS.N    ??f_read_21
   \   000001B0   0x46A8             MOV      R8,R5
   2651          #if _FS_TINY
   2652          		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
   2653          			ABORT(fp->fs, FR_DISK_ERR);
   2654          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   2655          #else
   2656          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_21:
   \   000001B2   0x4642             MOV      R2,R8
   \   000001B4   0x68A0             LDR      R0,[R4, #+8]
   \   000001B6   0xF44F 0x7100      MOV      R1,#+512
   \   000001BA   0xFBB0 0xF3F1      UDIV     R3,R0,R1
   \   000001BE   0xFB03 0x0311      MLS      R3,R3,R1,R0
   \   000001C2   0x1918             ADDS     R0,R3,R4
   \   000001C4   0xF110 0x0124      ADDS     R1,R0,#+36
   \   000001C8   0x4658             MOV      R0,R11
   \   000001CA   0x.... 0x....      BL       mem_cpy
   2657          #endif
   2658          	}
   \                     ??f_read_17:
   \   000001CE   0xEB18 0x0B0B      ADDS     R11,R8,R11
   \   000001D2   0x68A0             LDR      R0,[R4, #+8]
   \   000001D4   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001D8   0x60A0             STR      R0,[R4, #+8]
   \   000001DA   0x9804             LDR      R0,[SP, #+16]
   \   000001DC   0x6800             LDR      R0,[R0, #+0]
   \   000001DE   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001E2   0x9904             LDR      R1,[SP, #+16]
   \   000001E4   0x6008             STR      R0,[R1, #+0]
   \   000001E6   0xEBB5 0x0508      SUBS     R5,R5,R8
   \   000001EA   0xE732             B.N      ??f_read_4
   2659          
   2660          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_5:
   \   000001EC   0x2000             MOVS     R0,#+0
   \                     ??f_read_1:
   \   000001EE   0xB005             ADD      SP,SP,#+20
   \   000001F0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2661          }
   2662          
   2663          
   2664          
   2665          
   2666          #if !_FS_READONLY
   2667          /*-----------------------------------------------------------------------*/
   2668          /* Write File                                                            */
   2669          /*-----------------------------------------------------------------------*/
   2670          

   \                                 In section .text, align 2, keep-with-next
   2671          FRESULT f_write (
   2672          	FIL* fp,			/* Pointer to the file object */
   2673          	const void *buff,	/* Pointer to the data to be written */
   2674          	UINT btw,			/* Number of bytes to write */
   2675          	UINT* bw			/* Pointer to number of bytes written */
   2676          )
   2677          {
   \                     f_write:
   \   00000000   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
   2678          	FRESULT res;
   2679          	DWORD clst, sect;
   2680          	UINT wcnt, cc;
   2681          	const BYTE *wbuff = (const BYTE*)buff;
   \   00000008   0xF8DD 0xA004      LDR      R10,[SP, #+4]
   2682          	BYTE csect;
   2683          
   2684          
   2685          	*bw = 0;	/* Clear write byte counter */
   \   0000000C   0x9802             LDR      R0,[SP, #+8]
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6001             STR      R1,[R0, #+0]
   2686          
   2687          	res = validate(fp);						/* Check validity */
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       validate
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2688          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD002             BEQ.N    ??f_write_0
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0xE0FF             B.N      ??f_write_1
   2689          	if (fp->err)							/* Check error */
   \                     ??f_write_0:
   \   0000002A   0x79E0             LDRB     R0,[R4, #+7]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ.N    ??f_write_2
   2690          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   \   00000030   0x79E0             LDRB     R0,[R4, #+7]
   \   00000032   0xE0FA             B.N      ??f_write_1
   2691          	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   \                     ??f_write_2:
   \   00000034   0x79A0             LDRB     R0,[R4, #+6]
   \   00000036   0x0780             LSLS     R0,R0,#+30
   \   00000038   0xD401             BMI.N    ??f_write_3
   2692          		LEAVE_FF(fp->fs, FR_DENIED);
   \   0000003A   0x2007             MOVS     R0,#+7
   \   0000003C   0xE0F5             B.N      ??f_write_1
   2693          	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
   \                     ??f_write_3:
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0x1828             ADDS     R0,R5,R0
   \   00000042   0x68A1             LDR      R1,[R4, #+8]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD201             BCS.N    ??f_write_4
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x0005             MOVS     R5,R0
   2694          
   2695          	for ( ;  btw;							/* Repeat until all data written */
   \                     ??f_write_4:
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xF000 0x80E1      BEQ.W    ??f_write_5
   2696          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   2697          		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   \   00000052   0x68A0             LDR      R0,[R4, #+8]
   \   00000054   0xF44F 0x7100      MOV      R1,#+512
   \   00000058   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   0000005C   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000060   0x2A00             CMP      R2,#+0
   \   00000062   0xF040 0x80A9      BNE.W    ??f_write_6
   2698          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   \   00000066   0x68A0             LDR      R0,[R4, #+8]
   \   00000068   0x0A40             LSRS     R0,R0,#+9
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x7889             LDRB     R1,[R1, #+2]
   \   0000006E   0x1E49             SUBS     R1,R1,#+1
   \   00000070   0x4008             ANDS     R0,R1,R0
   \   00000072   0x4683             MOV      R11,R0
   2699          			if (!csect) {					/* On the cluster boundary? */
   \   00000074   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000078   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000007C   0xD126             BNE.N    ??f_write_7
   2700          				if (fp->fptr == 0) {		/* On the top of the file? */
   \   0000007E   0x68A0             LDR      R0,[R4, #+8]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD109             BNE.N    ??f_write_8
   2701          					clst = fp->sclust;		/* Follow from the origin */
   \   00000084   0x6920             LDR      R0,[R4, #+16]
   \   00000086   0x0006             MOVS     R6,R0
   2702          					if (clst == 0)			/* When no cluster is allocated, */
   \   00000088   0x2E00             CMP      R6,#+0
   \   0000008A   0xD10A             BNE.N    ??f_write_9
   2703          						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x.... 0x....      BL       create_chain
   \   00000094   0x0006             MOVS     R6,R0
   \   00000096   0xE004             B.N      ??f_write_9
   2704          				} else {					/* Middle or end of the file */
   2705          #if _USE_FASTSEEK
   2706          					if (fp->cltbl)
   2707          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2708          					else
   2709          #endif
   2710          						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   \                     ??f_write_8:
   \   00000098   0x6961             LDR      R1,[R4, #+20]
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x.... 0x....      BL       create_chain
   \   000000A0   0x0006             MOVS     R6,R0
   2711          				}
   2712          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   \                     ??f_write_9:
   \   000000A2   0x2E00             CMP      R6,#+0
   \   000000A4   0xF000 0x80B6      BEQ.W    ??f_write_5
   2713          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \                     ??f_write_10:
   \   000000A8   0x2E01             CMP      R6,#+1
   \   000000AA   0xD103             BNE.N    ??f_write_11
   \   000000AC   0x2002             MOVS     R0,#+2
   \   000000AE   0x71E0             STRB     R0,[R4, #+7]
   \   000000B0   0x2002             MOVS     R0,#+2
   \   000000B2   0xE0BA             B.N      ??f_write_1
   2714          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_write_11:
   \   000000B4   0xF116 0x0F01      CMN      R6,#+1
   \   000000B8   0xD103             BNE.N    ??f_write_12
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x71E0             STRB     R0,[R4, #+7]
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xE0B3             B.N      ??f_write_1
   2715          				fp->clust = clst;			/* Update current cluster */
   \                     ??f_write_12:
   \   000000C2   0x6166             STR      R6,[R4, #+20]
   2716          				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
   \   000000C4   0x6920             LDR      R0,[R4, #+16]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD100             BNE.N    ??f_write_7
   \   000000CA   0x6126             STR      R6,[R4, #+16]
   2717          			}
   2718          #if _FS_TINY
   2719          			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
   2720          				ABORT(fp->fs, FR_DISK_ERR);
   2721          #else
   2722          			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   \                     ??f_write_7:
   \   000000CC   0x79A0             LDRB     R0,[R4, #+6]
   \   000000CE   0x0640             LSLS     R0,R0,#+25
   \   000000D0   0xD511             BPL.N    ??f_write_13
   2723          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   000000D2   0x2301             MOVS     R3,#+1
   \   000000D4   0x69A2             LDR      R2,[R4, #+24]
   \   000000D6   0xF114 0x0124      ADDS     R1,R4,#+36
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x7840             LDRB     R0,[R0, #+1]
   \   000000DE   0x.... 0x....      BL       disk_write
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD003             BEQ.N    ??f_write_14
   2724          					ABORT(fp->fs, FR_DISK_ERR);
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0x71E0             STRB     R0,[R4, #+7]
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xE09D             B.N      ??f_write_1
   2725          				fp->flag &= ~FA__DIRTY;
   \                     ??f_write_14:
   \   000000EE   0x79A0             LDRB     R0,[R4, #+6]
   \   000000F0   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000000F4   0x71A0             STRB     R0,[R4, #+6]
   2726          			}
   2727          #endif
   2728          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   \                     ??f_write_13:
   \   000000F6   0x6961             LDR      R1,[R4, #+20]
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x.... 0x....      BL       clust2sect
   \   000000FE   0x0007             MOVS     R7,R0
   2729          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   \   00000100   0x2F00             CMP      R7,#+0
   \   00000102   0xD103             BNE.N    ??f_write_15
   \   00000104   0x2002             MOVS     R0,#+2
   \   00000106   0x71E0             STRB     R0,[R4, #+7]
   \   00000108   0x2002             MOVS     R0,#+2
   \   0000010A   0xE08E             B.N      ??f_write_1
   2730          			sect += csect;
   \                     ??f_write_15:
   \   0000010C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000110   0xEB1B 0x0707      ADDS     R7,R11,R7
   2731          			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   \   00000114   0x0A68             LSRS     R0,R5,#+9
   \   00000116   0x4681             MOV      R9,R0
   2732          			if (cc) {						/* Write maximum contiguous sectors directly */
   \   00000118   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000011C   0xD036             BEQ.N    ??f_write_16
   2733          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x7880             LDRB     R0,[R0, #+2]
   \   00000122   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000126   0xEB19 0x010B      ADDS     R1,R9,R11
   \   0000012A   0x4288             CMP      R0,R1
   \   0000012C   0xD206             BCS.N    ??f_write_17
   2734          					cc = fp->fs->csize - csect;
   \   0000012E   0x6820             LDR      R0,[R4, #+0]
   \   00000130   0x7880             LDRB     R0,[R0, #+2]
   \   00000132   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000136   0xEBB0 0x000B      SUBS     R0,R0,R11
   \   0000013A   0x4681             MOV      R9,R0
   2735          				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
   \                     ??f_write_17:
   \   0000013C   0x464B             MOV      R3,R9
   \   0000013E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000140   0x003A             MOVS     R2,R7
   \   00000142   0x4651             MOV      R1,R10
   \   00000144   0x6820             LDR      R0,[R4, #+0]
   \   00000146   0x7840             LDRB     R0,[R0, #+1]
   \   00000148   0x.... 0x....      BL       disk_write
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xD003             BEQ.N    ??f_write_18
   2736          					ABORT(fp->fs, FR_DISK_ERR);
   \   00000150   0x2001             MOVS     R0,#+1
   \   00000152   0x71E0             STRB     R0,[R4, #+7]
   \   00000154   0x2001             MOVS     R0,#+1
   \   00000156   0xE068             B.N      ??f_write_1
   2737          #if _FS_MINIMIZE <= 2
   2738          #if _FS_TINY
   2739          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   2740          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   2741          					fp->fs->wflag = 0;
   2742          				}
   2743          #else
   2744          				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   \                     ??f_write_18:
   \   00000158   0x69A0             LDR      R0,[R4, #+24]
   \   0000015A   0x1BC0             SUBS     R0,R0,R7
   \   0000015C   0x4548             CMP      R0,R9
   \   0000015E   0xD20F             BCS.N    ??f_write_19
   2745          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   \   00000160   0xF44F 0x7200      MOV      R2,#+512
   \   00000164   0x69A0             LDR      R0,[R4, #+24]
   \   00000166   0x1BC0             SUBS     R0,R0,R7
   \   00000168   0xF44F 0x7100      MOV      R1,#+512
   \   0000016C   0xFB01 0xA100      MLA      R1,R1,R0,R10
   \   00000170   0xF114 0x0024      ADDS     R0,R4,#+36
   \   00000174   0x.... 0x....      BL       mem_cpy
   2746          					fp->flag &= ~FA__DIRTY;
   \   00000178   0x79A0             LDRB     R0,[R4, #+6]
   \   0000017A   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000017E   0x71A0             STRB     R0,[R4, #+6]
   2747          				}
   2748          #endif
   2749          #endif
   2750          				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   \                     ??f_write_19:
   \   00000180   0xF44F 0x7000      MOV      R0,#+512
   \   00000184   0xFB00 0xF009      MUL      R0,R0,R9
   \   00000188   0x4680             MOV      R8,R0
   2751          				continue;
   \   0000018A   0xE034             B.N      ??f_write_20
   2752          			}
   2753          #if _FS_TINY
   2754          			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   2755          				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
   2756          				fp->fs->winsect = sect;
   2757          			}
   2758          #else
   2759          			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   \                     ??f_write_16:
   \   0000018C   0x69A0             LDR      R0,[R4, #+24]
   \   0000018E   0x42B8             CMP      R0,R7
   \   00000190   0xD011             BEQ.N    ??f_write_21
   2760          				if (fp->fptr < fp->fsize &&
   2761          					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   \   00000192   0x68A0             LDR      R0,[R4, #+8]
   \   00000194   0x68E1             LDR      R1,[R4, #+12]
   \   00000196   0x4288             CMP      R0,R1
   \   00000198   0xD20D             BCS.N    ??f_write_21
   \   0000019A   0x2301             MOVS     R3,#+1
   \   0000019C   0x003A             MOVS     R2,R7
   \   0000019E   0xF114 0x0124      ADDS     R1,R4,#+36
   \   000001A2   0x6820             LDR      R0,[R4, #+0]
   \   000001A4   0x7840             LDRB     R0,[R0, #+1]
   \   000001A6   0x.... 0x....      BL       disk_read
   \   000001AA   0x2800             CMP      R0,#+0
   \   000001AC   0xD003             BEQ.N    ??f_write_21
   2762          						ABORT(fp->fs, FR_DISK_ERR);
   \   000001AE   0x2001             MOVS     R0,#+1
   \   000001B0   0x71E0             STRB     R0,[R4, #+7]
   \   000001B2   0x2001             MOVS     R0,#+1
   \   000001B4   0xE039             B.N      ??f_write_1
   2763          			}
   2764          #endif
   2765          			fp->dsect = sect;
   \                     ??f_write_21:
   \   000001B6   0x61A7             STR      R7,[R4, #+24]
   2766          		}
   2767          		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   \                     ??f_write_6:
   \   000001B8   0x68A0             LDR      R0,[R4, #+8]
   \   000001BA   0xF44F 0x7100      MOV      R1,#+512
   \   000001BE   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000001C2   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000001C6   0xF5D2 0x7000      RSBS     R0,R2,#+512
   \   000001CA   0x4680             MOV      R8,R0
   2768          		if (wcnt > btw) wcnt = btw;
   \   000001CC   0x4545             CMP      R5,R8
   \   000001CE   0xD200             BCS.N    ??f_write_22
   \   000001D0   0x46A8             MOV      R8,R5
   2769          #if _FS_TINY
   2770          		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
   2771          			ABORT(fp->fs, FR_DISK_ERR);
   2772          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2773          		fp->fs->wflag = 1;
   2774          #else
   2775          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   \                     ??f_write_22:
   \   000001D2   0x4642             MOV      R2,R8
   \   000001D4   0x4651             MOV      R1,R10
   \   000001D6   0x68A0             LDR      R0,[R4, #+8]
   \   000001D8   0xF44F 0x7300      MOV      R3,#+512
   \   000001DC   0xFBB0 0xFCF3      UDIV     R12,R0,R3
   \   000001E0   0xFB0C 0x0C13      MLS      R12,R12,R3,R0
   \   000001E4   0xEB1C 0x0004      ADDS     R0,R12,R4
   \   000001E8   0x3024             ADDS     R0,R0,#+36
   \   000001EA   0x.... 0x....      BL       mem_cpy
   2776          		fp->flag |= FA__DIRTY;
   \   000001EE   0x79A0             LDRB     R0,[R4, #+6]
   \   000001F0   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000001F4   0x71A0             STRB     R0,[R4, #+6]
   2777          #endif
   2778          	}
   \                     ??f_write_20:
   \   000001F6   0xEB18 0x0A0A      ADDS     R10,R8,R10
   \   000001FA   0x68A0             LDR      R0,[R4, #+8]
   \   000001FC   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000200   0x60A0             STR      R0,[R4, #+8]
   \   00000202   0x9802             LDR      R0,[SP, #+8]
   \   00000204   0x6800             LDR      R0,[R0, #+0]
   \   00000206   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000020A   0x9902             LDR      R1,[SP, #+8]
   \   0000020C   0x6008             STR      R0,[R1, #+0]
   \   0000020E   0xEBB5 0x0508      SUBS     R5,R5,R8
   \   00000212   0xE71B             B.N      ??f_write_4
   2779          
   2780          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_5:
   \   00000214   0x68E0             LDR      R0,[R4, #+12]
   \   00000216   0x68A1             LDR      R1,[R4, #+8]
   \   00000218   0x4288             CMP      R0,R1
   \   0000021A   0xD201             BCS.N    ??f_write_23
   \   0000021C   0x68A0             LDR      R0,[R4, #+8]
   \   0000021E   0x60E0             STR      R0,[R4, #+12]
   2781          	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   \                     ??f_write_23:
   \   00000220   0x79A0             LDRB     R0,[R4, #+6]
   \   00000222   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000226   0x71A0             STRB     R0,[R4, #+6]
   2782          
   2783          	LEAVE_FF(fp->fs, FR_OK);
   \   00000228   0x2000             MOVS     R0,#+0
   \                     ??f_write_1:
   \   0000022A   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2784          }
   2785          
   2786          
   2787          
   2788          
   2789          /*-----------------------------------------------------------------------*/
   2790          /* Synchronize the File                                                  */
   2791          /*-----------------------------------------------------------------------*/
   2792          

   \                                 In section .text, align 2, keep-with-next
   2793          FRESULT f_sync (
   2794          	FIL* fp		/* Pointer to the file object */
   2795          )
   2796          {
   \                     f_sync:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2797          	FRESULT res;
   2798          	DWORD tm;
   2799          	BYTE *dir;
   2800          
   2801          
   2802          	res = validate(fp);					/* Check validity of the object */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       validate
   \   0000000A   0x0005             MOVS     R5,R0
   2803          	if (res == FR_OK) {
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD14E             BNE.N    ??f_sync_0
   2804          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   \   00000012   0x79A0             LDRB     R0,[R4, #+6]
   \   00000014   0x0680             LSLS     R0,R0,#+26
   \   00000016   0xD54B             BPL.N    ??f_sync_0
   2805          			/* Write-back dirty buffer */
   2806          #if !_FS_TINY
   2807          			if (fp->flag & FA__DIRTY) {
   \   00000018   0x79A0             LDRB     R0,[R4, #+6]
   \   0000001A   0x0640             LSLS     R0,R0,#+25
   \   0000001C   0xD50F             BPL.N    ??f_sync_1
   2808          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0000001E   0x2301             MOVS     R3,#+1
   \   00000020   0x69A2             LDR      R2,[R4, #+24]
   \   00000022   0xF114 0x0124      ADDS     R1,R4,#+36
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x7840             LDRB     R0,[R0, #+1]
   \   0000002A   0x.... 0x....      BL       disk_write
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??f_sync_2
   2809          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE03E             B.N      ??f_sync_3
   2810          				fp->flag &= ~FA__DIRTY;
   \                     ??f_sync_2:
   \   00000036   0x79A0             LDRB     R0,[R4, #+6]
   \   00000038   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000003C   0x71A0             STRB     R0,[R4, #+6]
   2811          			}
   2812          #endif
   2813          			/* Update the directory entry */
   2814          			res = move_window(fp->fs, fp->dir_sect);
   \                     ??f_sync_1:
   \   0000003E   0x69E1             LDR      R1,[R4, #+28]
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       move_window
   \   00000046   0x0005             MOVS     R5,R0
   2815          			if (res == FR_OK) {
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD130             BNE.N    ??f_sync_0
   2816          				dir = fp->dir_ptr;
   \   0000004E   0x6A20             LDR      R0,[R4, #+32]
   \   00000050   0x0007             MOVS     R7,R0
   2817          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   00000052   0x7AF8             LDRB     R0,[R7, #+11]
   \   00000054   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000058   0x72F8             STRB     R0,[R7, #+11]
   2818          				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   \   0000005A   0x68E0             LDR      R0,[R4, #+12]
   \   0000005C   0x7738             STRB     R0,[R7, #+28]
   \   0000005E   0x68E0             LDR      R0,[R4, #+12]
   \   00000060   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000062   0x0A00             LSRS     R0,R0,#+8
   \   00000064   0x7778             STRB     R0,[R7, #+29]
   \   00000066   0x68E0             LDR      R0,[R4, #+12]
   \   00000068   0x0C00             LSRS     R0,R0,#+16
   \   0000006A   0x77B8             STRB     R0,[R7, #+30]
   \   0000006C   0x68E0             LDR      R0,[R4, #+12]
   \   0000006E   0x0E00             LSRS     R0,R0,#+24
   \   00000070   0x77F8             STRB     R0,[R7, #+31]
   2819          				st_clust(dir, fp->sclust);					/* Update start cluster */
   \   00000072   0x6921             LDR      R1,[R4, #+16]
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       st_clust
   2820          				tm = GET_FATTIME();							/* Update updated time */
   \   0000007A   0x.... 0x....      BL       get_fattime
   \   0000007E   0x0006             MOVS     R6,R0
   2821          				ST_DWORD(dir+DIR_WrtTime, tm);
   \   00000080   0x75BE             STRB     R6,[R7, #+22]
   \   00000082   0x0030             MOVS     R0,R6
   \   00000084   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000086   0x0A00             LSRS     R0,R0,#+8
   \   00000088   0x75F8             STRB     R0,[R7, #+23]
   \   0000008A   0x0C30             LSRS     R0,R6,#+16
   \   0000008C   0x7638             STRB     R0,[R7, #+24]
   \   0000008E   0x0E30             LSRS     R0,R6,#+24
   \   00000090   0x7678             STRB     R0,[R7, #+25]
   2822          				ST_WORD(dir+DIR_LstAccDate, 0);
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x74B8             STRB     R0,[R7, #+18]
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x74F8             STRB     R0,[R7, #+19]
   2823          				fp->flag &= ~FA__WRITTEN;
   \   0000009A   0x79A0             LDRB     R0,[R4, #+6]
   \   0000009C   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   000000A0   0x71A0             STRB     R0,[R4, #+6]
   2824          				fp->fs->wflag = 1;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0x7101             STRB     R1,[R0, #+4]
   2825          				res = sync_fs(fp->fs);
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x.... 0x....      BL       sync_fs
   \   000000AE   0x0005             MOVS     R5,R0
   2826          			}
   2827          		}
   2828          	}
   2829          
   2830          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0:
   \   000000B0   0x0028             MOVS     R0,R5
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_sync_3:
   \   000000B4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2831          }
   2832          
   2833          #endif /* !_FS_READONLY */
   2834          
   2835          
   2836          
   2837          
   2838          /*-----------------------------------------------------------------------*/
   2839          /* Close File                                                            */
   2840          /*-----------------------------------------------------------------------*/
   2841          

   \                                 In section .text, align 2, keep-with-next
   2842          FRESULT f_close (
   2843          	FIL *fp		/* Pointer to the file object to be closed */
   2844          )
   2845          {
   \                     f_close:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2846          	FRESULT res;
   2847          
   2848          
   2849          #if !_FS_READONLY
   2850          	res = f_sync(fp);					/* Flush cached data */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       f_sync
   \   0000000A   0x0005             MOVS     R5,R0
   2851          	if (res == FR_OK)
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD108             BNE.N    ??f_close_0
   2852          #endif
   2853          	{
   2854          		res = validate(fp);				/* Lock volume */
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       validate
   \   00000018   0x0005             MOVS     R5,R0
   2855          		if (res == FR_OK) {
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD101             BNE.N    ??f_close_0
   2856          #if _FS_REENTRANT
   2857          			FATFS *fs = fp->fs;
   2858          #endif
   2859          #if _FS_LOCK
   2860          			res = dec_lock(fp->lockid);	/* Decrement file open counter */
   2861          			if (res == FR_OK)
   2862          #endif
   2863          				fp->fs = 0;				/* Invalidate file object */
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6020             STR      R0,[R4, #+0]
   2864          #if _FS_REENTRANT
   2865          			unlock_fs(fs, FR_OK);		/* Unlock volume */
   2866          #endif
   2867          		}
   2868          	}
   2869          	return res;
   \                     ??f_close_0:
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2870          }
   2871          
   2872          
   2873          
   2874          
   2875          /*-----------------------------------------------------------------------*/
   2876          /* Change Current Directory or Current Drive, Get Current Directory      */
   2877          /*-----------------------------------------------------------------------*/
   2878          
   2879          #if _FS_RPATH >= 1
   2880          #if _VOLUMES >= 2
   2881          FRESULT f_chdrive (
   2882          	const TCHAR* path		/* Drive number */
   2883          )
   2884          {
   2885          	int vol;
   2886          
   2887          
   2888          	vol = get_ldnumber(&path);
   2889          	if (vol < 0) return FR_INVALID_DRIVE;
   2890          
   2891          	CurrVol = (BYTE)vol;
   2892          
   2893          	return FR_OK;
   2894          }
   2895          #endif
   2896          
   2897          

   \                                 In section .text, align 2, keep-with-next
   2898          FRESULT f_chdir (
   2899          	const TCHAR* path	/* Pointer to the directory path */
   2900          )
   2901          {
   \                     f_chdir:
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   2902          	FRESULT res;
   2903          	DIR dj;
   2904          	DEF_NAMEBUF;
   2905          
   2906          
   2907          	/* Get logical drive number */
   2908          	res = find_volume(&dj.fs, &path, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xA90D             ADD      R1,SP,#+52
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      BL       find_volume
   \   0000000E   0x0004             MOVS     R4,R0
   2909          	if (res == FR_OK) {
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD125             BNE.N    ??f_chdir_0
   2910          		INIT_BUF(dj);
   \   00000016   0xA809             ADD      R0,SP,#+36
   \   00000018   0x9006             STR      R0,[SP, #+24]
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000001E   0x9007             STR      R0,[SP, #+28]
   2911          		res = follow_path(&dj, path);		/* Follow the path */
   \   00000020   0x990D             LDR      R1,[SP, #+52]
   \   00000022   0xA800             ADD      R0,SP,#+0
   \   00000024   0x.... 0x....      BL       follow_path
   \   00000028   0x0004             MOVS     R4,R0
   2912          		FREE_BUF();
   2913          		if (res == FR_OK) {					/* Follow completed */
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD113             BNE.N    ??f_chdir_1
   2914          			if (!dj.dir) {
   \   00000030   0x9805             LDR      R0,[SP, #+20]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD103             BNE.N    ??f_chdir_2
   2915          				dj.fs->cdir = dj.sclust;	/* Start directory itself */
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x9902             LDR      R1,[SP, #+8]
   \   0000003A   0x6141             STR      R1,[R0, #+20]
   \   0000003C   0xE00C             B.N      ??f_chdir_1
   2916          			} else {
   2917          				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
   \                     ??f_chdir_2:
   \   0000003E   0x9805             LDR      R0,[SP, #+20]
   \   00000040   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000042   0x06C0             LSLS     R0,R0,#+27
   \   00000044   0xD506             BPL.N    ??f_chdir_3
   2918          					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
   \   00000046   0x9905             LDR      R1,[SP, #+20]
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x.... 0x....      BL       ld_clust
   \   0000004E   0x9900             LDR      R1,[SP, #+0]
   \   00000050   0x6148             STR      R0,[R1, #+20]
   \   00000052   0xE001             B.N      ??f_chdir_1
   2919          				else
   2920          					res = FR_NO_PATH;		/* Reached but a file */
   \                     ??f_chdir_3:
   \   00000054   0x2005             MOVS     R0,#+5
   \   00000056   0x0004             MOVS     R4,R0
   2921          			}
   2922          		}
   2923          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_chdir_1:
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x2C04             CMP      R4,#+4
   \   0000005C   0xD101             BNE.N    ??f_chdir_0
   \   0000005E   0x2005             MOVS     R0,#+5
   \   00000060   0x0004             MOVS     R4,R0
   2924          	}
   2925          
   2926          	LEAVE_FF(dj.fs, res);
   \                     ??f_chdir_0:
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xB00E             ADD      SP,SP,#+56
   \   00000068   0xBD10             POP      {R4,PC}          ;; return
   2927          }
   2928          
   2929          
   2930          #if _FS_RPATH >= 2
   2931          FRESULT f_getcwd (
   2932          	TCHAR* buff,	/* Pointer to the directory path */
   2933          	UINT len		/* Size of path */
   2934          )
   2935          {
   2936          	FRESULT res;
   2937          	DIR dj;
   2938          	UINT i, n;
   2939          	DWORD ccl;
   2940          	TCHAR *tp;
   2941          	FILINFO fno;
   2942          	DEF_NAMEBUF;
   2943          
   2944          
   2945          	*buff = 0;
   2946          	/* Get logical drive number */
   2947          	res = find_volume(&dj.fs, (const TCHAR**)&buff, 0);	/* Get current volume */
   2948          	if (res == FR_OK) {
   2949          		INIT_BUF(dj);
   2950          		i = len;			/* Bottom of buffer (directory stack base) */
   2951          		dj.sclust = dj.fs->cdir;			/* Start to follow upper directory from current directory */
   2952          		while ((ccl = dj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
   2953          			res = dir_sdi(&dj, 1);			/* Get parent directory */
   2954          			if (res != FR_OK) break;
   2955          			res = dir_read(&dj, 0);
   2956          			if (res != FR_OK) break;
   2957          			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent directory */
   2958          			res = dir_sdi(&dj, 0);
   2959          			if (res != FR_OK) break;
   2960          			do {							/* Find the entry links to the child directory */
   2961          				res = dir_read(&dj, 0);
   2962          				if (res != FR_OK) break;
   2963          				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
   2964          				res = dir_next(&dj, 0);	
   2965          			} while (res == FR_OK);
   2966          			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   2967          			if (res != FR_OK) break;
   2968          #if _USE_LFN
   2969          			fno.lfname = buff;
   2970          			fno.lfsize = i;
   2971          #endif
   2972          			get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
   2973          			tp = fno.fname;
   2974          #if _USE_LFN
   2975          			if (*buff) tp = buff;
   2976          #endif
   2977          			for (n = 0; tp[n]; n++) ;
   2978          			if (i < n + 3) {
   2979          				res = FR_NOT_ENOUGH_CORE; break;
   2980          			}
   2981          			while (n) buff[--i] = tp[--n];
   2982          			buff[--i] = '/';
   2983          		}
   2984          		tp = buff;
   2985          		if (res == FR_OK) {
   2986          #if _VOLUMES >= 2
   2987          			*tp++ = '0' + CurrVol;			/* Put drive number */
   2988          			*tp++ = ':';
   2989          #endif
   2990          			if (i == len) {					/* Root-directory */
   2991          				*tp++ = '/';
   2992          			} else {						/* Sub-directroy */
   2993          				do		/* Add stacked path str */
   2994          					*tp++ = buff[i++];
   2995          				while (i < len);
   2996          			}
   2997          		}
   2998          		*tp = 0;
   2999          		FREE_BUF();
   3000          	}
   3001          
   3002          	LEAVE_FF(dj.fs, res);
   3003          }
   3004          #endif /* _FS_RPATH >= 2 */
   3005          #endif /* _FS_RPATH >= 1 */
   3006          
   3007          
   3008          
   3009          #if _FS_MINIMIZE <= 2
   3010          /*-----------------------------------------------------------------------*/
   3011          /* Seek File R/W Pointer                                                 */
   3012          /*-----------------------------------------------------------------------*/
   3013          

   \                                 In section .text, align 2, keep-with-next
   3014          FRESULT f_lseek (
   3015          	FIL* fp,		/* Pointer to the file object */
   3016          	DWORD ofs		/* File pointer from top of file */
   3017          )
   3018          {
   \                     f_lseek:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   3019          	FRESULT res;
   3020          
   3021          
   3022          	res = validate(fp);					/* Check validity of the object */
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       validate
   \   0000000E   0x0006             MOVS     R6,R0
   3023          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD002             BEQ.N    ??f_lseek_0
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xE0CC             B.N      ??f_lseek_1
   3024          	if (fp->err)						/* Check error */
   \                     ??f_lseek_0:
   \   0000001C   0x79E0             LDRB     R0,[R4, #+7]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??f_lseek_2
   3025          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   \   00000022   0x79E0             LDRB     R0,[R4, #+7]
   \   00000024   0xE0C7             B.N      ??f_lseek_1
   3026          
   3027          #if _USE_FASTSEEK
   3028          	if (fp->cltbl) {	/* Fast seek */
   3029          		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   3030          
   3031          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   3032          			tbl = fp->cltbl;
   3033          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   3034          			cl = fp->sclust;			/* Top of the chain */
   3035          			if (cl) {
   3036          				do {
   3037          					/* Get a fragment */
   3038          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   3039          					do {
   3040          						pcl = cl; ncl++;
   3041          						cl = get_fat(fp->fs, cl);
   3042          						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   3043          						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3044          					} while (cl == pcl + 1);
   3045          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   3046          						*tbl++ = ncl; *tbl++ = tcl;
   3047          					}
   3048          				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
   3049          			}
   3050          			*fp->cltbl = ulen;	/* Number of items used */
   3051          			if (ulen <= tlen)
   3052          				*tbl = 0;		/* Terminate table */
   3053          			else
   3054          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   3055          
   3056          		} else {						/* Fast seek */
   3057          			if (ofs > fp->fsize)		/* Clip offset at the file size */
   3058          				ofs = fp->fsize;
   3059          			fp->fptr = ofs;				/* Set file pointer */
   3060          			if (ofs) {
   3061          				fp->clust = clmt_clust(fp, ofs - 1);
   3062          				dsc = clust2sect(fp->fs, fp->clust);
   3063          				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   3064          				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   3065          				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
   3066          #if !_FS_TINY
   3067          #if !_FS_READONLY
   3068          					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   3069          						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   3070          							ABORT(fp->fs, FR_DISK_ERR);
   3071          						fp->flag &= ~FA__DIRTY;
   3072          					}
   3073          #endif
   3074          					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
   3075          						ABORT(fp->fs, FR_DISK_ERR);
   3076          #endif
   3077          					fp->dsect = dsc;
   3078          				}
   3079          			}
   3080          		}
   3081          	} else
   3082          #endif
   3083          
   3084          	/* Normal Seek */
   3085          	{
   3086          		DWORD clst, bcs, nsect, ifptr;
   3087          
   3088          		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   3089          #if !_FS_READONLY
   3090          			 && !(fp->flag & FA_WRITE)
   3091          #endif
   3092          			) ofs = fp->fsize;
   \                     ??f_lseek_2:
   \   00000026   0x68E0             LDR      R0,[R4, #+12]
   \   00000028   0x42A8             CMP      R0,R5
   \   0000002A   0xD204             BCS.N    ??f_lseek_3
   \   0000002C   0x79A0             LDRB     R0,[R4, #+6]
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD401             BMI.N    ??f_lseek_3
   \   00000032   0x68E0             LDR      R0,[R4, #+12]
   \   00000034   0x0005             MOVS     R5,R0
   3093          
   3094          		ifptr = fp->fptr;
   \                     ??f_lseek_3:
   \   00000036   0x68A0             LDR      R0,[R4, #+8]
   \   00000038   0x4682             MOV      R10,R0
   3095          		fp->fptr = nsect = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x4681             MOV      R9,R0
   \   0000003E   0x60A0             STR      R0,[R4, #+8]
   3096          		if (ofs) {
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD07B             BEQ.N    ??f_lseek_4
   3097          			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x7880             LDRB     R0,[R0, #+2]
   \   00000048   0xF44F 0x7100      MOV      R1,#+512
   \   0000004C   0x4348             MULS     R0,R1,R0
   \   0000004E   0x4680             MOV      R8,R0
   3098          			if (ifptr > 0 &&
   3099          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   00000050   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000054   0xD013             BEQ.N    ??f_lseek_5
   \   00000056   0xF1BA 0x0001      SUBS     R0,R10,#+1
   \   0000005A   0xFBB0 0xF0F8      UDIV     R0,R0,R8
   \   0000005E   0x1E69             SUBS     R1,R5,#+1
   \   00000060   0xFBB1 0xF1F8      UDIV     R1,R1,R8
   \   00000064   0x4281             CMP      R1,R0
   \   00000066   0xD30A             BCC.N    ??f_lseek_5
   3100          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \   00000068   0xF1BA 0x0001      SUBS     R0,R10,#+1
   \   0000006C   0xF1B8 0x0101      SUBS     R1,R8,#+1
   \   00000070   0x4388             BICS     R0,R0,R1
   \   00000072   0x60A0             STR      R0,[R4, #+8]
   3101          				ofs -= fp->fptr;
   \   00000074   0x68A0             LDR      R0,[R4, #+8]
   \   00000076   0x1A2D             SUBS     R5,R5,R0
   3102          				clst = fp->clust;
   \   00000078   0x6960             LDR      R0,[R4, #+20]
   \   0000007A   0x0007             MOVS     R7,R0
   \   0000007C   0xE017             B.N      ??f_lseek_6
   3103          			} else {									/* When seek to back cluster, */
   3104          				clst = fp->sclust;						/* start from the first cluster */
   \                     ??f_lseek_5:
   \   0000007E   0x6920             LDR      R0,[R4, #+16]
   \   00000080   0x0007             MOVS     R7,R0
   3105          #if !_FS_READONLY
   3106          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   \   00000082   0x2F00             CMP      R7,#+0
   \   00000084   0xD112             BNE.N    ??f_lseek_7
   3107          					clst = create_chain(fp->fs, 0);
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x.... 0x....      BL       create_chain
   \   0000008E   0x0007             MOVS     R7,R0
   3108          					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   00000090   0x2F01             CMP      R7,#+1
   \   00000092   0xD103             BNE.N    ??f_lseek_8
   \   00000094   0x2002             MOVS     R0,#+2
   \   00000096   0x71E0             STRB     R0,[R4, #+7]
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0xE08C             B.N      ??f_lseek_1
   3109          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_8:
   \   0000009C   0xF117 0x0F01      CMN      R7,#+1
   \   000000A0   0xD103             BNE.N    ??f_lseek_9
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x71E0             STRB     R0,[R4, #+7]
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xE085             B.N      ??f_lseek_1
   3110          					fp->sclust = clst;
   \                     ??f_lseek_9:
   \   000000AA   0x6127             STR      R7,[R4, #+16]
   3111          				}
   3112          #endif
   3113          				fp->clust = clst;
   \                     ??f_lseek_7:
   \   000000AC   0x6167             STR      R7,[R4, #+20]
   3114          			}
   3115          			if (clst != 0) {
   \                     ??f_lseek_6:
   \   000000AE   0x2F00             CMP      R7,#+0
   \   000000B0   0xD044             BEQ.N    ??f_lseek_4
   3116          				while (ofs > bcs) {						/* Cluster following loop */
   \                     ??f_lseek_10:
   \   000000B2   0x45A8             CMP      R8,R5
   \   000000B4   0xD229             BCS.N    ??f_lseek_11
   3117          #if !_FS_READONLY
   3118          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   \   000000B6   0x79A0             LDRB     R0,[R4, #+6]
   \   000000B8   0x0780             LSLS     R0,R0,#+30
   \   000000BA   0xD508             BPL.N    ??f_lseek_12
   3119          						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   \   000000BC   0x0039             MOVS     R1,R7
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x.... 0x....      BL       create_chain
   \   000000C4   0x0007             MOVS     R7,R0
   3120          						if (clst == 0) {				/* When disk gets full, clip file size */
   \   000000C6   0x2F00             CMP      R7,#+0
   \   000000C8   0xD106             BNE.N    ??f_lseek_13
   3121          							ofs = bcs; break;
   \   000000CA   0x4645             MOV      R5,R8
   \   000000CC   0xE01D             B.N      ??f_lseek_11
   3122          						}
   3123          					} else
   3124          #endif
   3125          						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   \                     ??f_lseek_12:
   \   000000CE   0x0039             MOVS     R1,R7
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x.... 0x....      BL       get_fat
   \   000000D6   0x0007             MOVS     R7,R0
   3126          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_13:
   \   000000D8   0xF117 0x0F01      CMN      R7,#+1
   \   000000DC   0xD103             BNE.N    ??f_lseek_14
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x71E0             STRB     R0,[R4, #+7]
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xE067             B.N      ??f_lseek_1
   3127          					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   \                     ??f_lseek_14:
   \   000000E6   0x2F02             CMP      R7,#+2
   \   000000E8   0xD303             BCC.N    ??f_lseek_15
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6980             LDR      R0,[R0, #+24]
   \   000000EE   0x4287             CMP      R7,R0
   \   000000F0   0xD303             BCC.N    ??f_lseek_16
   \                     ??f_lseek_15:
   \   000000F2   0x2002             MOVS     R0,#+2
   \   000000F4   0x71E0             STRB     R0,[R4, #+7]
   \   000000F6   0x2002             MOVS     R0,#+2
   \   000000F8   0xE05D             B.N      ??f_lseek_1
   3128          					fp->clust = clst;
   \                     ??f_lseek_16:
   \   000000FA   0x6167             STR      R7,[R4, #+20]
   3129          					fp->fptr += bcs;
   \   000000FC   0x68A0             LDR      R0,[R4, #+8]
   \   000000FE   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000102   0x60A0             STR      R0,[R4, #+8]
   3130          					ofs -= bcs;
   \   00000104   0xEBB5 0x0508      SUBS     R5,R5,R8
   \   00000108   0xE7D3             B.N      ??f_lseek_10
   3131          				}
   3132          				fp->fptr += ofs;
   \                     ??f_lseek_11:
   \   0000010A   0x68A0             LDR      R0,[R4, #+8]
   \   0000010C   0x1828             ADDS     R0,R5,R0
   \   0000010E   0x60A0             STR      R0,[R4, #+8]
   3133          				if (ofs % SS(fp->fs)) {
   \   00000110   0xF44F 0x7000      MOV      R0,#+512
   \   00000114   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   00000118   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   0000011C   0x2900             CMP      R1,#+0
   \   0000011E   0xD00D             BEQ.N    ??f_lseek_4
   3134          					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   00000120   0x0039             MOVS     R1,R7
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x.... 0x....      BL       clust2sect
   \   00000128   0x4681             MOV      R9,R0
   3135          					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   0000012A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000012E   0xD103             BNE.N    ??f_lseek_17
   \   00000130   0x2002             MOVS     R0,#+2
   \   00000132   0x71E0             STRB     R0,[R4, #+7]
   \   00000134   0x2002             MOVS     R0,#+2
   \   00000136   0xE03E             B.N      ??f_lseek_1
   3136          					nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_17:
   \   00000138   0xEB19 0x2955      ADDS     R9,R9,R5, LSR #+9
   3137          				}
   3138          			}
   3139          		}
   3140          		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   \                     ??f_lseek_4:
   \   0000013C   0x68A0             LDR      R0,[R4, #+8]
   \   0000013E   0xF44F 0x7100      MOV      R1,#+512
   \   00000142   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000146   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000014A   0x2A00             CMP      R2,#+0
   \   0000014C   0xD027             BEQ.N    ??f_lseek_18
   \   0000014E   0x69A0             LDR      R0,[R4, #+24]
   \   00000150   0x4581             CMP      R9,R0
   \   00000152   0xD024             BEQ.N    ??f_lseek_18
   3141          #if !_FS_TINY
   3142          #if !_FS_READONLY
   3143          			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   \   00000154   0x79A0             LDRB     R0,[R4, #+6]
   \   00000156   0x0640             LSLS     R0,R0,#+25
   \   00000158   0xD511             BPL.N    ??f_lseek_19
   3144          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0000015A   0x2301             MOVS     R3,#+1
   \   0000015C   0x69A2             LDR      R2,[R4, #+24]
   \   0000015E   0xF114 0x0124      ADDS     R1,R4,#+36
   \   00000162   0x6820             LDR      R0,[R4, #+0]
   \   00000164   0x7840             LDRB     R0,[R0, #+1]
   \   00000166   0x.... 0x....      BL       disk_write
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD003             BEQ.N    ??f_lseek_20
   3145          					ABORT(fp->fs, FR_DISK_ERR);
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0x71E0             STRB     R0,[R4, #+7]
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0xE01F             B.N      ??f_lseek_1
   3146          				fp->flag &= ~FA__DIRTY;
   \                     ??f_lseek_20:
   \   00000176   0x79A0             LDRB     R0,[R4, #+6]
   \   00000178   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000017C   0x71A0             STRB     R0,[R4, #+6]
   3147          			}
   3148          #endif
   3149          			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   \                     ??f_lseek_19:
   \   0000017E   0x2301             MOVS     R3,#+1
   \   00000180   0x464A             MOV      R2,R9
   \   00000182   0xF114 0x0124      ADDS     R1,R4,#+36
   \   00000186   0x6820             LDR      R0,[R4, #+0]
   \   00000188   0x7840             LDRB     R0,[R0, #+1]
   \   0000018A   0x.... 0x....      BL       disk_read
   \   0000018E   0x2800             CMP      R0,#+0
   \   00000190   0xD003             BEQ.N    ??f_lseek_21
   3150          				ABORT(fp->fs, FR_DISK_ERR);
   \   00000192   0x2001             MOVS     R0,#+1
   \   00000194   0x71E0             STRB     R0,[R4, #+7]
   \   00000196   0x2001             MOVS     R0,#+1
   \   00000198   0xE00D             B.N      ??f_lseek_1
   3151          #endif
   3152          			fp->dsect = nsect;
   \                     ??f_lseek_21:
   \   0000019A   0xF8C4 0x9018      STR      R9,[R4, #+24]
   3153          		}
   3154          #if !_FS_READONLY
   3155          		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   \                     ??f_lseek_18:
   \   0000019E   0x68E0             LDR      R0,[R4, #+12]
   \   000001A0   0x68A1             LDR      R1,[R4, #+8]
   \   000001A2   0x4288             CMP      R0,R1
   \   000001A4   0xD205             BCS.N    ??f_lseek_22
   3156          			fp->fsize = fp->fptr;
   \   000001A6   0x68A0             LDR      R0,[R4, #+8]
   \   000001A8   0x60E0             STR      R0,[R4, #+12]
   3157          			fp->flag |= FA__WRITTEN;
   \   000001AA   0x79A0             LDRB     R0,[R4, #+6]
   \   000001AC   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000001B0   0x71A0             STRB     R0,[R4, #+6]
   3158          		}
   3159          #endif
   3160          	}
   3161          
   3162          	LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_22:
   \   000001B2   0x0030             MOVS     R0,R6
   \   000001B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_lseek_1:
   \   000001B6   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   3163          }
   3164          
   3165          
   3166          
   3167          #if _FS_MINIMIZE <= 1
   3168          /*-----------------------------------------------------------------------*/
   3169          /* Create a Directory Object                                             */
   3170          /*-----------------------------------------------------------------------*/
   3171          

   \                                 In section .text, align 2, keep-with-next
   3172          FRESULT f_opendir (
   3173          	DIR* dp,			/* Pointer to directory object to create */
   3174          	const TCHAR* path	/* Pointer to the directory path */
   3175          )
   3176          {
   \                     f_opendir:
   \   00000000   0xB532             PUSH     {R1,R4,R5,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   3177          	FRESULT res;
   3178          	FATFS* fs;
   3179          	DEF_NAMEBUF;
   3180          
   3181          
   3182          	if (!dp) return FR_INVALID_OBJECT;
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??f_opendir_0
   \   0000000A   0x2009             MOVS     R0,#+9
   \   0000000C   0xE03D             B.N      ??f_opendir_1
   3183          
   3184          	/* Get logical drive number */
   3185          	res = find_volume(&fs, &path, 0);
   \                     ??f_opendir_0:
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xA904             ADD      R1,SP,#+16
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       find_volume
   \   00000018   0x0005             MOVS     R5,R0
   3186          	if (res == FR_OK) {
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD12D             BNE.N    ??f_opendir_2
   3187          		dp->fs = fs;
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x6020             STR      R0,[R4, #+0]
   3188          		INIT_BUF(*dp);
   \   00000024   0xA801             ADD      R0,SP,#+4
   \   00000026   0x61A0             STR      R0,[R4, #+24]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000002C   0x61E0             STR      R0,[R4, #+28]
   3189          		res = follow_path(dp, path);			/* Follow the path to the directory */
   \   0000002E   0x9904             LDR      R1,[SP, #+16]
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       follow_path
   \   00000036   0x0005             MOVS     R5,R0
   3190          		FREE_BUF();
   3191          		if (res == FR_OK) {						/* Follow completed */
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD119             BNE.N    ??f_opendir_3
   3192          			if (dp->dir) {						/* It is not the origin directory itself */
   \   0000003E   0x6960             LDR      R0,[R4, #+20]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD00B             BEQ.N    ??f_opendir_4
   3193          				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
   \   00000044   0x6960             LDR      R0,[R4, #+20]
   \   00000046   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000048   0x06C0             LSLS     R0,R0,#+27
   \   0000004A   0xD505             BPL.N    ??f_opendir_5
   3194          					dp->sclust = ld_clust(fs, dp->dir);
   \   0000004C   0x6961             LDR      R1,[R4, #+20]
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
   \   00000050   0x.... 0x....      BL       ld_clust
   \   00000054   0x60A0             STR      R0,[R4, #+8]
   \   00000056   0xE001             B.N      ??f_opendir_4
   3195          				else							/* The object is a file */
   3196          					res = FR_NO_PATH;
   \                     ??f_opendir_5:
   \   00000058   0x2005             MOVS     R0,#+5
   \   0000005A   0x0005             MOVS     R5,R0
   3197          			}
   3198          			if (res == FR_OK) {
   \                     ??f_opendir_4:
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD107             BNE.N    ??f_opendir_3
   3199          				dp->id = fs->id;
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x88C0             LDRH     R0,[R0, #+6]
   \   00000066   0x80A0             STRH     R0,[R4, #+4]
   3200          				res = dir_sdi(dp, 0);			/* Rewind directory */
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       dir_sdi
   \   00000070   0x0005             MOVS     R5,R0
   3201          #if _FS_LOCK
   3202          				if (res == FR_OK) {
   3203          					if (dp->sclust) {
   3204          						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
   3205          						if (!dp->lockid)
   3206          							res = FR_TOO_MANY_OPEN_FILES;
   3207          					} else {
   3208          						dp->lockid = 0;	/* Root directory need not to be locked */
   3209          					}
   3210          				}
   3211          #endif
   3212          			}
   3213          		}
   3214          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_opendir_3:
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0x2D04             CMP      R5,#+4
   \   00000076   0xD101             BNE.N    ??f_opendir_2
   \   00000078   0x2005             MOVS     R0,#+5
   \   0000007A   0x0005             MOVS     R5,R0
   3215          	}
   3216          	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
   \                     ??f_opendir_2:
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0x2D00             CMP      R5,#+0
   \   00000080   0xD001             BEQ.N    ??f_opendir_6
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x6020             STR      R0,[R4, #+0]
   3217          
   3218          	LEAVE_FF(fs, res);
   \                     ??f_opendir_6:
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_opendir_1:
   \   0000008A   0xB005             ADD      SP,SP,#+20
   \   0000008C   0xBD30             POP      {R4,R5,PC}       ;; return
   3219          }
   3220          
   3221          
   3222          
   3223          
   3224          /*-----------------------------------------------------------------------*/
   3225          /* Close Directory                                                       */
   3226          /*-----------------------------------------------------------------------*/
   3227          

   \                                 In section .text, align 2, keep-with-next
   3228          FRESULT f_closedir (
   3229          	DIR *dp		/* Pointer to the directory object to be closed */
   3230          )
   3231          {
   \                     f_closedir:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3232          	FRESULT res;
   3233          
   3234          
   3235          	res = validate(dp);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       validate
   \   0000000A   0x0005             MOVS     R5,R0
   3236          	if (res == FR_OK) {
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD101             BNE.N    ??f_closedir_0
   3237          #if _FS_REENTRANT
   3238          		FATFS *fs = dp->fs;
   3239          #endif
   3240          #if _FS_LOCK
   3241          		if (dp->lockid)				/* Decrement sub-directory open counter */
   3242          			res = dec_lock(dp->lockid);
   3243          		if (res == FR_OK)
   3244          #endif
   3245          			dp->fs = 0;				/* Invalidate directory object */
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6020             STR      R0,[R4, #+0]
   3246          #if _FS_REENTRANT
   3247          		unlock_fs(fs, FR_OK);		/* Unlock volume */
   3248          #endif
   3249          	}
   3250          	return res;
   \                     ??f_closedir_0:
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3251          }
   3252          
   3253          
   3254          
   3255          
   3256          /*-----------------------------------------------------------------------*/
   3257          /* Read Directory Entries in Sequence                                    */
   3258          /*-----------------------------------------------------------------------*/
   3259          

   \                                 In section .text, align 2, keep-with-next
   3260          FRESULT f_readdir (
   3261          	DIR* dp,			/* Pointer to the open directory object */
   3262          	FILINFO* fno		/* Pointer to file information to return */
   3263          )
   3264          {
   \                     f_readdir:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   3265          	FRESULT res;
   3266          	DEF_NAMEBUF;
   3267          
   3268          
   3269          	res = validate(dp);						/* Check validity of the object */
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       validate
   \   0000000E   0x0006             MOVS     R6,R0
   3270          	if (res == FR_OK) {
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD12B             BNE.N    ??f_readdir_0
   3271          		if (!fno) {
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD105             BNE.N    ??f_readdir_1
   3272          			res = dir_sdi(dp, 0);			/* Rewind the directory object */
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       dir_sdi
   \   00000022   0x0006             MOVS     R6,R0
   \   00000024   0xE023             B.N      ??f_readdir_0
   3273          		} else {
   3274          			INIT_BUF(*dp);
   \                     ??f_readdir_1:
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x61A0             STR      R0,[R4, #+24]
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000002E   0x61E0             STR      R0,[R4, #+28]
   3275          			res = dir_read(dp, 0);			/* Read an item */
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       dir_read
   \   00000038   0x0006             MOVS     R6,R0
   3276          			if (res == FR_NO_FILE) {		/* Reached end of directory */
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E04             CMP      R6,#+4
   \   0000003E   0xD103             BNE.N    ??f_readdir_2
   3277          				dp->sect = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6120             STR      R0,[R4, #+16]
   3278          				res = FR_OK;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0006             MOVS     R6,R0
   3279          			}
   3280          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_2:
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xD10F             BNE.N    ??f_readdir_0
   3281          				get_fileinfo(dp, fno);		/* Get the object information */
   \   0000004E   0x0029             MOVS     R1,R5
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       get_fileinfo
   3282          				res = dir_next(dp, 0);		/* Increment index for next */
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       dir_next
   \   0000005E   0x0006             MOVS     R6,R0
   3283          				if (res == FR_NO_FILE) {
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x2E04             CMP      R6,#+4
   \   00000064   0xD103             BNE.N    ??f_readdir_0
   3284          					dp->sect = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x6120             STR      R0,[R4, #+16]
   3285          					res = FR_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x0006             MOVS     R6,R0
   3286          				}
   3287          			}
   3288          			FREE_BUF();
   3289          		}
   3290          	}
   3291          
   3292          	LEAVE_FF(dp->fs, res);
   \                     ??f_readdir_0:
   \   0000006E   0x0030             MOVS     R0,R6
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xB004             ADD      SP,SP,#+16
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return
   3293          }
   3294          
   3295          
   3296          
   3297          #if _FS_MINIMIZE == 0
   3298          /*-----------------------------------------------------------------------*/
   3299          /* Get File Status                                                       */
   3300          /*-----------------------------------------------------------------------*/
   3301          

   \                                 In section .text, align 2, keep-with-next
   3302          FRESULT f_stat (
   3303          	const TCHAR* path,	/* Pointer to the file path */
   3304          	FILINFO* fno		/* Pointer to file information to return */
   3305          )
   3306          {
   \                     f_stat:
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x000C             MOVS     R4,R1
   3307          	FRESULT res;
   3308          	DIR dj;
   3309          	DEF_NAMEBUF;
   3310          
   3311          
   3312          	/* Get logical drive number */
   3313          	res = find_volume(&dj.fs, &path, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA90C             ADD      R1,SP,#+48
   \   0000000A   0xA803             ADD      R0,SP,#+12
   \   0000000C   0x.... 0x....      BL       find_volume
   \   00000010   0x0005             MOVS     R5,R0
   3314          	if (res == FR_OK) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD117             BNE.N    ??f_stat_0
   3315          		INIT_BUF(dj);
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x9009             STR      R0,[SP, #+36]
   \   0000001C   0x....             LDR.N    R0,??DataTable12
   \   0000001E   0x900A             STR      R0,[SP, #+40]
   3316          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000020   0x990C             LDR      R1,[SP, #+48]
   \   00000022   0xA803             ADD      R0,SP,#+12
   \   00000024   0x.... 0x....      BL       follow_path
   \   00000028   0x0005             MOVS     R5,R0
   3317          		if (res == FR_OK) {				/* Follow completed */
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD10B             BNE.N    ??f_stat_0
   3318          			if (dj.dir) {		/* Found an object */
   \   00000030   0x9808             LDR      R0,[SP, #+32]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD006             BEQ.N    ??f_stat_1
   3319          				if (fno) get_fileinfo(&dj, fno);
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD006             BEQ.N    ??f_stat_0
   \   0000003A   0x0021             MOVS     R1,R4
   \   0000003C   0xA803             ADD      R0,SP,#+12
   \   0000003E   0x.... 0x....      BL       get_fileinfo
   \   00000042   0xE001             B.N      ??f_stat_0
   3320          			} else {			/* It is root directory */
   3321          				res = FR_INVALID_NAME;
   \                     ??f_stat_1:
   \   00000044   0x2006             MOVS     R0,#+6
   \   00000046   0x0005             MOVS     R5,R0
   3322          			}
   3323          		}
   3324          		FREE_BUF();
   3325          	}
   3326          
   3327          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0:
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xB00D             ADD      SP,SP,#+52
   \   0000004E   0xBD30             POP      {R4,R5,PC}       ;; return
   3328          }
   3329          
   3330          
   3331          
   3332          #if !_FS_READONLY
   3333          /*-----------------------------------------------------------------------*/
   3334          /* Get Number of Free Clusters                                           */
   3335          /*-----------------------------------------------------------------------*/
   3336          

   \                                 In section .text, align 2, keep-with-next
   3337          FRESULT f_getfree (
   3338          	const TCHAR* path,	/* Path name of the logical drive number */
   3339          	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
   3340          	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
   3341          )
   3342          {
   \                     f_getfree:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   3343          	FRESULT res;
   3344          	FATFS *fs;
   3345          	DWORD n, clst, sect, stat;
   3346          	UINT i;
   3347          	BYTE fat, *p;
   3348          
   3349          
   3350          	/* Get logical drive number */
   3351          	res = find_volume(fatfs, &path, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA902             ADD      R1,SP,#+8
   \   0000000A   0x9804             LDR      R0,[SP, #+16]
   \   0000000C   0x.... 0x....      BL       find_volume
   \   00000010   0x0004             MOVS     R4,R0
   3352          	fs = *fatfs;
   \   00000012   0x9804             LDR      R0,[SP, #+16]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0005             MOVS     R5,R0
   3353          	if (res == FR_OK) {
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD17A             BNE.N    ??f_getfree_0
   3354          		/* If free_clust is valid, return it without full cluster scan */
   3355          		if (fs->free_clust <= fs->n_fatent - 2) {
   \   0000001E   0x69A8             LDR      R0,[R5, #+24]
   \   00000020   0x1E80             SUBS     R0,R0,#+2
   \   00000022   0x6929             LDR      R1,[R5, #+16]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD303             BCC.N    ??f_getfree_1
   3356          			*nclst = fs->free_clust;
   \   00000028   0x6928             LDR      R0,[R5, #+16]
   \   0000002A   0x9903             LDR      R1,[SP, #+12]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   \   0000002E   0xE071             B.N      ??f_getfree_0
   3357          		} else {
   3358          			/* Get number of free clusters */
   3359          			fat = fs->fs_type;
   \                     ??f_getfree_1:
   \   00000030   0x7828             LDRB     R0,[R5, #+0]
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3360          			n = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0006             MOVS     R6,R0
   3361          			if (fat == FS_FAT12) {
   \   0000003A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD11B             BNE.N    ??f_getfree_2
   3362          				clst = 2;
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x0007             MOVS     R7,R0
   3363          				do {
   3364          					stat = get_fat(fs, clst);
   \                     ??f_getfree_3:
   \   00000046   0x0039             MOVS     R1,R7
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       get_fat
   \   0000004E   0x4681             MOV      R9,R0
   3365          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   00000050   0xF119 0x0F01      CMN      R9,#+1
   \   00000054   0xD102             BNE.N    ??f_getfree_4
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x0004             MOVS     R4,R0
   \   0000005A   0xE054             B.N      ??f_getfree_5
   3366          					if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_4:
   \   0000005C   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000060   0xD102             BNE.N    ??f_getfree_6
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x0004             MOVS     R4,R0
   \   00000066   0xE04E             B.N      ??f_getfree_5
   3367          					if (stat == 0) n++;
   \                     ??f_getfree_6:
   \   00000068   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000006C   0xD100             BNE.N    ??f_getfree_7
   \   0000006E   0x1C76             ADDS     R6,R6,#+1
   3368          				} while (++clst < fs->n_fatent);
   \                     ??f_getfree_7:
   \   00000070   0x1C7F             ADDS     R7,R7,#+1
   \   00000072   0x69A8             LDR      R0,[R5, #+24]
   \   00000074   0x4287             CMP      R7,R0
   \   00000076   0xD3E6             BCC.N    ??f_getfree_3
   \   00000078   0xE045             B.N      ??f_getfree_5
   3369          			} else {
   3370          				clst = fs->n_fatent;
   \                     ??f_getfree_2:
   \   0000007A   0x69A8             LDR      R0,[R5, #+24]
   \   0000007C   0x0007             MOVS     R7,R0
   3371          				sect = fs->fatbase;
   \   0000007E   0x6A68             LDR      R0,[R5, #+36]
   \   00000080   0x4680             MOV      R8,R0
   3372          				i = 0; p = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x4682             MOV      R10,R0
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x4683             MOV      R11,R0
   3373          				do {
   3374          					if (!i) {
   \                     ??f_getfree_8:
   \   0000008A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000008E   0xD10F             BNE.N    ??f_getfree_9
   3375          						res = move_window(fs, sect++);
   \   00000090   0x4641             MOV      R1,R8
   \   00000092   0x0028             MOVS     R0,R5
   \   00000094   0x.... 0x....      BL       move_window
   \   00000098   0x0004             MOVS     R4,R0
   \   0000009A   0xF118 0x0801      ADDS     R8,R8,#+1
   3376          						if (res != FR_OK) break;
   \   0000009E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A0   0x2C00             CMP      R4,#+0
   \   000000A2   0xD130             BNE.N    ??f_getfree_5
   3377          						p = fs->win;
   \                     ??f_getfree_10:
   \   000000A4   0xF115 0x0034      ADDS     R0,R5,#+52
   \   000000A8   0x4683             MOV      R11,R0
   3378          						i = SS(fs);
   \   000000AA   0xF44F 0x7000      MOV      R0,#+512
   \   000000AE   0x4682             MOV      R10,R0
   3379          					}
   3380          					if (fat == FS_FAT16) {
   \                     ??f_getfree_9:
   \   000000B0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B4   0x2802             CMP      R0,#+2
   \   000000B6   0xD10E             BNE.N    ??f_getfree_11
   3381          						if (LD_WORD(p) == 0) n++;
   \   000000B8   0xF89B 0x0001      LDRB     R0,[R11, #+1]
   \   000000BC   0xF89B 0x1000      LDRB     R1,[R11, #+0]
   \   000000C0   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000C4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD100             BNE.N    ??f_getfree_12
   \   000000CA   0x1C76             ADDS     R6,R6,#+1
   3382          						p += 2; i -= 2;
   \                     ??f_getfree_12:
   \   000000CC   0xF11B 0x0B02      ADDS     R11,R11,#+2
   \   000000D0   0xF1BA 0x0A02      SUBS     R10,R10,#+2
   \   000000D4   0xE014             B.N      ??f_getfree_13
   3383          					} else {
   3384          						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_11:
   \   000000D6   0xF89B 0x0003      LDRB     R0,[R11, #+3]
   \   000000DA   0xF89B 0x1002      LDRB     R1,[R11, #+2]
   \   000000DE   0x0409             LSLS     R1,R1,#+16
   \   000000E0   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000000E4   0xF89B 0x1001      LDRB     R1,[R11, #+1]
   \   000000E8   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000EC   0xF89B 0x1000      LDRB     R1,[R11, #+0]
   \   000000F0   0x4308             ORRS     R0,R1,R0
   \   000000F2   0x0100             LSLS     R0,R0,#+4
   \   000000F4   0xD100             BNE.N    ??f_getfree_14
   \   000000F6   0x1C76             ADDS     R6,R6,#+1
   3385          						p += 4; i -= 4;
   \                     ??f_getfree_14:
   \   000000F8   0xF11B 0x0B04      ADDS     R11,R11,#+4
   \   000000FC   0xF1BA 0x0A04      SUBS     R10,R10,#+4
   3386          					}
   3387          				} while (--clst);
   \                     ??f_getfree_13:
   \   00000100   0x1E7F             SUBS     R7,R7,#+1
   \   00000102   0x2F00             CMP      R7,#+0
   \   00000104   0xD1C1             BNE.N    ??f_getfree_8
   3388          			}
   3389          			fs->free_clust = n;
   \                     ??f_getfree_5:
   \   00000106   0x612E             STR      R6,[R5, #+16]
   3390          			fs->fsi_flag |= 1;
   \   00000108   0x7968             LDRB     R0,[R5, #+5]
   \   0000010A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000010E   0x7168             STRB     R0,[R5, #+5]
   3391          			*nclst = n;
   \   00000110   0x9803             LDR      R0,[SP, #+12]
   \   00000112   0x6006             STR      R6,[R0, #+0]
   3392          		}
   3393          	}
   3394          	LEAVE_FF(fs, res);
   \                     ??f_getfree_0:
   \   00000114   0x0020             MOVS     R0,R4
   \   00000116   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000118   0xB005             ADD      SP,SP,#+20
   \   0000011A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   3395          }
   3396          
   3397          
   3398          
   3399          
   3400          /*-----------------------------------------------------------------------*/
   3401          /* Truncate File                                                         */
   3402          /*-----------------------------------------------------------------------*/
   3403          

   \                                 In section .text, align 2, keep-with-next
   3404          FRESULT f_truncate (
   3405          	FIL* fp		/* Pointer to the file object */
   3406          )
   3407          {
   \                     f_truncate:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3408          	FRESULT res;
   3409          	DWORD ncl;
   3410          
   3411          
   3412          	res = validate(fp);						/* Check validity of the object */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       validate
   \   0000000A   0x0005             MOVS     R5,R0
   3413          	if (res == FR_OK) {
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD10A             BNE.N    ??f_truncate_0
   3414          		if (fp->err) {						/* Check error */
   \   00000012   0x79E0             LDRB     R0,[R4, #+7]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??f_truncate_1
   3415          			res = (FRESULT)fp->err;
   \   00000018   0x79E0             LDRB     R0,[R4, #+7]
   \   0000001A   0x0005             MOVS     R5,R0
   \   0000001C   0xE004             B.N      ??f_truncate_0
   3416          		} else {
   3417          			if (!(fp->flag & FA_WRITE))		/* Check access mode */
   \                     ??f_truncate_1:
   \   0000001E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000020   0x0780             LSLS     R0,R0,#+30
   \   00000022   0xD401             BMI.N    ??f_truncate_0
   3418          				res = FR_DENIED;
   \   00000024   0x2007             MOVS     R0,#+7
   \   00000026   0x0005             MOVS     R5,R0
   3419          		}
   3420          	}
   3421          	if (res == FR_OK) {
   \                     ??f_truncate_0:
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD155             BNE.N    ??f_truncate_2
   3422          		if (fp->fsize > fp->fptr) {
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0x68E1             LDR      R1,[R4, #+12]
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD24D             BCS.N    ??f_truncate_3
   3423          			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \   00000036   0x68A0             LDR      R0,[R4, #+8]
   \   00000038   0x60E0             STR      R0,[R4, #+12]
   3424          			fp->flag |= FA__WRITTEN;
   \   0000003A   0x79A0             LDRB     R0,[R4, #+6]
   \   0000003C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000040   0x71A0             STRB     R0,[R4, #+6]
   3425          			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   00000042   0x68A0             LDR      R0,[R4, #+8]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD107             BNE.N    ??f_truncate_4
   3426          				res = remove_chain(fp->fs, fp->sclust);
   \   00000048   0x6921             LDR      R1,[R4, #+16]
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       remove_chain
   \   00000050   0x0005             MOVS     R5,R0
   3427          				fp->sclust = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6120             STR      R0,[R4, #+16]
   \   00000056   0xE025             B.N      ??f_truncate_5
   3428          			} else {				/* When truncate a part of the file, remove remaining clusters */
   3429          				ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_4:
   \   00000058   0x6961             LDR      R1,[R4, #+20]
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x.... 0x....      BL       get_fat
   \   00000060   0x0006             MOVS     R6,R0
   3430          				res = FR_OK;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x0005             MOVS     R5,R0
   3431          				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   00000066   0xF116 0x0F01      CMN      R6,#+1
   \   0000006A   0xD101             BNE.N    ??f_truncate_6
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x0005             MOVS     R5,R0
   3432          				if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_6:
   \   00000070   0x2E01             CMP      R6,#+1
   \   00000072   0xD101             BNE.N    ??f_truncate_7
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0x0005             MOVS     R5,R0
   3433          				if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \                     ??f_truncate_7:
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0x2D00             CMP      R5,#+0
   \   0000007C   0xD112             BNE.N    ??f_truncate_5
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6980             LDR      R0,[R0, #+24]
   \   00000082   0x4286             CMP      R6,R0
   \   00000084   0xD20E             BCS.N    ??f_truncate_5
   3434          					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \   00000086   0xF07F 0x4270      MVNS     R2,#-268435456
   \   0000008A   0x6961             LDR      R1,[R4, #+20]
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x.... 0x....      BL       put_fat
   \   00000092   0x0005             MOVS     R5,R0
   3435          					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   00000094   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000096   0x2D00             CMP      R5,#+0
   \   00000098   0xD104             BNE.N    ??f_truncate_5
   \   0000009A   0x0031             MOVS     R1,R6
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x.... 0x....      BL       remove_chain
   \   000000A2   0x0005             MOVS     R5,R0
   3436          				}
   3437          			}
   3438          #if !_FS_TINY
   3439          			if (res == FR_OK && (fp->flag & FA__DIRTY)) {
   \                     ??f_truncate_5:
   \   000000A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A6   0x2D00             CMP      R5,#+0
   \   000000A8   0xD113             BNE.N    ??f_truncate_3
   \   000000AA   0x79A0             LDRB     R0,[R4, #+6]
   \   000000AC   0x0640             LSLS     R0,R0,#+25
   \   000000AE   0xD510             BPL.N    ??f_truncate_3
   3440          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   000000B0   0x2301             MOVS     R3,#+1
   \   000000B2   0x69A2             LDR      R2,[R4, #+24]
   \   000000B4   0xF114 0x0124      ADDS     R1,R4,#+36
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x7840             LDRB     R0,[R0, #+1]
   \   000000BC   0x.... 0x....      BL       disk_write
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD002             BEQ.N    ??f_truncate_8
   3441          					res = FR_DISK_ERR;
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x0005             MOVS     R5,R0
   \   000000C8   0xE003             B.N      ??f_truncate_3
   3442          				else
   3443          					fp->flag &= ~FA__DIRTY;
   \                     ??f_truncate_8:
   \   000000CA   0x79A0             LDRB     R0,[R4, #+6]
   \   000000CC   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000000D0   0x71A0             STRB     R0,[R4, #+6]
   3444          			}
   3445          #endif
   3446          		}
   3447          		if (res != FR_OK) fp->err = (FRESULT)res;
   \                     ??f_truncate_3:
   \   000000D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D4   0x2D00             CMP      R5,#+0
   \   000000D6   0xD000             BEQ.N    ??f_truncate_2
   \   000000D8   0x71E5             STRB     R5,[R4, #+7]
   3448          	}
   3449          
   3450          	LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_2:
   \   000000DA   0x0028             MOVS     R0,R5
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0xBD70             POP      {R4-R6,PC}       ;; return
   3451          }
   3452          
   3453          
   3454          
   3455          
   3456          /*-----------------------------------------------------------------------*/
   3457          /* Delete a File or Directory                                            */
   3458          /*-----------------------------------------------------------------------*/
   3459          

   \                                 In section .text, align 2, keep-with-next
   3460          FRESULT f_unlink (
   3461          	const TCHAR* path		/* Pointer to the file or directory path */
   3462          )
   3463          {
   \                     f_unlink:
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB095             SUB      SP,SP,#+84
   3464          	FRESULT res;
   3465          	DIR dj, sdj;
   3466          	BYTE *dir;
   3467          	DWORD dclst = 0;
   \   00000004   0x2600             MOVS     R6,#+0
   3468          	DEF_NAMEBUF;
   3469          
   3470          
   3471          	/* Get logical drive number */
   3472          	res = find_volume(&dj.fs, &path, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA915             ADD      R1,SP,#+84
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x.... 0x....      BL       find_volume
   \   00000010   0x0004             MOVS     R4,R0
   3473          	if (res == FR_OK) {
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD169             BNE.N    ??f_unlink_0
   3474          		INIT_BUF(dj);
   \   00000018   0xA809             ADD      R0,SP,#+36
   \   0000001A   0x9006             STR      R0,[SP, #+24]
   \   0000001C   0x....             LDR.N    R0,??DataTable12
   \   0000001E   0x9007             STR      R0,[SP, #+28]
   3475          		res = follow_path(&dj, path);		/* Follow the file path */
   \   00000020   0x9915             LDR      R1,[SP, #+84]
   \   00000022   0xA800             ADD      R0,SP,#+0
   \   00000024   0x.... 0x....      BL       follow_path
   \   00000028   0x0004             MOVS     R4,R0
   3476          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD105             BNE.N    ??f_unlink_1
   \   00000030   0x9806             LDR      R0,[SP, #+24]
   \   00000032   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000034   0x0680             LSLS     R0,R0,#+26
   \   00000036   0xD501             BPL.N    ??f_unlink_1
   3477          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   \   00000038   0x2006             MOVS     R0,#+6
   \   0000003A   0x0004             MOVS     R4,R0
   3478          #if _FS_LOCK
   3479          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open object */
   3480          #endif
   3481          		if (res == FR_OK) {					/* The object is accessible */
   \                     ??f_unlink_1:
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD154             BNE.N    ??f_unlink_0
   3482          			dir = dj.dir;
   \   00000042   0x9805             LDR      R0,[SP, #+20]
   \   00000044   0x0005             MOVS     R5,R0
   3483          			if (!dir) {
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD102             BNE.N    ??f_unlink_2
   3484          				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
   \   0000004A   0x2006             MOVS     R0,#+6
   \   0000004C   0x0004             MOVS     R4,R0
   \   0000004E   0xE004             B.N      ??f_unlink_3
   3485          			} else {
   3486          				if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_2:
   \   00000050   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000052   0x07C0             LSLS     R0,R0,#+31
   \   00000054   0xD501             BPL.N    ??f_unlink_3
   3487          					res = FR_DENIED;		/* Cannot remove R/O object */
   \   00000056   0x2007             MOVS     R0,#+7
   \   00000058   0x0004             MOVS     R4,R0
   3488          			}
   3489          			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
   \                     ??f_unlink_3:
   \   0000005A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005C   0x2C00             CMP      R4,#+0
   \   0000005E   0xD12D             BNE.N    ??f_unlink_4
   \   00000060   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000062   0x06C0             LSLS     R0,R0,#+27
   \   00000064   0xD52A             BPL.N    ??f_unlink_4
   3490          				dclst = ld_clust(dj.fs, dir);
   \   00000066   0x0029             MOVS     R1,R5
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0x.... 0x....      BL       ld_clust
   \   0000006E   0x0006             MOVS     R6,R0
   3491          				if (!dclst) {
   \   00000070   0x2E00             CMP      R6,#+0
   \   00000072   0xD102             BNE.N    ??f_unlink_5
   3492          					res = FR_INT_ERR;
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0x0004             MOVS     R4,R0
   \   00000078   0xE020             B.N      ??f_unlink_4
   3493          				} else {					/* Make sure the sub-directory is empty */
   3494          					mem_cpy(&sdj, &dj, sizeof (DIR));
   \                     ??f_unlink_5:
   \   0000007A   0x2224             MOVS     R2,#+36
   \   0000007C   0xA900             ADD      R1,SP,#+0
   \   0000007E   0xA80C             ADD      R0,SP,#+48
   \   00000080   0x.... 0x....      BL       mem_cpy
   3495          					sdj.sclust = dclst;
   \   00000084   0x960E             STR      R6,[SP, #+56]
   3496          					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
   \   00000086   0x2102             MOVS     R1,#+2
   \   00000088   0xA80C             ADD      R0,SP,#+48
   \   0000008A   0x.... 0x....      BL       dir_sdi
   \   0000008E   0x0004             MOVS     R4,R0
   3497          					if (res == FR_OK) {
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0x2C00             CMP      R4,#+0
   \   00000094   0xD112             BNE.N    ??f_unlink_4
   3498          						res = dir_read(&sdj, 0);	/* Read an item */
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0xA80C             ADD      R0,SP,#+48
   \   0000009A   0x.... 0x....      BL       dir_read
   \   0000009E   0x0004             MOVS     R4,R0
   3499          						if (res == FR_OK		/* Not empty directory */
   3500          #if _FS_RPATH
   3501          						|| dclst == dj.fs->cdir	/* or current directory */
   3502          #endif
   3503          						) res = FR_DENIED;
   \   000000A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A2   0x2C00             CMP      R4,#+0
   \   000000A4   0xD003             BEQ.N    ??f_unlink_6
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0x6940             LDR      R0,[R0, #+20]
   \   000000AA   0x4286             CMP      R6,R0
   \   000000AC   0xD101             BNE.N    ??f_unlink_7
   \                     ??f_unlink_6:
   \   000000AE   0x2007             MOVS     R0,#+7
   \   000000B0   0x0004             MOVS     R4,R0
   3504          						if (res == FR_NO_FILE) res = FR_OK;	/* It is empty */
   \                     ??f_unlink_7:
   \   000000B2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B4   0x2C04             CMP      R4,#+4
   \   000000B6   0xD101             BNE.N    ??f_unlink_4
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x0004             MOVS     R4,R0
   3505          					}
   3506          				}
   3507          			}
   3508          			if (res == FR_OK) {
   \                     ??f_unlink_4:
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x2C00             CMP      R4,#+0
   \   000000C0   0xD114             BNE.N    ??f_unlink_0
   3509          				res = dir_remove(&dj);		/* Remove the directory entry */
   \   000000C2   0xA800             ADD      R0,SP,#+0
   \   000000C4   0x.... 0x....      BL       dir_remove
   \   000000C8   0x0004             MOVS     R4,R0
   3510          				if (res == FR_OK && dclst)	/* Remove the cluster chain if exist */
   \   000000CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CC   0x2C00             CMP      R4,#+0
   \   000000CE   0xD106             BNE.N    ??f_unlink_8
   \   000000D0   0x2E00             CMP      R6,#+0
   \   000000D2   0xD004             BEQ.N    ??f_unlink_8
   3511          					res = remove_chain(dj.fs, dclst);
   \   000000D4   0x0031             MOVS     R1,R6
   \   000000D6   0x9800             LDR      R0,[SP, #+0]
   \   000000D8   0x.... 0x....      BL       remove_chain
   \   000000DC   0x0004             MOVS     R4,R0
   3512          				if (res == FR_OK) res = sync_fs(dj.fs);
   \                     ??f_unlink_8:
   \   000000DE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E0   0x2C00             CMP      R4,#+0
   \   000000E2   0xD103             BNE.N    ??f_unlink_0
   \   000000E4   0x9800             LDR      R0,[SP, #+0]
   \   000000E6   0x.... 0x....      BL       sync_fs
   \   000000EA   0x0004             MOVS     R4,R0
   3513          			}
   3514          		}
   3515          		FREE_BUF();
   3516          	}
   3517          
   3518          	LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_0:
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0xB016             ADD      SP,SP,#+88
   \   000000F2   0xBD70             POP      {R4-R6,PC}       ;; return
   3519          }
   3520          
   3521          
   3522          
   3523          
   3524          /*-----------------------------------------------------------------------*/
   3525          /* Create a Directory                                                    */
   3526          /*-----------------------------------------------------------------------*/
   3527          

   \                                 In section .text, align 2, keep-with-next
   3528          FRESULT f_mkdir (
   3529          	const TCHAR* path		/* Pointer to the directory path */
   3530          )
   3531          {
   \                     f_mkdir:
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   3532          	FRESULT res;
   3533          	DIR dj;
   3534          	BYTE *dir, n;
   3535          	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
   \   00000006   0x.... 0x....      BL       get_fattime
   \   0000000A   0x4682             MOV      R10,R0
   3536          	DEF_NAMEBUF;
   3537          
   3538          
   3539          	/* Get logical drive number */
   3540          	res = find_volume(&dj.fs, &path, 1);
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xA90D             ADD      R1,SP,#+52
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       find_volume
   \   00000016   0x0004             MOVS     R4,R0
   3541          	if (res == FR_OK) {
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xF040 0x80C2      BNE.W    ??f_mkdir_0
   3542          		INIT_BUF(dj);
   \   00000020   0xA809             ADD      R0,SP,#+36
   \   00000022   0x9006             STR      R0,[SP, #+24]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000028   0x9007             STR      R0,[SP, #+28]
   3543          		res = follow_path(&dj, path);			/* Follow the file path */
   \   0000002A   0x990D             LDR      R1,[SP, #+52]
   \   0000002C   0xA800             ADD      R0,SP,#+0
   \   0000002E   0x.... 0x....      BL       follow_path
   \   00000032   0x0004             MOVS     R4,R0
   3544          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD101             BNE.N    ??f_mkdir_1
   \   0000003A   0x2008             MOVS     R0,#+8
   \   0000003C   0x0004             MOVS     R4,R0
   3545          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
   \                     ??f_mkdir_1:
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x2C04             CMP      R4,#+4
   \   00000042   0xD105             BNE.N    ??f_mkdir_2
   \   00000044   0x9806             LDR      R0,[SP, #+24]
   \   00000046   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000048   0x0680             LSLS     R0,R0,#+26
   \   0000004A   0xD501             BPL.N    ??f_mkdir_2
   3546          			res = FR_INVALID_NAME;
   \   0000004C   0x2006             MOVS     R0,#+6
   \   0000004E   0x0004             MOVS     R4,R0
   3547          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   \                     ??f_mkdir_2:
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x2C04             CMP      R4,#+4
   \   00000054   0xF040 0x80A6      BNE.W    ??f_mkdir_0
   3548          			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0x.... 0x....      BL       create_chain
   \   00000060   0x4680             MOV      R8,R0
   3549          			res = FR_OK;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x0004             MOVS     R4,R0
   3550          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   \   00000066   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000006A   0xD101             BNE.N    ??f_mkdir_3
   \   0000006C   0x2007             MOVS     R0,#+7
   \   0000006E   0x0004             MOVS     R4,R0
   3551          			if (dcl == 1) res = FR_INT_ERR;
   \                     ??f_mkdir_3:
   \   00000070   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000074   0xD101             BNE.N    ??f_mkdir_4
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0x0004             MOVS     R4,R0
   3552          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \                     ??f_mkdir_4:
   \   0000007A   0xF118 0x0F01      CMN      R8,#+1
   \   0000007E   0xD101             BNE.N    ??f_mkdir_5
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x0004             MOVS     R4,R0
   3553          			if (res == FR_OK)					/* Flush FAT */
   \                     ??f_mkdir_5:
   \   00000084   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000086   0x2C00             CMP      R4,#+0
   \   00000088   0xD103             BNE.N    ??f_mkdir_6
   3554          				res = sync_window(dj.fs);
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x.... 0x....      BL       sync_window
   \   00000090   0x0004             MOVS     R4,R0
   3555          			if (res == FR_OK) {					/* Initialize the new directory table */
   \                     ??f_mkdir_6:
   \   00000092   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000094   0x2C00             CMP      R4,#+0
   \   00000096   0xD15B             BNE.N    ??f_mkdir_7
   3556          				dsc = clust2sect(dj.fs, dcl);
   \   00000098   0x4641             MOV      R1,R8
   \   0000009A   0x9800             LDR      R0,[SP, #+0]
   \   0000009C   0x.... 0x....      BL       clust2sect
   \   000000A0   0x0007             MOVS     R7,R0
   3557          				dir = dj.fs->win;
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x3034             ADDS     R0,R0,#+52
   \   000000A6   0x0005             MOVS     R5,R0
   3558          				mem_set(dir, 0, SS(dj.fs));
   \   000000A8   0xF44F 0x7200      MOV      R2,#+512
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x0028             MOVS     R0,R5
   \   000000B0   0x.... 0x....      BL       mem_set
   3559          				mem_set(dir+DIR_Name, ' ', 11);	/* Create "." entry */
   \   000000B4   0x220B             MOVS     R2,#+11
   \   000000B6   0x2120             MOVS     R1,#+32
   \   000000B8   0x0028             MOVS     R0,R5
   \   000000BA   0x.... 0x....      BL       mem_set
   3560          				dir[DIR_Name] = '.';
   \   000000BE   0x202E             MOVS     R0,#+46
   \   000000C0   0x7028             STRB     R0,[R5, #+0]
   3561          				dir[DIR_Attr] = AM_DIR;
   \   000000C2   0x2010             MOVS     R0,#+16
   \   000000C4   0x72E8             STRB     R0,[R5, #+11]
   3562          				ST_DWORD(dir+DIR_WrtTime, tm);
   \   000000C6   0xF885 0xA016      STRB     R10,[R5, #+22]
   \   000000CA   0x4650             MOV      R0,R10
   \   000000CC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CE   0x0A00             LSRS     R0,R0,#+8
   \   000000D0   0x75E8             STRB     R0,[R5, #+23]
   \   000000D2   0xEA5F 0x401A      LSRS     R0,R10,#+16
   \   000000D6   0x7628             STRB     R0,[R5, #+24]
   \   000000D8   0xEA5F 0x601A      LSRS     R0,R10,#+24
   \   000000DC   0x7668             STRB     R0,[R5, #+25]
   3563          				st_clust(dir, dcl);
   \   000000DE   0x4641             MOV      R1,R8
   \   000000E0   0x0028             MOVS     R0,R5
   \   000000E2   0x.... 0x....      BL       st_clust
   3564          				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
   \   000000E6   0x2220             MOVS     R2,#+32
   \   000000E8   0x0029             MOVS     R1,R5
   \   000000EA   0xF115 0x0020      ADDS     R0,R5,#+32
   \   000000EE   0x.... 0x....      BL       mem_cpy
   3565          				dir[SZ_DIR+1] = '.'; pcl = dj.sclust;
   \   000000F2   0x202E             MOVS     R0,#+46
   \   000000F4   0xF885 0x0021      STRB     R0,[R5, #+33]
   \   000000F8   0x9802             LDR      R0,[SP, #+8]
   \   000000FA   0x4681             MOV      R9,R0
   3566          				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   000000FC   0x9800             LDR      R0,[SP, #+0]
   \   000000FE   0x7800             LDRB     R0,[R0, #+0]
   \   00000100   0x2803             CMP      R0,#+3
   \   00000102   0xD105             BNE.N    ??f_mkdir_8
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   \   00000106   0x6A80             LDR      R0,[R0, #+40]
   \   00000108   0x4581             CMP      R9,R0
   \   0000010A   0xD101             BNE.N    ??f_mkdir_8
   3567          					pcl = 0;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x4681             MOV      R9,R0
   3568          				st_clust(dir+SZ_DIR, pcl);
   \                     ??f_mkdir_8:
   \   00000110   0x4649             MOV      R1,R9
   \   00000112   0xF115 0x0020      ADDS     R0,R5,#+32
   \   00000116   0x.... 0x....      BL       st_clust
   3569          				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   \   0000011A   0x9800             LDR      R0,[SP, #+0]
   \   0000011C   0x7880             LDRB     R0,[R0, #+2]
   \   0000011E   0x0006             MOVS     R6,R0
   \                     ??f_mkdir_9:
   \   00000120   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000122   0x2E00             CMP      R6,#+0
   \   00000124   0xD014             BEQ.N    ??f_mkdir_7
   3570          					dj.fs->winsect = dsc++;
   \   00000126   0x9800             LDR      R0,[SP, #+0]
   \   00000128   0x6307             STR      R7,[R0, #+48]
   \   0000012A   0x1C7F             ADDS     R7,R7,#+1
   3571          					dj.fs->wflag = 1;
   \   0000012C   0x9800             LDR      R0,[SP, #+0]
   \   0000012E   0x2101             MOVS     R1,#+1
   \   00000130   0x7101             STRB     R1,[R0, #+4]
   3572          					res = sync_window(dj.fs);
   \   00000132   0x9800             LDR      R0,[SP, #+0]
   \   00000134   0x.... 0x....      BL       sync_window
   \   00000138   0x0004             MOVS     R4,R0
   3573          					if (res != FR_OK) break;
   \   0000013A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013C   0x2C00             CMP      R4,#+0
   \   0000013E   0xD107             BNE.N    ??f_mkdir_7
   3574          					mem_set(dir, 0, SS(dj.fs));
   \                     ??f_mkdir_10:
   \   00000140   0xF44F 0x7200      MOV      R2,#+512
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0x0028             MOVS     R0,R5
   \   00000148   0x.... 0x....      BL       mem_set
   3575          				}
   \   0000014C   0x1E76             SUBS     R6,R6,#+1
   \   0000014E   0xE7E7             B.N      ??f_mkdir_9
   3576          			}
   3577          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   \                     ??f_mkdir_7:
   \   00000150   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000152   0x2C00             CMP      R4,#+0
   \   00000154   0xD103             BNE.N    ??f_mkdir_11
   \   00000156   0xA800             ADD      R0,SP,#+0
   \   00000158   0x.... 0x....      BL       dir_register
   \   0000015C   0x0004             MOVS     R4,R0
   3578          			if (res != FR_OK) {
   \                     ??f_mkdir_11:
   \   0000015E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000160   0x2C00             CMP      R4,#+0
   \   00000162   0xD004             BEQ.N    ??f_mkdir_12
   3579          				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   \   00000164   0x4641             MOV      R1,R8
   \   00000166   0x9800             LDR      R0,[SP, #+0]
   \   00000168   0x.... 0x....      BL       remove_chain
   \   0000016C   0xE01A             B.N      ??f_mkdir_0
   3580          			} else {
   3581          				dir = dj.dir;
   \                     ??f_mkdir_12:
   \   0000016E   0x9805             LDR      R0,[SP, #+20]
   \   00000170   0x0005             MOVS     R5,R0
   3582          				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   \   00000172   0x2010             MOVS     R0,#+16
   \   00000174   0x72E8             STRB     R0,[R5, #+11]
   3583          				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
   \   00000176   0xF885 0xA016      STRB     R10,[R5, #+22]
   \   0000017A   0x4650             MOV      R0,R10
   \   0000017C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000017E   0x0A00             LSRS     R0,R0,#+8
   \   00000180   0x75E8             STRB     R0,[R5, #+23]
   \   00000182   0xEA5F 0x401A      LSRS     R0,R10,#+16
   \   00000186   0x7628             STRB     R0,[R5, #+24]
   \   00000188   0xEA5F 0x601A      LSRS     R0,R10,#+24
   \   0000018C   0x7668             STRB     R0,[R5, #+25]
   3584          				st_clust(dir, dcl);					/* Table start cluster */
   \   0000018E   0x4641             MOV      R1,R8
   \   00000190   0x0028             MOVS     R0,R5
   \   00000192   0x.... 0x....      BL       st_clust
   3585          				dj.fs->wflag = 1;
   \   00000196   0x9800             LDR      R0,[SP, #+0]
   \   00000198   0x2101             MOVS     R1,#+1
   \   0000019A   0x7101             STRB     R1,[R0, #+4]
   3586          				res = sync_fs(dj.fs);
   \   0000019C   0x9800             LDR      R0,[SP, #+0]
   \   0000019E   0x.... 0x....      BL       sync_fs
   \   000001A2   0x0004             MOVS     R4,R0
   3587          			}
   3588          		}
   3589          		FREE_BUF();
   3590          	}
   3591          
   3592          	LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_0:
   \   000001A4   0x0020             MOVS     R0,R4
   \   000001A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A8   0xB00E             ADD      SP,SP,#+56
   \   000001AA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   3593          }
   3594          
   3595          
   3596          
   3597          
   3598          /*-----------------------------------------------------------------------*/
   3599          /* Change Attribute                                                      */
   3600          /*-----------------------------------------------------------------------*/
   3601          

   \                                 In section .text, align 2, keep-with-next
   3602          FRESULT f_chmod (
   3603          	const TCHAR* path,	/* Pointer to the file path */
   3604          	BYTE value,			/* Attribute bits */
   3605          	BYTE mask			/* Attribute mask to change */
   3606          )
   3607          {
   \                     f_chmod:
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
   3608          	FRESULT res;
   3609          	DIR dj;
   3610          	BYTE *dir;
   3611          	DEF_NAMEBUF;
   3612          
   3613          
   3614          	/* Get logical drive number */
   3615          	res = find_volume(&dj.fs, &path, 1);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xA90C             ADD      R1,SP,#+48
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       find_volume
   \   00000012   0x0006             MOVS     R6,R0
   3616          	if (res == FR_OK) {
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD12B             BNE.N    ??f_chmod_0
   3617          		INIT_BUF(dj);
   \   0000001A   0xA809             ADD      R0,SP,#+36
   \   0000001C   0x9006             STR      R0,[SP, #+24]
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000022   0x9007             STR      R0,[SP, #+28]
   3618          		res = follow_path(&dj, path);		/* Follow the file path */
   \   00000024   0x990C             LDR      R1,[SP, #+48]
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       follow_path
   \   0000002C   0x0006             MOVS     R6,R0
   3619          		FREE_BUF();
   3620          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD105             BNE.N    ??f_chmod_1
   \   00000034   0x9806             LDR      R0,[SP, #+24]
   \   00000036   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000038   0x0680             LSLS     R0,R0,#+26
   \   0000003A   0xD501             BPL.N    ??f_chmod_1
   3621          			res = FR_INVALID_NAME;
   \   0000003C   0x2006             MOVS     R0,#+6
   \   0000003E   0x0006             MOVS     R6,R0
   3622          		if (res == FR_OK) {
   \                     ??f_chmod_1:
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD115             BNE.N    ??f_chmod_0
   3623          			dir = dj.dir;
   \   00000046   0x9805             LDR      R0,[SP, #+20]
   \   00000048   0x0007             MOVS     R7,R0
   3624          			if (!dir) {						/* Is it a root directory? */
   \   0000004A   0x2F00             CMP      R7,#+0
   \   0000004C   0xD102             BNE.N    ??f_chmod_2
   3625          				res = FR_INVALID_NAME;
   \   0000004E   0x2006             MOVS     R0,#+6
   \   00000050   0x0006             MOVS     R6,R0
   \   00000052   0xE00E             B.N      ??f_chmod_0
   3626          			} else {						/* File or sub directory */
   3627          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_2:
   \   00000054   0xF015 0x0527      ANDS     R5,R5,#0x27
   3628          				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   \   00000058   0xEA15 0x0004      ANDS     R0,R5,R4
   \   0000005C   0x7AF9             LDRB     R1,[R7, #+11]
   \   0000005E   0x43A9             BICS     R1,R1,R5
   \   00000060   0x4308             ORRS     R0,R1,R0
   \   00000062   0x72F8             STRB     R0,[R7, #+11]
   3629          				dj.fs->wflag = 1;
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x7101             STRB     R1,[R0, #+4]
   3630          				res = sync_fs(dj.fs);
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0x.... 0x....      BL       sync_fs
   \   00000070   0x0006             MOVS     R6,R0
   3631          			}
   3632          		}
   3633          	}
   3634          
   3635          	LEAVE_FF(dj.fs, res);
   \                     ??f_chmod_0:
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0xB00D             ADD      SP,SP,#+52
   \   00000078   0xBDF0             POP      {R4-R7,PC}       ;; return
   3636          }
   3637          
   3638          
   3639          
   3640          
   3641          /*-----------------------------------------------------------------------*/
   3642          /* Rename File/Directory                                                 */
   3643          /*-----------------------------------------------------------------------*/
   3644          

   \                                 In section .text, align 2, keep-with-next
   3645          FRESULT f_rename (
   3646          	const TCHAR* path_old,	/* Pointer to the object to be renamed */
   3647          	const TCHAR* path_new	/* Pointer to the new name */
   3648          )
   3649          {
   \                     f_rename:
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0xB09C             SUB      SP,SP,#+112
   3650          	FRESULT res;
   3651          	DIR djo, djn;
   3652          	BYTE buf[21], *dir;
   3653          	DWORD dw;
   3654          	DEF_NAMEBUF;
   3655          
   3656          
   3657          	/* Get logical drive number of the source object */
   3658          	res = find_volume(&djo.fs, &path_old, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA91C             ADD      R1,SP,#+112
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      BL       find_volume
   \   0000000E   0x0004             MOVS     R4,R0
   3659          	if (res == FR_OK) {
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xF040 0x808F      BNE.W    ??f_rename_0
   3660          		djn.fs = djo.fs;
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x9012             STR      R0,[SP, #+72]
   3661          		INIT_BUF(djo);
   \   0000001C   0xA809             ADD      R0,SP,#+36
   \   0000001E   0x9006             STR      R0,[SP, #+24]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000024   0x9007             STR      R0,[SP, #+28]
   3662          		res = follow_path(&djo, path_old);		/* Check old object */
   \   00000026   0x991C             LDR      R1,[SP, #+112]
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       follow_path
   \   0000002E   0x0004             MOVS     R4,R0
   3663          		if (_FS_RPATH && res == FR_OK && (djo.fn[NSFLAG] & NS_DOT))
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD105             BNE.N    ??f_rename_1
   \   00000036   0x9806             LDR      R0,[SP, #+24]
   \   00000038   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000003A   0x0680             LSLS     R0,R0,#+26
   \   0000003C   0xD501             BPL.N    ??f_rename_1
   3664          			res = FR_INVALID_NAME;
   \   0000003E   0x2006             MOVS     R0,#+6
   \   00000040   0x0004             MOVS     R4,R0
   3665          #if _FS_LOCK
   3666          		if (res == FR_OK) res = chk_lock(&djo, 2);
   3667          #endif
   3668          		if (res == FR_OK) {						/* Old object is found */
   \                     ??f_rename_1:
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD176             BNE.N    ??f_rename_0
   3669          			if (!djo.dir) {						/* Is root dir? */
   \   00000048   0x9805             LDR      R0,[SP, #+20]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD102             BNE.N    ??f_rename_2
   3670          				res = FR_NO_FILE;
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x0004             MOVS     R4,R0
   \   00000052   0xE070             B.N      ??f_rename_0
   3671          			} else {
   3672          				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except name */
   \                     ??f_rename_2:
   \   00000054   0x2215             MOVS     R2,#+21
   \   00000056   0x9805             LDR      R0,[SP, #+20]
   \   00000058   0xF110 0x010B      ADDS     R1,R0,#+11
   \   0000005C   0xA80C             ADD      R0,SP,#+48
   \   0000005E   0x.... 0x....      BL       mem_cpy
   3673          				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
   \   00000062   0x2224             MOVS     R2,#+36
   \   00000064   0xA900             ADD      R1,SP,#+0
   \   00000066   0xA812             ADD      R0,SP,#+72
   \   00000068   0x.... 0x....      BL       mem_cpy
   3674          				if (get_ldnumber(&path_new) >= 0)		/* Snip drive number off and ignore it */
   \   0000006C   0xA81D             ADD      R0,SP,#+116
   \   0000006E   0x.... 0x....      BL       get_ldnumber
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD405             BMI.N    ??f_rename_3
   3675          					res = follow_path(&djn, path_new);	/* and make sure if new object name is not conflicting */
   \   00000076   0x991D             LDR      R1,[SP, #+116]
   \   00000078   0xA812             ADD      R0,SP,#+72
   \   0000007A   0x.... 0x....      BL       follow_path
   \   0000007E   0x0004             MOVS     R4,R0
   \   00000080   0xE001             B.N      ??f_rename_4
   3676          				else
   3677          					res = FR_INVALID_DRIVE;
   \                     ??f_rename_3:
   \   00000082   0x200B             MOVS     R0,#+11
   \   00000084   0x0004             MOVS     R4,R0
   3678          				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
   \                     ??f_rename_4:
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0x2C00             CMP      R4,#+0
   \   0000008A   0xD101             BNE.N    ??f_rename_5
   \   0000008C   0x2008             MOVS     R0,#+8
   \   0000008E   0x0004             MOVS     R4,R0
   3679          				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
   \                     ??f_rename_5:
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0x2C04             CMP      R4,#+4
   \   00000094   0xD14F             BNE.N    ??f_rename_0
   3680          /* Start of critical section that any interruption can cause a cross-link */
   3681          					res = dir_register(&djn);			/* Register the new entry */
   \   00000096   0xA812             ADD      R0,SP,#+72
   \   00000098   0x.... 0x....      BL       dir_register
   \   0000009C   0x0004             MOVS     R4,R0
   3682          					if (res == FR_OK) {
   \   0000009E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A0   0x2C00             CMP      R4,#+0
   \   000000A2   0xD148             BNE.N    ??f_rename_0
   3683          						dir = djn.dir;					/* Copy object information except name */
   \   000000A4   0x9817             LDR      R0,[SP, #+92]
   \   000000A6   0x0005             MOVS     R5,R0
   3684          						mem_cpy(dir+13, buf+2, 19);
   \   000000A8   0x2213             MOVS     R2,#+19
   \   000000AA   0xF10D 0x0132      ADD      R1,SP,#+50
   \   000000AE   0xF115 0x000D      ADDS     R0,R5,#+13
   \   000000B2   0x.... 0x....      BL       mem_cpy
   3685          						dir[DIR_Attr] = buf[0] | AM_ARC;
   \   000000B6   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \   000000BA   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000BE   0x72E8             STRB     R0,[R5, #+11]
   3686          						djo.fs->wflag = 1;
   \   000000C0   0x9800             LDR      R0,[SP, #+0]
   \   000000C2   0x2101             MOVS     R1,#+1
   \   000000C4   0x7101             STRB     R1,[R0, #+4]
   3687          						if ((dir[DIR_Attr] & AM_DIR) && djo.sclust != djn.sclust) {	/* Update .. entry in the directory if needed */
   \   000000C6   0x7AE8             LDRB     R0,[R5, #+11]
   \   000000C8   0x06C0             LSLS     R0,R0,#+27
   \   000000CA   0xD526             BPL.N    ??f_rename_6
   \   000000CC   0x9802             LDR      R0,[SP, #+8]
   \   000000CE   0x9914             LDR      R1,[SP, #+80]
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xD022             BEQ.N    ??f_rename_6
   3688          							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
   \   000000D4   0x0029             MOVS     R1,R5
   \   000000D6   0x9800             LDR      R0,[SP, #+0]
   \   000000D8   0x.... 0x....      BL       ld_clust
   \   000000DC   0x0001             MOVS     R1,R0
   \   000000DE   0x9800             LDR      R0,[SP, #+0]
   \   000000E0   0x.... 0x....      BL       clust2sect
   \   000000E4   0x0006             MOVS     R6,R0
   3689          							if (!dw) {
   \   000000E6   0x2E00             CMP      R6,#+0
   \   000000E8   0xD102             BNE.N    ??f_rename_7
   3690          								res = FR_INT_ERR;
   \   000000EA   0x2002             MOVS     R0,#+2
   \   000000EC   0x0004             MOVS     R4,R0
   \   000000EE   0xE014             B.N      ??f_rename_6
   3691          							} else {
   3692          								res = move_window(djo.fs, dw);
   \                     ??f_rename_7:
   \   000000F0   0x0031             MOVS     R1,R6
   \   000000F2   0x9800             LDR      R0,[SP, #+0]
   \   000000F4   0x.... 0x....      BL       move_window
   \   000000F8   0x0004             MOVS     R4,R0
   3693          								dir = djo.fs->win+SZ_DIR;	/* .. entry */
   \   000000FA   0x9800             LDR      R0,[SP, #+0]
   \   000000FC   0x3054             ADDS     R0,R0,#+84
   \   000000FE   0x0005             MOVS     R5,R0
   3694          								if (res == FR_OK && dir[1] == '.') {
   \   00000100   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000102   0x2C00             CMP      R4,#+0
   \   00000104   0xD109             BNE.N    ??f_rename_6
   \   00000106   0x7868             LDRB     R0,[R5, #+1]
   \   00000108   0x282E             CMP      R0,#+46
   \   0000010A   0xD106             BNE.N    ??f_rename_6
   3695          									st_clust(dir, djn.sclust);
   \   0000010C   0x9914             LDR      R1,[SP, #+80]
   \   0000010E   0x0028             MOVS     R0,R5
   \   00000110   0x.... 0x....      BL       st_clust
   3696          									djo.fs->wflag = 1;
   \   00000114   0x9800             LDR      R0,[SP, #+0]
   \   00000116   0x2101             MOVS     R1,#+1
   \   00000118   0x7101             STRB     R1,[R0, #+4]
   3697          								}
   3698          							}
   3699          						}
   3700          						if (res == FR_OK) {
   \                     ??f_rename_6:
   \   0000011A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011C   0x2C00             CMP      R4,#+0
   \   0000011E   0xD10A             BNE.N    ??f_rename_0
   3701          							res = dir_remove(&djo);		/* Remove old entry */
   \   00000120   0xA800             ADD      R0,SP,#+0
   \   00000122   0x.... 0x....      BL       dir_remove
   \   00000126   0x0004             MOVS     R4,R0
   3702          							if (res == FR_OK)
   \   00000128   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012A   0x2C00             CMP      R4,#+0
   \   0000012C   0xD103             BNE.N    ??f_rename_0
   3703          								res = sync_fs(djo.fs);
   \   0000012E   0x9800             LDR      R0,[SP, #+0]
   \   00000130   0x.... 0x....      BL       sync_fs
   \   00000134   0x0004             MOVS     R4,R0
   3704          						}
   3705          					}
   3706          /* End of critical section */
   3707          				}
   3708          			}
   3709          		}
   3710          		FREE_BUF();
   3711          	}
   3712          
   3713          	LEAVE_FF(djo.fs, res);
   \                     ??f_rename_0:
   \   00000136   0x0020             MOVS     R0,R4
   \   00000138   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013A   0xB01E             ADD      SP,SP,#+120
   \   0000013C   0xBD70             POP      {R4-R6,PC}       ;; return
   3714          }
   3715          
   3716          
   3717          
   3718          
   3719          /*-----------------------------------------------------------------------*/
   3720          /* Change Timestamp                                                      */
   3721          /*-----------------------------------------------------------------------*/
   3722          

   \                                 In section .text, align 2, keep-with-next
   3723          FRESULT f_utime (
   3724          	const TCHAR* path,	/* Pointer to the file/directory name */
   3725          	const FILINFO* fno	/* Pointer to the time stamp to be set */
   3726          )
   3727          {
   \                     f_utime:
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x000C             MOVS     R4,R1
   3728          	FRESULT res;
   3729          	DIR dj;
   3730          	BYTE *dir;
   3731          	DEF_NAMEBUF;
   3732          
   3733          
   3734          	/* Get logical drive number */
   3735          	res = find_volume(&dj.fs, &path, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA90D             ADD      R1,SP,#+52
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x.... 0x....      BL       find_volume
   \   00000010   0x0005             MOVS     R5,R0
   3736          	if (res == FR_OK) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD12F             BNE.N    ??f_utime_0
   3737          		INIT_BUF(dj);
   \   00000018   0xA809             ADD      R0,SP,#+36
   \   0000001A   0x9006             STR      R0,[SP, #+24]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000020   0x9007             STR      R0,[SP, #+28]
   3738          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000022   0x990D             LDR      R1,[SP, #+52]
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       follow_path
   \   0000002A   0x0005             MOVS     R5,R0
   3739          		FREE_BUF();
   3740          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD105             BNE.N    ??f_utime_1
   \   00000032   0x9806             LDR      R0,[SP, #+24]
   \   00000034   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000036   0x0680             LSLS     R0,R0,#+26
   \   00000038   0xD501             BPL.N    ??f_utime_1
   3741          			res = FR_INVALID_NAME;
   \   0000003A   0x2006             MOVS     R0,#+6
   \   0000003C   0x0005             MOVS     R5,R0
   3742          		if (res == FR_OK) {
   \                     ??f_utime_1:
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD119             BNE.N    ??f_utime_0
   3743          			dir = dj.dir;
   \   00000044   0x9805             LDR      R0,[SP, #+20]
   \   00000046   0x0006             MOVS     R6,R0
   3744          			if (!dir) {					/* Root directory */
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD102             BNE.N    ??f_utime_2
   3745          				res = FR_INVALID_NAME;
   \   0000004C   0x2006             MOVS     R0,#+6
   \   0000004E   0x0005             MOVS     R5,R0
   \   00000050   0xE012             B.N      ??f_utime_0
   3746          			} else {					/* File or sub-directory */
   3747          				ST_WORD(dir+DIR_WrtTime, fno->ftime);
   \                     ??f_utime_2:
   \   00000052   0x88E0             LDRH     R0,[R4, #+6]
   \   00000054   0x75B0             STRB     R0,[R6, #+22]
   \   00000056   0x88E0             LDRH     R0,[R4, #+6]
   \   00000058   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005A   0x0A00             LSRS     R0,R0,#+8
   \   0000005C   0x75F0             STRB     R0,[R6, #+23]
   3748          				ST_WORD(dir+DIR_WrtDate, fno->fdate);
   \   0000005E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000060   0x7630             STRB     R0,[R6, #+24]
   \   00000062   0x88A0             LDRH     R0,[R4, #+4]
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x0A00             LSRS     R0,R0,#+8
   \   00000068   0x7670             STRB     R0,[R6, #+25]
   3749          				dj.fs->wflag = 1;
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x7101             STRB     R1,[R0, #+4]
   3750          				res = sync_fs(dj.fs);
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x.... 0x....      BL       sync_fs
   \   00000076   0x0005             MOVS     R5,R0
   3751          			}
   3752          		}
   3753          	}
   3754          
   3755          	LEAVE_FF(dj.fs, res);
   \                     ??f_utime_0:
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0xB00E             ADD      SP,SP,#+56
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return
   3756          }
   3757          
   3758          #endif /* !_FS_READONLY */
   3759          #endif /* _FS_MINIMIZE == 0 */
   3760          #endif /* _FS_MINIMIZE <= 1 */
   3761          #endif /* _FS_MINIMIZE <= 2 */
   3762          
   3763          
   3764          
   3765          #if _USE_LABEL
   3766          /*-----------------------------------------------------------------------*/
   3767          /* Get volume label                                                      */
   3768          /*-----------------------------------------------------------------------*/
   3769          
   3770          FRESULT f_getlabel (
   3771          	const TCHAR* path,	/* Path name of the logical drive number */
   3772          	TCHAR* label,		/* Pointer to a buffer to return the volume label */
   3773          	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
   3774          )
   3775          {
   3776          	FRESULT res;
   3777          	DIR dj;
   3778          	UINT i, j;
   3779          
   3780          
   3781          	/* Get logical drive number */
   3782          	res = find_volume(&dj.fs, &path, 0);
   3783          
   3784          	/* Get volume label */
   3785          	if (res == FR_OK && label) {
   3786          		dj.sclust = 0;					/* Open root directory */
   3787          		res = dir_sdi(&dj, 0);
   3788          		if (res == FR_OK) {
   3789          			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
   3790          			if (res == FR_OK) {			/* A volume label is exist */
   3791          #if _USE_LFN && _LFN_UNICODE
   3792          				WCHAR w;
   3793          				i = j = 0;
   3794          				do {
   3795          					w = (i < 11) ? dj.dir[i++] : ' ';
   3796          					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
   3797          						w = w << 8 | dj.dir[i++];
   3798          					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
   3799          				} while (j < 11);
   3800          #else
   3801          				mem_cpy(label, dj.dir, 11);
   3802          #endif
   3803          				j = 11;
   3804          				do {
   3805          					label[j] = 0;
   3806          					if (!j) break;
   3807          				} while (label[--j] == ' ');
   3808          			}
   3809          			if (res == FR_NO_FILE) {	/* No label, return nul string */
   3810          				label[0] = 0;
   3811          				res = FR_OK;
   3812          			}
   3813          		}
   3814          	}
   3815          
   3816          	/* Get volume serial number */
   3817          	if (res == FR_OK && vsn) {
   3818          		res = move_window(dj.fs, dj.fs->volbase);
   3819          		if (res == FR_OK) {
   3820          			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
   3821          			*vsn = LD_DWORD(&dj.fs->win[i]);
   3822          		}
   3823          	}
   3824          
   3825          	LEAVE_FF(dj.fs, res);
   3826          }
   3827          
   3828          
   3829          
   3830          #if !_FS_READONLY
   3831          /*-----------------------------------------------------------------------*/
   3832          /* Set volume label                                                      */
   3833          /*-----------------------------------------------------------------------*/
   3834          
   3835          FRESULT f_setlabel (
   3836          	const TCHAR* label	/* Pointer to the volume label to set */
   3837          )
   3838          {
   3839          	FRESULT res;
   3840          	DIR dj;
   3841          	BYTE vn[11];
   3842          	UINT i, j, sl;
   3843          	WCHAR w;
   3844          	DWORD tm;
   3845          
   3846          
   3847          	/* Get logical drive number */
   3848          	res = find_volume(&dj.fs, &label, 1);
   3849          	if (res) LEAVE_FF(dj.fs, res);
   3850          
   3851          	/* Create a volume label in directory form */
   3852          	vn[0] = 0;
   3853          	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
   3854          	for ( ; sl && label[sl-1] == ' '; sl--) ;	/* Remove trailing spaces */
   3855          	if (sl) {	/* Create volume label in directory form */
   3856          		i = j = 0;
   3857          		do {
   3858          #if _USE_LFN && _LFN_UNICODE
   3859          			w = ff_convert(ff_wtoupper(label[i++]), 0);
   3860          #else
   3861          			w = (BYTE)label[i++];
   3862          			if (IsDBCS1(w))
   3863          				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
   3864          #if _USE_LFN
   3865          			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
   3866          #else
   3867          			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
   3868          #ifdef _EXCVT
   3869          			if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
   3870          #else
   3871          			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
   3872          #endif
   3873          #endif
   3874          #endif
   3875          			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
   3876          				LEAVE_FF(dj.fs, FR_INVALID_NAME);
   3877          			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
   3878          			vn[j++] = (BYTE)w;
   3879          		} while (i < sl);
   3880          		while (j < 11) vn[j++] = ' ';
   3881          	}
   3882          
   3883          	/* Set volume label */
   3884          	dj.sclust = 0;					/* Open root directory */
   3885          	res = dir_sdi(&dj, 0);
   3886          	if (res == FR_OK) {
   3887          		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
   3888          		if (res == FR_OK) {			/* A volume label is found */
   3889          			if (vn[0]) {
   3890          				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
   3891          				tm = GET_FATTIME();
   3892          				ST_DWORD(dj.dir+DIR_WrtTime, tm);
   3893          			} else {
   3894          				dj.dir[0] = DDE;			/* Remove the volume label */
   3895          			}
   3896          			dj.fs->wflag = 1;
   3897          			res = sync_fs(dj.fs);
   3898          		} else {					/* No volume label is found or error */
   3899          			if (res == FR_NO_FILE) {
   3900          				res = FR_OK;
   3901          				if (vn[0]) {				/* Create volume label as new */
   3902          					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
   3903          					if (res == FR_OK) {
   3904          						mem_set(dj.dir, 0, SZ_DIR);	/* Set volume label */
   3905          						mem_cpy(dj.dir, vn, 11);
   3906          						dj.dir[DIR_Attr] = AM_VOL;
   3907          						tm = GET_FATTIME();
   3908          						ST_DWORD(dj.dir+DIR_WrtTime, tm);
   3909          						dj.fs->wflag = 1;
   3910          						res = sync_fs(dj.fs);
   3911          					}
   3912          				}
   3913          			}
   3914          		}
   3915          	}
   3916          
   3917          	LEAVE_FF(dj.fs, res);
   3918          }
   3919          
   3920          #endif /* !_FS_READONLY */
   3921          #endif /* _USE_LABEL */
   3922          
   3923          
   3924          
   3925          /*-----------------------------------------------------------------------*/
   3926          /* Forward data to the stream directly (available on only tiny cfg)      */
   3927          /*-----------------------------------------------------------------------*/
   3928          #if _USE_FORWARD && _FS_TINY
   3929          
   3930          FRESULT f_forward (
   3931          	FIL* fp, 						/* Pointer to the file object */
   3932          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   3933          	UINT btf,						/* Number of bytes to forward */
   3934          	UINT* bf						/* Pointer to number of bytes forwarded */
   3935          )
   3936          {
   3937          	FRESULT res;
   3938          	DWORD remain, clst, sect;
   3939          	UINT rcnt;
   3940          	BYTE csect;
   3941          
   3942          
   3943          	*bf = 0;	/* Clear transfer byte counter */
   3944          
   3945          	res = validate(fp);								/* Check validity of the object */
   3946          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   3947          	if (fp->err)									/* Check error */
   3948          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   3949          	if (!(fp->flag & FA_READ))						/* Check access mode */
   3950          		LEAVE_FF(fp->fs, FR_DENIED);
   3951          
   3952          	remain = fp->fsize - fp->fptr;
   3953          	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
   3954          
   3955          	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   3956          		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
   3957          		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   3958          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   3959          			if (!csect) {							/* On the cluster boundary? */
   3960          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   3961          					fp->sclust : get_fat(fp->fs, fp->clust);
   3962          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   3963          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3964          				fp->clust = clst;					/* Update current cluster */
   3965          			}
   3966          		}
   3967          		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
   3968          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3969          		sect += csect;
   3970          		if (move_window(fp->fs, sect) != FR_OK)		/* Move sector window */
   3971          			ABORT(fp->fs, FR_DISK_ERR);
   3972          		fp->dsect = sect;
   3973          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   3974          		if (rcnt > btf) rcnt = btf;
   3975          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   3976          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   3977          	}
   3978          
   3979          	LEAVE_FF(fp->fs, FR_OK);
   3980          }
   3981          #endif /* _USE_FORWARD */
   3982          
   3983          
   3984          
   3985          #if _USE_MKFS && !_FS_READONLY
   3986          /*-----------------------------------------------------------------------*/
   3987          /* Create File System on the Drive                                       */
   3988          /*-----------------------------------------------------------------------*/
   3989          #define N_ROOTDIR	512		/* Number of root directory entries for FAT12/16 */
   3990          #define N_FATS		1		/* Number of FATs (1 or 2) */
   3991          
   3992          

   \                                 In section .text, align 2, keep-with-next
   3993          FRESULT f_mkfs (
   3994          	const TCHAR* path,	/* Logical drive number */
   3995          	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
   3996          	UINT au				/* Size of allocation unit in unit of byte or sector */
   3997          )
   3998          {
   \                     f_mkfs:
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   \   00000006   0x4690             MOV      R8,R2
   3999          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   4000          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   4001          	int vol;
   4002          	BYTE fmt, md, sys, *tbl, pdrv, part;
   4003          	DWORD n_clst, vs, n, wsect;
   4004          	UINT i;
   4005          	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
   4006          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   4007          	FATFS *fs;
   4008          	DSTATUS stat;
   4009          
   4010          
   4011          	/* Check mounted drive and clear work area */
   4012          	if (sfd > 1) return FR_INVALID_PARAMETER;
   \   00000008   0xF89D 0x0038      LDRB     R0,[SP, #+56]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xDB01             BLT.N    ??f_mkfs_0
   \   00000010   0x2013             MOVS     R0,#+19
   \   00000012   0xE34F             B.N      ??f_mkfs_1
   4013          	vol = get_ldnumber(&path);
   \                     ??f_mkfs_0:
   \   00000014   0xA80D             ADD      R0,SP,#+52
   \   00000016   0x.... 0x....      BL       get_ldnumber
   \   0000001A   0x9009             STR      R0,[SP, #+36]
   4014          	if (vol < 0) return FR_INVALID_DRIVE;
   \   0000001C   0x9809             LDR      R0,[SP, #+36]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD501             BPL.N    ??f_mkfs_2
   \   00000022   0x200B             MOVS     R0,#+11
   \   00000024   0xE346             B.N      ??f_mkfs_1
   4015          	fs = FatFs[vol];
   \                     ??f_mkfs_2:
   \   00000026   0x9809             LDR      R0,[SP, #+36]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   0000002C   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000030   0x9004             STR      R0,[SP, #+16]
   4016          	if (!fs) return FR_NOT_ENABLED;
   \   00000032   0x9804             LDR      R0,[SP, #+16]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE.N    ??f_mkfs_3
   \   00000038   0x200C             MOVS     R0,#+12
   \   0000003A   0xE33B             B.N      ??f_mkfs_1
   4017          	fs->fs_type = 0;
   \                     ??f_mkfs_3:
   \   0000003C   0x9804             LDR      R0,[SP, #+16]
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x7001             STRB     R1,[R0, #+0]
   4018          	pdrv = LD2PD(vol);	/* Physical drive */
   \   00000042   0x9809             LDR      R0,[SP, #+36]
   \   00000044   0x0006             MOVS     R6,R0
   4019          	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x000B      STRB     R0,[SP, #+11]
   4020          
   4021          	/* Get disk statics */
   4022          	stat = disk_initialize(pdrv);
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x.... 0x....      BL       disk_initialize
   \   00000054   0xF88D 0x000A      STRB     R0,[SP, #+10]
   4023          	if (stat & STA_NOINIT) return FR_NOT_READY;
   \   00000058   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   0000005C   0x07C0             LSLS     R0,R0,#+31
   \   0000005E   0xD501             BPL.N    ??f_mkfs_4
   \   00000060   0x2003             MOVS     R0,#+3
   \   00000062   0xE327             B.N      ??f_mkfs_1
   4024          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   \                     ??f_mkfs_4:
   \   00000064   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   00000068   0x0740             LSLS     R0,R0,#+29
   \   0000006A   0xD501             BPL.N    ??f_mkfs_5
   \   0000006C   0x200A             MOVS     R0,#+10
   \   0000006E   0xE321             B.N      ??f_mkfs_1
   4025          #if _MAX_SS != _MIN_SS		/* Get disk sector size */
   4026          	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS)
   4027          		return FR_DISK_ERR;
   4028          #endif
   4029          	if (_MULTI_PARTITION && part) {
   4030          		/* Get partition information from partition table in the MBR */
   4031          		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   4032          		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   4033          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   4034          		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
   4035          		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
   4036          		n_vol = LD_DWORD(tbl+12);	/* Volume size */
   4037          	} else {
   4038          		/* Create a partition in this function */
   4039          		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
   \                     ??f_mkfs_5:
   \   00000070   0xAA01             ADD      R2,SP,#+4
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x.... 0x....      BL       disk_ioctl
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD102             BNE.N    ??f_mkfs_6
   \   00000080   0x9801             LDR      R0,[SP, #+4]
   \   00000082   0x2880             CMP      R0,#+128
   \   00000084   0xD201             BCS.N    ??f_mkfs_7
   4040          			return FR_DISK_ERR;
   \                     ??f_mkfs_6:
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0xE314             B.N      ??f_mkfs_1
   4041          		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
   \                     ??f_mkfs_7:
   \   0000008A   0xF89D 0x0038      LDRB     R0,[SP, #+56]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD001             BEQ.N    ??f_mkfs_8
   \   00000092   0x2700             MOVS     R7,#+0
   \   00000094   0xE000             B.N      ??f_mkfs_9
   \                     ??f_mkfs_8:
   \   00000096   0x273F             MOVS     R7,#+63
   4042          		n_vol -= b_vol;				/* Volume size */
   \                     ??f_mkfs_9:
   \   00000098   0x9801             LDR      R0,[SP, #+4]
   \   0000009A   0x1BC0             SUBS     R0,R0,R7
   \   0000009C   0x9001             STR      R0,[SP, #+4]
   4043          	}
   4044          
   4045          	if (au & (au - 1)) au = 0;
   \   0000009E   0xF1B8 0x0001      SUBS     R0,R8,#+1
   \   000000A2   0xEA18 0x0F00      TST      R8,R0
   \   000000A6   0xD001             BEQ.N    ??f_mkfs_10
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x4680             MOV      R8,R0
   4046          	if (!au) {						/* AU auto selection */
   \                     ??f_mkfs_10:
   \   000000AC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000B0   0xD116             BNE.N    ??f_mkfs_11
   4047          		vs = n_vol / (2000 / (SS(fs) / 512));
   \   000000B2   0x9801             LDR      R0,[SP, #+4]
   \   000000B4   0xF44F 0x61FA      MOV      R1,#+2000
   \   000000B8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000BC   0x900B             STR      R0,[SP, #+44]
   4048          		for (i = 0; vs < vst[i]; i++) ;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x4682             MOV      R10,R0
   \                     ??f_mkfs_12:
   \   000000C2   0x980B             LDR      R0,[SP, #+44]
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   000000C8   0xF831 0x101A      LDRH     R1,[R1, R10, LSL #+1]
   \   000000CC   0x4288             CMP      R0,R1
   \   000000CE   0xD202             BCS.N    ??f_mkfs_13
   \   000000D0   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000000D4   0xE7F5             B.N      ??f_mkfs_12
   4049          		au = cst[i];
   \                     ??f_mkfs_13:
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   000000DA   0xF830 0x001A      LDRH     R0,[R0, R10, LSL #+1]
   \   000000DE   0x4680             MOV      R8,R0
   4050          	}
   4051          	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
   \                     ??f_mkfs_11:
   \   000000E0   0xF5B8 0x7F00      CMP      R8,#+512
   \   000000E4   0xD301             BCC.N    ??f_mkfs_14
   \   000000E6   0xEA5F 0x2858      LSRS     R8,R8,#+9
   4052          	if (!au) au = 1;
   \                     ??f_mkfs_14:
   \   000000EA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000EE   0xD101             BNE.N    ??f_mkfs_15
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0x4680             MOV      R8,R0
   4053          	if (au > 128) au = 128;
   \                     ??f_mkfs_15:
   \   000000F4   0xF1B8 0x0F81      CMP      R8,#+129
   \   000000F8   0xD301             BCC.N    ??f_mkfs_16
   \   000000FA   0x2080             MOVS     R0,#+128
   \   000000FC   0x4680             MOV      R8,R0
   4054          
   4055          	/* Pre-compute number of clusters and FAT sub-type */
   4056          	n_clst = n_vol / au;
   \                     ??f_mkfs_16:
   \   000000FE   0x9801             LDR      R0,[SP, #+4]
   \   00000100   0xFBB0 0xF0F8      UDIV     R0,R0,R8
   \   00000104   0x9003             STR      R0,[SP, #+12]
   4057          	fmt = FS_FAT12;
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0x0004             MOVS     R4,R0
   4058          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   \   0000010A   0x9803             LDR      R0,[SP, #+12]
   \   0000010C   0xF640 0x71F6      MOVW     R1,#+4086
   \   00000110   0x4288             CMP      R0,R1
   \   00000112   0xD301             BCC.N    ??f_mkfs_17
   \   00000114   0x2002             MOVS     R0,#+2
   \   00000116   0x0004             MOVS     R4,R0
   4059          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??f_mkfs_17:
   \   00000118   0x9803             LDR      R0,[SP, #+12]
   \   0000011A   0xF64F 0x71F6      MOVW     R1,#+65526
   \   0000011E   0x4288             CMP      R0,R1
   \   00000120   0xD301             BCC.N    ??f_mkfs_18
   \   00000122   0x2003             MOVS     R0,#+3
   \   00000124   0x0004             MOVS     R4,R0
   4060          
   4061          	/* Determine offset and size of FAT structure */
   4062          	if (fmt == FS_FAT32) {
   \                     ??f_mkfs_18:
   \   00000126   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000128   0x2C03             CMP      R4,#+3
   \   0000012A   0xD10A             BNE.N    ??f_mkfs_19
   4063          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   \   0000012C   0x9803             LDR      R0,[SP, #+12]
   \   0000012E   0x0080             LSLS     R0,R0,#+2
   \   00000130   0xF200 0x2007      ADDW     R0,R0,#+519
   \   00000134   0x0A40             LSRS     R0,R0,#+9
   \   00000136   0x4681             MOV      R9,R0
   4064          		n_rsv = 32;
   \   00000138   0x2020             MOVS     R0,#+32
   \   0000013A   0x9005             STR      R0,[SP, #+20]
   4065          		n_dir = 0;
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x9006             STR      R0,[SP, #+24]
   \   00000140   0xE016             B.N      ??f_mkfs_20
   4066          	} else {
   4067          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   \                     ??f_mkfs_19:
   \   00000142   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000144   0x2C01             CMP      R4,#+1
   \   00000146   0xD107             BNE.N    ??f_mkfs_21
   \   00000148   0x9803             LDR      R0,[SP, #+12]
   \   0000014A   0x2103             MOVS     R1,#+3
   \   0000014C   0x4348             MULS     R0,R1,R0
   \   0000014E   0x1C40             ADDS     R0,R0,#+1
   \   00000150   0x0840             LSRS     R0,R0,#+1
   \   00000152   0xF110 0x0903      ADDS     R9,R0,#+3
   \   00000156   0xE003             B.N      ??f_mkfs_22
   \                     ??f_mkfs_21:
   \   00000158   0x9803             LDR      R0,[SP, #+12]
   \   0000015A   0x0040             LSLS     R0,R0,#+1
   \   0000015C   0xF110 0x0904      ADDS     R9,R0,#+4
   4068          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   \                     ??f_mkfs_22:
   \   00000160   0xF209 0x10FF      ADDW     R0,R9,#+511
   \   00000164   0xEA5F 0x2950      LSRS     R9,R0,#+9
   4069          		n_rsv = 1;
   \   00000168   0x2001             MOVS     R0,#+1
   \   0000016A   0x9005             STR      R0,[SP, #+20]
   4070          		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
   \   0000016C   0x2020             MOVS     R0,#+32
   \   0000016E   0x9006             STR      R0,[SP, #+24]
   4071          	}
   4072          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   \                     ??f_mkfs_20:
   \   00000170   0x9805             LDR      R0,[SP, #+20]
   \   00000172   0x19C0             ADDS     R0,R0,R7
   \   00000174   0x9007             STR      R0,[SP, #+28]
   4073          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   \   00000176   0x9807             LDR      R0,[SP, #+28]
   \   00000178   0xEB19 0x0000      ADDS     R0,R9,R0
   \   0000017C   0x900A             STR      R0,[SP, #+40]
   4074          	b_data = b_dir + n_dir;				/* Data area start sector */
   \   0000017E   0x980A             LDR      R0,[SP, #+40]
   \   00000180   0x9906             LDR      R1,[SP, #+24]
   \   00000182   0x1808             ADDS     R0,R1,R0
   \   00000184   0x9008             STR      R0,[SP, #+32]
   4075          	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
   \   00000186   0x9801             LDR      R0,[SP, #+4]
   \   00000188   0x9908             LDR      R1,[SP, #+32]
   \   0000018A   0xEB18 0x0101      ADDS     R1,R8,R1
   \   0000018E   0x1BC9             SUBS     R1,R1,R7
   \   00000190   0x4288             CMP      R0,R1
   \   00000192   0xD201             BCS.N    ??f_mkfs_23
   \   00000194   0x200E             MOVS     R0,#+14
   \   00000196   0xE28D             B.N      ??f_mkfs_1
   4076          
   4077          	/* Align data start sector to erase block boundary (for flash memory media) */
   4078          	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   \                     ??f_mkfs_23:
   \   00000198   0xAA00             ADD      R2,SP,#+0
   \   0000019A   0x2103             MOVS     R1,#+3
   \   0000019C   0x0030             MOVS     R0,R6
   \   0000019E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A0   0x.... 0x....      BL       disk_ioctl
   \   000001A4   0x2800             CMP      R0,#+0
   \   000001A6   0xD106             BNE.N    ??f_mkfs_24
   \   000001A8   0x9800             LDR      R0,[SP, #+0]
   \   000001AA   0x2800             CMP      R0,#+0
   \   000001AC   0xD003             BEQ.N    ??f_mkfs_24
   \   000001AE   0x9800             LDR      R0,[SP, #+0]
   \   000001B0   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000001B4   0xD901             BLS.N    ??f_mkfs_25
   \                     ??f_mkfs_24:
   \   000001B6   0x2001             MOVS     R0,#+1
   \   000001B8   0x9000             STR      R0,[SP, #+0]
   4079          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   \                     ??f_mkfs_25:
   \   000001BA   0x9808             LDR      R0,[SP, #+32]
   \   000001BC   0x9900             LDR      R1,[SP, #+0]
   \   000001BE   0x1808             ADDS     R0,R1,R0
   \   000001C0   0x1E40             SUBS     R0,R0,#+1
   \   000001C2   0x9900             LDR      R1,[SP, #+0]
   \   000001C4   0x1E49             SUBS     R1,R1,#+1
   \   000001C6   0x4388             BICS     R0,R0,R1
   \   000001C8   0x9000             STR      R0,[SP, #+0]
   4080          	n = (n - b_data) / N_FATS;
   \   000001CA   0x9800             LDR      R0,[SP, #+0]
   \   000001CC   0x9908             LDR      R1,[SP, #+32]
   \   000001CE   0x1A40             SUBS     R0,R0,R1
   \   000001D0   0x2101             MOVS     R1,#+1
   \   000001D2   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001D6   0x9000             STR      R0,[SP, #+0]
   4081          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   \   000001D8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001DA   0x2C03             CMP      R4,#+3
   \   000001DC   0xD108             BNE.N    ??f_mkfs_26
   4082          		n_rsv += n;
   \   000001DE   0x9805             LDR      R0,[SP, #+20]
   \   000001E0   0x9900             LDR      R1,[SP, #+0]
   \   000001E2   0x1808             ADDS     R0,R1,R0
   \   000001E4   0x9005             STR      R0,[SP, #+20]
   4083          		b_fat += n;
   \   000001E6   0x9807             LDR      R0,[SP, #+28]
   \   000001E8   0x9900             LDR      R1,[SP, #+0]
   \   000001EA   0x1808             ADDS     R0,R1,R0
   \   000001EC   0x9007             STR      R0,[SP, #+28]
   \   000001EE   0xE002             B.N      ??f_mkfs_27
   4084          	} else {					/* FAT12/16: Expand FAT size */
   4085          		n_fat += n;
   \                     ??f_mkfs_26:
   \   000001F0   0x9800             LDR      R0,[SP, #+0]
   \   000001F2   0xEB10 0x0909      ADDS     R9,R0,R9
   4086          	}
   4087          
   4088          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   4089          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   \                     ??f_mkfs_27:
   \   000001F6   0x9801             LDR      R0,[SP, #+4]
   \   000001F8   0x9905             LDR      R1,[SP, #+20]
   \   000001FA   0x1A40             SUBS     R0,R0,R1
   \   000001FC   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   00000200   0x9906             LDR      R1,[SP, #+24]
   \   00000202   0x1A40             SUBS     R0,R0,R1
   \   00000204   0xFBB0 0xF0F8      UDIV     R0,R0,R8
   \   00000208   0x9003             STR      R0,[SP, #+12]
   4090          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   4091          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   \   0000020A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000020C   0x2C02             CMP      R4,#+2
   \   0000020E   0xD104             BNE.N    ??f_mkfs_28
   \   00000210   0x9803             LDR      R0,[SP, #+12]
   \   00000212   0xF640 0x71F6      MOVW     R1,#+4086
   \   00000216   0x4288             CMP      R0,R1
   \   00000218   0xD307             BCC.N    ??f_mkfs_29
   \                     ??f_mkfs_28:
   \   0000021A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000021C   0x2C03             CMP      R4,#+3
   \   0000021E   0xD106             BNE.N    ??f_mkfs_30
   \   00000220   0x9803             LDR      R0,[SP, #+12]
   \   00000222   0xF64F 0x71F6      MOVW     R1,#+65526
   \   00000226   0x4288             CMP      R0,R1
   \   00000228   0xD201             BCS.N    ??f_mkfs_30
   4092          		return FR_MKFS_ABORTED;
   \                     ??f_mkfs_29:
   \   0000022A   0x200E             MOVS     R0,#+14
   \   0000022C   0xE242             B.N      ??f_mkfs_1
   4093          
   4094          	/* Determine system ID in the partition table */
   4095          	if (fmt == FS_FAT32) {
   \                     ??f_mkfs_30:
   \   0000022E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000230   0x2C03             CMP      R4,#+3
   \   00000232   0xD103             BNE.N    ??f_mkfs_31
   4096          		sys = 0x0C;		/* FAT32X */
   \   00000234   0x200C             MOVS     R0,#+12
   \   00000236   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   0000023A   0xE013             B.N      ??f_mkfs_32
   4097          	} else {
   4098          		if (fmt == FS_FAT12 && n_vol < 0x10000) {
   \                     ??f_mkfs_31:
   \   0000023C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000023E   0x2C01             CMP      R4,#+1
   \   00000240   0xD107             BNE.N    ??f_mkfs_33
   \   00000242   0x9801             LDR      R0,[SP, #+4]
   \   00000244   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000248   0xD203             BCS.N    ??f_mkfs_33
   4099          			sys = 0x01;	/* FAT12(<65536) */
   \   0000024A   0x2001             MOVS     R0,#+1
   \   0000024C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   00000250   0xE008             B.N      ??f_mkfs_32
   4100          		} else {
   4101          			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
   \                     ??f_mkfs_33:
   \   00000252   0x9801             LDR      R0,[SP, #+4]
   \   00000254   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000258   0xD201             BCS.N    ??f_mkfs_34
   \   0000025A   0x2004             MOVS     R0,#+4
   \   0000025C   0xE000             B.N      ??f_mkfs_35
   \                     ??f_mkfs_34:
   \   0000025E   0x2006             MOVS     R0,#+6
   \                     ??f_mkfs_35:
   \   00000260   0xF88D 0x0008      STRB     R0,[SP, #+8]
   4102          		}
   4103          	}
   4104          
   4105          	if (_MULTI_PARTITION && part) {
   4106          		/* Update system ID in the partition table */
   4107          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   4108          		tbl[4] = sys;
   4109          		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
   4110          			return FR_DISK_ERR;
   4111          		md = 0xF8;
   4112          	} else {
   4113          		if (sfd) {	/* No partition table (SFD) */
   \                     ??f_mkfs_32:
   \   00000264   0xF89D 0x0038      LDRB     R0,[SP, #+56]
   \   00000268   0x2800             CMP      R0,#+0
   \   0000026A   0xD003             BEQ.N    ??f_mkfs_36
   4114          			md = 0xF0;
   \   0000026C   0x20F0             MOVS     R0,#+240
   \   0000026E   0xF88D 0x0009      STRB     R0,[SP, #+9]
   \   00000272   0xE051             B.N      ??f_mkfs_37
   4115          		} else {	/* Create partition table (FDISK) */
   4116          			mem_set(fs->win, 0, SS(fs));
   \                     ??f_mkfs_36:
   \   00000274   0xF44F 0x7200      MOV      R2,#+512
   \   00000278   0x2100             MOVS     R1,#+0
   \   0000027A   0x9804             LDR      R0,[SP, #+16]
   \   0000027C   0x3034             ADDS     R0,R0,#+52
   \   0000027E   0x.... 0x....      BL       mem_set
   4117          			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
   \   00000282   0x9804             LDR      R0,[SP, #+16]
   \   00000284   0xF200 0x10F2      ADDW     R0,R0,#+498
   \   00000288   0x0005             MOVS     R5,R0
   4118          			tbl[1] = 1;						/* Partition start head */
   \   0000028A   0x2001             MOVS     R0,#+1
   \   0000028C   0x7068             STRB     R0,[R5, #+1]
   4119          			tbl[2] = 1;						/* Partition start sector */
   \   0000028E   0x2001             MOVS     R0,#+1
   \   00000290   0x70A8             STRB     R0,[R5, #+2]
   4120          			tbl[3] = 0;						/* Partition start cylinder */
   \   00000292   0x2000             MOVS     R0,#+0
   \   00000294   0x70E8             STRB     R0,[R5, #+3]
   4121          			tbl[4] = sys;					/* System type */
   \   00000296   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000029A   0x7128             STRB     R0,[R5, #+4]
   4122          			tbl[5] = 254;					/* Partition end head */
   \   0000029C   0x20FE             MOVS     R0,#+254
   \   0000029E   0x7168             STRB     R0,[R5, #+5]
   4123          			n = (b_vol + n_vol) / 63 / 255;
   \   000002A0   0x9801             LDR      R0,[SP, #+4]
   \   000002A2   0x19C0             ADDS     R0,R0,R7
   \   000002A4   0x213F             MOVS     R1,#+63
   \   000002A6   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000002AA   0x21FF             MOVS     R1,#+255
   \   000002AC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000002B0   0x9000             STR      R0,[SP, #+0]
   4124          			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
   \   000002B2   0x9800             LDR      R0,[SP, #+0]
   \   000002B4   0x0880             LSRS     R0,R0,#+2
   \   000002B6   0xF050 0x003F      ORRS     R0,R0,#0x3F
   \   000002BA   0x71A8             STRB     R0,[R5, #+6]
   4125          			tbl[7] = (BYTE)n;				/* End cylinder */
   \   000002BC   0x9800             LDR      R0,[SP, #+0]
   \   000002BE   0x71E8             STRB     R0,[R5, #+7]
   4126          			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
   \   000002C0   0x203F             MOVS     R0,#+63
   \   000002C2   0x7228             STRB     R0,[R5, #+8]
   \   000002C4   0x2000             MOVS     R0,#+0
   \   000002C6   0x7268             STRB     R0,[R5, #+9]
   \   000002C8   0x2000             MOVS     R0,#+0
   \   000002CA   0x72A8             STRB     R0,[R5, #+10]
   \   000002CC   0x2000             MOVS     R0,#+0
   \   000002CE   0x72E8             STRB     R0,[R5, #+11]
   4127          			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
   \   000002D0   0x9801             LDR      R0,[SP, #+4]
   \   000002D2   0x7328             STRB     R0,[R5, #+12]
   \   000002D4   0x9801             LDR      R0,[SP, #+4]
   \   000002D6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000002D8   0x0A00             LSRS     R0,R0,#+8
   \   000002DA   0x7368             STRB     R0,[R5, #+13]
   \   000002DC   0x9801             LDR      R0,[SP, #+4]
   \   000002DE   0x0C00             LSRS     R0,R0,#+16
   \   000002E0   0x73A8             STRB     R0,[R5, #+14]
   \   000002E2   0x9801             LDR      R0,[SP, #+4]
   \   000002E4   0x0E00             LSRS     R0,R0,#+24
   \   000002E6   0x73E8             STRB     R0,[R5, #+15]
   4128          			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
   \   000002E8   0x9804             LDR      R0,[SP, #+16]
   \   000002EA   0x2155             MOVS     R1,#+85
   \   000002EC   0xF880 0x1232      STRB     R1,[R0, #+562]
   \   000002F0   0x9804             LDR      R0,[SP, #+16]
   \   000002F2   0x21AA             MOVS     R1,#+170
   \   000002F4   0xF880 0x1233      STRB     R1,[R0, #+563]
   4129          			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
   \   000002F8   0x2301             MOVS     R3,#+1
   \   000002FA   0x2200             MOVS     R2,#+0
   \   000002FC   0x9804             LDR      R0,[SP, #+16]
   \   000002FE   0xF110 0x0134      ADDS     R1,R0,#+52
   \   00000302   0x0030             MOVS     R0,R6
   \   00000304   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000306   0x.... 0x....      BL       disk_write
   \   0000030A   0x2800             CMP      R0,#+0
   \   0000030C   0xD001             BEQ.N    ??f_mkfs_38
   4130          				return FR_DISK_ERR;
   \   0000030E   0x2001             MOVS     R0,#+1
   \   00000310   0xE1D0             B.N      ??f_mkfs_1
   4131          			md = 0xF8;
   \                     ??f_mkfs_38:
   \   00000312   0x20F8             MOVS     R0,#+248
   \   00000314   0xF88D 0x0009      STRB     R0,[SP, #+9]
   4132          		}
   4133          	}
   4134          
   4135          	/* Create BPB in the VBR */
   4136          	tbl = fs->win;							/* Clear sector */
   \                     ??f_mkfs_37:
   \   00000318   0x9804             LDR      R0,[SP, #+16]
   \   0000031A   0x3034             ADDS     R0,R0,#+52
   \   0000031C   0x0005             MOVS     R5,R0
   4137          	mem_set(tbl, 0, SS(fs));
   \   0000031E   0xF44F 0x7200      MOV      R2,#+512
   \   00000322   0x2100             MOVS     R1,#+0
   \   00000324   0x0028             MOVS     R0,R5
   \   00000326   0x.... 0x....      BL       mem_set
   4138          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   \   0000032A   0x220B             MOVS     R2,#+11
   \   0000032C   0x....             LDR.N    R1,??DataTable17_4
   \   0000032E   0x0028             MOVS     R0,R5
   \   00000330   0x.... 0x....      BL       mem_cpy
   4139          	i = SS(fs);								/* Sector size */
   \   00000334   0xF44F 0x7000      MOV      R0,#+512
   \   00000338   0x4682             MOV      R10,R0
   4140          	ST_WORD(tbl+BPB_BytsPerSec, i);
   \   0000033A   0xF885 0xA00B      STRB     R10,[R5, #+11]
   \   0000033E   0x4650             MOV      R0,R10
   \   00000340   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000342   0x0A00             LSRS     R0,R0,#+8
   \   00000344   0x7328             STRB     R0,[R5, #+12]
   4141          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   \   00000346   0xF885 0x800D      STRB     R8,[R5, #+13]
   4142          	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
   \   0000034A   0x9805             LDR      R0,[SP, #+20]
   \   0000034C   0x73A8             STRB     R0,[R5, #+14]
   \   0000034E   0x9805             LDR      R0,[SP, #+20]
   \   00000350   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000352   0x0A00             LSRS     R0,R0,#+8
   \   00000354   0x73E8             STRB     R0,[R5, #+15]
   4143          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   \   00000356   0x2001             MOVS     R0,#+1
   \   00000358   0x7428             STRB     R0,[R5, #+16]
   4144          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
   \   0000035A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000035C   0x2C03             CMP      R4,#+3
   \   0000035E   0xD102             BNE.N    ??f_mkfs_39
   \   00000360   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000364   0xE001             B.N      ??f_mkfs_40
   \                     ??f_mkfs_39:
   \   00000366   0xF44F 0x7A00      MOV      R10,#+512
   4145          	ST_WORD(tbl+BPB_RootEntCnt, i);
   \                     ??f_mkfs_40:
   \   0000036A   0xF885 0xA011      STRB     R10,[R5, #+17]
   \   0000036E   0x4650             MOV      R0,R10
   \   00000370   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000372   0x0A00             LSRS     R0,R0,#+8
   \   00000374   0x74A8             STRB     R0,[R5, #+18]
   4146          	if (n_vol < 0x10000) {					/* Number of total sectors */
   \   00000376   0x9801             LDR      R0,[SP, #+4]
   \   00000378   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000037C   0xD206             BCS.N    ??f_mkfs_41
   4147          		ST_WORD(tbl+BPB_TotSec16, n_vol);
   \   0000037E   0x9801             LDR      R0,[SP, #+4]
   \   00000380   0x74E8             STRB     R0,[R5, #+19]
   \   00000382   0x9801             LDR      R0,[SP, #+4]
   \   00000384   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000386   0x0A00             LSRS     R0,R0,#+8
   \   00000388   0x7528             STRB     R0,[R5, #+20]
   \   0000038A   0xE00F             B.N      ??f_mkfs_42
   4148          	} else {
   4149          		ST_DWORD(tbl+BPB_TotSec32, n_vol);
   \                     ??f_mkfs_41:
   \   0000038C   0x9801             LDR      R0,[SP, #+4]
   \   0000038E   0xF885 0x0020      STRB     R0,[R5, #+32]
   \   00000392   0x9801             LDR      R0,[SP, #+4]
   \   00000394   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000396   0x0A00             LSRS     R0,R0,#+8
   \   00000398   0xF885 0x0021      STRB     R0,[R5, #+33]
   \   0000039C   0x9801             LDR      R0,[SP, #+4]
   \   0000039E   0x0C00             LSRS     R0,R0,#+16
   \   000003A0   0xF885 0x0022      STRB     R0,[R5, #+34]
   \   000003A4   0x9801             LDR      R0,[SP, #+4]
   \   000003A6   0x0E00             LSRS     R0,R0,#+24
   \   000003A8   0xF885 0x0023      STRB     R0,[R5, #+35]
   4150          	}
   4151          	tbl[BPB_Media] = md;					/* Media descriptor */
   \                     ??f_mkfs_42:
   \   000003AC   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000003B0   0x7568             STRB     R0,[R5, #+21]
   4152          	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
   \   000003B2   0x203F             MOVS     R0,#+63
   \   000003B4   0x7628             STRB     R0,[R5, #+24]
   \   000003B6   0x2000             MOVS     R0,#+0
   \   000003B8   0x7668             STRB     R0,[R5, #+25]
   4153          	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
   \   000003BA   0x20FF             MOVS     R0,#+255
   \   000003BC   0x76A8             STRB     R0,[R5, #+26]
   \   000003BE   0x2000             MOVS     R0,#+0
   \   000003C0   0x76E8             STRB     R0,[R5, #+27]
   4154          	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
   \   000003C2   0x772F             STRB     R7,[R5, #+28]
   \   000003C4   0x0038             MOVS     R0,R7
   \   000003C6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000003C8   0x0A00             LSRS     R0,R0,#+8
   \   000003CA   0x7768             STRB     R0,[R5, #+29]
   \   000003CC   0x0C38             LSRS     R0,R7,#+16
   \   000003CE   0x77A8             STRB     R0,[R5, #+30]
   \   000003D0   0x0E38             LSRS     R0,R7,#+24
   \   000003D2   0x77E8             STRB     R0,[R5, #+31]
   4155          	n = GET_FATTIME();						/* Use current time as VSN */
   \   000003D4   0x.... 0x....      BL       get_fattime
   \   000003D8   0x9000             STR      R0,[SP, #+0]
   4156          	if (fmt == FS_FAT32) {
   \   000003DA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003DC   0x2C03             CMP      R4,#+3
   \   000003DE   0xD143             BNE.N    ??f_mkfs_43
   4157          		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
   \   000003E0   0x9800             LDR      R0,[SP, #+0]
   \   000003E2   0xF885 0x0043      STRB     R0,[R5, #+67]
   \   000003E6   0x9800             LDR      R0,[SP, #+0]
   \   000003E8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000003EA   0x0A00             LSRS     R0,R0,#+8
   \   000003EC   0xF885 0x0044      STRB     R0,[R5, #+68]
   \   000003F0   0x9800             LDR      R0,[SP, #+0]
   \   000003F2   0x0C00             LSRS     R0,R0,#+16
   \   000003F4   0xF885 0x0045      STRB     R0,[R5, #+69]
   \   000003F8   0x9800             LDR      R0,[SP, #+0]
   \   000003FA   0x0E00             LSRS     R0,R0,#+24
   \   000003FC   0xF885 0x0046      STRB     R0,[R5, #+70]
   4158          		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   \   00000400   0xF885 0x9024      STRB     R9,[R5, #+36]
   \   00000404   0x4648             MOV      R0,R9
   \   00000406   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000408   0x0A00             LSRS     R0,R0,#+8
   \   0000040A   0xF885 0x0025      STRB     R0,[R5, #+37]
   \   0000040E   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   00000412   0xF885 0x0026      STRB     R0,[R5, #+38]
   \   00000416   0xEA5F 0x6019      LSRS     R0,R9,#+24
   \   0000041A   0xF885 0x0027      STRB     R0,[R5, #+39]
   4159          		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
   \   0000041E   0x2002             MOVS     R0,#+2
   \   00000420   0xF885 0x002C      STRB     R0,[R5, #+44]
   \   00000424   0x2000             MOVS     R0,#+0
   \   00000426   0xF885 0x002D      STRB     R0,[R5, #+45]
   \   0000042A   0x2000             MOVS     R0,#+0
   \   0000042C   0xF885 0x002E      STRB     R0,[R5, #+46]
   \   00000430   0x2000             MOVS     R0,#+0
   \   00000432   0xF885 0x002F      STRB     R0,[R5, #+47]
   4160          		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSINFO record offset (VBR+1) */
   \   00000436   0x2001             MOVS     R0,#+1
   \   00000438   0xF885 0x0030      STRB     R0,[R5, #+48]
   \   0000043C   0x2000             MOVS     R0,#+0
   \   0000043E   0xF885 0x0031      STRB     R0,[R5, #+49]
   4161          		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
   \   00000442   0x2006             MOVS     R0,#+6
   \   00000444   0xF885 0x0032      STRB     R0,[R5, #+50]
   \   00000448   0x2000             MOVS     R0,#+0
   \   0000044A   0xF885 0x0033      STRB     R0,[R5, #+51]
   4162          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   \   0000044E   0x2080             MOVS     R0,#+128
   \   00000450   0xF885 0x0040      STRB     R0,[R5, #+64]
   4163          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   \   00000454   0x2029             MOVS     R0,#+41
   \   00000456   0xF885 0x0042      STRB     R0,[R5, #+66]
   4164          		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   \   0000045A   0x2213             MOVS     R2,#+19
   \   0000045C   0x....             LDR.N    R1,??DataTable17_5
   \   0000045E   0xF115 0x0047      ADDS     R0,R5,#+71
   \   00000462   0x.... 0x....      BL       mem_cpy
   \   00000466   0xE021             B.N      ??f_mkfs_44
   4165          	} else {
   4166          		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
   \                     ??f_mkfs_43:
   \   00000468   0x9800             LDR      R0,[SP, #+0]
   \   0000046A   0xF885 0x0027      STRB     R0,[R5, #+39]
   \   0000046E   0x9800             LDR      R0,[SP, #+0]
   \   00000470   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000472   0x0A00             LSRS     R0,R0,#+8
   \   00000474   0xF885 0x0028      STRB     R0,[R5, #+40]
   \   00000478   0x9800             LDR      R0,[SP, #+0]
   \   0000047A   0x0C00             LSRS     R0,R0,#+16
   \   0000047C   0xF885 0x0029      STRB     R0,[R5, #+41]
   \   00000480   0x9800             LDR      R0,[SP, #+0]
   \   00000482   0x0E00             LSRS     R0,R0,#+24
   \   00000484   0xF885 0x002A      STRB     R0,[R5, #+42]
   4167          		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
   \   00000488   0xF885 0x9016      STRB     R9,[R5, #+22]
   \   0000048C   0x4648             MOV      R0,R9
   \   0000048E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000490   0x0A00             LSRS     R0,R0,#+8
   \   00000492   0x75E8             STRB     R0,[R5, #+23]
   4168          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   \   00000494   0x2080             MOVS     R0,#+128
   \   00000496   0xF885 0x0024      STRB     R0,[R5, #+36]
   4169          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   \   0000049A   0x2029             MOVS     R0,#+41
   \   0000049C   0xF885 0x0026      STRB     R0,[R5, #+38]
   4170          		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   \   000004A0   0x2213             MOVS     R2,#+19
   \   000004A2   0x....             LDR.N    R1,??DataTable17_6
   \   000004A4   0xF115 0x002B      ADDS     R0,R5,#+43
   \   000004A8   0x.... 0x....      BL       mem_cpy
   4171          	}
   4172          	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   \                     ??f_mkfs_44:
   \   000004AC   0x2055             MOVS     R0,#+85
   \   000004AE   0xF885 0x01FE      STRB     R0,[R5, #+510]
   \   000004B2   0x20AA             MOVS     R0,#+170
   \   000004B4   0xF885 0x01FF      STRB     R0,[R5, #+511]
   4173          	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
   \   000004B8   0x2301             MOVS     R3,#+1
   \   000004BA   0x003A             MOVS     R2,R7
   \   000004BC   0x0029             MOVS     R1,R5
   \   000004BE   0x0030             MOVS     R0,R6
   \   000004C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004C2   0x.... 0x....      BL       disk_write
   \   000004C6   0x2800             CMP      R0,#+0
   \   000004C8   0xD001             BEQ.N    ??f_mkfs_45
   4174          		return FR_DISK_ERR;
   \   000004CA   0x2001             MOVS     R0,#+1
   \   000004CC   0xE0F2             B.N      ??f_mkfs_1
   4175          	if (fmt == FS_FAT32)					/* Write backup VBR if needed (VBR+6) */
   \                     ??f_mkfs_45:
   \   000004CE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004D0   0x2C03             CMP      R4,#+3
   \   000004D2   0xD106             BNE.N    ??f_mkfs_46
   4176          		disk_write(pdrv, tbl, b_vol + 6, 1);
   \   000004D4   0x2301             MOVS     R3,#+1
   \   000004D6   0x1DBA             ADDS     R2,R7,#+6
   \   000004D8   0x0029             MOVS     R1,R5
   \   000004DA   0x0030             MOVS     R0,R6
   \   000004DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004DE   0x.... 0x....      BL       disk_write
   4177          
   4178          	/* Initialize FAT area */
   4179          	wsect = b_fat;
   \                     ??f_mkfs_46:
   \   000004E2   0x9807             LDR      R0,[SP, #+28]
   \   000004E4   0x4683             MOV      R11,R0
   4180          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   \   000004E6   0x2000             MOVS     R0,#+0
   \   000004E8   0x4682             MOV      R10,R0
   \                     ??f_mkfs_47:
   \   000004EA   0xF1BA 0x0F00      CMP      R10,#+0
   \   000004EE   0xD170             BNE.N    ??f_mkfs_48
   4181          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   \   000004F0   0xF44F 0x7200      MOV      R2,#+512
   \   000004F4   0x2100             MOVS     R1,#+0
   \   000004F6   0x0028             MOVS     R0,R5
   \   000004F8   0x.... 0x....      BL       mem_set
   4182          		n = md;								/* Media descriptor byte */
   \   000004FC   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000500   0x9000             STR      R0,[SP, #+0]
   4183          		if (fmt != FS_FAT32) {
   \   00000502   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000504   0x2C03             CMP      R4,#+3
   \   00000506   0xD016             BEQ.N    ??f_mkfs_49
   4184          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   \   00000508   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000050A   0x2C01             CMP      R4,#+1
   \   0000050C   0xD101             BNE.N    ??f_mkfs_50
   \   0000050E   0x....             LDR.N    R0,??DataTable17_7  ;; 0xffff00
   \   00000510   0xE001             B.N      ??f_mkfs_51
   \                     ??f_mkfs_50:
   \   00000512   0xF07F 0x00FF      MVNS     R0,#+255
   \                     ??f_mkfs_51:
   \   00000516   0x9900             LDR      R1,[SP, #+0]
   \   00000518   0x4308             ORRS     R0,R0,R1
   \   0000051A   0x9000             STR      R0,[SP, #+0]
   4185          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
   \   0000051C   0x9800             LDR      R0,[SP, #+0]
   \   0000051E   0x7028             STRB     R0,[R5, #+0]
   \   00000520   0x9800             LDR      R0,[SP, #+0]
   \   00000522   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000524   0x0A00             LSRS     R0,R0,#+8
   \   00000526   0x7068             STRB     R0,[R5, #+1]
   \   00000528   0x9800             LDR      R0,[SP, #+0]
   \   0000052A   0x0C00             LSRS     R0,R0,#+16
   \   0000052C   0x70A8             STRB     R0,[R5, #+2]
   \   0000052E   0x9800             LDR      R0,[SP, #+0]
   \   00000530   0x0E00             LSRS     R0,R0,#+24
   \   00000532   0x70E8             STRB     R0,[R5, #+3]
   \   00000534   0xE01F             B.N      ??f_mkfs_52
   4186          		} else {
   4187          			n |= 0xFFFFFF00;
   \                     ??f_mkfs_49:
   \   00000536   0x9800             LDR      R0,[SP, #+0]
   \   00000538   0xF070 0x00FF      ORNS     R0,R0,#+255
   \   0000053C   0x9000             STR      R0,[SP, #+0]
   4188          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
   \   0000053E   0x9800             LDR      R0,[SP, #+0]
   \   00000540   0x7028             STRB     R0,[R5, #+0]
   \   00000542   0x9800             LDR      R0,[SP, #+0]
   \   00000544   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000546   0x0A00             LSRS     R0,R0,#+8
   \   00000548   0x7068             STRB     R0,[R5, #+1]
   \   0000054A   0x9800             LDR      R0,[SP, #+0]
   \   0000054C   0x0C00             LSRS     R0,R0,#+16
   \   0000054E   0x70A8             STRB     R0,[R5, #+2]
   \   00000550   0x9800             LDR      R0,[SP, #+0]
   \   00000552   0x0E00             LSRS     R0,R0,#+24
   \   00000554   0x70E8             STRB     R0,[R5, #+3]
   4189          			ST_DWORD(tbl+4, 0xFFFFFFFF);
   \   00000556   0x20FF             MOVS     R0,#+255
   \   00000558   0x7128             STRB     R0,[R5, #+4]
   \   0000055A   0x20FF             MOVS     R0,#+255
   \   0000055C   0x7168             STRB     R0,[R5, #+5]
   \   0000055E   0x20FF             MOVS     R0,#+255
   \   00000560   0x71A8             STRB     R0,[R5, #+6]
   \   00000562   0x20FF             MOVS     R0,#+255
   \   00000564   0x71E8             STRB     R0,[R5, #+7]
   4190          			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
   \   00000566   0x20FF             MOVS     R0,#+255
   \   00000568   0x7228             STRB     R0,[R5, #+8]
   \   0000056A   0x20FF             MOVS     R0,#+255
   \   0000056C   0x7268             STRB     R0,[R5, #+9]
   \   0000056E   0x20FF             MOVS     R0,#+255
   \   00000570   0x72A8             STRB     R0,[R5, #+10]
   \   00000572   0x200F             MOVS     R0,#+15
   \   00000574   0x72E8             STRB     R0,[R5, #+11]
   4191          		}
   4192          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_52:
   \   00000576   0x2301             MOVS     R3,#+1
   \   00000578   0x465A             MOV      R2,R11
   \   0000057A   0x0029             MOVS     R1,R5
   \   0000057C   0x0030             MOVS     R0,R6
   \   0000057E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000580   0x.... 0x....      BL       disk_write
   \   00000584   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000588   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000058A   0x2800             CMP      R0,#+0
   \   0000058C   0xD001             BEQ.N    ??f_mkfs_53
   4193          			return FR_DISK_ERR;
   \   0000058E   0x2001             MOVS     R0,#+1
   \   00000590   0xE090             B.N      ??f_mkfs_1
   4194          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   \                     ??f_mkfs_53:
   \   00000592   0xF44F 0x7200      MOV      R2,#+512
   \   00000596   0x2100             MOVS     R1,#+0
   \   00000598   0x0028             MOVS     R0,R5
   \   0000059A   0x.... 0x....      BL       mem_set
   4195          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   \   0000059E   0x2001             MOVS     R0,#+1
   \   000005A0   0x9000             STR      R0,[SP, #+0]
   \                     ??f_mkfs_54:
   \   000005A2   0x9800             LDR      R0,[SP, #+0]
   \   000005A4   0x4548             CMP      R0,R9
   \   000005A6   0xD211             BCS.N    ??f_mkfs_55
   4196          			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \   000005A8   0x2301             MOVS     R3,#+1
   \   000005AA   0x465A             MOV      R2,R11
   \   000005AC   0x0029             MOVS     R1,R5
   \   000005AE   0x0030             MOVS     R0,R6
   \   000005B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005B2   0x.... 0x....      BL       disk_write
   \   000005B6   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000005BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005BC   0x2800             CMP      R0,#+0
   \   000005BE   0xD001             BEQ.N    ??f_mkfs_56
   4197          				return FR_DISK_ERR;
   \   000005C0   0x2001             MOVS     R0,#+1
   \   000005C2   0xE077             B.N      ??f_mkfs_1
   4198          		}
   \                     ??f_mkfs_56:
   \   000005C4   0x9800             LDR      R0,[SP, #+0]
   \   000005C6   0x1C40             ADDS     R0,R0,#+1
   \   000005C8   0x9000             STR      R0,[SP, #+0]
   \   000005CA   0xE7EA             B.N      ??f_mkfs_54
   4199          	}
   \                     ??f_mkfs_55:
   \   000005CC   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000005D0   0xE78B             B.N      ??f_mkfs_47
   4200          
   4201          	/* Initialize root directory */
   4202          	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
   \                     ??f_mkfs_48:
   \   000005D2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005D4   0x2C03             CMP      R4,#+3
   \   000005D6   0xD101             BNE.N    ??f_mkfs_57
   \   000005D8   0x46C2             MOV      R10,R8
   \   000005DA   0xE001             B.N      ??f_mkfs_58
   \                     ??f_mkfs_57:
   \   000005DC   0xF8DD 0xA018      LDR      R10,[SP, #+24]
   4203          	do {
   4204          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_58:
   \   000005E0   0x2301             MOVS     R3,#+1
   \   000005E2   0x465A             MOV      R2,R11
   \   000005E4   0x0029             MOVS     R1,R5
   \   000005E6   0x0030             MOVS     R0,R6
   \   000005E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005EA   0x.... 0x....      BL       disk_write
   \   000005EE   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000005F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005F4   0x2800             CMP      R0,#+0
   \   000005F6   0xD001             BEQ.N    ??f_mkfs_59
   4205          			return FR_DISK_ERR;
   \   000005F8   0x2001             MOVS     R0,#+1
   \   000005FA   0xE05B             B.N      ??f_mkfs_1
   4206          	} while (--i);
   \                     ??f_mkfs_59:
   \   000005FC   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000600   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000604   0xD1EC             BNE.N    ??f_mkfs_58
   4207          
   4208          #if _USE_TRIM	/* Erase data area if needed */
   4209          	{
   4210          		DWORD eb[2];
   4211          
   4212          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   4213          		disk_ioctl(pdrv, CTRL_TRIM, eb);
   4214          	}
   4215          #endif
   4216          
   4217          	/* Create FSINFO if needed */
   4218          	if (fmt == FS_FAT32) {
   \   00000606   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000608   0x2C03             CMP      R4,#+3
   \   0000060A   0xD147             BNE.N    ??f_mkfs_60
   4219          		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   \   0000060C   0x2052             MOVS     R0,#+82
   \   0000060E   0x7028             STRB     R0,[R5, #+0]
   \   00000610   0x2052             MOVS     R0,#+82
   \   00000612   0x7068             STRB     R0,[R5, #+1]
   \   00000614   0x2061             MOVS     R0,#+97
   \   00000616   0x70A8             STRB     R0,[R5, #+2]
   \   00000618   0x2041             MOVS     R0,#+65
   \   0000061A   0x70E8             STRB     R0,[R5, #+3]
   4220          		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   \   0000061C   0x2072             MOVS     R0,#+114
   \   0000061E   0xF885 0x01E4      STRB     R0,[R5, #+484]
   \   00000622   0x2072             MOVS     R0,#+114
   \   00000624   0xF885 0x01E5      STRB     R0,[R5, #+485]
   \   00000628   0x2041             MOVS     R0,#+65
   \   0000062A   0xF885 0x01E6      STRB     R0,[R5, #+486]
   \   0000062E   0x2061             MOVS     R0,#+97
   \   00000630   0xF885 0x01E7      STRB     R0,[R5, #+487]
   4221          		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   \   00000634   0x9803             LDR      R0,[SP, #+12]
   \   00000636   0x1E40             SUBS     R0,R0,#+1
   \   00000638   0xF885 0x01E8      STRB     R0,[R5, #+488]
   \   0000063C   0x9803             LDR      R0,[SP, #+12]
   \   0000063E   0x1E40             SUBS     R0,R0,#+1
   \   00000640   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000642   0x0A00             LSRS     R0,R0,#+8
   \   00000644   0xF885 0x01E9      STRB     R0,[R5, #+489]
   \   00000648   0x9803             LDR      R0,[SP, #+12]
   \   0000064A   0x1E40             SUBS     R0,R0,#+1
   \   0000064C   0x0C00             LSRS     R0,R0,#+16
   \   0000064E   0xF885 0x01EA      STRB     R0,[R5, #+490]
   \   00000652   0x9803             LDR      R0,[SP, #+12]
   \   00000654   0x1E40             SUBS     R0,R0,#+1
   \   00000656   0x0E00             LSRS     R0,R0,#+24
   \   00000658   0xF885 0x01EB      STRB     R0,[R5, #+491]
   4222          		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
   \   0000065C   0x2002             MOVS     R0,#+2
   \   0000065E   0xF885 0x01EC      STRB     R0,[R5, #+492]
   \   00000662   0x2000             MOVS     R0,#+0
   \   00000664   0xF885 0x01ED      STRB     R0,[R5, #+493]
   \   00000668   0x2000             MOVS     R0,#+0
   \   0000066A   0xF885 0x01EE      STRB     R0,[R5, #+494]
   \   0000066E   0x2000             MOVS     R0,#+0
   \   00000670   0xF885 0x01EF      STRB     R0,[R5, #+495]
   4223          		ST_WORD(tbl+BS_55AA, 0xAA55);
   \   00000674   0x2055             MOVS     R0,#+85
   \   00000676   0xF885 0x01FE      STRB     R0,[R5, #+510]
   \   0000067A   0x20AA             MOVS     R0,#+170
   \   0000067C   0xF885 0x01FF      STRB     R0,[R5, #+511]
   4224          		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
   \   00000680   0x2301             MOVS     R3,#+1
   \   00000682   0x1C7A             ADDS     R2,R7,#+1
   \   00000684   0x0029             MOVS     R1,R5
   \   00000686   0x0030             MOVS     R0,R6
   \   00000688   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000068A   0x.... 0x....      BL       disk_write
   4225          		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
   \   0000068E   0x2301             MOVS     R3,#+1
   \   00000690   0x1DFA             ADDS     R2,R7,#+7
   \   00000692   0x0029             MOVS     R1,R5
   \   00000694   0x0030             MOVS     R0,R6
   \   00000696   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000698   0x.... 0x....      BL       disk_write
   4226          	}
   4227          
   4228          	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   \                     ??f_mkfs_60:
   \   0000069C   0x2200             MOVS     R2,#+0
   \   0000069E   0x2100             MOVS     R1,#+0
   \   000006A0   0x0030             MOVS     R0,R6
   \   000006A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000006A4   0x.... 0x....      BL       disk_ioctl
   \   000006A8   0x2800             CMP      R0,#+0
   \   000006AA   0xD101             BNE.N    ??f_mkfs_61
   \   000006AC   0x2000             MOVS     R0,#+0
   \   000006AE   0xE000             B.N      ??f_mkfs_62
   \                     ??f_mkfs_61:
   \   000006B0   0x2001             MOVS     R0,#+1
   \                     ??f_mkfs_62:
   \   000006B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_mkfs_1:
   \   000006B4   0xB00F             ADD      SP,SP,#+60
   \   000006B6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   4229          }

   \                                 In section .rodata, align 4
   \                     ??vst:
   \   00000000   0x0400 0x0200      DC16 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0
   \              0x0100 0x0080
   \              0x0040 0x0020
   \              0x0010 0x0008
   \              0x0004 0x0002
   \              0x0000       
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ??cst:
   \   00000000   0x8000 0x4000      DC16 32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512
   \              0x2000 0x1000
   \              0x0800 0x4000
   \              0x2000 0x1000
   \              0x0800 0x0400
   \              0x0200       
   \   00000016   0x00 0x00          DC8 0, 0
   4230          
   4231          
   4232          
   4233          #if _MULTI_PARTITION
   4234          /*-----------------------------------------------------------------------*/
   4235          /* Divide Physical Drive                                                 */
   4236          /*-----------------------------------------------------------------------*/
   4237          
   4238          FRESULT f_fdisk (
   4239          	BYTE pdrv,			/* Physical drive number */
   4240          	const DWORD szt[],	/* Pointer to the size table for each partitions */
   4241          	void* work			/* Pointer to the working buffer */
   4242          )
   4243          {
   4244          	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   4245          	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
   4246          	DSTATUS stat;
   4247          	DWORD sz_disk, sz_part, s_part;
   4248          
   4249          
   4250          	stat = disk_initialize(pdrv);
   4251          	if (stat & STA_NOINIT) return FR_NOT_READY;
   4252          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   4253          	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   4254          
   4255          	/* Determine CHS in the table regardless of the drive geometry */
   4256          	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
   4257          	if (n == 256) n--;
   4258          	e_hd = n - 1;
   4259          	sz_cyl = 63 * n;
   4260          	tot_cyl = sz_disk / sz_cyl;
   4261          
   4262          	/* Create partition table */
   4263          	mem_set(buf, 0, _MAX_SS);
   4264          	p = buf + MBR_Table; b_cyl = 0;
   4265          	for (i = 0; i < 4; i++, p += SZ_PTE) {
   4266          		p_cyl = (szt[i] <= 100U) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
   4267          		if (!p_cyl) continue;
   4268          		s_part = (DWORD)sz_cyl * b_cyl;
   4269          		sz_part = (DWORD)sz_cyl * p_cyl;
   4270          		if (i == 0) {	/* Exclude first track of cylinder 0 */
   4271          			s_hd = 1;
   4272          			s_part += 63; sz_part -= 63;
   4273          		} else {
   4274          			s_hd = 0;
   4275          		}
   4276          		e_cyl = b_cyl + p_cyl - 1;
   4277          		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   4278          
   4279          		/* Set partition table */
   4280          		p[1] = s_hd;						/* Start head */
   4281          		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
   4282          		p[3] = (BYTE)b_cyl;					/* Start cylinder */
   4283          		p[4] = 0x06;						/* System type (temporary setting) */
   4284          		p[5] = e_hd;						/* End head */
   4285          		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
   4286          		p[7] = (BYTE)e_cyl;					/* End cylinder */
   4287          		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
   4288          		ST_DWORD(p + 12, sz_part);			/* Partition size */
   4289          
   4290          		/* Next partition */
   4291          		b_cyl += p_cyl;
   4292          	}
   4293          	ST_WORD(p, 0xAA55);
   4294          
   4295          	/* Write it to the MBR */
   4296          	return (disk_write(pdrv, buf, 0, 1) != RES_OK || disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) ? FR_DISK_ERR : FR_OK;
   4297          }
   4298          
   4299          
   4300          #endif /* _MULTI_PARTITION */
   4301          #endif /* _USE_MKFS && !_FS_READONLY */
   4302          
   4303          
   4304          
   4305          
   4306          #if _USE_STRFUNC
   4307          /*-----------------------------------------------------------------------*/
   4308          /* Get a string from the file                                            */
   4309          /*-----------------------------------------------------------------------*/
   4310          

   \                                 In section .text, align 2, keep-with-next
   4311          TCHAR* f_gets (
   4312          	TCHAR* buff,	/* Pointer to the string buffer to read */
   4313          	int len,		/* Size of string buffer (characters) */
   4314          	FIL* fp			/* Pointer to the file object */
   4315          )
   4316          {
   \                     f_gets:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   4317          	int n = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
   4318          	TCHAR c, *p = buff;
   \   0000000E   0x46A1             MOV      R9,R4
   4319          	BYTE s[2];
   4320          	UINT rc;
   4321          
   4322          
   4323          	while (n < len - 1) {	/* Read characters until buffer gets filled */
   \                     ??f_gets_0:
   \   00000010   0x1E68             SUBS     R0,R5,#+1
   \   00000012   0x4287             CMP      R7,R0
   \   00000014   0xDA15             BGE.N    ??f_gets_1
   4324          #if _USE_LFN && _LFN_UNICODE
   4325          #if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
   4326          		f_read(fp, s, 1, &rc);
   4327          		if (rc != 1) break;
   4328          		c = s[0];
   4329          		if (c >= 0x80) {
   4330          			if (c < 0xC0) continue;	/* Skip stray trailer */
   4331          			if (c < 0xE0) {			/* Two-byte sequence */
   4332          				f_read(fp, s, 1, &rc);
   4333          				if (rc != 1) break;
   4334          				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
   4335          				if (c < 0x80) c = '?';
   4336          			} else {
   4337          				if (c < 0xF0) {		/* Three-byte sequence */
   4338          					f_read(fp, s, 2, &rc);
   4339          					if (rc != 2) break;
   4340          					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
   4341          					if (c < 0x800) c = '?';
   4342          				} else {			/* Reject four-byte sequence */
   4343          					c = '?';
   4344          				}
   4345          			}
   4346          		}
   4347          #elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
   4348          		f_read(fp, s, 2, &rc);
   4349          		if (rc != 2) break;
   4350          		c = s[1] + (s[0] << 8);
   4351          #elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
   4352          		f_read(fp, s, 2, &rc);
   4353          		if (rc != 2) break;
   4354          		c = s[0] + (s[1] << 8);
   4355          #else						/* Read a character in ANSI/OEM */
   4356          		f_read(fp, s, 1, &rc);
   4357          		if (rc != 1) break;
   4358          		c = s[0];
   4359          		if (IsDBCS1(c)) {
   4360          			f_read(fp, s, 1, &rc);
   4361          			if (rc != 1) break;
   4362          			c = (c << 8) + s[0];
   4363          		}
   4364          		c = ff_convert(c, 1);	/* OEM -> Unicode */
   4365          		if (!c) c = '?';
   4366          #endif
   4367          #else						/* Read a character without conversion */
   4368          		f_read(fp, s, 1, &rc);
   \   00000016   0xAB00             ADD      R3,SP,#+0
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0xA901             ADD      R1,SP,#+4
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x.... 0x....      BL       f_read
   4369          		if (rc != 1) break;
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD10C             BNE.N    ??f_gets_1
   4370          		c = s[0];
   \                     ??f_gets_2:
   \   00000028   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000002C   0x4680             MOV      R8,R0
   4371          #endif
   4372          		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
   4373          		*p++ = c;
   \   0000002E   0xF889 0x8000      STRB     R8,[R9, #+0]
   \   00000032   0xF119 0x0901      ADDS     R9,R9,#+1
   4374          		n++;
   \   00000036   0x1C7F             ADDS     R7,R7,#+1
   4375          		if (c == '\n') break;		/* Break on EOL */
   \   00000038   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003C   0xF1B8 0x0F0A      CMP      R8,#+10
   \   00000040   0xD1E6             BNE.N    ??f_gets_0
   4376          	}
   4377          	*p = 0;
   \                     ??f_gets_1:
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF889 0x0000      STRB     R0,[R9, #+0]
   4378          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   \   00000048   0x2F00             CMP      R7,#+0
   \   0000004A   0xD100             BNE.N    ??f_gets_3
   \                     ??f_gets_4:
   \   0000004C   0x2400             MOVS     R4,#+0
   \                     ??f_gets_3:
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   4379          }
   4380          
   4381          
   4382          
   4383          #if !_FS_READONLY
   4384          #include <stdarg.h>
   4385          /*-----------------------------------------------------------------------*/
   4386          /* Put a character to the file                                           */
   4387          /*-----------------------------------------------------------------------*/
   4388          
   4389          typedef struct {
   4390          	FIL* fp;
   4391          	int idx, nchr;
   4392          	BYTE buf[64];
   4393          } putbuff;
   4394          
   4395          

   \                                 In section .text, align 2, keep-with-next
   4396          static
   4397          void putc_bfd (
   4398          	putbuff* pb,
   4399          	TCHAR c
   4400          )
   4401          {
   \                     putc_bfd:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   4402          	UINT bw;
   4403          	int i;
   4404          
   4405          
   4406          	if (_USE_STRFUNC == 2 && c == '\n')	 /* LF -> CRLF conversion */
   4407          		putc_bfd(pb, '\r');
   4408          
   4409          	i = pb->idx;	/* Buffer write index (-1:error) */
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x0006             MOVS     R6,R0
   4410          	if (i < 0) return;
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD416             BMI.N    ??putc_bfd_0
   4411          
   4412          #if _USE_LFN && _LFN_UNICODE
   4413          #if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
   4414          	if (c < 0x80) {				/* 7-bit */
   4415          		pb->buf[i++] = (BYTE)c;
   4416          	} else {
   4417          		if (c < 0x800) {		/* 11-bit */
   4418          			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
   4419          		} else {				/* 16-bit */
   4420          			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
   4421          			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
   4422          		}
   4423          		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
   4424          	}
   4425          #elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
   4426          	pb->buf[i++] = (BYTE)(c >> 8);
   4427          	pb->buf[i++] = (BYTE)c;
   4428          #elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
   4429          	pb->buf[i++] = (BYTE)c;
   4430          	pb->buf[i++] = (BYTE)(c >> 8);
   4431          #else							/* Write a character in ANSI/OEM */
   4432          	c = ff_convert(c, 0);	/* Unicode -> OEM */
   4433          	if (!c) c = '?';
   4434          	if (c >= 0x100)
   4435          		pb->buf[i++] = (BYTE)(c >> 8);
   4436          	pb->buf[i++] = (BYTE)c;
   4437          #endif
   4438          #else							/* Write a character without conversion */
   4439          	pb->buf[i++] = (BYTE)c;
   \                     ??putc_bfd_1:
   \   00000010   0x1930             ADDS     R0,R6,R4
   \   00000012   0x7305             STRB     R5,[R0, #+12]
   \   00000014   0x1C76             ADDS     R6,R6,#+1
   4440          #endif
   4441          
   4442          	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
   \   00000016   0x2E3D             CMP      R6,#+61
   \   00000018   0xDB0D             BLT.N    ??putc_bfd_2
   4443          		f_write(pb->fp, pb->buf, (UINT)i, &bw);
   \   0000001A   0xAB00             ADD      R3,SP,#+0
   \   0000001C   0x0032             MOVS     R2,R6
   \   0000001E   0xF114 0x010C      ADDS     R1,R4,#+12
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       f_write
   4444          		i = (bw == (UINT)i) ? 0 : -1;
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x42B0             CMP      R0,R6
   \   0000002C   0xD101             BNE.N    ??putc_bfd_3
   \   0000002E   0x2600             MOVS     R6,#+0
   \   00000030   0xE001             B.N      ??putc_bfd_2
   \                     ??putc_bfd_3:
   \   00000032   0xF05F 0x36FF      MOVS     R6,#-1
   4445          	}
   4446          	pb->idx = i;
   \                     ??putc_bfd_2:
   \   00000036   0x6066             STR      R6,[R4, #+4]
   4447          	pb->nchr++;
   \   00000038   0x68A0             LDR      R0,[R4, #+8]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x60A0             STR      R0,[R4, #+8]
   4448          }
   \                     ??putc_bfd_0:
   \   0000003E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   4449          
   4450          
   4451          

   \                                 In section .text, align 2, keep-with-next
   4452          int f_putc (
   4453          	TCHAR c,	/* A character to be output */
   4454          	FIL* fp		/* Pointer to the file object */
   4455          )
   4456          {
   \                     f_putc:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB095             SUB      SP,SP,#+84
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   4457          	putbuff pb;
   4458          	UINT nw;
   4459          
   4460          
   4461          	pb.fp = fp;			/* Initialize output buffer */
   \   00000008   0x9501             STR      R5,[SP, #+4]
   4462          	pb.nchr = pb.idx = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0x9003             STR      R0,[SP, #+12]
   4463          
   4464          	putc_bfd(&pb, c);	/* Put a character */
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       putc_bfd
   4465          
   4466          	if (   pb.idx >= 0	/* Flush buffered characters to the file */
   4467          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   4468          		&& (UINT)pb.idx == nw) return pb.nchr;
   \   0000001A   0x9802             LDR      R0,[SP, #+8]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD40D             BMI.N    ??f_putc_0
   \   00000020   0xAB00             ADD      R3,SP,#+0
   \   00000022   0x9A02             LDR      R2,[SP, #+8]
   \   00000024   0xA904             ADD      R1,SP,#+16
   \   00000026   0x9801             LDR      R0,[SP, #+4]
   \   00000028   0x.... 0x....      BL       f_write
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD105             BNE.N    ??f_putc_0
   \   00000030   0x9802             LDR      R0,[SP, #+8]
   \   00000032   0x9900             LDR      R1,[SP, #+0]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD101             BNE.N    ??f_putc_0
   \   00000038   0x9803             LDR      R0,[SP, #+12]
   \   0000003A   0xE001             B.N      ??f_putc_1
   4469          	return EOF;
   \                     ??f_putc_0:
   \   0000003C   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??f_putc_1:
   \   00000040   0xB015             ADD      SP,SP,#+84
   \   00000042   0xBD30             POP      {R4,R5,PC}       ;; return
   4470          }
   4471          
   4472          
   4473          
   4474          
   4475          /*-----------------------------------------------------------------------*/
   4476          /* Put a string to the file                                              */
   4477          /*-----------------------------------------------------------------------*/
   4478          

   \                                 In section .text, align 2, keep-with-next
   4479          int f_puts (
   4480          	const TCHAR* str,	/* Pointer to the string to be output */
   4481          	FIL* fp				/* Pointer to the file object */
   4482          )
   4483          {
   \                     f_puts:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB095             SUB      SP,SP,#+84
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
   4484          	putbuff pb;
   4485          	UINT nw;
   4486          
   4487          
   4488          	pb.fp = fp;				/* Initialize output buffer */
   \   00000008   0x9401             STR      R4,[SP, #+4]
   4489          	pb.nchr = pb.idx = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0x9003             STR      R0,[SP, #+12]
   4490          
   4491          	while (*str)			/* Put the string */
   \                     ??f_puts_0:
   \   00000010   0x7828             LDRB     R0,[R5, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ.N    ??f_puts_1
   4492          		putc_bfd(&pb, *str++);
   \   00000016   0x7829             LDRB     R1,[R5, #+0]
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       putc_bfd
   \   0000001E   0x1C6D             ADDS     R5,R5,#+1
   \   00000020   0xE7F6             B.N      ??f_puts_0
   4493          
   4494          	if (   pb.idx >= 0		/* Flush buffered characters to the file */
   4495          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   4496          		&& (UINT)pb.idx == nw) return pb.nchr;
   \                     ??f_puts_1:
   \   00000022   0x9802             LDR      R0,[SP, #+8]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD40D             BMI.N    ??f_puts_2
   \   00000028   0xAB00             ADD      R3,SP,#+0
   \   0000002A   0x9A02             LDR      R2,[SP, #+8]
   \   0000002C   0xA904             ADD      R1,SP,#+16
   \   0000002E   0x9801             LDR      R0,[SP, #+4]
   \   00000030   0x.... 0x....      BL       f_write
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD105             BNE.N    ??f_puts_2
   \   00000038   0x9802             LDR      R0,[SP, #+8]
   \   0000003A   0x9900             LDR      R1,[SP, #+0]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD101             BNE.N    ??f_puts_2
   \   00000040   0x9803             LDR      R0,[SP, #+12]
   \   00000042   0xE001             B.N      ??f_puts_3
   4497          	return EOF;
   \                     ??f_puts_2:
   \   00000044   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??f_puts_3:
   \   00000048   0xB015             ADD      SP,SP,#+84
   \   0000004A   0xBD30             POP      {R4,R5,PC}       ;; return
   4498          }
   4499          
   4500          
   4501          
   4502          
   4503          /*-----------------------------------------------------------------------*/
   4504          /* Put a formatted string to the file                                    */
   4505          /*-----------------------------------------------------------------------*/
   4506          

   \                                 In section .text, align 2, keep-with-next
   4507          int f_printf (
   4508          	FIL* fp,			/* Pointer to the file object */
   4509          	const TCHAR* fmt,	/* Pointer to the format string */
   4510          	...					/* Optional arguments... */
   4511          )
   4512          {
   \                     f_printf:
   \   00000000   0xB40D             PUSH     {R0,R2,R3}
   \   00000002   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000006   0xB09A             SUB      SP,SP,#+104
   \   00000008   0x4688             MOV      R8,R1
   4513          	va_list arp;
   4514          	BYTE f, r;
   4515          	UINT nw, i, j, w;
   4516          	DWORD v;
   4517          	TCHAR c, d, s[16], *p;
   4518          	putbuff pb;
   4519          
   4520          
   4521          	pb.fp = fp;				/* Initialize output buffer */
   \   0000000A   0x9823             LDR      R0,[SP, #+140]
   \   0000000C   0x9003             STR      R0,[SP, #+12]
   4522          	pb.nchr = pb.idx = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9004             STR      R0,[SP, #+16]
   \   00000012   0x9005             STR      R0,[SP, #+20]
   4523          
   4524          	va_start(arp, fmt);
   \   00000014   0xA824             ADD      R0,SP,#+144
   \   00000016   0x4682             MOV      R10,R0
   4525          
   4526          	for (;;) {
   4527          		c = *fmt++;
   \                     ??f_printf_0:
   \   00000018   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000020   0xF118 0x0801      ADDS     R8,R8,#+1
   4528          		if (c == 0) break;			/* End of string */
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xF000 0x813D      BEQ.W    ??f_printf_1
   4529          		if (c != '%') {				/* Non escape character */
   \                     ??f_printf_2:
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000032   0x2825             CMP      R0,#+37
   \   00000034   0xD005             BEQ.N    ??f_printf_3
   4530          			putc_bfd(&pb, c);
   \   00000036   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000003A   0xA803             ADD      R0,SP,#+12
   \   0000003C   0x.... 0x....      BL       putc_bfd
   4531          			continue;
   \   00000040   0xE7EA             B.N      ??f_printf_0
   4532          		}
   4533          		w = f = 0;
   \                     ??f_printf_3:
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0007             MOVS     R7,R0
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x0006             MOVS     R6,R0
   4534          		c = *fmt++;
   \   0000004A   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000004E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000052   0xF118 0x0801      ADDS     R8,R8,#+1
   4535          		if (c == '0') {				/* Flag: '0' padding */
   \   00000056   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005A   0x2830             CMP      R0,#+48
   \   0000005C   0xD108             BNE.N    ??f_printf_4
   4536          			f = 1; c = *fmt++;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x0007             MOVS     R7,R0
   \   00000062   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000066   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000006A   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000006E   0xE00B             B.N      ??f_printf_5
   4537          		} else {
   4538          			if (c == '-') {			/* Flag: left justified */
   \                     ??f_printf_4:
   \   00000070   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000074   0x282D             CMP      R0,#+45
   \   00000076   0xD107             BNE.N    ??f_printf_5
   4539          				f = 2; c = *fmt++;
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0x0007             MOVS     R7,R0
   \   0000007C   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000080   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000084   0xF118 0x0801      ADDS     R8,R8,#+1
   4540          			}
   4541          		}
   4542          		while (IsDigit(c)) {		/* Precision */
   \                     ??f_printf_5:
   \   00000088   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000008C   0x2830             CMP      R0,#+48
   \   0000008E   0xDB11             BLT.N    ??f_printf_6
   \   00000090   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000094   0x283A             CMP      R0,#+58
   \   00000096   0xDA0D             BGE.N    ??f_printf_6
   4543          			w = w * 10 + c - '0';
   \   00000098   0x200A             MOVS     R0,#+10
   \   0000009A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000009E   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   000000A2   0xF1B0 0x0630      SUBS     R6,R0,#+48
   4544          			c = *fmt++;
   \   000000A6   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000AA   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000AE   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000B2   0xE7E9             B.N      ??f_printf_5
   4545          		}
   4546          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   \                     ??f_printf_6:
   \   000000B4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B8   0x286C             CMP      R0,#+108
   \   000000BA   0xD003             BEQ.N    ??f_printf_7
   \   000000BC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C0   0x284C             CMP      R0,#+76
   \   000000C2   0xD107             BNE.N    ??f_printf_8
   4547          			f |= 4; c = *fmt++;
   \                     ??f_printf_7:
   \   000000C4   0xF057 0x0704      ORRS     R7,R7,#0x4
   \   000000C8   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000CC   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000D0   0xF118 0x0801      ADDS     R8,R8,#+1
   4548          		}
   4549          		if (!c) break;
   \                     ??f_printf_8:
   \   000000D4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xF000 0x80E5      BEQ.W    ??f_printf_1
   4550          		d = c;
   \                     ??f_printf_9:
   \   000000DE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E2   0x4681             MOV      R9,R0
   4551          		if (IsLower(d)) d -= 0x20;
   \   000000E4   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000E8   0xF1B9 0x0F61      CMP      R9,#+97
   \   000000EC   0xDB06             BLT.N    ??f_printf_10
   \   000000EE   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000F2   0xF1B9 0x0F7B      CMP      R9,#+123
   \   000000F6   0xDA01             BGE.N    ??f_printf_10
   \   000000F8   0xF1B9 0x0920      SUBS     R9,R9,#+32
   4552          		switch (d) {				/* Type is... */
   \                     ??f_printf_10:
   \   000000FC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0x2842             CMP      R0,#+66
   \   00000104   0xD048             BEQ.N    ??f_printf_11
   \   00000106   0x2843             CMP      R0,#+67
   \   00000108   0xD03D             BEQ.N    ??f_printf_12
   \   0000010A   0x2844             CMP      R0,#+68
   \   0000010C   0xD04C             BEQ.N    ??f_printf_13
   \   0000010E   0x284F             CMP      R0,#+79
   \   00000110   0xD046             BEQ.N    ??f_printf_14
   \   00000112   0x2853             CMP      R0,#+83
   \   00000114   0xD004             BEQ.N    ??f_printf_15
   \   00000116   0x2855             CMP      R0,#+85
   \   00000118   0xD046             BEQ.N    ??f_printf_13
   \   0000011A   0x2858             CMP      R0,#+88
   \   0000011C   0xD048             BEQ.N    ??f_printf_16
   \   0000011E   0xE04B             B.N      ??f_printf_17
   4553          		case 'S' :					/* String */
   4554          			p = va_arg(arp, TCHAR*);
   \                     ??f_printf_15:
   \   00000120   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000124   0x9001             STR      R0,[SP, #+4]
   \   00000126   0xF11A 0x0A04      ADDS     R10,R10,#+4
   4555          			for (j = 0; p[j]; j++) ;
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x4683             MOV      R11,R0
   \                     ??f_printf_18:
   \   0000012E   0x9801             LDR      R0,[SP, #+4]
   \   00000130   0xF81B 0x0000      LDRB     R0,[R11, R0]
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD002             BEQ.N    ??f_printf_19
   \   00000138   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   0000013C   0xE7F7             B.N      ??f_printf_18
   4556          			if (!(f & 2)) {
   \                     ??f_printf_19:
   \   0000013E   0x07B8             LSLS     R0,R7,#+30
   \   00000140   0xD409             BMI.N    ??f_printf_20
   4557          				while (j++ < w) putc_bfd(&pb, ' ');
   \                     ??f_printf_21:
   \   00000142   0x4658             MOV      R0,R11
   \   00000144   0xF110 0x0B01      ADDS     R11,R0,#+1
   \   00000148   0x42B0             CMP      R0,R6
   \   0000014A   0xD204             BCS.N    ??f_printf_20
   \   0000014C   0x2120             MOVS     R1,#+32
   \   0000014E   0xA803             ADD      R0,SP,#+12
   \   00000150   0x.... 0x....      BL       putc_bfd
   \   00000154   0xE7F5             B.N      ??f_printf_21
   4558          			}
   4559          			while (*p) putc_bfd(&pb, *p++);
   \                     ??f_printf_20:
   \   00000156   0x9801             LDR      R0,[SP, #+4]
   \   00000158   0x7800             LDRB     R0,[R0, #+0]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD008             BEQ.N    ??f_printf_22
   \   0000015E   0x9801             LDR      R0,[SP, #+4]
   \   00000160   0x7801             LDRB     R1,[R0, #+0]
   \   00000162   0xA803             ADD      R0,SP,#+12
   \   00000164   0x.... 0x....      BL       putc_bfd
   \   00000168   0x9801             LDR      R0,[SP, #+4]
   \   0000016A   0x1C40             ADDS     R0,R0,#+1
   \   0000016C   0x9001             STR      R0,[SP, #+4]
   \   0000016E   0xE7F2             B.N      ??f_printf_20
   4560          			while (j++ < w) putc_bfd(&pb, ' ');
   \                     ??f_printf_22:
   \   00000170   0x4658             MOV      R0,R11
   \   00000172   0xF110 0x0B01      ADDS     R11,R0,#+1
   \   00000176   0x42B0             CMP      R0,R6
   \   00000178   0xD204             BCS.N    ??f_printf_23
   \   0000017A   0x2120             MOVS     R1,#+32
   \   0000017C   0xA803             ADD      R0,SP,#+12
   \   0000017E   0x.... 0x....      BL       putc_bfd
   \   00000182   0xE7F5             B.N      ??f_printf_22
   4561          			continue;
   \                     ??f_printf_23:
   \   00000184   0xE748             B.N      ??f_printf_0
   4562          		case 'C' :					/* Character */
   4563          			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
   \                     ??f_printf_12:
   \   00000186   0x4650             MOV      R0,R10
   \   00000188   0xF110 0x0A04      ADDS     R10,R0,#+4
   \   0000018C   0x6801             LDR      R1,[R0, #+0]
   \   0000018E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000190   0xA803             ADD      R0,SP,#+12
   \   00000192   0x.... 0x....      BL       putc_bfd
   \   00000196   0xE73F             B.N      ??f_printf_0
   4564          		case 'B' :					/* Binary */
   4565          			r = 2; break;
   \                     ??f_printf_11:
   \   00000198   0x2002             MOVS     R0,#+2
   \   0000019A   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000019E   0xE011             B.N      ??f_printf_24
   4566          		case 'O' :					/* Octal */
   4567          			r = 8; break;
   \                     ??f_printf_14:
   \   000001A0   0x2008             MOVS     R0,#+8
   \   000001A2   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   000001A6   0xE00D             B.N      ??f_printf_24
   4568          		case 'D' :					/* Signed decimal */
   4569          		case 'U' :					/* Unsigned decimal */
   4570          			r = 10; break;
   \                     ??f_printf_13:
   \   000001A8   0x200A             MOVS     R0,#+10
   \   000001AA   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   000001AE   0xE009             B.N      ??f_printf_24
   4571          		case 'X' :					/* Hexdecimal */
   4572          			r = 16; break;
   \                     ??f_printf_16:
   \   000001B0   0x2010             MOVS     R0,#+16
   \   000001B2   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   000001B6   0xE005             B.N      ??f_printf_24
   4573          		default:					/* Unknown type (pass-through) */
   4574          			putc_bfd(&pb, c); continue;
   \                     ??f_printf_17:
   \   000001B8   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000001BC   0xA803             ADD      R0,SP,#+12
   \   000001BE   0x.... 0x....      BL       putc_bfd
   \   000001C2   0xE729             B.N      ??f_printf_0
   4575          		}
   4576          
   4577          		/* Get an argument and put it in numeral */
   4578          		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
   \                     ??f_printf_24:
   \   000001C4   0x0778             LSLS     R0,R7,#+29
   \   000001C6   0xD504             BPL.N    ??f_printf_25
   \   000001C8   0xF8DA 0x5000      LDR      R5,[R10, #+0]
   \   000001CC   0xF11A 0x0A04      ADDS     R10,R10,#+4
   \   000001D0   0xE00D             B.N      ??f_printf_26
   \                     ??f_printf_25:
   \   000001D2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001D6   0xF1B9 0x0F44      CMP      R9,#+68
   \   000001DA   0xD104             BNE.N    ??f_printf_27
   \   000001DC   0xF8DA 0x5000      LDR      R5,[R10, #+0]
   \   000001E0   0xF11A 0x0A04      ADDS     R10,R10,#+4
   \   000001E4   0xE003             B.N      ??f_printf_26
   \                     ??f_printf_27:
   \   000001E6   0xF8DA 0x5000      LDR      R5,[R10, #+0]
   \   000001EA   0xF11A 0x0A04      ADDS     R10,R10,#+4
   4579          		if (d == 'D' && (v & 0x80000000)) {
   \                     ??f_printf_26:
   \   000001EE   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001F2   0xF1B9 0x0F44      CMP      R9,#+68
   \   000001F6   0xD104             BNE.N    ??f_printf_28
   \   000001F8   0x2D00             CMP      R5,#+0
   \   000001FA   0xD502             BPL.N    ??f_printf_28
   4580          			v = 0 - v;
   \   000001FC   0x426D             RSBS     R5,R5,#+0
   4581          			f |= 8;
   \   000001FE   0xF057 0x0708      ORRS     R7,R7,#0x8
   4582          		}
   4583          		i = 0;
   \                     ??f_printf_28:
   \   00000202   0x2000             MOVS     R0,#+0
   \   00000204   0x0004             MOVS     R4,R0
   4584          		do {
   4585          			d = (TCHAR)(v % r); v /= r;
   \                     ??f_printf_29:
   \   00000206   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000020A   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   0000020E   0xFB00 0x5011      MLS      R0,R0,R1,R5
   \   00000212   0x4681             MOV      R9,R0
   \   00000214   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000218   0xFBB5 0xF5F0      UDIV     R5,R5,R0
   4586          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   \   0000021C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000220   0xF1B9 0x0F0A      CMP      R9,#+10
   \   00000224   0xDB08             BLT.N    ??f_printf_30
   \   00000226   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000022A   0x2878             CMP      R0,#+120
   \   0000022C   0xD101             BNE.N    ??f_printf_31
   \   0000022E   0x2027             MOVS     R0,#+39
   \   00000230   0xE000             B.N      ??f_printf_32
   \                     ??f_printf_31:
   \   00000232   0x2007             MOVS     R0,#+7
   \                     ??f_printf_32:
   \   00000234   0xEB10 0x0909      ADDS     R9,R0,R9
   4587          			s[i++] = d + '0';
   \                     ??f_printf_30:
   \   00000238   0xA816             ADD      R0,SP,#+88
   \   0000023A   0xF119 0x0130      ADDS     R1,R9,#+48
   \   0000023E   0x5421             STRB     R1,[R4, R0]
   \   00000240   0x1C64             ADDS     R4,R4,#+1
   4588          		} while (v && i < sizeof s / sizeof s[0]);
   \   00000242   0x2D00             CMP      R5,#+0
   \   00000244   0xD001             BEQ.N    ??f_printf_33
   \   00000246   0x2C10             CMP      R4,#+16
   \   00000248   0xD3DD             BCC.N    ??f_printf_29
   4589          		if (f & 8) s[i++] = '-';
   \                     ??f_printf_33:
   \   0000024A   0x0738             LSLS     R0,R7,#+28
   \   0000024C   0xD503             BPL.N    ??f_printf_34
   \   0000024E   0xA816             ADD      R0,SP,#+88
   \   00000250   0x212D             MOVS     R1,#+45
   \   00000252   0x5421             STRB     R1,[R4, R0]
   \   00000254   0x1C64             ADDS     R4,R4,#+1
   4590          		j = i; d = (f & 1) ? '0' : ' ';
   \                     ??f_printf_34:
   \   00000256   0x46A3             MOV      R11,R4
   \   00000258   0x07F8             LSLS     R0,R7,#+31
   \   0000025A   0xD502             BPL.N    ??f_printf_35
   \   0000025C   0xF05F 0x0930      MOVS     R9,#+48
   \   00000260   0xE001             B.N      ??f_printf_36
   \                     ??f_printf_35:
   \   00000262   0xF05F 0x0920      MOVS     R9,#+32
   4591          		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
   \                     ??f_printf_36:
   \                     ??f_printf_37:
   \   00000266   0x07B8             LSLS     R0,R7,#+30
   \   00000268   0xD40A             BMI.N    ??f_printf_38
   \   0000026A   0x4658             MOV      R0,R11
   \   0000026C   0xF110 0x0B01      ADDS     R11,R0,#+1
   \   00000270   0x42B0             CMP      R0,R6
   \   00000272   0xD205             BCS.N    ??f_printf_38
   \   00000274   0x4649             MOV      R1,R9
   \   00000276   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000278   0xA803             ADD      R0,SP,#+12
   \   0000027A   0x.... 0x....      BL       putc_bfd
   \   0000027E   0xE7F2             B.N      ??f_printf_37
   4592          		do putc_bfd(&pb, s[--i]); while (i);
   \                     ??f_printf_38:
   \   00000280   0x1E64             SUBS     R4,R4,#+1
   \   00000282   0xA816             ADD      R0,SP,#+88
   \   00000284   0x5C21             LDRB     R1,[R4, R0]
   \   00000286   0xA803             ADD      R0,SP,#+12
   \   00000288   0x.... 0x....      BL       putc_bfd
   \   0000028C   0x2C00             CMP      R4,#+0
   \   0000028E   0xD1F7             BNE.N    ??f_printf_38
   4593          		while (j++ < w) putc_bfd(&pb, d);
   \                     ??f_printf_39:
   \   00000290   0x4658             MOV      R0,R11
   \   00000292   0xF110 0x0B01      ADDS     R11,R0,#+1
   \   00000296   0x42B0             CMP      R0,R6
   \   00000298   0xF4BF 0xAEBE      BCS.W    ??f_printf_0
   \   0000029C   0x4649             MOV      R1,R9
   \   0000029E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002A0   0xA803             ADD      R0,SP,#+12
   \   000002A2   0x.... 0x....      BL       putc_bfd
   \   000002A6   0xE7F3             B.N      ??f_printf_39
   4594          	}
   4595          
   4596          	va_end(arp);
   4597          
   4598          	if (   pb.idx >= 0		/* Flush buffered characters to the file */
   4599          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   4600          		&& (UINT)pb.idx == nw) return pb.nchr;
   \                     ??f_printf_1:
   \   000002A8   0x9804             LDR      R0,[SP, #+16]
   \   000002AA   0x2800             CMP      R0,#+0
   \   000002AC   0xD40D             BMI.N    ??f_printf_40
   \   000002AE   0xAB02             ADD      R3,SP,#+8
   \   000002B0   0x9A04             LDR      R2,[SP, #+16]
   \   000002B2   0xA906             ADD      R1,SP,#+24
   \   000002B4   0x9803             LDR      R0,[SP, #+12]
   \   000002B6   0x.... 0x....      BL       f_write
   \   000002BA   0x2800             CMP      R0,#+0
   \   000002BC   0xD105             BNE.N    ??f_printf_40
   \   000002BE   0x9804             LDR      R0,[SP, #+16]
   \   000002C0   0x9902             LDR      R1,[SP, #+8]
   \   000002C2   0x4288             CMP      R0,R1
   \   000002C4   0xD101             BNE.N    ??f_printf_40
   \   000002C6   0x9805             LDR      R0,[SP, #+20]
   \   000002C8   0xE001             B.N      ??f_printf_41
   4601          	return EOF;
   \                     ??f_printf_40:
   \   000002CA   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??f_printf_41:
   \   000002CE   0xB01A             ADD      SP,SP,#+104
   \   000002D0   0xE8BD 0x0FF0      POP      {R4-R11}
   \   000002D4   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
   4602          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     LfnOfs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     `?<Constant "\\"*:<>?|\\177">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     ExCvt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     `?<Constant "+,;=[]">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x00544146         DC32     0x544146

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     FatFs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x41615252         DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x61417272         DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     Fsid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     LfnBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     LfnBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     FatFs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     ??vst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     ??cst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     `?<Constant "\\353\\376\\220MSDOS5.0">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     `?<Constant "NO NAME    FAT32   ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     `?<Constant "NO NAME    FAT     ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x00FFFF00         DC32     0xffff00

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"*:<>?|\\177">`:
   \   00000000   0x22 0x2A          DC8 "\"*:<>?|\177"
   \              0x3A 0x3C    
   \              0x3E 0x3F    
   \              0x7C 0x7F    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "+,;=[]">`:
   \   00000000   0x2B 0x2C          DC8 "+,;=[]"
   \              0x3B 0x3D    
   \              0x5B 0x5D    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\353\\376\\220MSDOS5.0">`:
   \   00000000   0xEB 0xFE          DC8 "\353\376\220MSDOS5.0"
   \              0x90 0x4D    
   \              0x53 0x44    
   \              0x4F 0x53    
   \              0x35 0x2E    
   \              0x30 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "NO NAME    FAT32   ">`:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT32   "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x33 0x32    
   \              0x20 0x20    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "NO NAME    FAT     ">`:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT     "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    
   4603          
   4604          #endif /* !_FS_READONLY */
   4605          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   check_fs
        16   -> move_window
       0   chk_chr
       0   clust2sect
      32   cmp_lfn
        32   -> ff_wtoupper
      32   create_chain
        32   -> get_fat
        32   -> put_fat
      48   create_name
        48   -> chk_chr
        48   -> ff_convert
        48   -> mem_set
      24   dir_alloc
        24   -> dir_next
        24   -> dir_sdi
        24   -> move_window
      32   dir_find
        32   -> cmp_lfn
        32   -> dir_next
        32   -> dir_sdi
        32   -> mem_cmp
        32   -> move_window
        32   -> sum_sfn
      24   dir_next
        24   -> clust2sect
        24   -> create_chain
        24   -> get_fat
        24   -> mem_set
        24   -> sync_window
      40   dir_read
        40   -> dir_next
        40   -> move_window
        40   -> pick_lfn
        40   -> sum_sfn
      48   dir_register
        48   -> dir_alloc
        48   -> dir_find
        48   -> dir_next
        48   -> dir_sdi
        48   -> fit_lfn
        48   -> gen_numname
        48   -> mem_cpy
        48   -> mem_set
        48   -> move_window
        48   -> sum_sfn
      16   dir_remove
        16   -> dir_next
        16   -> dir_sdi
        16   -> mem_set
        16   -> move_window
      24   dir_sdi
        24   -> clust2sect
        24   -> get_fat
      64   f_chdir
        64   -> find_volume
        64   -> follow_path
        64   -> ld_clust
      72   f_chmod
        72   -> find_volume
        72   -> follow_path
        72   -> sync_fs
      16   f_close
        16   -> f_sync
        16   -> validate
      16   f_closedir
        16   -> validate
      56   f_getfree
        56   -> find_volume
        56   -> get_fat
        56   -> move_window
      40   f_gets
        40   -> f_read
      32   f_lseek
        32   -> clust2sect
        32   -> create_chain
        32   -> disk_read
        32   -> disk_write
        32   -> get_fat
        32   -> validate
      88   f_mkdir
        88   -> clust2sect
        88   -> create_chain
        88   -> dir_register
        88   -> find_volume
        88   -> follow_path
        88   -> get_fattime
        88   -> mem_cpy
        88   -> mem_set
        88   -> remove_chain
        88   -> st_clust
        88   -> sync_fs
        88   -> sync_window
      96   f_mkfs
        96   -> disk_initialize
        96   -> disk_ioctl
        96   -> disk_write
        96   -> get_fattime
        96   -> get_ldnumber
        96   -> mem_cpy
        96   -> mem_set
      32   f_mount
        32   -> find_volume
        32   -> get_ldnumber
      80   f_open
        80   -> dir_register
        80   -> find_volume
        80   -> follow_path
        80   -> get_fattime
        80   -> ld_clust
        80   -> move_window
        80   -> remove_chain
        80   -> st_clust
      32   f_opendir
        32   -> dir_sdi
        32   -> find_volume
        32   -> follow_path
        32   -> ld_clust
     152   f_printf
       152   -> f_write
       152   -> putc_bfd
      96   f_putc
        96   -> f_write
        96   -> putc_bfd
      96   f_puts
        96   -> f_write
        96   -> putc_bfd
      56   f_read
        56   -> clust2sect
        56   -> disk_read
        56   -> disk_write
        56   -> get_fat
        56   -> mem_cpy
        56   -> validate
      32   f_readdir
        32   -> dir_next
        32   -> dir_read
        32   -> dir_sdi
        32   -> get_fileinfo
        32   -> validate
     136   f_rename
       136   -> clust2sect
       136   -> dir_register
       136   -> dir_remove
       136   -> find_volume
       136   -> follow_path
       136   -> get_ldnumber
       136   -> ld_clust
       136   -> mem_cpy
       136   -> move_window
       136   -> st_clust
       136   -> sync_fs
      64   f_stat
        64   -> find_volume
        64   -> follow_path
        64   -> get_fileinfo
      24   f_sync
        24   -> disk_write
        24   -> get_fattime
        24   -> move_window
        24   -> st_clust
        24   -> sync_fs
        24   -> validate
      16   f_truncate
        16   -> disk_write
        16   -> get_fat
        16   -> put_fat
        16   -> remove_chain
        16   -> validate
     104   f_unlink
       104   -> dir_read
       104   -> dir_remove
       104   -> dir_sdi
       104   -> find_volume
       104   -> follow_path
       104   -> ld_clust
       104   -> mem_cpy
       104   -> remove_chain
       104   -> sync_fs
      72   f_utime
        72   -> find_volume
        72   -> follow_path
        72   -> sync_fs
      48   f_write
        48   -> clust2sect
        48   -> create_chain
        48   -> disk_read
        48   -> disk_write
        48   -> mem_cpy
        48   -> validate
      80   find_volume
        80   -> check_fs
        80   -> disk_initialize
        80   -> disk_status
        80   -> get_ldnumber
        80   -> move_window
      16   fit_lfn
      24   follow_path
        24   -> create_name
        24   -> dir_find
        24   -> dir_sdi
        24   -> ld_clust
      40   gen_numname
        40   -> mem_cpy
      32   get_fat
        32   -> move_window
      32   get_fileinfo
        32   -> ff_convert
       8   get_ldnumber
       4   ld_clust
      12   mem_cmp
       8   mem_cpy
       4   mem_set
      16   move_window
        16   -> disk_read
        16   -> sync_window
      16   pick_lfn
      32   put_fat
        32   -> move_window
      24   putc_bfd
        24   -> f_write
      24   remove_chain
        24   -> get_fat
        24   -> put_fat
       0   st_clust
       0   sum_sfn
      16   sync_fs
        16   -> disk_ioctl
        16   -> disk_write
        16   -> mem_set
        16   -> sync_window
      24   sync_window
        24   -> disk_write
      16   validate
        16   -> disk_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "+,;=[]">
      20  ?<Constant "NO NAME    FAT     ">
      20  ?<Constant "NO NAME    FAT32   ">
      12  ?<Constant "\"*:<>?|\177">
      12  ?<Constant "\353\376\220MSDOS5.0">
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable12
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable4
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable8
       4  ??DataTable8_1
     128  ExCvt
       4  FatFs
       2  Fsid
     512  LfnBuf
      16  LfnOfs
     126  check_fs
      20  chk_chr
      26  clust2sect
     158  cmp_lfn
     234  create_chain
     706  create_name
      24  cst
     102  dir_alloc
     278  dir_find
     298  dir_next
     258  dir_read
     346  dir_register
     114  dir_remove
     178  dir_sdi
     106  f_chdir
     122  f_chmod
      42  f_close
      28  f_closedir
     286  f_getfree
      84  f_gets
     442  f_lseek
     430  f_mkdir
    1722  f_mkfs
     100  f_mount
     402  f_open
     142  f_opendir
     728  f_printf
      68  f_putc
      76  f_puts
     500  f_read
     118  f_readdir
     318  f_rename
      80  f_stat
     182  f_sync
     224  f_truncate
     244  f_unlink
     128  f_utime
     558  f_write
    1092  find_volume
     132  fit_lfn
     174  follow_path
     202  gen_numname
     284  get_fat
     274  get_fileinfo
      80  get_ldnumber
      40  ld_clust
      36  mem_cmp
      28  mem_cpy
      22  mem_set
      64  move_window
     120  pick_lfn
     364  put_fat
      64  putc_bfd
     118  remove_chain
      24  st_clust
      30  sum_sfn
     216  sync_fs
      90  sync_window
      58  validate
      24  vst

 
    518 bytes in section .bss
    264 bytes in section .rodata
 13 558 bytes in section .text
 
 13 558 bytes of CODE  memory
    264 bytes of CONST memory
    518 bytes of DATA  memory

Errors: none
Warnings: none
