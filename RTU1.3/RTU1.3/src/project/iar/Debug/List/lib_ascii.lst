###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:14 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uC- #
#                    LIB\lib_ascii.c                                          #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uC- #
#                    LIB\lib_ascii.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\Debug\List\ -o                   #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\lib_ascii.lst                              #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\lib_ascii.o                                 #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uC-LIB\lib_ascii.c
      1          /*
      2          *********************************************************************************************************
      3          *                                               uC/LIB
      4          *                                       CUSTOM LIBRARY MODULES
      5          *
      6          *                          (c) Copyright 2004-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/LIB is provided in source form for FREE evaluation, for educational
     11          *               use or peaceful research.  If you plan on using uC/LIB in a commercial
     12          *               product you need to contact Micrium to properly license its use in your
     13          *               product.  We provide ALL the source code for your convenience and to
     14          *               help you experience uC/LIB.  The fact that the source code is provided
     15          *               does NOT mean that you can use it without paying a licensing fee.
     16          *
     17          *               Knowledge of the source code may NOT be used to develop a similar product.
     18          *
     19          *               Please help us continue to provide the Embedded community with the finest
     20          *               software available.  Your honesty is greatly appreciated.
     21          *********************************************************************************************************
     22          */
     23          
     24          /*
     25          *********************************************************************************************************
     26          *
     27          *                                     ASCII CHARACTER OPERATIONS
     28          *
     29          * Filename      : lib_ascii.c
     30          * Version       : V1.30
     31          * Programmer(s) : BAN
     32          *                 ITJ
     33          *********************************************************************************************************
     34          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     35          *
     36          *                     (a) ALL standard library functions are implemented in the custom library modules :
     37          *
     38          *                         (1) \<Custom Library Directory>\lib*.*
     39          *
     40          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     41          *
     42          *                               where
     43          *                                       <Custom Library Directory>      directory path for custom library software
     44          *                                       <cpu>                           directory name for specific processor (CPU)
     45          *                                       <compiler>                      directory name for specific compiler
     46          *
     47          *                     (b) Product-specific library functions are implemented in individual products.
     48          *
     49          *
     50          *                 (2) (a) ECMA-6 '7-Bit coded Character Set' (6th edition), which corresponds to the
     51          *                         3rd edition of ISO 646, specifies several versions of a 7-bit character set :
     52          *
     53          *                         (1) THE GENERAL VERSION, which allows characters at 0x23 and 0x24 to be given a
     54          *                             set alternate form and allows the characters 0x40, 0x5B, 0x5D, 0x60, 0x7B &
     55          *                             0x7D to be assigned a "unique graphic character" or to be declared as unused.
     56          *                             All other characters are explicitly specified.
     57          *
     58          *                         (2) THE INTERNATIONAL REFERENCE VERSION, which explicitly specifies all characters
     59          *                             in the 7-bit character set.
     60          *
     61          *                         (3) NATIONAL & APPLICATION-ORIENTED VERSIONS, which may be derived from the
     62          *                             standard in specified ways.
     63          *
     64          *                     (b) The character set represented in this file reproduces the Internation Reference
     65          *                         Version.  This is identical to the 7-bit character set which occupies Unicode
     66          *                         characters 0x0000 through 0x007F.  The character names are taken from v5.0 of the
     67          *                         Unicode specification, with certain abbreviations so that the resulting #define
     68          *                         names will not violate ANSI C naming restriction :
     69          *
     70          *                         (1) For the Latin capital & lowercase letters, the name components 'LETTER_CAPITAL'
     71          *                             & 'LETTER_SMALL' are replaced by 'UPPER' & 'LOWER', respectively.
     72          *********************************************************************************************************
     73          */
     74          
     75          
     76          /*
     77          *********************************************************************************************************
     78          *                                            INCLUDE FILES
     79          *********************************************************************************************************
     80          */
     81          
     82          #define    LIB_ASCII_MODULE
     83          #include  <lib_ascii.h>
     84          
     85          
     86          /*$PAGE*/
     87          /*
     88          *********************************************************************************************************
     89          *                                            LOCAL DEFINES
     90          *********************************************************************************************************
     91          */
     92          
     93          
     94          /*
     95          *********************************************************************************************************
     96          *                                           LOCAL CONSTANTS
     97          *********************************************************************************************************
     98          */
     99          
    100          
    101          /*
    102          *********************************************************************************************************
    103          *                                          LOCAL DATA TYPES
    104          *********************************************************************************************************
    105          */
    106          
    107          
    108          /*
    109          *********************************************************************************************************
    110          *                                            LOCAL TABLES
    111          *********************************************************************************************************
    112          */
    113          
    114          
    115          /*
    116          *********************************************************************************************************
    117          *                                       LOCAL GLOBAL VARIABLES
    118          *********************************************************************************************************
    119          */
    120          
    121          
    122          /*
    123          *********************************************************************************************************
    124          *                                      LOCAL FUNCTION PROTOTYPES
    125          *********************************************************************************************************
    126          */
    127          
    128          
    129          /*
    130          *********************************************************************************************************
    131          *                                     LOCAL CONFIGURATION ERRORS
    132          *********************************************************************************************************
    133          */
    134          
    135          
    136          /*$PAGE*/
    137          /*
    138          *********************************************************************************************************
    139          *                                           ASCII_IsAlpha()
    140          *
    141          * Description : Determine whether a character is an alphabetic character.
    142          *
    143          * Argument(s) : c           Character to examine.
    144          *
    145          * Return(s)   : DEF_YES, if character is     an alphabetic character.
    146          *
    147          *               DEF_NO,	 if character is NOT an alphabetic character.
    148          *
    149          * Caller(s)   : Application.
    150          *
    151          * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.2.(2) states that "isalpha() returns true only for the
    152          *                   characters for which isupper() or islower() is true".
    153          *********************************************************************************************************
    154          */
    155          

   \                                 In section .text, align 2, keep-with-next
    156          CPU_BOOLEAN  ASCII_IsAlpha (CPU_CHAR  c)
    157          {
   \                     ASCII_IsAlpha:
   \   00000000   0x0001             MOVS     R1,R0
    158              CPU_BOOLEAN  alpha;
    159          
    160          
    161              alpha = ASCII_IS_ALPHA(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2941             CMP      R1,#+65
   \   00000006   0xDB04             BLT.N    ??ASCII_IsAlpha_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x295B             CMP      R1,#+91
   \   0000000C   0xDA01             BGE.N    ??ASCII_IsAlpha_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_IsAlpha_1
   \                     ??ASCII_IsAlpha_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsAlpha_1:
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD00A             BEQ.N    ??ASCII_IsAlpha_2
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x2961             CMP      R1,#+97
   \   0000001C   0xDB04             BLT.N    ??ASCII_IsAlpha_3
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x297B             CMP      R1,#+123
   \   00000022   0xDA01             BGE.N    ??ASCII_IsAlpha_3
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B.N      ??ASCII_IsAlpha_4
   \                     ??ASCII_IsAlpha_3:
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsAlpha_4:
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??ASCII_IsAlpha_5
   \                     ??ASCII_IsAlpha_2:
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE000             B.N      ??ASCII_IsAlpha_6
   \                     ??ASCII_IsAlpha_5:
   \   00000032   0x2000             MOVS     R0,#+0
    162          
    163              return (alpha);
   \                     ??ASCII_IsAlpha_6:
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x4770             BX       LR               ;; return
    164          }
    165          
    166          
    167          /*
    168          *********************************************************************************************************
    169          *                                         ASCII_IsAlphaNum()
    170          *
    171          * Description : Determine whether a character is an alphanumeric character.
    172          *
    173          * Argument(s) : c           Character to examine.
    174          *
    175          * Return(s)   : DEF_YES, if character is     an alphanumeric character.
    176          *
    177          *               DEF_NO,	 if character is NOT an alphanumeric character.
    178          *
    179          * Caller(s)   : Application.
    180          *
    181          * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.1.(2) states that "isalnum() ... tests for any character
    182          *                   for which isalpha() or isdigit() is true".
    183          *********************************************************************************************************
    184          */
    185          

   \                                 In section .text, align 2, keep-with-next
    186          CPU_BOOLEAN  ASCII_IsAlphaNum (CPU_CHAR  c)
    187          {
   \                     ASCII_IsAlphaNum:
   \   00000000   0x0001             MOVS     R1,R0
    188              CPU_BOOLEAN  alpha_num;
    189          
    190          
    191              alpha_num = ASCII_IS_ALPHA_NUM(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2941             CMP      R1,#+65
   \   00000006   0xDB04             BLT.N    ??ASCII_IsAlphaNum_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x295B             CMP      R1,#+91
   \   0000000C   0xDA01             BGE.N    ??ASCII_IsAlphaNum_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_IsAlphaNum_1
   \                     ??ASCII_IsAlphaNum_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsAlphaNum_1:
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD00A             BEQ.N    ??ASCII_IsAlphaNum_2
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x2961             CMP      R1,#+97
   \   0000001C   0xDB04             BLT.N    ??ASCII_IsAlphaNum_3
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x297B             CMP      R1,#+123
   \   00000022   0xDA01             BGE.N    ??ASCII_IsAlphaNum_3
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B.N      ??ASCII_IsAlphaNum_4
   \                     ??ASCII_IsAlphaNum_3:
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsAlphaNum_4:
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??ASCII_IsAlphaNum_5
   \                     ??ASCII_IsAlphaNum_2:
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE000             B.N      ??ASCII_IsAlphaNum_6
   \                     ??ASCII_IsAlphaNum_5:
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsAlphaNum_6:
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD00A             BEQ.N    ??ASCII_IsAlphaNum_7
   \   00000038   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003A   0x2930             CMP      R1,#+48
   \   0000003C   0xDB04             BLT.N    ??ASCII_IsAlphaNum_8
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0x293A             CMP      R1,#+58
   \   00000042   0xDA01             BGE.N    ??ASCII_IsAlphaNum_8
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xE000             B.N      ??ASCII_IsAlphaNum_9
   \                     ??ASCII_IsAlphaNum_8:
   \   00000048   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsAlphaNum_9:
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD101             BNE.N    ??ASCII_IsAlphaNum_10
   \                     ??ASCII_IsAlphaNum_7:
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE000             B.N      ??ASCII_IsAlphaNum_11
   \                     ??ASCII_IsAlphaNum_10:
   \   00000052   0x2000             MOVS     R0,#+0
    192          
    193              return (alpha_num);
   \                     ??ASCII_IsAlphaNum_11:
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x4770             BX       LR               ;; return
    194          }
    195          
    196          
    197          /*$PAGE*/
    198          /*
    199          *********************************************************************************************************
    200          *                                           ASCII_IsLower()
    201          *
    202          * Description : Determine whether a character is a lowercase alphabetic character.
    203          *
    204          * Argument(s) : c           Character to examine.
    205          *
    206          * Return(s)   : DEF_YES, if character is     a lowercase alphabetic character.
    207          *
    208          *               DEF_NO,	 if character is NOT a lowercase alphabetic character.
    209          *
    210          * Caller(s)   : Application.
    211          *
    212          * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.7.(2)  states that "islower() returns true only for
    213          *                   the lowercase letters".
    214          *********************************************************************************************************
    215          */
    216          

   \                                 In section .text, align 2, keep-with-next
    217          CPU_BOOLEAN  ASCII_IsLower (CPU_CHAR  c)
    218          {
   \                     ASCII_IsLower:
   \   00000000   0x0001             MOVS     R1,R0
    219              CPU_BOOLEAN  lower;
    220          
    221          
    222              lower = ASCII_IS_LOWER(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2961             CMP      R1,#+97
   \   00000006   0xDB04             BLT.N    ??ASCII_IsLower_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x297B             CMP      R1,#+123
   \   0000000C   0xDA01             BGE.N    ??ASCII_IsLower_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_IsLower_1
   \                     ??ASCII_IsLower_0:
   \   00000012   0x2000             MOVS     R0,#+0
    223          
    224              return (lower);
   \                     ??ASCII_IsLower_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    225          }
    226          
    227          
    228          /*
    229          *********************************************************************************************************
    230          *                                           ASCII_IsUpper()
    231          *
    232          * Description : Determine whether a character is an uppercase alphabetic character.
    233          *
    234          * Argument(s) : c           Character to examine.
    235          *
    236          * Return(s)   : DEF_YES, if character is     an uppercase alphabetic character.
    237          *
    238          *               DEF_NO,	 if character is NOT an uppercase alphabetic character.
    239          *
    240          * Caller(s)   : Application.
    241          *
    242          * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.11.(2) states that "isupper() returns true only for
    243          *                   the uppercase letters".
    244          *********************************************************************************************************
    245          */
    246          

   \                                 In section .text, align 2, keep-with-next
    247          CPU_BOOLEAN  ASCII_IsUpper (CPU_CHAR  c)
    248          {
   \                     ASCII_IsUpper:
   \   00000000   0x0001             MOVS     R1,R0
    249              CPU_BOOLEAN  upper;
    250          
    251          
    252              upper = ASCII_IS_UPPER(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2941             CMP      R1,#+65
   \   00000006   0xDB04             BLT.N    ??ASCII_IsUpper_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x295B             CMP      R1,#+91
   \   0000000C   0xDA01             BGE.N    ??ASCII_IsUpper_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_IsUpper_1
   \                     ??ASCII_IsUpper_0:
   \   00000012   0x2000             MOVS     R0,#+0
    253          
    254              return (upper);
   \                     ??ASCII_IsUpper_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    255          }
    256          
    257          
    258          /*$PAGE*/
    259          /*
    260          *********************************************************************************************************
    261          *                                            ASCII_IsDig()
    262          *
    263          * Description : Determine whether a character is a decimal-digit character.
    264          *
    265          * Argument(s) : c           Character to examine.
    266          *
    267          * Return(s)   : DEF_YES, if character is     a decimal-digit character.
    268          *
    269          *               DEF_NO,	 if character is NOT a decimal-digit character.
    270          *
    271          * Caller(s)   : Application.
    272          *
    273          * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.5.(2)  states that "isdigit()  ... tests for any
    274          *                   decimal-digit character".
    275          *********************************************************************************************************
    276          */
    277          

   \                                 In section .text, align 2, keep-with-next
    278          CPU_BOOLEAN  ASCII_IsDig (CPU_CHAR  c)
    279          {
   \                     ASCII_IsDig:
   \   00000000   0x0001             MOVS     R1,R0
    280              CPU_BOOLEAN  dig;
    281          
    282          
    283              dig = ASCII_IS_DIG(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2930             CMP      R1,#+48
   \   00000006   0xDB04             BLT.N    ??ASCII_IsDig_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x293A             CMP      R1,#+58
   \   0000000C   0xDA01             BGE.N    ??ASCII_IsDig_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_IsDig_1
   \                     ??ASCII_IsDig_0:
   \   00000012   0x2000             MOVS     R0,#+0
    284          
    285              return (dig);
   \                     ??ASCII_IsDig_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    286          }
    287          
    288          
    289          /*
    290          *********************************************************************************************************
    291          *                                          ASCII_IsDigOct()
    292          *
    293          * Description : Determine whether a character is an octal-digit character.
    294          *
    295          * Argument(s) : c           Character to examine.
    296          *
    297          * Return(s)   : DEF_YES, if character is     an octal-digit character.
    298          *
    299          *               DEF_NO,	 if character is NOT an octal-digit character.
    300          *
    301          * Caller(s)   : Application.
    302          *
    303          * Note(s)     : none.
    304          *********************************************************************************************************
    305          */
    306          

   \                                 In section .text, align 2, keep-with-next
    307          CPU_BOOLEAN  ASCII_IsDigOct (CPU_CHAR  c)
    308          {
   \                     ASCII_IsDigOct:
   \   00000000   0x0001             MOVS     R1,R0
    309              CPU_BOOLEAN  dig_oct;
    310          
    311          
    312              dig_oct = ASCII_IS_DIG_OCT(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2930             CMP      R1,#+48
   \   00000006   0xDB04             BLT.N    ??ASCII_IsDigOct_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2938             CMP      R1,#+56
   \   0000000C   0xDA01             BGE.N    ??ASCII_IsDigOct_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_IsDigOct_1
   \                     ??ASCII_IsDigOct_0:
   \   00000012   0x2000             MOVS     R0,#+0
    313          
    314              return (dig_oct);
   \                     ??ASCII_IsDigOct_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    315          }
    316          
    317          
    318          /*
    319          *********************************************************************************************************
    320          *                                          ASCII_IsDigHex()
    321          *
    322          * Description : Determine whether a character is a hexadecimal-digit character.
    323          *
    324          * Argument(s) : c           Character to examine.
    325          *
    326          * Return(s)   : DEF_YES, if character is     a hexadecimal-digit character.
    327          *
    328          *               DEF_NO,	 if character is NOT a hexadecimal-digit character.
    329          *
    330          * Caller(s)   : Application.
    331          *
    332          * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.12.(2) states that "isxdigit() ... tests for any
    333          *                   hexadecimal-digit character".
    334          *********************************************************************************************************
    335          */
    336          

   \                                 In section .text, align 2, keep-with-next
    337          CPU_BOOLEAN  ASCII_IsDigHex (CPU_CHAR  c)
    338          {
   \                     ASCII_IsDigHex:
   \   00000000   0x0001             MOVS     R1,R0
    339              CPU_BOOLEAN  dig_hex;
    340          
    341          
    342              dig_hex = ASCII_IS_DIG_HEX(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2930             CMP      R1,#+48
   \   00000006   0xDB02             BLT.N    ??ASCII_IsDigHex_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x293A             CMP      R1,#+58
   \   0000000C   0xDB0B             BLT.N    ??ASCII_IsDigHex_1
   \                     ??ASCII_IsDigHex_0:
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2941             CMP      R1,#+65
   \   00000012   0xDB02             BLT.N    ??ASCII_IsDigHex_2
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2947             CMP      R1,#+71
   \   00000018   0xDB05             BLT.N    ??ASCII_IsDigHex_1
   \                     ??ASCII_IsDigHex_2:
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x2961             CMP      R1,#+97
   \   0000001E   0xDB04             BLT.N    ??ASCII_IsDigHex_3
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x2967             CMP      R1,#+103
   \   00000024   0xDA01             BGE.N    ??ASCII_IsDigHex_3
   \                     ??ASCII_IsDigHex_1:
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE000             B.N      ??ASCII_IsDigHex_4
   \                     ??ASCII_IsDigHex_3:
   \   0000002A   0x2000             MOVS     R0,#+0
    343          
    344              return (dig_hex);
   \                     ??ASCII_IsDigHex_4:
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x4770             BX       LR               ;; return
    345          }
    346          
    347          
    348          /*$PAGE*/
    349          /*
    350          *********************************************************************************************************
    351          *                                           ASCII_IsBlank()
    352          *
    353          * Description : Determine whether a character is a standard blank character.
    354          *
    355          * Argument(s) : c           Character to examine.
    356          *
    357          * Return(s)   : DEF_YES, if character is     a standard blank character.
    358          *
    359          *               DEF_NO,	 if character is NOT a standard blank character.
    360          *
    361          * Caller(s)   : Application.
    362          *
    363          * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) states that "isblank() returns true only for
    364          *                       the standard blank characters".
    365          *
    366          *                   (b) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) defines "the standard blank characters" as
    367          *                       the "space (' '), and horizontal tab ('\t')".
    368          *********************************************************************************************************
    369          */
    370          

   \                                 In section .text, align 2, keep-with-next
    371          CPU_BOOLEAN  ASCII_IsBlank (CPU_CHAR  c)
    372          {
   \                     ASCII_IsBlank:
   \   00000000   0x0001             MOVS     R1,R0
    373              CPU_BOOLEAN  blank;
    374          
    375          
    376              blank = ASCII_IS_BLANK(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2920             CMP      R1,#+32
   \   00000006   0xD002             BEQ.N    ??ASCII_IsBlank_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2909             CMP      R1,#+9
   \   0000000C   0xD101             BNE.N    ??ASCII_IsBlank_1
   \                     ??ASCII_IsBlank_0:
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_IsBlank_2
   \                     ??ASCII_IsBlank_1:
   \   00000012   0x2000             MOVS     R0,#+0
    377          
    378              return (blank);
   \                     ??ASCII_IsBlank_2:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    379          }
    380          
    381          
    382          /*
    383          *********************************************************************************************************
    384          *                                           ASCII_IsSpace()
    385          *
    386          * Description : Determine whether a character is a white-space character.
    387          *
    388          * Argument(s) : c           Character to examine.
    389          *
    390          * Return(s)   : DEF_YES, if character is     a white-space character.
    391          *
    392          *               DEF_NO,	 if character is NOT a white-space character.
    393          *
    394          * Caller(s)   : Application.
    395          *
    396          * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) states that "isspace() returns true only
    397          *                       for the standard white-space characters".
    398          *
    399          *                   (b) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) defines "the standard white-space characters"
    400          *                       as the "space (' '), form feed ('\f'), new-line ('\n'), carriage return ('\r'),
    401          *                       horizontal tab ('\t'), and vertical tab ('\v')".
    402          *********************************************************************************************************
    403          */
    404          

   \                                 In section .text, align 2, keep-with-next
    405          CPU_BOOLEAN  ASCII_IsSpace (CPU_CHAR  c)
    406          {
   \                     ASCII_IsSpace:
   \   00000000   0x0001             MOVS     R1,R0
    407              CPU_BOOLEAN  space;
    408          
    409          
    410              space = ASCII_IS_SPACE(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2920             CMP      R1,#+32
   \   00000006   0xD00E             BEQ.N    ??ASCII_IsSpace_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x290D             CMP      R1,#+13
   \   0000000C   0xD00B             BEQ.N    ??ASCII_IsSpace_0
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x290A             CMP      R1,#+10
   \   00000012   0xD008             BEQ.N    ??ASCII_IsSpace_0
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x290C             CMP      R1,#+12
   \   00000018   0xD005             BEQ.N    ??ASCII_IsSpace_0
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x2909             CMP      R1,#+9
   \   0000001E   0xD002             BEQ.N    ??ASCII_IsSpace_0
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x290B             CMP      R1,#+11
   \   00000024   0xD101             BNE.N    ??ASCII_IsSpace_1
   \                     ??ASCII_IsSpace_0:
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE000             B.N      ??ASCII_IsSpace_2
   \                     ??ASCII_IsSpace_1:
   \   0000002A   0x2000             MOVS     R0,#+0
    411          
    412              return (space);
   \                     ??ASCII_IsSpace_2:
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x4770             BX       LR               ;; return
    413          }
    414          
    415          
    416          /*$PAGE*/
    417          /*
    418          *********************************************************************************************************
    419          *                                           ASCII_IsPrint()
    420          *
    421          * Description : Determine whether a character is a printing character.
    422          *
    423          * Argument(s) : c           Character to examine.
    424          *
    425          * Return(s)   : DEF_YES, if character is     a printing character.
    426          *
    427          *               DEF_NO,	 if character is NOT a printing character.
    428          *
    429          * Caller(s)   : Application.
    430          *
    431          * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.8.(2) states that "isprint() ... tests for any
    432          *                       printing character including space (' ')".
    433          *
    434          *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
    435          *                       ASCII character set, the printing characters are those whose values lie from
    436          *                       0x20 (space) through 0x7E (tilde)".
    437          *********************************************************************************************************
    438          */
    439          

   \                                 In section .text, align 2, keep-with-next
    440          CPU_BOOLEAN  ASCII_IsPrint (CPU_CHAR  c)
    441          {
   \                     ASCII_IsPrint:
   \   00000000   0x0001             MOVS     R1,R0
    442              CPU_BOOLEAN  print;
    443          
    444          
    445              print = ASCII_IS_PRINT(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2920             CMP      R1,#+32
   \   00000006   0xDB04             BLT.N    ??ASCII_IsPrint_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x297F             CMP      R1,#+127
   \   0000000C   0xDA01             BGE.N    ??ASCII_IsPrint_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_IsPrint_1
   \                     ??ASCII_IsPrint_0:
   \   00000012   0x2000             MOVS     R0,#+0
    446          
    447              return (print);
   \                     ??ASCII_IsPrint_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    448          }
    449          
    450          
    451          /*
    452          *********************************************************************************************************
    453          *                                           ASCII_IsGraph()
    454          *
    455          * Description : Determine whether a character is any printing character except a space character.
    456          *
    457          * Argument(s) : c           Character to examine.
    458          *
    459          * Return(s)   : DEF_YES, if character is     a graphic character.
    460          *
    461          *               DEF_NO,	 if character is NOT a graphic character.
    462          *
    463          * Caller(s)   : Application.
    464          *
    465          * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.6.(2) states that "isgraph() ... tests for any
    466          *                       printing character except space (' ')".
    467          *
    468          *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
    469          *                       ASCII character set, the printing characters are those whose values lie from
    470          *                       0x20 (space) through 0x7E (tilde)".
    471          *********************************************************************************************************
    472          */
    473          

   \                                 In section .text, align 2, keep-with-next
    474          CPU_BOOLEAN  ASCII_IsGraph (CPU_CHAR  c)
    475          {
   \                     ASCII_IsGraph:
   \   00000000   0x0001             MOVS     R1,R0
    476              CPU_BOOLEAN  graph;
    477          
    478          
    479              graph = ASCII_IS_GRAPH(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2921             CMP      R1,#+33
   \   00000006   0xDB04             BLT.N    ??ASCII_IsGraph_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x297F             CMP      R1,#+127
   \   0000000C   0xDA01             BGE.N    ??ASCII_IsGraph_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_IsGraph_1
   \                     ??ASCII_IsGraph_0:
   \   00000012   0x2000             MOVS     R0,#+0
    480          
    481              return (graph);
   \                     ??ASCII_IsGraph_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    482          }
    483          
    484          
    485          /*$PAGE*/
    486          /*
    487          *********************************************************************************************************
    488          *                                           ASCII_IsPunct()
    489          *
    490          * Description : Determine whether a character is a punctuation character.
    491          *
    492          * Argument(s) : c           Character to examine.
    493          *
    494          * Return(s)   : DEF_YES, if character is     a punctuation character.
    495          *
    496          *               DEF_NO,	 if character is NOT a punctuation character.
    497          *
    498          * Caller(s)   : Application.
    499          *
    500          * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.9.(2) states that "ispunct() returns true for every
    501          *                   printing character for which neither isspace() nor isalnum() is true".
    502          *********************************************************************************************************
    503          */
    504          

   \                                 In section .text, align 2, keep-with-next
    505          CPU_BOOLEAN  ASCII_IsPunct (CPU_CHAR  c)
    506          {
   \                     ASCII_IsPunct:
   \   00000000   0x0001             MOVS     R1,R0
    507              CPU_BOOLEAN  punct;
    508          
    509          
    510              punct = ASCII_IS_PUNCT(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2920             CMP      R1,#+32
   \   00000006   0xDB04             BLT.N    ??ASCII_IsPunct_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x297F             CMP      R1,#+127
   \   0000000C   0xDA01             BGE.N    ??ASCII_IsPunct_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_IsPunct_1
   \                     ??ASCII_IsPunct_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsPunct_1:
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD143             BNE.N    ??ASCII_IsPunct_2
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x2920             CMP      R1,#+32
   \   0000001C   0xD00E             BEQ.N    ??ASCII_IsPunct_3
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x290D             CMP      R1,#+13
   \   00000022   0xD00B             BEQ.N    ??ASCII_IsPunct_3
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0x290A             CMP      R1,#+10
   \   00000028   0xD008             BEQ.N    ??ASCII_IsPunct_3
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x290C             CMP      R1,#+12
   \   0000002E   0xD005             BEQ.N    ??ASCII_IsPunct_3
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0x2909             CMP      R1,#+9
   \   00000034   0xD002             BEQ.N    ??ASCII_IsPunct_3
   \   00000036   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000038   0x290B             CMP      R1,#+11
   \   0000003A   0xD101             BNE.N    ??ASCII_IsPunct_4
   \                     ??ASCII_IsPunct_3:
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE000             B.N      ??ASCII_IsPunct_5
   \                     ??ASCII_IsPunct_4:
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsPunct_5:
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD12C             BNE.N    ??ASCII_IsPunct_2
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x2941             CMP      R1,#+65
   \   0000004A   0xDB04             BLT.N    ??ASCII_IsPunct_6
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x295B             CMP      R1,#+91
   \   00000050   0xDA01             BGE.N    ??ASCII_IsPunct_6
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE000             B.N      ??ASCII_IsPunct_7
   \                     ??ASCII_IsPunct_6:
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsPunct_7:
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD00A             BEQ.N    ??ASCII_IsPunct_8
   \   0000005C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005E   0x2961             CMP      R1,#+97
   \   00000060   0xDB04             BLT.N    ??ASCII_IsPunct_9
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0x297B             CMP      R1,#+123
   \   00000066   0xDA01             BGE.N    ??ASCII_IsPunct_9
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xE000             B.N      ??ASCII_IsPunct_10
   \                     ??ASCII_IsPunct_9:
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsPunct_10:
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD101             BNE.N    ??ASCII_IsPunct_11
   \                     ??ASCII_IsPunct_8:
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE000             B.N      ??ASCII_IsPunct_12
   \                     ??ASCII_IsPunct_11:
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsPunct_12:
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD00A             BEQ.N    ??ASCII_IsPunct_13
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0x2930             CMP      R1,#+48
   \   00000080   0xDB04             BLT.N    ??ASCII_IsPunct_14
   \   00000082   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000084   0x293A             CMP      R1,#+58
   \   00000086   0xDA01             BGE.N    ??ASCII_IsPunct_14
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xE000             B.N      ??ASCII_IsPunct_15
   \                     ??ASCII_IsPunct_14:
   \   0000008C   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsPunct_15:
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xD101             BNE.N    ??ASCII_IsPunct_16
   \                     ??ASCII_IsPunct_13:
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0xE000             B.N      ??ASCII_IsPunct_17
   \                     ??ASCII_IsPunct_16:
   \   00000096   0x2000             MOVS     R0,#+0
   \                     ??ASCII_IsPunct_17:
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD101             BNE.N    ??ASCII_IsPunct_2
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE000             B.N      ??ASCII_IsPunct_18
   \                     ??ASCII_IsPunct_2:
   \   000000A0   0x2000             MOVS     R0,#+0
    511          
    512              return (punct);
   \                     ??ASCII_IsPunct_18:
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0x4770             BX       LR               ;; return
    513          }
    514          
    515          
    516          /*
    517          *********************************************************************************************************
    518          *                                           ASCII_IsCtrl()
    519          *
    520          * Description : Determine whether a character is a control character.
    521          *
    522          * Argument(s) : c           Character to examine.
    523          *
    524          * Return(s)   : DEF_YES, if character is     a control character.
    525          *
    526          *               DEF_NO,	 if character is NOT a control character.
    527          *
    528          * Caller(s)   : Application.
    529          *
    530          * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.4.(2) states that "iscntrl() ... tests for any
    531          *                       control character".
    532          *
    533          *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
    534          *                       ASCII character set, ... the control characters are those whose values lie from
    535          *                       0 (NUL) through 0x1F (US), and the character 0x7F (DEL)".
    536          *********************************************************************************************************
    537          */
    538          

   \                                 In section .text, align 2, keep-with-next
    539          CPU_BOOLEAN  ASCII_IsCtrl (CPU_CHAR  c)
    540          {
   \                     ASCII_IsCtrl:
   \   00000000   0x0001             MOVS     R1,R0
    541              CPU_BOOLEAN  ctrl;
    542          
    543          
    544              ctrl = ASCII_IS_CTRL(c);
   \   00000002   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD402             BMI.N    ??ASCII_IsCtrl_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2920             CMP      R1,#+32
   \   0000000C   0xDB02             BLT.N    ??ASCII_IsCtrl_1
   \                     ??ASCII_IsCtrl_0:
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x297F             CMP      R1,#+127
   \   00000012   0xD101             BNE.N    ??ASCII_IsCtrl_2
   \                     ??ASCII_IsCtrl_1:
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B.N      ??ASCII_IsCtrl_3
   \                     ??ASCII_IsCtrl_2:
   \   00000018   0x2000             MOVS     R0,#+0
    545          
    546              return (ctrl);
   \                     ??ASCII_IsCtrl_3:
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x4770             BX       LR               ;; return
    547          }
    548          
    549          
    550          /*$PAGE*/
    551          /*
    552          *********************************************************************************************************
    553          *                                           ASCII_ToLower()
    554          *
    555          * Description : Convert uppercase alphabetic character to its corresponding lowercase alphabetic character.
    556          *
    557          * Argument(s) : c           Character to convert.
    558          *
    559          * Return(s)   : Lowercase equivalent of 'c', if character 'c' is an uppercase character (see Note #1b1).
    560          *
    561          *               Character 'c',               otherwise                                  (see Note #1b2).
    562          *
    563          * Caller(s)   : Application.
    564          *
    565          * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.1.(2) states that "tolower() ... converts an
    566          *                       uppercase letter to a corresponding lowercase letter".
    567          *
    568          *                   (b) ISO/IEC 9899:TC2, Section 7.4.2.1.(3) states that :
    569          *
    570          *                       (1) (A) "if the argument is a character for which isupper() is true and there are
    571          *                                one or more corresponding characters ... for which islower() is true," ...
    572          *                           (B) "tolower() ... returns one of the corresponding characters;" ...
    573          *
    574          *                       (2) "otherwise, the argument is returned unchanged."
    575          *********************************************************************************************************
    576          */
    577          

   \                                 In section .text, align 2, keep-with-next
    578          CPU_CHAR  ASCII_ToLower (CPU_CHAR  c)
    579          {
   \                     ASCII_ToLower:
   \   00000000   0x0001             MOVS     R1,R0
    580              CPU_CHAR  lower;
    581          
    582          
    583              lower = ASCII_TO_LOWER(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2941             CMP      R1,#+65
   \   00000006   0xDB04             BLT.N    ??ASCII_ToLower_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x295B             CMP      R1,#+91
   \   0000000C   0xDA01             BGE.N    ??ASCII_ToLower_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_ToLower_1
   \                     ??ASCII_ToLower_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??ASCII_ToLower_1:
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD102             BNE.N    ??ASCII_ToLower_2
   \   00000018   0xF111 0x0020      ADDS     R0,R1,#+32
   \   0000001C   0xE000             B.N      ??ASCII_ToLower_3
   \                     ??ASCII_ToLower_2:
   \   0000001E   0x0008             MOVS     R0,R1
    584          
    585              return (lower);
   \                     ??ASCII_ToLower_3:
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x4770             BX       LR               ;; return
    586          }
    587          
    588          
    589          /*
    590          *********************************************************************************************************
    591          *                                           ASCII_ToUpper()
    592          *
    593          * Description : Convert lowercase alphabetic character to its corresponding uppercase alphabetic character.
    594          *
    595          * Argument(s) : c           Character to convert.
    596          *
    597          * Return(s)   : Uppercase equivalent of 'c', if character 'c' is a lowercase character (see Note #1b1).
    598          *
    599          *               Character 'c',               otherwise                                 (see Note #1b2).
    600          *
    601          * Caller(s)   : Application.
    602          *
    603          * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.2.(2) states that "toupper() ... converts a
    604          *                       lowercase letter to a corresponding uppercase letter".
    605          *
    606          *                   (b) ISO/IEC 9899:TC2, Section 7.4.2.2.(3) states that :
    607          *
    608          *                       (1) (A) "if the argument is a character for which islower() is true and there are
    609          *                                one or more corresponding characters ... for which isupper() is true," ...
    610          *                           (B) "toupper() ... returns one of the corresponding characters;" ...
    611          *
    612          *                       (2) "otherwise, the argument is returned unchanged."
    613          *********************************************************************************************************
    614          */
    615          

   \                                 In section .text, align 2, keep-with-next
    616          CPU_CHAR  ASCII_ToUpper (CPU_CHAR  c)
    617          {
   \                     ASCII_ToUpper:
   \   00000000   0x0001             MOVS     R1,R0
    618              CPU_CHAR  upper;
    619          
    620          
    621              upper = ASCII_TO_UPPER(c);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2961             CMP      R1,#+97
   \   00000006   0xDB04             BLT.N    ??ASCII_ToUpper_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x297B             CMP      R1,#+123
   \   0000000C   0xDA01             BGE.N    ??ASCII_ToUpper_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??ASCII_ToUpper_1
   \                     ??ASCII_ToUpper_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??ASCII_ToUpper_1:
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD102             BNE.N    ??ASCII_ToUpper_2
   \   00000018   0xF1B1 0x0020      SUBS     R0,R1,#+32
   \   0000001C   0xE000             B.N      ??ASCII_ToUpper_3
   \                     ??ASCII_ToUpper_2:
   \   0000001E   0x0008             MOVS     R0,R1
    622          
    623              return (upper);
   \                     ??ASCII_ToUpper_3:
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x4770             BX       LR               ;; return
    624          }
    625          
    626          
    627          /*$PAGE*/
    628          /*
    629          *********************************************************************************************************
    630          *                                             ASCII_Cmp()
    631          *
    632          * Description : Determine if two characters are identical (case-insensitive).
    633          *
    634          * Argument(s) : c1          First  character.
    635          *
    636          *               c2          Second character.
    637          *
    638          * Return(s)   : DEF_YES, if the characters are     identical.
    639          *
    640          *               DEF_NO,  if the characters are NOT identical.
    641          *
    642          * Caller(s)   : Application.
    643          *
    644          * Note(s)     : none.
    645          *********************************************************************************************************
    646          */
    647          

   \                                 In section .text, align 2, keep-with-next
    648          CPU_BOOLEAN  ASCII_Cmp (CPU_CHAR  c1,
    649                                  CPU_CHAR  c2)
    650          {
   \                     ASCII_Cmp:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    651              CPU_CHAR     c1_upper;
    652              CPU_CHAR     c2_upper;
    653              CPU_BOOLEAN  cmp;
    654          
    655          
    656              c1_upper =  ASCII_TO_UPPER(c1);
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x2A61             CMP      R2,#+97
   \   00000008   0xDB04             BLT.N    ??ASCII_Cmp_0
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x2A7B             CMP      R2,#+123
   \   0000000E   0xDA01             BGE.N    ??ASCII_Cmp_0
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0xE000             B.N      ??ASCII_Cmp_1
   \                     ??ASCII_Cmp_0:
   \   00000014   0x2300             MOVS     R3,#+0
   \                     ??ASCII_Cmp_1:
   \   00000016   0x2B01             CMP      R3,#+1
   \   00000018   0xD102             BNE.N    ??ASCII_Cmp_2
   \   0000001A   0xF1B2 0x0320      SUBS     R3,R2,#+32
   \   0000001E   0xE000             B.N      ??ASCII_Cmp_3
   \                     ??ASCII_Cmp_2:
   \   00000020   0x0013             MOVS     R3,R2
    657              c2_upper =  ASCII_TO_UPPER(c2);
   \                     ??ASCII_Cmp_3:
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x2961             CMP      R1,#+97
   \   00000026   0xDB04             BLT.N    ??ASCII_Cmp_4
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x297B             CMP      R1,#+123
   \   0000002C   0xDA01             BGE.N    ??ASCII_Cmp_4
   \   0000002E   0x2401             MOVS     R4,#+1
   \   00000030   0xE000             B.N      ??ASCII_Cmp_5
   \                     ??ASCII_Cmp_4:
   \   00000032   0x2400             MOVS     R4,#+0
   \                     ??ASCII_Cmp_5:
   \   00000034   0x2C01             CMP      R4,#+1
   \   00000036   0xD102             BNE.N    ??ASCII_Cmp_6
   \   00000038   0xF1B1 0x0420      SUBS     R4,R1,#+32
   \   0000003C   0xE000             B.N      ??ASCII_Cmp_7
   \                     ??ASCII_Cmp_6:
   \   0000003E   0x000C             MOVS     R4,R1
    658              cmp      = (c1_upper == c2_upper) ? (DEF_YES) : (DEF_NO);
   \                     ??ASCII_Cmp_7:
   \   00000040   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x42A3             CMP      R3,R4
   \   00000046   0xD101             BNE.N    ??ASCII_Cmp_8
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE000             B.N      ??ASCII_Cmp_9
   \                     ??ASCII_Cmp_8:
   \   0000004C   0x2000             MOVS     R0,#+0
    659          
    660              return (cmp);
   \                     ??ASCII_Cmp_9:
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xBC10             POP      {R4}
   \   00000052   0x4770             BX       LR               ;; return
    661          }
    662          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   ASCII_Cmp
       0   ASCII_IsAlpha
       0   ASCII_IsAlphaNum
       0   ASCII_IsBlank
       0   ASCII_IsCtrl
       0   ASCII_IsDig
       0   ASCII_IsDigHex
       0   ASCII_IsDigOct
       0   ASCII_IsGraph
       0   ASCII_IsLower
       0   ASCII_IsPrint
       0   ASCII_IsPunct
       0   ASCII_IsSpace
       0   ASCII_IsUpper
       0   ASCII_ToLower
       0   ASCII_ToUpper


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      84  ASCII_Cmp
      56  ASCII_IsAlpha
      88  ASCII_IsAlphaNum
      24  ASCII_IsBlank
      30  ASCII_IsCtrl
      24  ASCII_IsDig
      48  ASCII_IsDigHex
      24  ASCII_IsDigOct
      24  ASCII_IsGraph
      24  ASCII_IsLower
      24  ASCII_IsPrint
     166  ASCII_IsPunct
      48  ASCII_IsSpace
      24  ASCII_IsUpper
      36  ASCII_ToLower
      36  ASCII_ToUpper

 
 760 bytes in section .text
 
 760 bytes of CODE memory

Errors: none
Warnings: none
