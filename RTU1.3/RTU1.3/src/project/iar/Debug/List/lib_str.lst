###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:14 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uC- #
#                    LIB\lib_str.c                                            #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uC- #
#                    LIB\lib_str.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂ #
#                    ë\RTU_1.2\project\iar\Debug\List\ -o                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\lib_str.lst                                #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\lib_str.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uC-LIB\lib_str.c
      1          /*
      2          *********************************************************************************************************
      3          *                                               uC/LIB
      4          *                                       CUSTOM LIBRARY MODULES
      5          *
      6          *                          (c) Copyright 2004-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/LIB is provided in source form for FREE evaluation, for educational
     11          *               use or peaceful research.  If you plan on using uC/LIB in a commercial
     12          *               product you need to contact Micrium to properly license its use in your
     13          *               product.  We provide ALL the source code for your convenience and to
     14          *               help you experience uC/LIB.  The fact that the source code is provided
     15          *               does NOT mean that you can use it without paying a licensing fee.
     16          *
     17          *               Knowledge of the source code may NOT be used to develop a similar product.
     18          *
     19          *               Please help us continue to provide the Embedded community with the finest
     20          *               software available.  Your honesty is greatly appreciated.
     21          *********************************************************************************************************
     22          */
     23          
     24          /*
     25          *********************************************************************************************************
     26          *
     27          *                                       ASCII STRING MANAGEMENT
     28          *
     29          * Filename      : lib_str.c
     30          * Version       : V1.30
     31          * Programmer(s) : ITJ
     32          *                 BAN
     33          *                 JDH
     34          *********************************************************************************************************
     35          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     36          *
     37          *                     (a) ALL standard library functions are implemented in the custom library modules :
     38          *
     39          *                         (1) \<Custom Library Directory>\lib*.*
     40          *
     41          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     42          *
     43          *                               where
     44          *                                       <Custom Library Directory>      directory path for custom library software
     45          *                                       <cpu>                           directory name for specific processor (CPU)
     46          *                                       <compiler>                      directory name for specific compiler
     47          *
     48          *                     (b) Product-specific library functions are implemented in individual products.
     49          *
     50          *********************************************************************************************************
     51          * Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
     52          *                     us permission to reprint portions of their documentation.  Portions of this text are
     53          *                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
     54          *                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
     55          *                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
     56          *                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
     57          *                     discrepancy between these versions and the original IEEE and The Open Group Standard,
     58          *                     the original IEEE and The Open Group Standard is the referee document.  The original
     59          *                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
     60          *********************************************************************************************************
     61          */
     62          
     63          
     64          /*
     65          *********************************************************************************************************
     66          *                                            INCLUDE FILES
     67          *********************************************************************************************************
     68          */
     69          
     70          #define    LIB_STR_MODULE
     71          #include  <lib_str.h>
     72          
     73          
     74          /*$PAGE*/
     75          /*
     76          *********************************************************************************************************
     77          *                                            LOCAL DEFINES
     78          *********************************************************************************************************
     79          */
     80          
     81          
     82          /*
     83          *********************************************************************************************************
     84          *                                           LOCAL CONSTANTS
     85          *********************************************************************************************************
     86          */
     87          
     88          
     89          /*
     90          *********************************************************************************************************
     91          *                                          LOCAL DATA TYPES
     92          *********************************************************************************************************
     93          */
     94          
     95          
     96          /*
     97          *********************************************************************************************************
     98          *                                            LOCAL TABLES
     99          *********************************************************************************************************
    100          */
    101          

   \                                 In section .rodata, align 4
    102          static  const  CPU_INT32U  Str_MultOvfThTbl_Int32U[] = {
   \                     Str_MultOvfThTbl_Int32U:
   \   00000000   0xFFFFFFFF         DC32 4294967295, 4294967295, 2147483647, 1431655765, 1073741823
   \              0xFFFFFFFF   
   \              0x7FFFFFFF   
   \              0x55555555   
   \              0x3FFFFFFF   
   \   00000014   0x33333333         DC32 858993459, 715827882, 613566756, 536870911, 477218588, 429496729
   \              0x2AAAAAAA   
   \              0x24924924   
   \              0x1FFFFFFF   
   \              0x1C71C71C   
   \              0x19999999   
   \   0000002C   0x1745D174         DC32 390451572, 357913941, 330382099, 306783378, 286331153, 268435455
   \              0x15555555   
   \              0x13B13B13   
   \              0x12492492   
   \              0x11111111   
   \              0x0FFFFFFF   
   \   00000044   0x0F0F0F0F         DC32 252645135, 238609294, 226050910, 214748364, 204522252, 195225786
   \              0x0E38E38E   
   \              0x0D79435E   
   \              0x0CCCCCCC   
   \              0x0C30C30C   
   \              0x0BA2E8BA   
   \   0000005C   0x0B21642C         DC32 186737708, 178956970, 171798691, 165191049, 159072862, 153391689
   \              0x0AAAAAAA   
   \              0x0A3D70A3   
   \              0x09D89D89   
   \              0x097B425E   
   \              0x09249249   
   \   00000074   0x08D3DCB0         DC32 148102320, 143165576, 138547332, 134217727, 130150524, 126322567
   \              0x08888888   
   \              0x08421084   
   \              0x07FFFFFF   
   \              0x07C1F07C   
   \              0x07878787   
   \   0000008C   0x07507507         DC32 122713351, 119304647
   \              0x071C71C7   
    103             (CPU_INT32U) DEF_INT_32U_MAX_VAL,                /*                Invalid base  0.      */
    104            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL /  1)),         /*                Invalid base  1.      */
    105            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL /  2)),         /* 32-bit mult ovf th for base  2.      */
    106            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL /  3)),         /* 32-bit mult ovf th for base  3.      */
    107            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL /  4)),         /* 32-bit mult ovf th for base  4.      */
    108            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL /  5)),         /* 32-bit mult ovf th for base  5.      */
    109            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL /  6)),         /* 32-bit mult ovf th for base  6.      */
    110            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL /  7)),         /* 32-bit mult ovf th for base  7.      */
    111            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL /  8)),         /* 32-bit mult ovf th for base  8.      */
    112            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL /  9)),         /* 32-bit mult ovf th for base  9.      */
    113            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 10)),         /* 32-bit mult ovf th for base 10.      */
    114            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 11)),         /* 32-bit mult ovf th for base 11.      */
    115            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 12)),         /* 32-bit mult ovf th for base 12.      */
    116            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 13)),         /* 32-bit mult ovf th for base 13.      */
    117            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 14)),         /* 32-bit mult ovf th for base 14.      */
    118            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 15)),         /* 32-bit mult ovf th for base 15.      */
    119            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 16)),         /* 32-bit mult ovf th for base 16.      */
    120            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 17)),         /* 32-bit mult ovf th for base 17.      */
    121            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 18)),         /* 32-bit mult ovf th for base 18.      */
    122            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 19)),         /* 32-bit mult ovf th for base 19.      */
    123            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 20)),         /* 32-bit mult ovf th for base 20.      */
    124            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 21)),         /* 32-bit mult ovf th for base 21.      */
    125            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 22)),         /* 32-bit mult ovf th for base 22.      */
    126            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 23)),         /* 32-bit mult ovf th for base 23.      */
    127            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 24)),         /* 32-bit mult ovf th for base 24.      */
    128            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 25)),         /* 32-bit mult ovf th for base 25.      */
    129            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 26)),         /* 32-bit mult ovf th for base 26.      */
    130            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 27)),         /* 32-bit mult ovf th for base 27.      */
    131            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 28)),         /* 32-bit mult ovf th for base 28.      */
    132            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 29)),         /* 32-bit mult ovf th for base 29.      */
    133            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 30)),         /* 32-bit mult ovf th for base 30.      */
    134            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 31)),         /* 32-bit mult ovf th for base 31.      */
    135            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 32)),         /* 32-bit mult ovf th for base 32.      */
    136            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 33)),         /* 32-bit mult ovf th for base 33.      */
    137            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 34)),         /* 32-bit mult ovf th for base 34.      */
    138            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 35)),         /* 32-bit mult ovf th for base 35.      */
    139            ((CPU_INT32U)(DEF_INT_32U_MAX_VAL / 36))          /* 32-bit mult ovf th for base 36.      */
    140          };
    141          
    142          
    143          /*
    144          *********************************************************************************************************
    145          *                                       LOCAL GLOBAL VARIABLES
    146          *********************************************************************************************************
    147          */
    148          
    149          
    150          /*$PAGE*/
    151          /*
    152          *********************************************************************************************************
    153          *                                      LOCAL FUNCTION PROTOTYPES
    154          *********************************************************************************************************
    155          */
    156          
    157          static  CPU_CHAR    *Str_FmtNbr_Int32  (CPU_INT32U     nbr,
    158                                                  CPU_INT08U     nbr_dig,
    159                                                  CPU_INT08U     nbr_base,
    160                                                  CPU_BOOLEAN    nbr_neg,
    161                                                  CPU_CHAR       lead_char,
    162                                                  CPU_BOOLEAN    lower_case,
    163                                                  CPU_BOOLEAN    nul,
    164                                                  CPU_CHAR      *pstr);
    165          
    166          static  CPU_INT32U   Str_ParseNbr_Int32(CPU_CHAR      *pstr,
    167                                                  CPU_CHAR     **pstr_next,
    168                                                  CPU_INT08U     nbr_base,
    169                                                  CPU_BOOLEAN    nbr_signed,
    170                                                  CPU_BOOLEAN   *pnbr_neg);
    171          
    172          
    173          /*
    174          *********************************************************************************************************
    175          *                                     LOCAL CONFIGURATION ERRORS
    176          *********************************************************************************************************
    177          */
    178          
    179          
    180          /*$PAGE*/
    181          /*
    182          *********************************************************************************************************
    183          *                                              Str_Len()
    184          *
    185          * Description : Calculate length of a string.
    186          *
    187          * Argument(s) : pstr        Pointer to string (see Note #1).
    188          *
    189          * Return(s)   : Length of string; number of characters in string before terminating NULL character.
    190          *
    191          * Caller(s)   : Application.
    192          *
    193          * Note(s)     : (1) String buffer NOT modified.
    194          *
    195          *               (2) String length calculation terminates when :
    196          *
    197          *                   (a) String pointer points to NULL.
    198          *                       (1) String buffer overlaps with NULL address.
    199          *                       (2) String length calculated for string up to but NOT beyond or including
    200          *                           the NULL address.
    201          *
    202          *                   (b) Terminating NULL character found.
    203          *                       (1) String length calculated for string up to but NOT           including
    204          *                           the NULL character.
    205          *********************************************************************************************************
    206          */
    207          

   \                                 In section .text, align 2, keep-with-next
    208          CPU_SIZE_T  Str_Len (CPU_CHAR  *pstr)
    209          {
   \                     Str_Len:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    210              CPU_SIZE_T  len;
    211          
    212          
    213              len = Str_Len_N((CPU_CHAR *)pstr,
    214                              (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);
   \   00000004   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Str_Len_N
   \   0000000E   0x0005             MOVS     R5,R0
    215          
    216              return (len);
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    217          }
    218          
    219          
    220          /*$PAGE*/
    221          /*
    222          *********************************************************************************************************
    223          *                                             Str_Len_N()
    224          *
    225          * Description : Calculate length of a string, up to a maximum number of characters.
    226          *
    227          * Argument(s) : pstr        Pointer to string (see Note #1).
    228          *
    229          *               len_max     Maximum number of characters to search (see Note #2c).
    230          *
    231          * Return(s)   : Length of string; number of characters in string before terminating NULL character, 
    232          *                   if terminating NULL character     found.
    233          *               
    234          *               Requested maximum number of characters to search, 
    235          *                   if terminating NULL character NOT found.
    236          *
    237          * Caller(s)   : Application.
    238          *
    239          * Note(s)     : (1) String buffer NOT modified.
    240          *
    241          *               (2) String length calculation terminates when :
    242          *
    243          *                   (a) String pointer points to NULL.
    244          *                       (1) String buffer overlaps with NULL address.
    245          *                       (2) String length calculated for string up to but NOT beyond or including
    246          *                           the NULL address.
    247          *
    248          *                   (b) Terminating NULL character found.
    249          *                       (1) String length calculated for string up to but NOT           including
    250          *                           the NULL character.
    251          *
    252          *                   (c) 'len_max' number of characters searched.
    253          *                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
    254          *********************************************************************************************************
    255          */
    256          

   \                                 In section .text, align 2, keep-with-next
    257          CPU_SIZE_T  Str_Len_N (CPU_CHAR    *pstr,
    258                                 CPU_SIZE_T   len_max)
    259          {
   \                     Str_Len_N:
   \   00000000   0x0002             MOVS     R2,R0
    260              CPU_SIZE_T  len;
    261          
    262          
    263              len = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x0018             MOVS     R0,R3
    264              while (( pstr != (CPU_CHAR *)  0 ) &&                       /* Calc str len until NULL ptr (see Note #2a) ...       */
    265                     (*pstr != (CPU_CHAR  )'\0') &&                       /* ... or NULL char found      (see Note #2b) ...       */
    266                     ( len   < (CPU_SIZE_T)len_max)) {                    /* ... or max nbr chars srch'd (see Note #2c).          */
   \                     ??Str_Len_N_0:
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD007             BEQ.N    ??Str_Len_N_1
   \   0000000A   0x7813             LDRB     R3,[R2, #+0]
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD004             BEQ.N    ??Str_Len_N_1
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD202             BCS.N    ??Str_Len_N_1
    267                  len++;
   \   00000014   0x1C40             ADDS     R0,R0,#+1
    268                  pstr++;
   \   00000016   0x1C52             ADDS     R2,R2,#+1
   \   00000018   0xE7F5             B.N      ??Str_Len_N_0
    269              }
    270          
    271              return (len);
   \                     ??Str_Len_N_1:
   \   0000001A   0x4770             BX       LR               ;; return
    272          }
    273          
    274          
    275          /*$PAGE*/
    276          /*
    277          *********************************************************************************************************
    278          *                                             Str_Copy()
    279          *
    280          * Description : Copy source string to destination string buffer.
    281          *
    282          * Argument(s) : pdest       Pointer to destination string buffer to receive source string copy (see Note #1).
    283          *
    284          *               psrc        Pointer to source      string to copy into destination string buffer.
    285          *
    286          * Return(s)   : Pointer to destination string, if NO errors (see Note #2).
    287          *
    288          *               Pointer to NULL,               otherwise.
    289          *
    290          * Caller(s)   : Application.
    291          *
    292          * Note(s)     : (1) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    293          *
    294          *                   (a) Destination buffer size MUST be large enough to accommodate the entire source
    295          *                       string size including the terminating NULL character.
    296          *
    297          *               (2) String copy terminates when :
    298          *
    299          *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
    300          *                       (1) No string copy performed; NULL pointer returned.
    301          *
    302          *                   (b) Destination/Source string pointer(s) points to NULL.
    303          *                       (1) String buffer(s) overlap with NULL address.
    304          *                       (2) Source string copied into destination string buffer up to but NOT beyond or
    305          *                           including the NULL address; destination string buffer properly terminated
    306          *                           with NULL character.
    307          *
    308          *                   (c) Source string's terminating NULL character found.
    309          *                       (1) Entire source string copied into destination string buffer.
    310          *********************************************************************************************************
    311          */
    312          

   \                                 In section .text, align 2, keep-with-next
    313          CPU_CHAR  *Str_Copy (CPU_CHAR  *pdest,
    314                               CPU_CHAR  *psrc)
    315          {
   \                     Str_Copy:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    316              pdest = Str_Copy_N((CPU_CHAR *)pdest,
    317                                 (CPU_CHAR *)psrc,
    318                                 (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       Str_Copy_N
   \   00000012   0x0004             MOVS     R4,R0
    319          
    320              return (pdest);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    321          }
    322          
    323          
    324          /*$PAGE*/
    325          /*
    326          *********************************************************************************************************
    327          *                                            Str_Copy_N()
    328          *
    329          * Description : Copy source string to destination string buffer, up to a maximum number of characters.
    330          *
    331          * Argument(s) : pdest       Pointer to destination string buffer to receive source string copy (see Note #1).
    332          *
    333          *               psrc        Pointer to source      string to copy into destination string buffer.
    334          *
    335          *               len_max     Maximum number of characters to copy (see Note #2d).
    336          *
    337          * Return(s)   : Pointer to destination string, if NO errors (see Note #2).
    338          *
    339          *               Pointer to NULL,               otherwise.
    340          *
    341          * Caller(s)   : Application.
    342          *
    343          * Note(s)     : (1) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    344          *
    345          *                   (a) Destination buffer size MUST be large enough to accommodate the entire source
    346          *                       string size including the terminating NULL character.
    347          *
    348          *               (2) String copy terminates when :
    349          *
    350          *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
    351          *                       (1) No string copy performed; NULL pointer returned.
    352          *
    353          *                   (b) Destination/Source string pointer(s) points to NULL.
    354          *                       (1) String buffer(s) overlap with NULL address.
    355          *                       (2) Source string copied into destination string buffer up to but NOT beyond or
    356          *                           including the NULL address; destination string buffer properly terminated
    357          *                           with NULL character.
    358          *
    359          *                   (c) Source string's terminating NULL character found.
    360          *                       (1) Entire source string copied into destination string buffer.
    361          *
    362          *                   (d) 'len_max' number of characters copied.
    363          *                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
    364          *
    365          *                           See also Note #1a.
    366          *********************************************************************************************************
    367          */
    368          

   \                                 In section .text, align 2, keep-with-next
    369          CPU_CHAR  *Str_Copy_N (CPU_CHAR    *pdest,
    370                                 CPU_CHAR    *psrc,
    371                                 CPU_SIZE_T   len_max)
    372          {
   \                     Str_Copy_N:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    373              CPU_CHAR    *pstr;
    374              CPU_CHAR    *pstr_next;
    375              CPU_SIZE_T   len_copy;
    376          
    377                                                                          /* Rtn NULL if str ptr(s) NULL      (see Note #2a).     */
    378              if (pdest == (CPU_CHAR *)0) {
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD101             BNE.N    ??Str_Copy_N_0
    379                  return  ((CPU_CHAR *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE01F             B.N      ??Str_Copy_N_1
    380              }
    381              if (psrc  == (CPU_CHAR *)0) {
   \                     ??Str_Copy_N_0:
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD101             BNE.N    ??Str_Copy_N_2
    382                  return  ((CPU_CHAR *)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE01B             B.N      ??Str_Copy_N_1
    383              }
    384          
    385              if (len_max == (CPU_SIZE_T)0) {                             /* Rtn NULL if copy len equals zero (see Note #2d).     */
   \                     ??Str_Copy_N_2:
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD101             BNE.N    ??Str_Copy_N_3
    386                  return  ((CPU_CHAR *)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE017             B.N      ??Str_Copy_N_1
    387              }
    388          
    389          
    390              pstr      = pdest;
   \                     ??Str_Copy_N_3:
   \   0000001C   0x001C             MOVS     R4,R3
    391              pstr_next = pstr;
   \   0000001E   0x0025             MOVS     R5,R4
    392              pstr_next++;
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
    393              len_copy  = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0006             MOVS     R6,R0
    394          
    395              while (( pstr_next != (CPU_CHAR *)  0 ) &&                  /* Copy str until NULL ptr(s)  [see Note #2b]  ...      */
    396                     ( psrc      != (CPU_CHAR *)  0 ) &&
    397                     (*psrc      != (CPU_CHAR  )'\0') &&                  /* ... or NULL char found      (see Note #2c); ...      */
    398                     ( len_copy  <  (CPU_SIZE_T)len_max)) {               /* ... or max nbr chars copied (see Note #2d).          */
   \                     ??Str_Copy_N_4:
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD00D             BEQ.N    ??Str_Copy_N_5
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD00B             BEQ.N    ??Str_Copy_N_5
   \   0000002E   0x7808             LDRB     R0,[R1, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD008             BEQ.N    ??Str_Copy_N_5
   \   00000034   0x4296             CMP      R6,R2
   \   00000036   0xD206             BCS.N    ??Str_Copy_N_5
    399                 *pstr = *psrc;
   \   00000038   0x7808             LDRB     R0,[R1, #+0]
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
    400                  pstr++;
   \   0000003C   0x1C64             ADDS     R4,R4,#+1
    401                  pstr_next++;
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
    402                  psrc++;
   \   00000040   0x1C49             ADDS     R1,R1,#+1
    403                  len_copy++;
   \   00000042   0x1C76             ADDS     R6,R6,#+1
   \   00000044   0xE7EF             B.N      ??Str_Copy_N_4
    404              }
    405          
    406             *pstr = (CPU_CHAR)'\0';                                      /* Append NULL char (see Note #2b2).                    */
   \                     ??Str_Copy_N_5:
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x7020             STRB     R0,[R4, #+0]
    407          
    408          
    409              return (pdest);
   \   0000004A   0x0018             MOVS     R0,R3
   \                     ??Str_Copy_N_1:
   \   0000004C   0xBC70             POP      {R4-R6}
   \   0000004E   0x4770             BX       LR               ;; return
    410          }
    411          
    412          
    413          /*$PAGE*/
    414          /*
    415          *********************************************************************************************************
    416          *                                              Str_Cat()
    417          *
    418          * Description : Append concatenation string to destination string.
    419          *
    420          * Argument(s) : pdest       Pointer to destination   string to append concatenation  string (see Note #1).
    421          *
    422          *               pstr_cat    Pointer to concatenation string to append to destination string.
    423          *
    424          * Return(s)   : Pointer to destination string, if NO errors (see Note #2).
    425          *
    426          *               Pointer to NULL,               otherwise.
    427          *
    428          * Caller(s)   : Application.
    429          *
    430          * Note(s)     : (1) Destination string buffer size NOT validated; buffer overruns MUST be prevented by caller.
    431          *
    432          *                   (a) Destination buffer size MUST be large enough to accommodate the entire concatenated
    433          *                       string size including the terminating NULL character.
    434          *
    435          *               (2) String concatenation terminates when :
    436          *
    437          *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
    438          *                       (1) No string concatenation performed; NULL pointer returned.
    439          *
    440          *                   (b) Destination string overlaps with NULL address.
    441          *                       (1) No string concatenation performed; NULL pointer returned.
    442          *
    443          *                   (c) Destination/Concatenation string pointer(s) points to NULL.
    444          *                       (1) String buffer(s) overlap with NULL address.
    445          *                       (2) Concatenation string appended into destination string buffer up to but NOT
    446          *                           beyond or including the NULL address; destination string buffer properly
    447          *                           terminated with NULL character.
    448          *
    449          *                   (d) Concatenation string's terminating NULL character found.
    450          *                       (1) Entire concatenation string appended to destination string.
    451          *********************************************************************************************************
    452          */
    453          

   \                                 In section .text, align 2, keep-with-next
    454          CPU_CHAR  *Str_Cat (CPU_CHAR  *pdest,
    455                              CPU_CHAR  *pstr_cat)
    456          {
   \                     Str_Cat:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    457              pdest = Str_Cat_N((CPU_CHAR *)pdest,
    458                                (CPU_CHAR *)pstr_cat,
    459                                (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       Str_Cat_N
   \   00000012   0x0004             MOVS     R4,R0
    460          
    461              return (pdest);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    462          }
    463          
    464          
    465          /*$PAGE*/
    466          /*
    467          *********************************************************************************************************
    468          *                                             Str_Cat_N()
    469          *
    470          * Description : Append concatenation string to destination string, up to a maximum number of characters.
    471          *
    472          * Argument(s) : pdest       Pointer to destination   string to append concatenation  string (see Note #1).
    473          *
    474          *               pstr_cat    Pointer to concatenation string to append to destination string.
    475          *
    476          *               len_max     Maximum number of characters to concatenate (see Note #2e).
    477          *
    478          * Return(s)   : Pointer to destination string, if NO errors (see Note #2).
    479          *
    480          *               Pointer to NULL,               otherwise.
    481          *
    482          * Caller(s)   : Application.
    483          *
    484          * Note(s)     : (1) Destination string buffer size NOT validated; buffer overruns MUST be prevented by caller.
    485          *
    486          *                   (a) Destination buffer size MUST be large enough to accommodate the entire concatenated
    487          *                       string size including the terminating NULL character.
    488          *
    489          *               (2) String concatenation terminates when :
    490          *
    491          *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
    492          *                       (1) No string concatenation performed; NULL pointer returned.
    493          *
    494          *                   (b) Destination string overlaps with NULL address.
    495          *                       (1) No string concatenation performed; NULL pointer returned.
    496          *
    497          *                   (c) Destination/Concatenation string pointer(s) points to NULL.
    498          *                       (1) String buffer(s) overlap with NULL address.
    499          *                       (2) Concatenation string appended into destination string buffer up to but NOT
    500          *                           beyond or including the NULL address; destination string buffer properly
    501          *                           terminated with NULL character.
    502          *
    503          *                   (d) Concatenation string's terminating NULL character found.
    504          *                       (1) Entire concatenation string appended to destination string.
    505          *
    506          *                   (e) 'len_max' number of characters concatenated.
    507          *                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
    508          *
    509          *                           See also Note #1a.
    510          *********************************************************************************************************
    511          */
    512          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    513          CPU_CHAR  *Str_Cat_N (CPU_CHAR    *pdest,
    514                                CPU_CHAR    *pstr_cat,
    515                                CPU_SIZE_T   len_max)
    516          {
   \                     Str_Cat_N:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    517              CPU_CHAR    *pstr;
    518              CPU_CHAR    *pstr_next;
    519              CPU_SIZE_T   len_cat;
    520          
    521                                                                          /* Rtn NULL if str ptr(s) NULL     (see Note #2a).      */
    522              if (pdest == (CPU_CHAR *)0) {
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD101             BNE.N    ??Str_Cat_N_0
    523                  return  ((CPU_CHAR *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE02A             B.N      ??Str_Cat_N_1
    524              }
    525              if (pstr_cat == (CPU_CHAR *)0) {
   \                     ??Str_Cat_N_0:
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD101             BNE.N    ??Str_Cat_N_2
    526                  return  ((CPU_CHAR *)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE026             B.N      ??Str_Cat_N_1
    527              }
    528          
    529              if (len_max == (CPU_SIZE_T)0) {                             /* Rtn NULL if cat len equals zero (see Note #2e).      */
   \                     ??Str_Cat_N_2:
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD101             BNE.N    ??Str_Cat_N_3
    530                  return  ((CPU_CHAR *)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE022             B.N      ??Str_Cat_N_1
    531              }
    532          
    533          
    534              pstr = pdest;
   \                     ??Str_Cat_N_3:
   \   0000001C   0x001C             MOVS     R4,R3
    535              while (( pstr != (CPU_CHAR *)  0 ) &&                       /* Adv to end of cur dest str until NULL ptr ...        */
    536                     (*pstr != (CPU_CHAR  )'\0')) {                       /* ... or NULL char found..                             */
   \                     ??Str_Cat_N_4:
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD004             BEQ.N    ??Str_Cat_N_5
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??Str_Cat_N_5
    537                  pstr++;
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \   0000002A   0xE7F8             B.N      ??Str_Cat_N_4
    538              }
    539              if (pstr == (CPU_CHAR *)0) {                                /* If NULL str overrun, rtn NULL (see Note #2b).        */
   \                     ??Str_Cat_N_5:
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD101             BNE.N    ??Str_Cat_N_6
    540                  return ((CPU_CHAR *)0);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE016             B.N      ??Str_Cat_N_1
    541              }
    542          
    543              pstr_next = pstr;
   \                     ??Str_Cat_N_6:
   \   00000034   0x0025             MOVS     R5,R4
    544              pstr_next++;
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
    545              len_cat   = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x0006             MOVS     R6,R0
    546          
    547              while (( pstr_next != (CPU_CHAR *)  0 ) &&                  /* Cat str until NULL ptr(s)  [see Note #2c]  ...       */
    548                     ( pstr_cat  != (CPU_CHAR *)  0 ) &&
    549                     (*pstr_cat  != (CPU_CHAR  )'\0') &&                  /* ... or NULL char found     (see Note #2d); ...       */
    550                     ( len_cat   <  (CPU_SIZE_T)len_max)) {               /* ... or max nbr chars cat'd (see Note #2d).           */
   \                     ??Str_Cat_N_7:
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD00D             BEQ.N    ??Str_Cat_N_8
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD00B             BEQ.N    ??Str_Cat_N_8
   \   00000044   0x7808             LDRB     R0,[R1, #+0]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD008             BEQ.N    ??Str_Cat_N_8
   \   0000004A   0x4296             CMP      R6,R2
   \   0000004C   0xD206             BCS.N    ??Str_Cat_N_8
    551                 *pstr = *pstr_cat;
   \   0000004E   0x7808             LDRB     R0,[R1, #+0]
   \   00000050   0x7020             STRB     R0,[R4, #+0]
    552                  pstr++;
   \   00000052   0x1C64             ADDS     R4,R4,#+1
    553                  pstr_next++;
   \   00000054   0x1C6D             ADDS     R5,R5,#+1
    554                  pstr_cat++;
   \   00000056   0x1C49             ADDS     R1,R1,#+1
    555                  len_cat++;
   \   00000058   0x1C76             ADDS     R6,R6,#+1
   \   0000005A   0xE7EF             B.N      ??Str_Cat_N_7
    556              }
    557          
    558             *pstr = (CPU_CHAR)'\0';                                      /* Append NULL char (see Note #2c2).                    */
   \                     ??Str_Cat_N_8:
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x7020             STRB     R0,[R4, #+0]
    559          
    560          
    561              return (pdest);
   \   00000060   0x0018             MOVS     R0,R3
   \                     ??Str_Cat_N_1:
   \   00000062   0xBC70             POP      {R4-R6}
   \   00000064   0x4770             BX       LR               ;; return
    562          }
    563          
    564          
    565          /*$PAGE*/
    566          /*
    567          *********************************************************************************************************
    568          *                                              Str_Cmp()
    569          *
    570          * Description : Determine if two strings are identical.
    571          *
    572          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    573          *
    574          *               p2_str      Pointer to second string (see Note #1).
    575          *
    576          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
    577          *
    578          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    579          *
    580          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    581          *
    582          *               See also Note #2b.
    583          *
    584          * Caller(s)   : Application.
    585          *
    586          * Note(s)     : (1) String buffers NOT modified.
    587          *
    588          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' states that "the
    589          *                       strcmp() function shall compare the string pointed to by s1 to the string pointed
    590          *                       to by s2".
    591          *
    592          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : RETURN VALUE' states that
    593          *                          "upon successful completion, strncmp() shall return an integer greater than,
    594          *                           equal to, or less than 0".
    595          *
    596          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
    597          *                           sign of a non-zero return value shall be determined by the sign of the difference
    598          *                           between the values of the first pair of bytes ... that differ in the strings
    599          *                           being compared".
    600          *
    601          *               (3) String comparison terminates when :
    602          *
    603          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    604          *                               (1) NULL strings identical; return 0.
    605          *
    606          *                           (B) (1) 'p1_str' passed a NULL pointer.
    607          *                                   (a) Return negative value of character pointed to by 'p2_str'.
    608          *
    609          *                               (2) 'p2_str' passed a NULL pointer.
    610          *                                   (a) Return positive value of character pointed to by 'p1_str'.
    611          *
    612          *                       (2) (A) BOTH strings point to NULL.
    613          *                               (1) Strings overlap with NULL address.
    614          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    615          *                                   return 0.
    616          *
    617          *                           (B) (1) 'p1_str_next' points to NULL.
    618          *                                   (a) 'p1_str' overlaps with NULL address.
    619          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    620          *                                   (c) Return negative value of character pointed to by 'p2_str_next'.
    621          *
    622          *                               (2) 'p2_str_next' points to NULL.
    623          *                                   (a) 'p2_str' overlaps with NULL address.
    624          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    625          *                                   (c) Return positive value of character pointed to by 'p1_str_next'.
    626          *
    627          *                   (b) Terminating NULL character found in both strings.
    628          *                       (1) Strings identical; return 0.
    629          *                       (2) Only one NULL character test required in conditional since previous condition
    630          *                           tested character equality.
    631          *
    632          *                   (c) Non-matching characters found.
    633          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
    634          *                           from the character pointed to by 'p1_str'.
    635          *
    636          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    637          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    638          *********************************************************************************************************
    639          */
    640          

   \                                 In section .text, align 2, keep-with-next
    641          CPU_INT16S  Str_Cmp (CPU_CHAR  *p1_str,
    642                               CPU_CHAR  *p2_str)
    643          {
   \                     Str_Cmp:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    644              CPU_INT16S  cmp_val;
    645          
    646          
    647              cmp_val = Str_Cmp_N((CPU_CHAR *)p1_str,
    648                                  (CPU_CHAR *)p2_str,
    649                                  (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       Str_Cmp_N
   \   00000012   0x0006             MOVS     R6,R0
    650          
    651              return (cmp_val);
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
    652          }
    653          
    654          
    655          /*$PAGE*/
    656          /*
    657          *********************************************************************************************************
    658          *                                             Str_Cmp_N()
    659          *
    660          * Description : Determine if two strings are identical for up to a maximum number of characters.
    661          *
    662          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    663          *
    664          *               p2_str      Pointer to second string (see Note #1).
    665          *
    666          *               len_max     Maximum number of characters to compare  (see Note  #3d).
    667          *
    668          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
    669          *
    670          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    671          *
    672          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    673          *
    674          *               See also Note #2b.
    675          *
    676          * Caller(s)   : Application.
    677          *
    678          * Note(s)     : (1) String buffers NOT modified.
    679          *
    680          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' states that :
    681          *
    682          *                       (1) "The strncmp() function shall compare ... the array pointed to by s1 to the
    683          *                            array pointed to by s2" but ...
    684          *                       (2) "not more than 'n' bytes" of either array.
    685          *
    686          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : RETURN VALUE' states that
    687          *                          "upon successful completion, strncmp() shall return an integer greater than,
    688          *                           equal to, or less than 0".
    689          *
    690          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' adds that
    691          *                          "the sign of a non-zero return value is determined by the sign of the difference
    692          *                           between the values of the first pair of bytes ... that differ in the strings
    693          *                           being compared".
    694          *
    695          *               (3) String comparison terminates when :
    696          *
    697          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    698          *                               (1) NULL strings identical; return 0.
    699          *
    700          *                           (B) (1) 'p1_str' passed a NULL pointer.
    701          *                                   (a) Return negative value of character pointed to by 'p2_str'.
    702          *
    703          *                               (2) 'p2_str' passed a NULL pointer.
    704          *                                   (a) Return positive value of character pointed to by 'p1_str'.
    705          *
    706          *                       (2) (A) BOTH strings point to NULL.
    707          *                               (1) Strings overlap with NULL address.
    708          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    709          *                                   return 0.
    710          *
    711          *                           (B) (1) 'p1_str_next' points to NULL.
    712          *                                   (a) 'p1_str' overlaps with NULL address.
    713          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    714          *                                   (c) Return negative value of character pointed to by 'p2_str_next'.
    715          *
    716          *                               (2) 'p2_str_next' points to NULL.
    717          *                                   (a) 'p2_str' overlaps with NULL address.
    718          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    719          *                                   (c) Return positive value of character pointed to by 'p1_str_next'.
    720          *
    721          *                   (b) Terminating NULL character found in both strings.
    722          *                       (1) Strings identical; return 0.
    723          *                       (2) Only one NULL character test required in conditional since previous condition
    724          *                           tested character equality.
    725          *
    726          *                   (c) Non-matching characters found.
    727          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
    728          *                           from the character pointed to by 'p1_str'.
    729          *
    730          *                   (d) (1) 'len_max' passed a zero length.
    731          *                           (A) Zero-length strings identical; return 0.
    732          *
    733          *                       (2) First 'len_max' number of characters identical.
    734          *                           (A) Strings identical; return 0.
    735          *
    736          *                       See also Note #2a2.
    737          *
    738          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    739          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    740          *********************************************************************************************************
    741          */
    742          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    743          CPU_INT16S  Str_Cmp_N (CPU_CHAR    *p1_str,
    744                                 CPU_CHAR    *p2_str,
    745                                 CPU_SIZE_T   len_max)
    746          {
   \                     Str_Cmp_N:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
    747              CPU_CHAR    *p1_str_next;
    748              CPU_CHAR    *p2_str_next;
    749              CPU_INT16S   cmp_val;
    750              CPU_SIZE_T   cmp_len;
    751          
    752          
    753              if (len_max == 0) {                                         /* If cmp len equals zero, rtn 0      (see Note #3d1).  */
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??Str_Cmp_N_0
    754                  return ((CPU_INT16S)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE051             B.N      ??Str_Cmp_N_1
    755              }
    756          
    757              if (p1_str == (CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_0:
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD109             BNE.N    ??Str_Cmp_N_2
    758                  if (p2_str == (CPU_CHAR *)0) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD101             BNE.N    ??Str_Cmp_N_3
    759                      return ((CPU_INT16S)0);                             /* If BOTH str ptrs NULL,  rtn 0      (see Note #3a1A). */
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE04B             B.N      ??Str_Cmp_N_1
    760                  }
    761                  cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str);
   \                     ??Str_Cmp_N_3:
   \   00000018   0x7808             LDRB     R0,[R1, #+0]
   \   0000001A   0x4240             RSBS     R0,R0,#+0
   \   0000001C   0x0005             MOVS     R5,R0
    762                  return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000022   0xE045             B.N      ??Str_Cmp_N_1
    763              }
    764              if (p2_str == (CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_2:
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD104             BNE.N    ??Str_Cmp_N_4
    765                  cmp_val = (CPU_INT16S)(*p1_str);
   \   00000028   0x7818             LDRB     R0,[R3, #+0]
   \   0000002A   0x0005             MOVS     R5,R0
    766                  return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000030   0xE03E             B.N      ??Str_Cmp_N_1
    767              }
    768          
    769          
    770              p1_str_next = p1_str;
   \                     ??Str_Cmp_N_4:
   \   00000032   0x001E             MOVS     R6,R3
    771              p2_str_next = p2_str;
   \   00000034   0x000F             MOVS     R7,R1
    772              p1_str_next++;
   \   00000036   0x1C76             ADDS     R6,R6,#+1
    773              p2_str_next++;
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
    774              cmp_len     = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x0004             MOVS     R4,R0
    775              while ((*p1_str      == *p2_str)          &&                /* Cmp strs until non-matching chars (see Note #3c) ... */
    776                     (*p1_str      != (CPU_CHAR  )'\0') &&                /* ... or NULL chars                 (see Note #3b) ... */
    777                     ( p1_str_next != (CPU_CHAR *)  0 ) &&                /* ... or NULL ptr(s) found          (see Note #3a2);   */
    778                     ( p2_str_next != (CPU_CHAR *)  0 ) &&
    779                     ( cmp_len     <  (CPU_SIZE_T)len_max)) {             /* ... or max nbr chars cmp'd        (see Note #3d2).   */
   \                     ??Str_Cmp_N_5:
   \   0000003E   0x7818             LDRB     R0,[R3, #+0]
   \   00000040   0xF891 0xC000      LDRB     R12,[R1, #+0]
   \   00000044   0x4560             CMP      R0,R12
   \   00000046   0xD10E             BNE.N    ??Str_Cmp_N_6
   \   00000048   0x7818             LDRB     R0,[R3, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD00B             BEQ.N    ??Str_Cmp_N_6
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD009             BEQ.N    ??Str_Cmp_N_6
   \   00000052   0x2F00             CMP      R7,#+0
   \   00000054   0xD007             BEQ.N    ??Str_Cmp_N_6
   \   00000056   0x4294             CMP      R4,R2
   \   00000058   0xD205             BCS.N    ??Str_Cmp_N_6
    780                  p1_str_next++;
   \   0000005A   0x1C76             ADDS     R6,R6,#+1
    781                  p2_str_next++;
   \   0000005C   0x1C7F             ADDS     R7,R7,#+1
    782                  p1_str++;
   \   0000005E   0x1C5B             ADDS     R3,R3,#+1
    783                  p2_str++;
   \   00000060   0x1C49             ADDS     R1,R1,#+1
    784                  cmp_len++;
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \   00000064   0xE7EB             B.N      ??Str_Cmp_N_5
    785              }
    786          
    787          
    788              if (cmp_len == len_max) {                                       /* If strs     identical for len nbr of chars, ...  */
   \                     ??Str_Cmp_N_6:
   \   00000066   0x4294             CMP      R4,R2
   \   00000068   0xD101             BNE.N    ??Str_Cmp_N_7
    789                  return ((CPU_INT16S)0);                                     /* ... rtn 0                   (see Note #3d2).     */
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE020             B.N      ??Str_Cmp_N_1
    790              }
    791          
    792              if (*p1_str != *p2_str) {                                       /* If strs NOT identical, ...                       */
   \                     ??Str_Cmp_N_7:
   \   0000006E   0x7818             LDRB     R0,[R3, #+0]
   \   00000070   0xF891 0xC000      LDRB     R12,[R1, #+0]
   \   00000074   0x4560             CMP      R0,R12
   \   00000076   0xD006             BEQ.N    ??Str_Cmp_N_8
    793                   cmp_val = (CPU_INT16S)(*p1_str) - (CPU_INT16S)(*p2_str);   /* ... calc & rtn char diff    (see Note #3c).      */
   \   00000078   0x7818             LDRB     R0,[R3, #+0]
   \   0000007A   0xF891 0xC000      LDRB     R12,[R1, #+0]
   \   0000007E   0xEBB0 0x000C      SUBS     R0,R0,R12
   \   00000082   0x0005             MOVS     R5,R0
   \   00000084   0xE012             B.N      ??Str_Cmp_N_9
    794          
    795              } else if (*p1_str  == (CPU_CHAR)'\0') {                        /* If NULL char(s) found, ...                       */
   \                     ??Str_Cmp_N_8:
   \   00000086   0x7818             LDRB     R0,[R3, #+0]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD102             BNE.N    ??Str_Cmp_N_10
    796                   cmp_val = 0;                                               /* ... strs identical; rtn 0   (see Note #3b).      */
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x0005             MOVS     R5,R0
   \   00000090   0xE00C             B.N      ??Str_Cmp_N_9
    797          
    798              } else {
    799                  if (p1_str_next == (CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_10:
   \   00000092   0x2E00             CMP      R6,#+0
   \   00000094   0xD108             BNE.N    ??Str_Cmp_N_11
    800                      if (p2_str_next == (CPU_CHAR *)0) {                     /* If BOTH next str ptrs NULL, ...                  */
   \   00000096   0x2F00             CMP      R7,#+0
   \   00000098   0xD102             BNE.N    ??Str_Cmp_N_12
    801                          cmp_val  = (CPU_INT16S)0;                           /* ... rtn 0                   (see Note #3a2A).    */
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x0005             MOVS     R5,R0
   \   0000009E   0xE005             B.N      ??Str_Cmp_N_9
    802                      } else {                                                /* If p1_str_next NULL, ...                         */
    803                                                                              /* ... rtn neg p2_str_next val (see Note #3a2B1).   */
    804                          cmp_val  = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str_next);
   \                     ??Str_Cmp_N_12:
   \   000000A0   0x7838             LDRB     R0,[R7, #+0]
   \   000000A2   0x4240             RSBS     R0,R0,#+0
   \   000000A4   0x0005             MOVS     R5,R0
   \   000000A6   0xE001             B.N      ??Str_Cmp_N_9
    805                      }
    806                  } else {                                                    /* If p2_str_next NULL, ...                         */
    807                      cmp_val = (CPU_INT16S)(*p1_str_next);                   /* ... rtn pos p1_str_next val (see Note #3a2B2).   */
   \                     ??Str_Cmp_N_11:
   \   000000A8   0x7830             LDRB     R0,[R6, #+0]
   \   000000AA   0x0005             MOVS     R5,R0
    808                  }
    809              }
    810          
    811          
    812              return (cmp_val);
   \                     ??Str_Cmp_N_9:
   \   000000AC   0x0028             MOVS     R0,R5
   \   000000AE   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??Str_Cmp_N_1:
   \   000000B0   0xBCF0             POP      {R4-R7}
   \   000000B2   0x4770             BX       LR               ;; return
    813          }
    814          
    815          
    816          /*$PAGE*/
    817          /*
    818          *********************************************************************************************************
    819          *                                         Str_CmpIgnoreCase()
    820          *
    821          * Description : Determine if two strings are identical, ignoring case.
    822          *
    823          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    824          *
    825          *               p2_str      Pointer to second string (see Note #1).
    826          *
    827          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
    828          *
    829          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    830          *
    831          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    832          *
    833          *               See also Note #2b.
    834          *
    835          * Caller(s)   : Application.
    836          *
    837          * Note(s)     : (1) String buffers NOT modified.
    838          *
    839          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : DESCRIPTION' states that :
    840          *
    841          *                       (1) (A) "The strcasecmp() function shall compare ... the string pointed to by s1
    842          *                                to the string pointed to by s2" ...
    843          *                           (B) "ignoring differences in case".
    844          *
    845          *                       (2) "strcasecmp() ... shall behave as if the strings had been converted to lowercase
    846          *                            and then a byte comparison performed."
    847          *
    848          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : RETURN VALUE' states that
    849          *                          "upon successful completion, strcasecmp() shall return an integer greater than,
    850          *                           equal to, or less than 0".
    851          *
    852          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
    853          *                           sign of a non-zero return value shall be determined by the sign of the difference
    854          *                           between the values of the first pair of bytes ... that differ in the strings
    855          *                           being compared".
    856          *
    857          *               (3) String comparison terminates when :
    858          *
    859          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    860          *                               (1) NULL strings identical; return 0.
    861          *
    862          *                           (B) (1) 'p1_str' passed a NULL pointer.
    863          *                                   (a) Return negative value of character pointed to by 'p2_str', converted
    864          *                                       to lower case (see Note #2a2).
    865          *
    866          *                               (2) 'p2_str' passed a NULL pointer.
    867          *                                   (a) Return positive value of character pointed to by 'p1_str', converted
    868          *                                       to lower case (see Note #2a2).
    869          *
    870          *                       (2) (A) BOTH strings point to NULL.
    871          *                               (1) Strings overlap with NULL address.
    872          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    873          *                                   return 0.
    874          *
    875          *                           (B) (1) 'p1_str_next' points to NULL.
    876          *                                   (a) 'p1_str' overlaps with NULL address.
    877          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    878          *                                   (c) Return negative value of character pointed to by 'p2_str_next',
    879          *                                       converted to lower case (see Note #2a2).
    880          *
    881          *                               (2) 'p2_str_next' points to NULL.
    882          *                                   (a) 'p2_str' overlaps with NULL address.
    883          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    884          *                                   (c) Return positive value of character pointed to by 'p1_str_next',
    885          *                                       converted to lower case (see Note #2a2).
    886          *
    887          *                   (b) Terminating NULL character found in both strings.
    888          *                       (1) Strings identical; return 0.
    889          *                       (2) Only one NULL character test required in conditional since previous condition
    890          *                           tested character equality.
    891          *
    892          *                   (c) Non-matching characters found.
    893          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
    894          *                           converted to lower case, from the character pointed to by 'p1_str', converted
    895          *                           to lower case.
    896          *
    897          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    898          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    899          *********************************************************************************************************
    900          */
    901          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    902          CPU_INT16S  Str_CmpIgnoreCase (CPU_CHAR  *p1_str,
    903                                         CPU_CHAR  *p2_str)
    904          {
   \                     Str_CmpIgnoreCase:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    905              CPU_INT16S  cmp_val;
    906          
    907          
    908              cmp_val = Str_CmpIgnoreCase_N((CPU_CHAR *)p1_str,
    909                                            (CPU_CHAR *)p2_str,
    910                                            (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       Str_CmpIgnoreCase_N
   \   00000012   0x0006             MOVS     R6,R0
    911          
    912              return (cmp_val);
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
    913          }
    914          
    915          
    916          /*$PAGE*/
    917          /*
    918          *********************************************************************************************************
    919          *                                        Str_CmpIgnoreCase_N()
    920          *
    921          * Description : Determine if two strings are identical for up to a maximum number of characters,
    922          *                   ignoring case.
    923          *
    924          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    925          *
    926          *               p2_str      Pointer to second string (see Note #1).
    927          *
    928          *               len_max     Maximum number of characters to compare  (see Note  #3d).
    929          *
    930          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
    931          *
    932          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    933          *
    934          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    935          *
    936          *               See also Note #2b.
    937          *
    938          * Caller(s)   : Application.
    939          *
    940          * Note(s)     : (1) String buffers NOT modified.
    941          *
    942          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : DESCRIPTION' states that :
    943          *
    944          *                       (1) (A) "The strncasecmp() function shall compare ... the string pointed to by s1
    945          *                                to the string pointed to by s2" ...
    946          *                           (B) "ignoring differences in case" & ...
    947          *                           (C) "not more than 'n' bytes" of either string.
    948          *
    949          *                       (2) "strncasecmp() shall behave as if the strings had been converted to lowercase
    950          *                            and then a byte comparison performed."
    951          *
    952          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : RETURN VALUE' states that
    953          *                          "upon successful completion, strncasecmp() shall return an integer greater than,
    954          *                           equal to, or less than 0".
    955          *
    956          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
    957          *                           sign of a non-zero return value shall be determined by the sign of the difference
    958          *                           between the values of the first pair of bytes ... that differ in the strings
    959          *                           being compared".
    960          *
    961          *               (3) String comparison terminates when :
    962          *
    963          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    964          *                               (1) NULL strings identical; return 0.
    965          *
    966          *                           (B) (1) 'p1_str' passed a NULL pointer.
    967          *                                   (a) Return negative value of character pointed to by 'p2_str', converted
    968          *                                       to lower case (see Note #2a2).
    969          *
    970          *                               (2) 'p2_str' passed a NULL pointer.
    971          *                                   (a) Return positive value of character pointed to by 'p1_str', converted
    972          *                                       to lower case (see Note #2a2).
    973          *
    974          *                       (2) (A) BOTH strings point to NULL.
    975          *                               (1) Strings overlap with NULL address.
    976          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    977          *                                   return 0.
    978          *
    979          *                           (B) (1) 'p1_str_next' points to NULL.
    980          *                                   (a) 'p1_str' overlaps with NULL address.
    981          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    982          *                                   (c) Return negative value of character pointed to by 'p2_str_next',
    983          *                                       converted to lower case (see Note #2a2).
    984          *
    985          *                               (2) 'p2_str_next' points to NULL.
    986          *                                   (a) 'p2_str' overlaps with NULL address.
    987          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    988          *                                   (c) Return positive value of character pointed to by 'p1_str_next',
    989          *                                       converted to lower case (see Note #2a2).
    990          *
    991          *                   (b) Terminating NULL character found in both strings.
    992          *                       (1) Strings identical; return 0.
    993          *                       (2) Only one NULL character test required in conditional since previous condition
    994          *                           tested character equality.
    995          *
    996          *                   (c) Non-matching characters found.
    997          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
    998          *                           converted to lower case, from the character pointed to by 'p1_str', converted
    999          *                           to lower case.
   1000          *
   1001          *                   (d) (1) 'len_max' passed a zero length.
   1002          *                           (A) Zero-length strings identical; return 0.
   1003          *
   1004          *                       (2) First 'len_max' number of characters identical.
   1005          *                           (A) Strings identical; return 0.
   1006          *
   1007          *                       See also Note #2a1C.
   1008          *$PAGE*
   1009          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
   1010          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
   1011          *********************************************************************************************************
   1012          */
   1013          

   \                                 In section .text, align 2, keep-with-next
   1014          CPU_INT16S  Str_CmpIgnoreCase_N (CPU_CHAR    *p1_str,
   1015                                           CPU_CHAR    *p2_str,
   1016                                           CPU_SIZE_T   len_max)
   1017          {
   \                     Str_CmpIgnoreCase_N:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x0003             MOVS     R3,R0
   1018              CPU_CHAR    *p1_str_next;
   1019              CPU_CHAR    *p2_str_next;
   1020              CPU_CHAR     char1;
   1021              CPU_CHAR     char2;
   1022              CPU_INT16S   cmp_val;
   1023              CPU_SIZE_T   cmp_len;
   1024          
   1025          
   1026              if (len_max == 0) {                                         /* If cmp len equals zero, rtn 0      (see Note #3d1).  */
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_0
   1027                  return ((CPU_INT16S)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE0E4             B.N      ??Str_CmpIgnoreCase_N_1
   1028              }
   1029          
   1030              if (p1_str == (CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_0:
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD11C             BNE.N    ??Str_CmpIgnoreCase_N_2
   1031                  if (p2_str == (CPU_CHAR *)0) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_3
   1032                      return ((CPU_INT16S)0);                             /* If BOTH str ptrs NULL,  rtn 0      (see Note #3a1A). */
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE0DE             B.N      ??Str_CmpIgnoreCase_N_1
   1033                  }
   1034                  char2   =  ASCII_TO_LOWER(*p2_str);
   \                     ??Str_CmpIgnoreCase_N_3:
   \   00000018   0x7808             LDRB     R0,[R1, #+0]
   \   0000001A   0x2841             CMP      R0,#+65
   \   0000001C   0xDB04             BLT.N    ??Str_CmpIgnoreCase_N_4
   \   0000001E   0x7808             LDRB     R0,[R1, #+0]
   \   00000020   0x285B             CMP      R0,#+91
   \   00000022   0xDA01             BGE.N    ??Str_CmpIgnoreCase_N_4
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B.N      ??Str_CmpIgnoreCase_N_5
   \                     ??Str_CmpIgnoreCase_N_4:
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??Str_CmpIgnoreCase_N_5:
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD103             BNE.N    ??Str_CmpIgnoreCase_N_6
   \   0000002E   0x7808             LDRB     R0,[R1, #+0]
   \   00000030   0xF110 0x0E20      ADDS     LR,R0,#+32
   \   00000034   0xE001             B.N      ??Str_CmpIgnoreCase_N_7
   \                     ??Str_CmpIgnoreCase_N_6:
   \   00000036   0xF891 0xE000      LDRB     LR,[R1, #+0]
   1035                  cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char2;
   \                     ??Str_CmpIgnoreCase_N_7:
   \   0000003A   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   0000003E   0xF1DE 0x0000      RSBS     R0,LR,#+0
   \   00000042   0x0004             MOVS     R4,R0
   1036                  return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000048   0xE0C5             B.N      ??Str_CmpIgnoreCase_N_1
   1037              }
   1038              if (p2_str == (CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_2:
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD116             BNE.N    ??Str_CmpIgnoreCase_N_8
   1039                  char1   =  ASCII_TO_LOWER(*p1_str);
   \   0000004E   0x7818             LDRB     R0,[R3, #+0]
   \   00000050   0x2841             CMP      R0,#+65
   \   00000052   0xDB04             BLT.N    ??Str_CmpIgnoreCase_N_9
   \   00000054   0x7818             LDRB     R0,[R3, #+0]
   \   00000056   0x285B             CMP      R0,#+91
   \   00000058   0xDA01             BGE.N    ??Str_CmpIgnoreCase_N_9
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xE000             B.N      ??Str_CmpIgnoreCase_N_10
   \                     ??Str_CmpIgnoreCase_N_9:
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??Str_CmpIgnoreCase_N_10:
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD103             BNE.N    ??Str_CmpIgnoreCase_N_11
   \   00000064   0x7818             LDRB     R0,[R3, #+0]
   \   00000066   0xF110 0x0C20      ADDS     R12,R0,#+32
   \   0000006A   0xE001             B.N      ??Str_CmpIgnoreCase_N_12
   \                     ??Str_CmpIgnoreCase_N_11:
   \   0000006C   0xF893 0xC000      LDRB     R12,[R3, #+0]
   1040                  cmp_val = (CPU_INT16S)char1;
   \                     ??Str_CmpIgnoreCase_N_12:
   \   00000070   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000074   0x4664             MOV      R4,R12
   1041                  return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000007A   0xE0AC             B.N      ??Str_CmpIgnoreCase_N_1
   1042              }
   1043          
   1044          
   1045              p1_str_next = p1_str;
   \                     ??Str_CmpIgnoreCase_N_8:
   \   0000007C   0x001D             MOVS     R5,R3
   1046              p2_str_next = p2_str;
   \   0000007E   0x000E             MOVS     R6,R1
   1047              p1_str_next++;
   \   00000080   0x1C6D             ADDS     R5,R5,#+1
   1048              p2_str_next++;
   \   00000082   0x1C76             ADDS     R6,R6,#+1
   1049              char1       = ASCII_TO_LOWER(*p1_str);
   \   00000084   0x7818             LDRB     R0,[R3, #+0]
   \   00000086   0x2841             CMP      R0,#+65
   \   00000088   0xDB04             BLT.N    ??Str_CmpIgnoreCase_N_13
   \   0000008A   0x7818             LDRB     R0,[R3, #+0]
   \   0000008C   0x285B             CMP      R0,#+91
   \   0000008E   0xDA01             BGE.N    ??Str_CmpIgnoreCase_N_13
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xE000             B.N      ??Str_CmpIgnoreCase_N_14
   \                     ??Str_CmpIgnoreCase_N_13:
   \   00000094   0x2000             MOVS     R0,#+0
   \                     ??Str_CmpIgnoreCase_N_14:
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD103             BNE.N    ??Str_CmpIgnoreCase_N_15
   \   0000009A   0x7818             LDRB     R0,[R3, #+0]
   \   0000009C   0xF110 0x0C20      ADDS     R12,R0,#+32
   \   000000A0   0xE001             B.N      ??Str_CmpIgnoreCase_N_16
   \                     ??Str_CmpIgnoreCase_N_15:
   \   000000A2   0xF893 0xC000      LDRB     R12,[R3, #+0]
   1050              char2       = ASCII_TO_LOWER(*p2_str);
   \                     ??Str_CmpIgnoreCase_N_16:
   \   000000A6   0x7808             LDRB     R0,[R1, #+0]
   \   000000A8   0x2841             CMP      R0,#+65
   \   000000AA   0xDB04             BLT.N    ??Str_CmpIgnoreCase_N_17
   \   000000AC   0x7808             LDRB     R0,[R1, #+0]
   \   000000AE   0x285B             CMP      R0,#+91
   \   000000B0   0xDA01             BGE.N    ??Str_CmpIgnoreCase_N_17
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0xE000             B.N      ??Str_CmpIgnoreCase_N_18
   \                     ??Str_CmpIgnoreCase_N_17:
   \   000000B6   0x2000             MOVS     R0,#+0
   \                     ??Str_CmpIgnoreCase_N_18:
   \   000000B8   0x2801             CMP      R0,#+1
   \   000000BA   0xD103             BNE.N    ??Str_CmpIgnoreCase_N_19
   \   000000BC   0x7808             LDRB     R0,[R1, #+0]
   \   000000BE   0xF110 0x0E20      ADDS     LR,R0,#+32
   \   000000C2   0xE001             B.N      ??Str_CmpIgnoreCase_N_20
   \                     ??Str_CmpIgnoreCase_N_19:
   \   000000C4   0xF891 0xE000      LDRB     LR,[R1, #+0]
   1051              cmp_len     = 0;
   \                     ??Str_CmpIgnoreCase_N_20:
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x0007             MOVS     R7,R0
   1052              while (( char1       ==  char2)           &&                /* Cmp strs until non-matching chars (see Note #3c) ... */
   1053                     (*p1_str      != (CPU_CHAR  )'\0') &&                /* ... or NULL chars                 (see Note #3b) ... */
   1054                     ( p1_str_next != (CPU_CHAR *)  0 ) &&                /* ... or NULL ptr(s) found          (see Note #3a2);   */
   1055                     ( p2_str_next != (CPU_CHAR *)  0 ) &&
   1056                     ( cmp_len     <  (CPU_SIZE_T)len_max)) {             /* ... or max nbr chars cmp'd        (see Note #3d2).   */
   \                     ??Str_CmpIgnoreCase_N_21:
   \   000000CC   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   000000D0   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   000000D4   0x45F4             CMP      R12,LR
   \   000000D6   0xD130             BNE.N    ??Str_CmpIgnoreCase_N_22
   \   000000D8   0x7818             LDRB     R0,[R3, #+0]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD02D             BEQ.N    ??Str_CmpIgnoreCase_N_22
   \   000000DE   0x2D00             CMP      R5,#+0
   \   000000E0   0xD02B             BEQ.N    ??Str_CmpIgnoreCase_N_22
   \   000000E2   0x2E00             CMP      R6,#+0
   \   000000E4   0xD029             BEQ.N    ??Str_CmpIgnoreCase_N_22
   \   000000E6   0x4297             CMP      R7,R2
   \   000000E8   0xD227             BCS.N    ??Str_CmpIgnoreCase_N_22
   1057                  p1_str_next++;
   \   000000EA   0x1C6D             ADDS     R5,R5,#+1
   1058                  p2_str_next++;
   \   000000EC   0x1C76             ADDS     R6,R6,#+1
   1059                  p1_str++;
   \   000000EE   0x1C5B             ADDS     R3,R3,#+1
   1060                  p2_str++;
   \   000000F0   0x1C49             ADDS     R1,R1,#+1
   1061                  cmp_len++;
   \   000000F2   0x1C7F             ADDS     R7,R7,#+1
   1062                  char1 = ASCII_TO_LOWER(*p1_str);
   \   000000F4   0x7818             LDRB     R0,[R3, #+0]
   \   000000F6   0x2841             CMP      R0,#+65
   \   000000F8   0xDB04             BLT.N    ??Str_CmpIgnoreCase_N_23
   \   000000FA   0x7818             LDRB     R0,[R3, #+0]
   \   000000FC   0x285B             CMP      R0,#+91
   \   000000FE   0xDA01             BGE.N    ??Str_CmpIgnoreCase_N_23
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0xE000             B.N      ??Str_CmpIgnoreCase_N_24
   \                     ??Str_CmpIgnoreCase_N_23:
   \   00000104   0x2000             MOVS     R0,#+0
   \                     ??Str_CmpIgnoreCase_N_24:
   \   00000106   0x2801             CMP      R0,#+1
   \   00000108   0xD103             BNE.N    ??Str_CmpIgnoreCase_N_25
   \   0000010A   0x7818             LDRB     R0,[R3, #+0]
   \   0000010C   0xF110 0x0C20      ADDS     R12,R0,#+32
   \   00000110   0xE001             B.N      ??Str_CmpIgnoreCase_N_26
   \                     ??Str_CmpIgnoreCase_N_25:
   \   00000112   0xF893 0xC000      LDRB     R12,[R3, #+0]
   1063                  char2 = ASCII_TO_LOWER(*p2_str);
   \                     ??Str_CmpIgnoreCase_N_26:
   \   00000116   0x7808             LDRB     R0,[R1, #+0]
   \   00000118   0x2841             CMP      R0,#+65
   \   0000011A   0xDB04             BLT.N    ??Str_CmpIgnoreCase_N_27
   \   0000011C   0x7808             LDRB     R0,[R1, #+0]
   \   0000011E   0x285B             CMP      R0,#+91
   \   00000120   0xDA01             BGE.N    ??Str_CmpIgnoreCase_N_27
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xE000             B.N      ??Str_CmpIgnoreCase_N_28
   \                     ??Str_CmpIgnoreCase_N_27:
   \   00000126   0x2000             MOVS     R0,#+0
   \                     ??Str_CmpIgnoreCase_N_28:
   \   00000128   0x2801             CMP      R0,#+1
   \   0000012A   0xD103             BNE.N    ??Str_CmpIgnoreCase_N_29
   \   0000012C   0x7808             LDRB     R0,[R1, #+0]
   \   0000012E   0xF110 0x0E20      ADDS     LR,R0,#+32
   \   00000132   0xE001             B.N      ??Str_CmpIgnoreCase_N_30
   \                     ??Str_CmpIgnoreCase_N_29:
   \   00000134   0xF891 0xE000      LDRB     LR,[R1, #+0]
   \                     ??Str_CmpIgnoreCase_N_30:
   \   00000138   0xE7C8             B.N      ??Str_CmpIgnoreCase_N_21
   1064              }
   1065          
   1066          
   1067              if (cmp_len == len_max) {                                   /* If strs     identical for len nbr of chars, ...      */
   \                     ??Str_CmpIgnoreCase_N_22:
   \   0000013A   0x4297             CMP      R7,R2
   \   0000013C   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_31
   1068                  return ((CPU_INT16S)0);                                 /* ... rtn 0                   (see Note #3d2).         */
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0xE049             B.N      ??Str_CmpIgnoreCase_N_1
   1069              }
   1070          
   1071              if (char1 != char2) {                                       /* If strs NOT identical, ...                           */
   \                     ??Str_CmpIgnoreCase_N_31:
   \   00000142   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000146   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   0000014A   0x45F4             CMP      R12,LR
   \   0000014C   0xD007             BEQ.N    ??Str_CmpIgnoreCase_N_32
   1072                   cmp_val = (CPU_INT16S)char1 - (CPU_INT16S)char2;       /* ... calc & rtn char diff    (see Note #3c).          */
   \   0000014E   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000152   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   00000156   0xEBBC 0x000E      SUBS     R0,R12,LR
   \   0000015A   0x0004             MOVS     R4,R0
   \   0000015C   0xE039             B.N      ??Str_CmpIgnoreCase_N_33
   1073          
   1074              } else if (char1 == (CPU_CHAR)'\0') {                       /* If NULL char(s) found, ...                           */
   \                     ??Str_CmpIgnoreCase_N_32:
   \   0000015E   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000162   0xF1BC 0x0F00      CMP      R12,#+0
   \   00000166   0xD102             BNE.N    ??Str_CmpIgnoreCase_N_34
   1075                   cmp_val = 0;                                           /* ... strs identical; rtn 0   (see Note #3b).          */
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0x0004             MOVS     R4,R0
   \   0000016C   0xE031             B.N      ??Str_CmpIgnoreCase_N_33
   1076          
   1077              } else {
   1078                  if (p1_str_next == (CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_34:
   \   0000016E   0x2D00             CMP      R5,#+0
   \   00000170   0xD11B             BNE.N    ??Str_CmpIgnoreCase_N_35
   1079                      if (p2_str_next == (CPU_CHAR *)0) {                 /* If BOTH next str ptrs NULL, ...                      */
   \   00000172   0x2E00             CMP      R6,#+0
   \   00000174   0xD102             BNE.N    ??Str_CmpIgnoreCase_N_36
   1080                          cmp_val  = (CPU_INT16S)0;                       /* ... rtn 0                   (see Note #3a2A).        */
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0x0004             MOVS     R4,R0
   \   0000017A   0xE02A             B.N      ??Str_CmpIgnoreCase_N_33
   1081                      } else {                                            /* If p1_str_next NULL, ...                             */
   1082                          char2    =  ASCII_TO_LOWER(*p2_str_next);
   \                     ??Str_CmpIgnoreCase_N_36:
   \   0000017C   0x7830             LDRB     R0,[R6, #+0]
   \   0000017E   0x2841             CMP      R0,#+65
   \   00000180   0xDB04             BLT.N    ??Str_CmpIgnoreCase_N_37
   \   00000182   0x7830             LDRB     R0,[R6, #+0]
   \   00000184   0x285B             CMP      R0,#+91
   \   00000186   0xDA01             BGE.N    ??Str_CmpIgnoreCase_N_37
   \   00000188   0x2001             MOVS     R0,#+1
   \   0000018A   0xE000             B.N      ??Str_CmpIgnoreCase_N_38
   \                     ??Str_CmpIgnoreCase_N_37:
   \   0000018C   0x2000             MOVS     R0,#+0
   \                     ??Str_CmpIgnoreCase_N_38:
   \   0000018E   0x2801             CMP      R0,#+1
   \   00000190   0xD103             BNE.N    ??Str_CmpIgnoreCase_N_39
   \   00000192   0x7830             LDRB     R0,[R6, #+0]
   \   00000194   0xF110 0x0E20      ADDS     LR,R0,#+32
   \   00000198   0xE001             B.N      ??Str_CmpIgnoreCase_N_40
   \                     ??Str_CmpIgnoreCase_N_39:
   \   0000019A   0xF896 0xE000      LDRB     LR,[R6, #+0]
   1083                          cmp_val  = (CPU_INT16S)0 - (CPU_INT16S)char2;   /* ... rtn neg p2_str_next val (see Note #3a2B1).       */
   \                     ??Str_CmpIgnoreCase_N_40:
   \   0000019E   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   000001A2   0xF1DE 0x0000      RSBS     R0,LR,#+0
   \   000001A6   0x0004             MOVS     R4,R0
   \   000001A8   0xE013             B.N      ??Str_CmpIgnoreCase_N_33
   1084                      }
   1085                  } else {                                                /* If p2_str_next NULL, ...                             */
   1086                      char1   =  ASCII_TO_LOWER(*p1_str_next);
   \                     ??Str_CmpIgnoreCase_N_35:
   \   000001AA   0x7828             LDRB     R0,[R5, #+0]
   \   000001AC   0x2841             CMP      R0,#+65
   \   000001AE   0xDB04             BLT.N    ??Str_CmpIgnoreCase_N_41
   \   000001B0   0x7828             LDRB     R0,[R5, #+0]
   \   000001B2   0x285B             CMP      R0,#+91
   \   000001B4   0xDA01             BGE.N    ??Str_CmpIgnoreCase_N_41
   \   000001B6   0x2001             MOVS     R0,#+1
   \   000001B8   0xE000             B.N      ??Str_CmpIgnoreCase_N_42
   \                     ??Str_CmpIgnoreCase_N_41:
   \   000001BA   0x2000             MOVS     R0,#+0
   \                     ??Str_CmpIgnoreCase_N_42:
   \   000001BC   0x2801             CMP      R0,#+1
   \   000001BE   0xD103             BNE.N    ??Str_CmpIgnoreCase_N_43
   \   000001C0   0x7828             LDRB     R0,[R5, #+0]
   \   000001C2   0xF110 0x0C20      ADDS     R12,R0,#+32
   \   000001C6   0xE001             B.N      ??Str_CmpIgnoreCase_N_44
   \                     ??Str_CmpIgnoreCase_N_43:
   \   000001C8   0xF895 0xC000      LDRB     R12,[R5, #+0]
   1087                      cmp_val = (CPU_INT16S)char1;                        /* ... rtn pos p1_str_next val (see Note #3a2B2).       */
   \                     ??Str_CmpIgnoreCase_N_44:
   \   000001CC   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   000001D0   0x4664             MOV      R4,R12
   1088                  }
   1089              }
   1090          
   1091          
   1092              return (cmp_val);
   \                     ??Str_CmpIgnoreCase_N_33:
   \   000001D2   0x0020             MOVS     R0,R4
   \   000001D4   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??Str_CmpIgnoreCase_N_1:
   \   000001D6   0xBDF0             POP      {R4-R7,PC}       ;; return
   1093          }
   1094          
   1095          
   1096          /*$PAGE*/
   1097          /*
   1098          *********************************************************************************************************
   1099          *                                             Str_Char()
   1100          *
   1101          * Description : Search string for first occurrence of specific character.
   1102          *
   1103          * Argument(s) : pstr            Pointer to string (see Note #1).
   1104          *
   1105          *               srch_char       Search character.
   1106          *
   1107          * Return(s)   : Pointer to first occurrence of search character in string, if any.
   1108          *
   1109          *               Pointer to NULL,                                           otherwise.
   1110          *
   1111          * Caller(s)   : Application.
   1112          *
   1113          * Note(s)     : (1) String buffer NOT modified.
   1114          *
   1115          *               (2) String search terminates when :
   1116          *
   1117          *                   (a) String pointer passed a NULL pointer.
   1118          *                       (1) No string search performed; NULL pointer returned.
   1119          *
   1120          *                   (b) String pointer points to NULL.
   1121          *                       (1) String overlaps with NULL address.
   1122          *                       (2) String searched up to but NOT beyond or including the NULL address.
   1123          *
   1124          *                   (c) String's terminating NULL character found.
   1125          *                       (1) Search character NOT found in search string; NULL pointer returned.
   1126          *                       (2) Applicable ONLY IF search character is NOT the terminating NULL character.
   1127          *
   1128          *                   (d) Search character found.
   1129          *                       (1) Return pointer to first occurrence of search character in search string.
   1130          *********************************************************************************************************
   1131          */
   1132          

   \                                 In section .text, align 2, keep-with-next
   1133          CPU_CHAR  *Str_Char (CPU_CHAR  *pstr,
   1134                               CPU_CHAR   srch_char)
   1135          {
   \                     Str_Char:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1136              pstr = Str_Char_N((CPU_CHAR *)pstr,
   1137                                (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL,
   1138                                (CPU_CHAR  )srch_char);
   \   00000006   0x002A             MOVS     R2,R5
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       Str_Char_N
   \   00000014   0x0004             MOVS     R4,R0
   1139          
   1140              return (pstr);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1141          }
   1142          
   1143          
   1144          /*$PAGE*/
   1145          /*
   1146          *********************************************************************************************************
   1147          *                                            Str_Char_N()
   1148          *
   1149          * Description : Search string for first occurrence of specific character, up to a maximum number of characters.
   1150          *
   1151          * Argument(s) : pstr            Pointer to string (see Note #1).
   1152          *
   1153          *               len_max         Maximum number of characters to search (see Notes #2e & #3).
   1154          *
   1155          *               srch_char       Search character.
   1156          *
   1157          * Return(s)   : Pointer to first occurrence of search character in string, if any.
   1158          *
   1159          *               Pointer to NULL,                                           otherwise.
   1160          *
   1161          * Caller(s)   : Application.
   1162          *
   1163          * Note(s)     : (1) String buffer NOT modified.
   1164          *
   1165          *               (2) String search terminates when :
   1166          *
   1167          *                   (a) String pointer passed a NULL pointer.
   1168          *                       (1) No string search performed; NULL pointer returned.
   1169          *
   1170          *                   (b) String pointer points to NULL.
   1171          *                       (1) String overlaps with NULL address.
   1172          *                       (2) String searched up to but NOT beyond or including the NULL address.
   1173          *
   1174          *                   (c) String's terminating NULL character found.
   1175          *                       (1) Search character NOT found in search string; NULL pointer returned.
   1176          *                       (2) Applicable ONLY IF search character is NOT the terminating NULL character.
   1177          *
   1178          *                   (d) Search character found.
   1179          *                       (1) Return pointer to first occurrence of search character in search string.
   1180          *
   1181          *                   (e) 'len_max' number of characters searched.
   1182          *                       (1) 'len_max' number of characters does NOT include terminating NULL character.
   1183          *
   1184          *               (3) Ideally, the 'len_max' parameter would be the last parameter in this function's
   1185          *                   paramter list for consistency with all other custom string library functions.
   1186          *                   However, the 'len_max' parameter is ordered to comply with the standard library
   1187          *                   function's parameter list.
   1188          *********************************************************************************************************
   1189          */
   1190          

   \                                 In section .text, align 2, keep-with-next
   1191          CPU_CHAR  *Str_Char_N (CPU_CHAR    *pstr,
   1192                                 CPU_SIZE_T   len_max,
   1193                                 CPU_CHAR     srch_char)
   1194          {
   \                     Str_Char_N:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
   1195              CPU_CHAR    *pstr_next;
   1196              CPU_SIZE_T   len_srch;
   1197          
   1198          
   1199              if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if srch str ptr NULL    (see Note #2a).     */
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD101             BNE.N    ??Str_Char_N_0
   1200                  return ((CPU_CHAR *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE01D             B.N      ??Str_Char_N_1
   1201              }
   1202          
   1203              if (len_max == (CPU_SIZE_T)0) {                             /* Rtn NULL if srch len equals zero (see Note #2e).     */
   \                     ??Str_Char_N_0:
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD101             BNE.N    ??Str_Char_N_2
   1204                  return ((CPU_CHAR *)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE019             B.N      ??Str_Char_N_1
   1205              }
   1206          
   1207          
   1208              pstr_next = pstr;
   \                     ??Str_Char_N_2:
   \   00000014   0x001C             MOVS     R4,R3
   1209              pstr_next++;
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   1210              len_srch  = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
   1211              while (( pstr_next != (CPU_CHAR *)  0 )      &&             /* Srch str until NULL ptr(s)  [see Note #2b]  ...      */
   1212                     (*pstr      != (CPU_CHAR  )'\0')      &&             /* ... or NULL char            (see Note #2c)  ...      */
   1213                     (*pstr      != (CPU_CHAR  )srch_char) &&             /* ... or srch char found      (see Note #2d); ...      */
   1214                     ( len_srch  <  (CPU_SIZE_T)len_max)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
   \                     ??Str_Char_N_3:
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD00C             BEQ.N    ??Str_Char_N_4
   \   00000020   0x7818             LDRB     R0,[R3, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD009             BEQ.N    ??Str_Char_N_4
   \   00000026   0x7818             LDRB     R0,[R3, #+0]
   \   00000028   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002A   0x4290             CMP      R0,R2
   \   0000002C   0xD005             BEQ.N    ??Str_Char_N_4
   \   0000002E   0x428D             CMP      R5,R1
   \   00000030   0xD203             BCS.N    ??Str_Char_N_4
   1215                  pstr++;
   \   00000032   0x1C5B             ADDS     R3,R3,#+1
   1216                  pstr_next++;
   \   00000034   0x1C64             ADDS     R4,R4,#+1
   1217                  len_srch++;
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   \   00000038   0xE7F0             B.N      ??Str_Char_N_3
   1218              }
   1219          
   1220          
   1221              if (*pstr != srch_char) {                                   /* If srch char NOT found, str points to NULL; ...      */
   \                     ??Str_Char_N_4:
   \   0000003A   0x7818             LDRB     R0,[R3, #+0]
   \   0000003C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003E   0x4290             CMP      R0,R2
   \   00000040   0xD001             BEQ.N    ??Str_Char_N_5
   1222                   return ((CPU_CHAR *)0);                                /* ... rtn NULL (see Notes #2b & #2c).                  */
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE000             B.N      ??Str_Char_N_1
   1223              }
   1224          
   1225              return (pstr);                                              /* Else rtn ptr to found srch char (see Note #2d).      */
   \                     ??Str_Char_N_5:
   \   00000046   0x0018             MOVS     R0,R3
   \                     ??Str_Char_N_1:
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
   1226          }
   1227          
   1228          
   1229          /*$PAGE*/
   1230          /*
   1231          *********************************************************************************************************
   1232          *                                           Str_Char_Last()
   1233          *
   1234          * Description : Search string for last occurrence of specific character.
   1235          *
   1236          * Argument(s) : pstr            Pointer to string (see Note #1).
   1237          *
   1238          *               srch_char       Search character.
   1239          *
   1240          * Return(s)   : Pointer to last occurrence of search character in string, if any.
   1241          *
   1242          *               Pointer to NULL,                                          otherwise.
   1243          *
   1244          * Caller(s)   : Application.
   1245          *
   1246          * Note(s)     : (1) String buffer NOT modified.
   1247          *
   1248          *               (2) String search terminates when :
   1249          *
   1250          *                   (a) String pointer passed a NULL pointer.
   1251          *                       (1) No string search performed; NULL pointer returned.
   1252          *
   1253          *                   (b) String pointer points to NULL.
   1254          *                       (1) String overlaps with NULL address.
   1255          *                       (2) String searched up to but NOT beyond or including the NULL address.
   1256          *                       (3) NULL address boundary handled in Str_Len().
   1257          *
   1258          *                   (c) String searched from end to beginning.
   1259          *                       (1) Search character NOT found in search string; NULL pointer returned.
   1260          *                       (2) Applicable ONLY IF search character is NOT the terminating NULL character.
   1261          *
   1262          *                   (d) Search character found.
   1263          *                       (1) Return pointer to first occurrence of search character in search string.
   1264          *********************************************************************************************************
   1265          */
   1266          

   \                                 In section .text, align 2, keep-with-next
   1267          CPU_CHAR  *Str_Char_Last (CPU_CHAR  *pstr,
   1268                                    CPU_CHAR   srch_char)
   1269          {
   \                     Str_Char_Last:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1270              CPU_CHAR    *pstr_next;
   1271              CPU_SIZE_T   str_len;
   1272          
   1273          
   1274              if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if srch str ptr NULL (see Note #2a).        */
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??Str_Char_Last_0
   1275                  return ((CPU_CHAR *)0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE014             B.N      ??Str_Char_Last_1
   1276              }
   1277          
   1278          
   1279              pstr_next  = pstr;
   \                     ??Str_Char_Last_0:
   \   0000000E   0x0026             MOVS     R6,R4
   1280              str_len    = Str_Len(pstr);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       Str_Len
   \   00000016   0x0007             MOVS     R7,R0
   1281              pstr_next += str_len;
   \   00000018   0x19BE             ADDS     R6,R7,R6
   1282              while (( pstr_next != pstr) &&                              /* Srch str from end until begining (see Note #2c) ...  */
   1283                     (*pstr_next != srch_char)) {                         /* ... until srch char found        (see Note #2d).     */
   \                     ??Str_Char_Last_2:
   \   0000001A   0x42A6             CMP      R6,R4
   \   0000001C   0xD005             BEQ.N    ??Str_Char_Last_3
   \   0000001E   0x7830             LDRB     R0,[R6, #+0]
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x42A8             CMP      R0,R5
   \   00000024   0xD001             BEQ.N    ??Str_Char_Last_3
   1284                  pstr_next--;
   \   00000026   0x1E76             SUBS     R6,R6,#+1
   \   00000028   0xE7F7             B.N      ??Str_Char_Last_2
   1285              }
   1286          
   1287          
   1288              if (*pstr_next != srch_char) {                              /* If srch char NOT found, str points to NULL; ...      */
   \                     ??Str_Char_Last_3:
   \   0000002A   0x7830             LDRB     R0,[R6, #+0]
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x42A8             CMP      R0,R5
   \   00000030   0xD001             BEQ.N    ??Str_Char_Last_4
   1289                   return ((CPU_CHAR *)0);                                /* ... rtn NULL (see Notes #2b & #2c).                  */
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE000             B.N      ??Str_Char_Last_1
   1290              }
   1291          
   1292              return (pstr_next);                                         /* Else rtn ptr to found srch char (see Note #2d).      */
   \                     ??Str_Char_Last_4:
   \   00000036   0x0030             MOVS     R0,R6
   \                     ??Str_Char_Last_1:
   \   00000038   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1293          }
   1294          
   1295          
   1296          /*$PAGE*/
   1297          /*
   1298          *********************************************************************************************************
   1299          *                                             Str_Str()
   1300          *
   1301          * Description : Search string for first occurence of a specific search string.
   1302          *
   1303          * Argument(s) : pstr            Pointer to        string (see Note #1).
   1304          *
   1305          *               psrch_str       Pointer to search string (see Note #1).
   1306          *
   1307          * Return(s)   : Pointer to first occurrence of search string in string, if any.
   1308          *
   1309          *               Pointer to NULL,                                        otherwise.
   1310          *
   1311          * Caller(s)   : Application.
   1312          *
   1313          * Note(s)     : (1) String buffers NOT modified.
   1314          *
   1315          *               (2) String search terminates when :
   1316          *
   1317          *                   (a) String pointer passed a NULL pointer.
   1318          *                       (1) No string search performed; NULL pointer returned.
   1319          *
   1320          *                   (b) Search string length greater than string length.
   1321          *                       (1) No string search performed; NULL pointer returned.
   1322          *
   1323          *                   (c) Search string length equal to zero.
   1324          *                       (1) NULL search string at end of string returned.
   1325          *
   1326          *                   (d) Entire string has been searched.
   1327          *                       (1) Maximum size of the search is defined as the subtraction of the
   1328          *                           search string length from the string length.
   1329          *                       (2) Search string not found; NULL pointer returned.
   1330          *
   1331          *                   (e) Search string found.
   1332          *                       (1) Search string found according to Str_Cmp_N() return value.
   1333          *                       (2) Return pointer to first occurrence of search string in string.
   1334          *********************************************************************************************************
   1335          */
   1336          

   \                                 In section .text, align 2, keep-with-next
   1337          CPU_CHAR  *Str_Str (CPU_CHAR  *pstr,
   1338                              CPU_CHAR  *psrch_str)
   1339          {
   \                     Str_Str:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1340              CPU_SIZE_T    str_len;
   1341              CPU_SIZE_T    srch_str_len;
   1342              CPU_SIZE_T    srch_len;
   1343              CPU_SIZE_T    srch_ix;
   1344              CPU_BOOLEAN   srch_done;
   1345              CPU_INT16S    srch_cmp;
   1346              CPU_CHAR     *pstr_srch_ix;
   1347          
   1348                                                                          /* Rtn NULL if str ptr(s) NULL (see Note #2a).          */
   1349              if (pstr == (CPU_CHAR *)0) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??Str_Str_0
   1350                  return ((CPU_CHAR *)0);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE040             B.N      ??Str_Str_1
   1351              }
   1352              if (psrch_str == (CPU_CHAR *)0) {
   \                     ??Str_Str_0:
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD101             BNE.N    ??Str_Str_2
   1353                  return ((CPU_CHAR *)0);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE03C             B.N      ??Str_Str_1
   1354              }
   1355          
   1356          
   1357              str_len      = Str_Len(pstr);
   \                     ??Str_Str_2:
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       Str_Len
   \   0000001E   0x0006             MOVS     R6,R0
   1358              srch_str_len = Str_Len(psrch_str);
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       Str_Len
   \   00000026   0x0007             MOVS     R7,R0
   1359              if (srch_str_len > str_len) {                               /* If srch str len > str len, rtn NULL  (see Note #2b). */
   \   00000028   0x42BE             CMP      R6,R7
   \   0000002A   0xD201             BCS.N    ??Str_Str_3
   1360                  return ((CPU_CHAR *)0);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE030             B.N      ??Str_Str_1
   1361              }
   1362              if (srch_str_len == 0) {                                    /* If srch str len = 0, srch str equal NULL str; ...    */
   \                     ??Str_Str_3:
   \   00000030   0x2F00             CMP      R7,#+0
   \   00000032   0xD103             BNE.N    ??Str_Str_4
   1363                  pstr_srch_ix = (CPU_CHAR *)(pstr + str_len);            /* ... rtn ptr to NULL str found in str (see Note #2c). */
   \   00000034   0x1930             ADDS     R0,R6,R4
   \   00000036   0x4683             MOV      R11,R0
   1364                  return (pstr_srch_ix);
   \   00000038   0x4658             MOV      R0,R11
   \   0000003A   0xE02A             B.N      ??Str_Str_1
   1365              }
   1366          
   1367              srch_len  = str_len - srch_str_len;                         /* Determine srch len (see Note #2d1).                  */
   \                     ??Str_Str_4:
   \   0000003C   0x1BF0             SUBS     R0,R6,R7
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   1368              srch_ix   = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x4680             MOV      R8,R0
   1369              srch_done = DEF_NO;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x4681             MOV      R9,R0
   1370              do {
   1371                  pstr_srch_ix = (CPU_CHAR *)(pstr + srch_ix);
   \                     ??Str_Str_5:
   \   00000048   0xEB18 0x0004      ADDS     R0,R8,R4
   \   0000004C   0x4683             MOV      R11,R0
   1372                  srch_cmp     =  Str_Cmp_N(pstr_srch_ix, psrch_str, srch_str_len);
   \   0000004E   0x003A             MOVS     R2,R7
   \   00000050   0x0029             MOVS     R1,R5
   \   00000052   0x4658             MOV      R0,R11
   \   00000054   0x.... 0x....      BL       Str_Cmp_N
   \   00000058   0x4682             MOV      R10,R0
   1373                  srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
   \   0000005A   0xFA0F 0xFA8A      SXTH     R10,R10          ;; SignExt  R10,R10,#+16,#+16
   \   0000005E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000062   0xD102             BNE.N    ??Str_Str_6
   \   00000064   0xF05F 0x0901      MOVS     R9,#+1
   \   00000068   0xE001             B.N      ??Str_Str_7
   \                     ??Str_Str_6:
   \   0000006A   0xF05F 0x0900      MOVS     R9,#+0
   1374                  srch_ix++;
   \                     ??Str_Str_7:
   \   0000006E   0xF118 0x0801      ADDS     R8,R8,#+1
   1375              } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
   \   00000072   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000076   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000007A   0xD102             BNE.N    ??Str_Str_8
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x4540             CMP      R0,R8
   \   00000080   0xD2E2             BCS.N    ??Str_Str_5
   1376          
   1377          
   1378              if (srch_cmp != 0) {                                        /* If srch str NOT found, rtn NULL  (see Note #2d).     */
   \                     ??Str_Str_8:
   \   00000082   0xFA0F 0xFA8A      SXTH     R10,R10          ;; SignExt  R10,R10,#+16,#+16
   \   00000086   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000008A   0xD001             BEQ.N    ??Str_Str_9
   1379                  return ((CPU_CHAR *)0);
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE000             B.N      ??Str_Str_1
   1380              }
   1381          
   1382              return (pstr_srch_ix);                                      /* Rtn ptr to srch str found in str (see Note #2e).     */
   \                     ??Str_Str_9:
   \   00000090   0x4658             MOV      R0,R11
   \                     ??Str_Str_1:
   \   00000092   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1383          }
   1384          
   1385          
   1386          /*$PAGE*/
   1387          /*
   1388          *********************************************************************************************************
   1389          *                                         Str_FmtNbr_Int32U()
   1390          *
   1391          * Description : Format 32-bit unsigned integer into a multi-digit character string.
   1392          *
   1393          * Argument(s) : nbr             Number           to format.
   1394          *
   1395          *               nbr_dig         Number of digits to format (see Note #1).
   1396          *
   1397          *                               The following may be used to specify the number of digits to format :
   1398          *
   1399          *                                   DEF_INT_32U_NBR_DIG_MIN     Minimum number of 32-bit unsigned digits
   1400          *                                   DEF_INT_32U_NBR_DIG_MAX     Maximum number of 32-bit unsigned digits
   1401          *
   1402          *               nbr_base        Base   of number to format (see Note #2).
   1403          *
   1404          *                               The following may be used to specify the number base :
   1405          *
   1406          *                                   DEF_NBR_BASE_BIN            Base  2
   1407          *                                   DEF_NBR_BASE_OCT            Base  8
   1408          *                                   DEF_NBR_BASE_DEC            Base 10
   1409          *                                   DEF_NBR_BASE_HEX            Base 16
   1410          *
   1411          *               lead_char       Prepend leading character  (see Note #3) :
   1412          *
   1413          *                                   '\0'                    Do NOT prepend leading character to string.
   1414          *                                     Printable character          Prepend leading character to string.
   1415          *                                   Unprintable character   Do NOT format string.
   1416          *
   1417          *               lower_case      Format alphabetic characters (if any) in lower case :
   1418          *
   1419          *                                   DEF_NO          Format alphabetic characters in upper case.
   1420          *                                   DEF_YES         Format alphabetic characters in lower case.
   1421          *
   1422          *               nul             Append terminating NULL-character (see Note #4) :
   1423          *
   1424          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   1425          *                                   DEF_YES                Append terminating NULL-character to string.
   1426          *
   1427          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   1428          *
   1429          * Return(s)   : Pointer to formatted string, if NO errors.
   1430          *
   1431          *               Pointer to NULL,             otherwise.
   1432          *
   1433          * Caller(s)   : Application.
   1434          *
   1435          * Note(s)     : (1) If the number of digits to format ('nbr_dig') is less than the number of significant
   1436          *                   integer digits of the number to format ('nbr'); then the most-significant digits of
   1437          *                   the formatted number will be truncated.
   1438          *
   1439          *                       Example :
   1440          *
   1441          *                           nbr     = 23456
   1442          *                           nbr_dig = 3
   1443          *
   1444          *                           pstr    = "456"
   1445          *$PAGE*
   1446          *               (2) The number's base MUST be between 2 & 36, inclusive.
   1447          *
   1448          *               (3) (a) Leading character option prepends leading characters prior to the first non-zero
   1449          *                       digit.  The number of leading characters is such that the total number of integer
   1450          *                       digits is equal to the requested number of integer digits to format ('nbr_dig').
   1451          *
   1452          *                   (b) Leading character MUST be a printable ASCII character.
   1453          *
   1454          *                   (c) (1) If the value of the number to format is     zero  ...
   1455          *                       (2) ... & the number of digits to format is non-zero, ...
   1456          *                       (3) ... but NO leading character available;           ...
   1457          *                       (4) ... then one digit of '0' value is formatted.
   1458          *
   1459          *                           This is NOT a leading character; but a single integer digit of '0' value.
   1460          *
   1461          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   1462          *                       array formatting.
   1463          *
   1464          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   1465          *                       terminate option DISABLED will cause character string run-on.
   1466          *
   1467          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   1468          *
   1469          *                   (b) To prevent character buffer overrun :
   1470          *
   1471          *                           Character array size MUST be  >=  ('nbr_dig'         +
   1472          *                                                              1 'NUL' terminator)  characters
   1473          *********************************************************************************************************
   1474          */
   1475          

   \                                 In section .text, align 2, keep-with-next
   1476          CPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
   1477                                        CPU_INT08U    nbr_dig,
   1478                                        CPU_INT08U    nbr_base,
   1479                                        CPU_CHAR      lead_char,
   1480                                        CPU_BOOLEAN   lower_case,
   1481                                        CPU_BOOLEAN   nul,
   1482                                        CPU_CHAR     *pstr)
   1483          {
   \                     Str_FmtNbr_Int32U:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x000F             MOVS     R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
   \   0000000E   0x9D0E             LDR      R5,[SP, #+56]
   \   00000010   0x9C0F             LDR      R4,[SP, #+60]
   \   00000012   0xF8DD 0xA040      LDR      R10,[SP, #+64]
   1484              CPU_CHAR  *pstr_fmt;
   1485          
   1486          
   1487              pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U )nbr,               /* Fmt unsigned int into str.                           */
   1488                                          (CPU_INT08U )nbr_dig,
   1489                                          (CPU_INT08U )nbr_base,
   1490                                          (CPU_BOOLEAN)DEF_NO,
   1491                                          (CPU_CHAR   )lead_char,
   1492                                          (CPU_BOOLEAN)lower_case,
   1493                                          (CPU_BOOLEAN)nul,
   1494                                          (CPU_CHAR  *)pstr);
   \   00000016   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x9402             STR      R4,[SP, #+8]
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x9501             STR      R5,[SP, #+4]
   \   00000022   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000026   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x4642             MOV      R2,R8
   \   0000002E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000030   0x0039             MOVS     R1,R7
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       Str_FmtNbr_Int32
   \   0000003A   0x4683             MOV      R11,R0
   1495          
   1496              return (pstr_fmt);
   \   0000003C   0x4658             MOV      R0,R11
   \   0000003E   0xB005             ADD      SP,SP,#+20
   \   00000040   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1497          }
   1498          
   1499          
   1500          /*$PAGE*/
   1501          /*
   1502          *********************************************************************************************************
   1503          *                                         Str_FmtNbr_Int32S()
   1504          *
   1505          * Description : Format 32-bit signed integer into a multi-digit character string.
   1506          *
   1507          * Argument(s) : nbr             Number           to format.
   1508          *
   1509          *               nbr_dig         Number of digits to format (see Note #1).
   1510          *
   1511          *                               The following may be used to specify the number of digits to format :
   1512          *
   1513          *                                   DEF_INT_32S_NBR_DIG_MIN     Minimum number of 32-bit signed digits
   1514          *                                   DEF_INT_32S_NBR_DIG_MAX     Maximum number of 32-bit signed digits
   1515          *
   1516          *               nbr_base        Base   of number to format (see Note #2).
   1517          *
   1518          *                               The following may be used to specify the number base :
   1519          *
   1520          *                                   DEF_NBR_BASE_BIN            Base  2
   1521          *                                   DEF_NBR_BASE_OCT            Base  8
   1522          *                                   DEF_NBR_BASE_DEC            Base 10
   1523          *                                   DEF_NBR_BASE_HEX            Base 16
   1524          *
   1525          *               lead_char       Prepend leading character  (see Note #3) :
   1526          *
   1527          *                                   '\0'                    Do NOT prepend leading character to string.
   1528          *                                     Printable character          Prepend leading character to string.
   1529          *                                   Unprintable character   Do NOT format string.
   1530          *
   1531          *               lower_case      Format alphabetic characters (if any) in lower case :
   1532          *
   1533          *                                   DEF_NO          Format alphabetic characters in upper case.
   1534          *                                   DEF_YES         Format alphabetic characters in lower case.
   1535          *
   1536          *               nul             Append terminating NULL-character (see Note #4) :
   1537          *
   1538          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   1539          *                                   DEF_YES                Append terminating NULL-character to string.
   1540          *
   1541          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   1542          *
   1543          * Return(s)   : Pointer to formatted string, if NO errors.
   1544          *
   1545          *               Pointer to NULL,             otherwise.
   1546          *
   1547          * Caller(s)   : Application.
   1548          *
   1549          * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is less than the number of significant
   1550          *                       integer digits of the number to format ('nbr'); then the most-significant digits of
   1551          *                       the formatted number will be truncated.
   1552          *
   1553          *                           Example :
   1554          *
   1555          *                               nbr     = 23456
   1556          *                               nbr_dig = 3
   1557          *
   1558          *                               pstr    = "456"
   1559          *
   1560          *                   (b) If number to format ('nbr') is negative but the most-significant digits of the
   1561          *                       formatted number are truncated (see Note #2a); the negative sign still prefixes
   1562          *                       the truncated formatted number.
   1563          *
   1564          *                           Example :
   1565          *
   1566          *                               nbr     = -23456
   1567          *                               nbr_dig =  3
   1568          *
   1569          *                               pstr    = "-456"
   1570          *$PAGE*
   1571          *               (2) The number's base MUST be between 2 & 36, inclusive.
   1572          *
   1573          *               (3) (a) Leading character option prepends leading characters prior to the first non-zero
   1574          *                       digit.  The number of leading characters is such that the total number of integer
   1575          *                       digits is equal to the requested number of integer digits to format ('nbr_dig').
   1576          *
   1577          *                   (b) Leading character MUST be a printable ASCII character.
   1578          *
   1579          *                   (c) (1) If the value of the number to format is     zero  ...
   1580          *                       (2) ... & the number of digits to format is non-zero, ...
   1581          *                       (3) ... but NO leading character available;           ...
   1582          *                       (4) ... then one digit of '0' value is formatted.
   1583          *
   1584          *                           This is NOT a leading character; but a single integer digit of '0' value.
   1585          *
   1586          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   1587          *                       array formatting.
   1588          *
   1589          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   1590          *                       terminate option DISABLED will cause character string run-on.
   1591          *
   1592          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   1593          *
   1594          *                   (b) To prevent character buffer overrun :
   1595          *
   1596          *                           Character array size MUST be  >=  ('nbr_dig'         +
   1597          *                                                              1 negative sign   +
   1598          *                                                              1 'NUL' terminator)  characters
   1599          *********************************************************************************************************
   1600          */
   1601          

   \                                 In section .text, align 2, keep-with-next
   1602          CPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
   1603                                        CPU_INT08U    nbr_dig,
   1604                                        CPU_INT08U    nbr_base,
   1605                                        CPU_CHAR      lead_char,
   1606                                        CPU_BOOLEAN   lower_case,
   1607                                        CPU_BOOLEAN   nul,
   1608                                        CPU_CHAR     *pstr)
   1609          {
   \                     Str_FmtNbr_Int32S:
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   \   0000000A   0x9C10             LDR      R4,[SP, #+64]
   \   0000000C   0x9D11             LDR      R5,[SP, #+68]
   \   0000000E   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   1610              CPU_CHAR     *pstr_fmt;
   1611              CPU_INT32S    nbr_fmt;
   1612              CPU_BOOLEAN   nbr_neg;
   1613          
   1614          
   1615              nbr_fmt = nbr;
   \   00000012   0x9805             LDR      R0,[SP, #+20]
   \   00000014   0x4682             MOV      R10,R0
   1616              if (nbr_fmt < 0) {                                          /* If nbr neg, ...                                      */
   \   00000016   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000001A   0xD504             BPL.N    ??Str_FmtNbr_Int32S_0
   1617                  nbr_fmt = -nbr_fmt;                                     /* ... negate nbr.                                      */
   \   0000001C   0xF1DA 0x0A00      RSBS     R10,R10,#+0
   1618                  nbr_neg =  DEF_YES;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x4683             MOV      R11,R0
   \   00000024   0xE001             B.N      ??Str_FmtNbr_Int32S_1
   1619              } else {
   1620                  nbr_neg =  DEF_NO;
   \                     ??Str_FmtNbr_Int32S_0:
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x4683             MOV      R11,R0
   1621              }
   1622          
   1623              pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U )nbr_fmt,           /* Fmt signed int into str.                             */
   1624                                          (CPU_INT08U )nbr_dig,
   1625                                          (CPU_INT08U )nbr_base,
   1626                                          (CPU_BOOLEAN)nbr_neg,
   1627                                          (CPU_CHAR   )lead_char,
   1628                                          (CPU_BOOLEAN)lower_case,
   1629                                          (CPU_BOOLEAN)nul,
   1630                                          (CPU_CHAR  *)pstr);
   \                     ??Str_FmtNbr_Int32S_1:
   \   0000002A   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x9502             STR      R5,[SP, #+8]
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x9401             STR      R4,[SP, #+4]
   \   00000036   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000038   0x9700             STR      R7,[SP, #+0]
   \   0000003A   0x465B             MOV      R3,R11
   \   0000003C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003E   0x0032             MOVS     R2,R6
   \   00000040   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000042   0xF89D 0x1018      LDRB     R1,[SP, #+24]
   \   00000046   0x4650             MOV      R0,R10
   \   00000048   0x.... 0x....      BL       Str_FmtNbr_Int32
   \   0000004C   0x4681             MOV      R9,R0
   1631          
   1632              return (pstr_fmt);
   \   0000004E   0x4648             MOV      R0,R9
   \   00000050   0xB007             ADD      SP,SP,#+28
   \   00000052   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1633          }
   1634          
   1635          
   1636          /*$PAGE*/
   1637          /*
   1638          *********************************************************************************************************
   1639          *                                           Str_FmtNbr_32()
   1640          *
   1641          * Description : Format number into a multi-digit character string.
   1642          *
   1643          * Argument(s) : nbr             Number                         to format (see Note #1).
   1644          *
   1645          *               nbr_dig         Number of decimal       digits to format (see Note #2).
   1646          *
   1647          *               nbr_dp          Number of decimal point digits to format.
   1648          *
   1649          *               lead_char       Prepend leading character (see Note #3) :
   1650          *
   1651          *                                   '\0'                    Do NOT prepend leading character to string.
   1652          *                                     Printable character          Prepend leading character to string.
   1653          *                                   Unprintable character   Do NOT format string (see Note #6b).
   1654          *
   1655          *               nul             Append terminating NULL-character (see Note #4) :
   1656          *
   1657          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   1658          *                                   DEF_YES                Append terminating NULL-character to string.
   1659          *
   1660          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   1661          *
   1662          * Return(s)   : Pointer to formatted string, if NO errors (see Note #6).
   1663          *
   1664          *               Pointer to NULL,             otherwise.
   1665          *
   1666          * Caller(s)   : Application.
   1667          *
   1668          * Note(s)     : (1) (a) The maximum accuracy for 32-bit floating-point numbers :
   1669          *
   1670          *
   1671          *                                 Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
   1672          *                           32-bit Floating-point Number  =  -----------------------------------------------------
   1673          *                                                                             log [External-Base]
   1674          *
   1675          *                                                             log [2 ^ 24]
   1676          *                                                         =  --------------
   1677          *                                                               log [10]
   1678          *
   1679          *                                                         <  7.225  Base-10 Digits
   1680          *
   1681          *                               where
   1682          *                                       Internal-Base                   Internal number base of floating-
   1683          *                                                                           point numbers (i.e.  2)
   1684          *                                       External-Base                   External number base of floating-
   1685          *                                                                           point numbers (i.e. 10)
   1686          *                                       Number-Internal-Base-Digits     Number of internal number base
   1687          *                                                                           significant digits (i.e. 24)
   1688          *
   1689          *                   (b) Some compilers' floating-point routines MAY further reduce the maximum accuracy.
   1690          *
   1691          *                   (c) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than the
   1692          *                       maximum accuracy; digits following the first, significantly-accurate digits will
   1693          *                       be inaccurate.
   1694          *$PAGE*
   1695          *               (2) (a) If the number of digits to format ('nbr_dig') is less than the number of significant
   1696          *                       integer digits of the number to format ('nbr'); then the most-significant digits of
   1697          *                       the formatted number will be truncated.
   1698          *
   1699          *                           Example :
   1700          *
   1701          *                               nbr     = 23456.789
   1702          *                               nbr_dig = 3
   1703          *                               nbr_dp  = 2
   1704          *
   1705          *                               pstr    = "456.78"
   1706          *
   1707          *                   (b) If number to format ('nbr') is negative but the most-significant digits of the
   1708          *                       formatted number are truncated (see Note #2a); the negative sign still prefixes
   1709          *                       the truncated formatted number.
   1710          *
   1711          *                           Example :
   1712          *
   1713          *                               nbr     = -23456.789
   1714          *                               nbr_dig =  3
   1715          *                               nbr_dp  =  2
   1716          *
   1717          *                               pstr    = "-456.78"
   1718          *
   1719          *               (3) (a) Leading character option prepends leading characters prior to the first non-zero
   1720          *                       digit.  The number of leading characters is such that the total number of integer
   1721          *                       digits is equal to the requested number of integer digits to format ('nbr_dig').
   1722          *
   1723          *                   (b) Leading character MUST be a printable ASCII character.
   1724          *
   1725          *                   (c) (1) If the integer value of the number to format is zero ...
   1726          *                       (2) ... & the number of digits to format is non-zero,    ...
   1727          *                       (3) ... but NO leading character available;              ...
   1728          *                       (4) ... then one digit of '0' value is formatted.
   1729          *
   1730          *                           This is NOT a leading character; but a single integer digit of '0' value.
   1731          *
   1732          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   1733          *                       array formatting.
   1734          *
   1735          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   1736          *                       terminate option DISABLED will cause character string run-on.
   1737          *
   1738          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   1739          *
   1740          *                   (b) To prevent character buffer overrun :
   1741          *
   1742          *                           Character array size MUST be  >=  ('nbr_dig'         +
   1743          *                                                              'nbr_dp'          +
   1744          *                                                              1 negative sign   +
   1745          *                                                              1 decimal point   +
   1746          *                                                              1 'NUL' terminator)  characters
   1747          *
   1748          *               (6) String format terminates when :
   1749          *
   1750          *                   (a) Format string pointer is passed a NULL pointer.
   1751          *                       (1) No string format performed; NULL pointer returned.
   1752          *
   1753          *                   (b) Lead character is NOT a printable character (see Note #3b).
   1754          *                       (1) No string format performed; NULL pointer returned.
   1755          *
   1756          *                   (c) Number successfully formatted into character string array.
   1757          *********************************************************************************************************
   1758          */
   1759          /*$PAGE*/
   1760          #if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
   1761          CPU_CHAR  *Str_FmtNbr_32 (CPU_FP32      nbr,
   1762                                    CPU_INT08U    nbr_dig,
   1763                                    CPU_INT08U    nbr_dp,
   1764                                    CPU_CHAR      lead_char,
   1765                                    CPU_BOOLEAN   nul,
   1766                                    CPU_CHAR     *pstr)
   1767          {
   1768              CPU_CHAR     *pstr_fmt;
   1769              CPU_FP32      nbr_fmt;
   1770              CPU_INT32U    dig_nbr;
   1771              CPU_INT32U    dig_val;
   1772              CPU_FP32      dig_exp;
   1773              CPU_FP32      dp_exp;
   1774              CPU_INT08U    i;
   1775              CPU_BOOLEAN   print_char;
   1776          
   1777          
   1778              if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
   1779                  return ((CPU_CHAR *)0);
   1780              }
   1781          
   1782              if (lead_char != (CPU_CHAR)'\0') {
   1783                  print_char =  ASCII_IsPrint(lead_char);
   1784                  if (print_char != DEF_YES) {                            /* Rtn NULL if lead char non-printable (see Note #6b).  */
   1785                      return  ((CPU_CHAR *)0);
   1786                  }
   1787              }
   1788          
   1789          
   1790              nbr_fmt  = nbr;
   1791              pstr_fmt = pstr;
   1792          
   1793              if (nbr_fmt < 0.0f) {                                       /* If nbr neg,               ...                        */
   1794                  nbr_fmt = -nbr_fmt;                                     /* ... negate nbr;           ...                        */
   1795                  if ((nbr_dig > 0) ||                                    /* ... & if at least one dig ...                        */
   1796                      (nbr_dp  > 0)) {                                    /* ...   or at least one dp; ...                        */
   1797                      *pstr_fmt++ = '-';                                  /* ... prepend a neg sign (see Note #2b).               */
   1798                  }
   1799              }
   1800          
   1801              if (nbr_dig > 0) {
   1802                  dig_exp = 1.0f;
   1803                  for (i = 1; i < nbr_dig; i++) {
   1804                      dig_exp *= 10.0f;
   1805                  }
   1806                  for (i = nbr_dig; i > 0; i--) {                         /* Fmt str for desired nbr digs.                        */
   1807                      dig_nbr = (CPU_INT32U)(nbr_fmt / dig_exp);
   1808                      if ((dig_nbr >  0) ||                               /* If dig nbr > 0              (see Note #3c1), ...     */
   1809                          (nbr_dig == 1) ||                               /* ... OR exactly 1 dig to fmt (see Note #3c2), ...     */
   1810                          (i       == 1)) {                               /* ... OR on one's  dig to fmt;                 ...     */
   1811                                                                          /* ... calc & fmt dig val.                              */
   1812                          dig_val    = (CPU_INT32U)(dig_nbr % 10 );
   1813                         *pstr_fmt++ = (CPU_CHAR  )(dig_val + '0');
   1814          
   1815                      } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
   1816                         *pstr_fmt++ = (CPU_CHAR)lead_char;               /* ... fmt lead char.                                   */
   1817                      }
   1818          
   1819                      dig_exp /= 10.0f;                                   /* Shift to next least-significant dig.                 */
   1820                  }
   1821              }
   1822          
   1823              if (nbr_dp > 0) {
   1824                 *pstr_fmt++ = '.';                                       /* Append dp prior to dp conversion.                    */
   1825                  dp_exp = 10.0f;
   1826                  for (i = 0; i < nbr_dp; i++) {                          /* Fmt str for desired nbr dp.                          */
   1827                      dig_nbr     = (CPU_INT32U)(nbr_fmt * dp_exp);
   1828                      dig_val     = (CPU_INT32U)(dig_nbr % 10 );
   1829                     *pstr_fmt++  = (CPU_CHAR  )(dig_val + '0');
   1830                      dp_exp     *=  10.0f;                               /* Shift to next least-significant dp.                  */
   1831                  }
   1832              }
   1833          
   1834              if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
   1835                 *pstr_fmt = (CPU_CHAR)'\0';
   1836              }
   1837          
   1838          
   1839              return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6c).                 */
   1840          }
   1841          #endif
   1842          
   1843          
   1844          /*$PAGE*/
   1845          /*
   1846          *********************************************************************************************************
   1847          *                                        Str_ParseNbr_Int32U()
   1848          *
   1849          * Description : Parse 32-bit unsigned integer from string.
   1850          *
   1851          * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
   1852          *
   1853          *               pstr_next   Pointer to a variable to ... :
   1854          *
   1855          *                               (a) Return a pointer to first character following the integer string,
   1856          *                                       if NO errors (see Note  #2a2B2);
   1857          *                               (b) Return a pointer to 'pstr',
   1858          *                                       otherwise    (see Note  #2a2A2).
   1859          *
   1860          *               nbr_base    Base of number to parse  (see Notes #2a1B1 & #2a2B1).
   1861          *
   1862          * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
   1863          *
   1864          *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
   1865          *
   1866          *               0,                   otherwise                            (see Note #2a3B).
   1867          *
   1868          * Caller(s)   : Application.
   1869          *
   1870          * Note(s)     : (1) String buffer NOT modified.
   1871          *
   1872          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : DESCRIPTION' states that "these
   1873          *                       functions shall convert the initial portion of the string pointed to by 'str' to a
   1874          *                       type unsigned long ... representation" :
   1875          *
   1876          *                       (1) "First, they decompose the input string into three parts" :
   1877          *
   1878          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   1879          *                                by isspace()]."
   1880          *
   1881          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   1882          *                                    input string, starting with the first non-white-space character that is of
   1883          *                                    the expected form.  The subject sequence shall contain no characters if the
   1884          *                                    input string is empty or consists entirely of white-space characters."
   1885          *
   1886          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   1887          *                                    determined by the value of 'base'" :
   1888          *
   1889          *                                   (a) "If the value of 'base' is 0, the expected form of the subject sequence
   1890          *                                        is that of a decimal constant, octal constant, or hexadecimal constant" :
   1891          *
   1892          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   1893          *                                            sequence of decimal digits."
   1894          *
   1895          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   1896          *                                            a sequence of the digits '0' to '7' only."
   1897          *
   1898          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   1899          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   1900          *                                            (or 'F') with values 10 to 15 respectively."
   1901          *
   1902          *                                   (b) "If the value of 'base' is between 2 and 36, the expected form of the
   1903          *                                        subject sequence is a sequence of letters and digits representing an
   1904          *                                        integer with the radix specified by 'base'" :
   1905          *
   1906          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   1907          *                                                ascribed the values 10 to 35"; ...
   1908          *                                           (B) "only letters whose ascribed values are less than that of base
   1909          *                                                are permitted."
   1910          *
   1911          *                                       (2) (A) "If the value of 'base' is 16, the characters '0x' or '0X' may
   1912          *                                                optionally precede the sequence of letters and digits."
   1913          *
   1914          *                                           (B) Although NO specification states that "if the value of 'base'
   1915          *                                               is" 8, the '0' character "may optionally precede the sequence
   1916          *                                               of letters and digits"; it seems reasonable to allow the '0'
   1917          *                                               character to be optionally parsed.
   1918          *
   1919          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   1920          *
   1921          *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
   1922          *                                       integer string into an unsigned integer.
   1923          *
   1924          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   1925          *                                   (b) "including the terminating null byte of the input string" ...
   1926          *                               (2) "other than a sign or a permissible letter or digit."
   1927          *$PAGE*
   1928          *                       (2) Second, "they shall attempt to convert the subject sequence to an unsigned integer" :
   1929          *
   1930          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   1931          *
   1932          *                               (1) "no conversion [is] performed"; ...
   1933          *                               (2) "the value of 'str' [is] stored in the object pointed to by 'endptr',
   1934          *                                    provided that 'endptr' is not a null pointer."
   1935          *
   1936          *                           (B) "If the subject sequence has the expected form" :
   1937          *
   1938          *                               (1) (a) "and the value of 'base' is 0, the sequence of characters starting with
   1939          *                                        the first digit shall be interpreted as an integer constant."
   1940          *
   1941          *                                   (b) "and the value of 'base' is between 2 and 36, it shall be used as the
   1942          *                                        base for conversion, ascribing to each letter its value as given above"
   1943          *                                        (see Note #2a1B1b1A).
   1944          *
   1945          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   1946          *                                   'endptr', provided that 'endptr' is not a null pointer."
   1947          *
   1948          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : RETURN VALUE' states that :
   1949          *
   1950          *                           (A) "Upon successful completion, these functions shall return the converted value."
   1951          *                               (1) "If the correct value is outside the range of representable values, {ULONG_MAX}
   1952          *                                    ... shall be returned."
   1953          *
   1954          *                           (B) "If no conversion could be performed, 0 shall be returned."
   1955          *
   1956          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   1957          *                           shall fail if" :
   1958          *
   1959          *                           (A) "[EINVAL] - The value of 'base' is not supported."
   1960          *
   1961          *                           (B) "[ERANGE] - The value to be returned is not representable."
   1962          *
   1963          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   1964          *                           may fail if" :
   1965          *
   1966          *                           (A) "[EINVAL] - No conversion could be performed."
   1967          *
   1968          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   1969          *
   1970          *                   (a) Valid parse string integer :
   1971          *
   1972          *                           pstr      = "     ABCDE xyz"
   1973          *                           nbr_base  = 16
   1974          *
   1975          *                           nbr       = 703710
   1976          *                           pstr_next = " xyz"
   1977          *
   1978          *
   1979          *                   (b) Invalid parse string integer :
   1980          *
   1981          *                           pstr      = "     ABCDE"
   1982          *                           nbr_base  = 10
   1983          *
   1984          *                           nbr       =  0
   1985          *                           pstr_next = pstr = "     ABCDE"
   1986          *
   1987          *
   1988          *                   (c) Valid hexadecimal parse string integer :
   1989          *
   1990          *                           pstr      = "     0xGABCDE"
   1991          *                           nbr_base  = 16
   1992          *
   1993          *                           nbr       =  0
   1994          *                           pstr_next = "xGABCDE"
   1995          *
   1996          *
   1997          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   1998          *                               following invalid hexadecimal characters) :
   1999          *
   2000          *                           pstr      = "     0xGABCDE"
   2001          *                           nbr_base  =  0
   2002          *
   2003          *                           nbr       =  0
   2004          *                           pstr_next = "xGABCDE"
   2005          *
   2006          *
   2007          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   2008          *                               following invalid octal       characters) :
   2009          *
   2010          *                           pstr      = "     0GABCDE"
   2011          *                           nbr_base  =  0
   2012          *
   2013          *                           nbr       =  0
   2014          *                           pstr_next = "GABCDE"
   2015          *
   2016          *$PAGE*
   2017          *                   (f) Parse string integer overflow :
   2018          *
   2019          *                           pstr      = "   12345678901234567890*123456"
   2020          *                           nbr_base  = 10
   2021          *
   2022          *                           nbr       = DEF_INT_32U_MAX_VAL
   2023          *                           pstr_next = "*123456"
   2024          *
   2025          *
   2026          *                   (g) Invalid negative unsigned parse string :
   2027          *
   2028          *                           pstr      = "  -12345678901234567890*123456"
   2029          *                           nbr_base  = 10
   2030          *
   2031          *                           nbr       = 0
   2032          *                           pstr_next = pstr = "  -12345678901234567890*123456"
   2033          *
   2034          *********************************************************************************************************
   2035          */
   2036          

   \                                 In section .text, align 2, keep-with-next
   2037          CPU_INT32U  Str_ParseNbr_Int32U (CPU_CHAR     *pstr,
   2038                                           CPU_CHAR    **pstr_next,
   2039                                           CPU_INT08U    nbr_base)
   2040          {
   \                     Str_ParseNbr_Int32U:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2041              CPU_INT32U  nbr;
   2042          
   2043          
   2044              nbr = Str_ParseNbr_Int32((CPU_CHAR    *)pstr,               /* Parse/convert str ...                                */
   2045                                       (CPU_CHAR   **)pstr_next,
   2046                                       (CPU_INT08U   )nbr_base,
   2047                                       (CPU_BOOLEAN  )DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
   2048                                       (CPU_BOOLEAN *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x0032             MOVS     R2,R6
   \   00000010   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       Str_ParseNbr_Int32
   \   0000001A   0x0007             MOVS     R7,R0
   2049          
   2050              return (nbr);
   \   0000001C   0x0038             MOVS     R0,R7
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2051          }
   2052          
   2053          
   2054          /*$PAGE*/
   2055          /*
   2056          *********************************************************************************************************
   2057          *                                        Str_ParseNbr_Int32S()
   2058          *
   2059          * Description : Parse 32-bit signed integer from string.
   2060          *
   2061          * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
   2062          *
   2063          *               pstr_next   Pointer to a variable to ... :
   2064          *
   2065          *                               (a) Return a pointer to first character following the integer string,
   2066          *                                       if NO errors (see Note  #2a2B2);
   2067          *                               (b) Return a pointer to 'pstr',
   2068          *                                       otherwise    (see Note  #2a2A2).
   2069          *
   2070          *               nbr_base    Base of number to parse  (see Notes #2a1B1 & #2a2B1).
   2071          *
   2072          * Return(s)   : Parsed integer,      if integer parsed with NO over- or underflow (see Note #2a3A).
   2073          *
   2074          *               DEF_INT_32S_MIN_VAL, if integer parsed but negatively underflowed (see Note #2a3A1a).
   2075          *
   2076          *               DEF_INT_32U_MAX_VAL, if integer parsed but positively overflowed  (see Note #2a3A1b).
   2077          *
   2078          *               0,                   otherwise                                    (see Note #2a3B).
   2079          *
   2080          * Caller(s)   : Application.
   2081          *
   2082          * Note(s)     : (1) String buffer NOT modified.
   2083          *
   2084          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
   2085          *                       functions shall convert the initial portion of the string pointed to by 'str' to a
   2086          *                       type long ... representation" :
   2087          *
   2088          *                       (1) "First, they decompose the input string into three parts" :
   2089          *
   2090          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   2091          *                                by isspace()]."
   2092          *
   2093          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   2094          *                                    input string, starting with the first non-white-space character that is of
   2095          *                                    the expected form.  The subject sequence shall contain no characters if the
   2096          *                                    input string is empty or consists entirely of white-space characters."
   2097          *
   2098          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   2099          *                                    determined by the value of 'base'" :
   2100          *
   2101          *                                   (a) "If the value of 'base' is 0, the expected form of the subject sequence
   2102          *                                        is that of a decimal constant, octal constant, or hexadecimal constant" :
   2103          *
   2104          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   2105          *                                            sequence of decimal digits."
   2106          *
   2107          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   2108          *                                            a sequence of the digits '0' to '7' only."
   2109          *
   2110          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   2111          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   2112          *                                            (or 'F') with values 10 to 15 respectively."
   2113          *
   2114          *                                   (b) "If the value of 'base' is between 2 and 36, the expected form of the
   2115          *                                        subject sequence is a sequence of letters and digits representing an
   2116          *                                        integer with the radix specified by 'base'" :
   2117          *
   2118          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   2119          *                                                ascribed the values 10 to 35"; ...
   2120          *                                           (B) "only letters whose ascribed values are less than that of base
   2121          *                                                are permitted."
   2122          *
   2123          *                                       (2) (A) "If the value of 'base' is 16, the characters '0x' or '0X' may
   2124          *                                                optionally precede the sequence of letters and digits."
   2125          *
   2126          *                                           (B) Although NO specification states that "if the value of 'base'
   2127          *                                               is" 8, the '0' character "may optionally precede the sequence
   2128          *                                               of letters and digits"; it seems reasonable to allow the '0'
   2129          *                                               character to be optionally parsed.
   2130          *
   2131          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   2132          *
   2133          *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
   2134          *                                       integer string into an unsigned integer.
   2135          *
   2136          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   2137          *                                   (b) "including the terminating null byte of the input string" ...
   2138          *                               (2) "other than a sign or a permissible letter or digit."
   2139          *$PAGE*
   2140          *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
   2141          *
   2142          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   2143          *
   2144          *                               (1) "no conversion is performed"; ...
   2145          *                               (2) "the value of 'str' is stored in the object pointed to by 'endptr',
   2146          *                                    provided that 'endptr' is not a null pointer."
   2147          *
   2148          *                           (B) "If the subject sequence has the expected form" :
   2149          *
   2150          *                               (1) (a) "and the value of 'base' is 0, the sequence of characters starting with
   2151          *                                        the first digit shall be interpreted as an integer constant."
   2152          *
   2153          *                                   (b) "and the value of 'base' is between 2 and 36, it shall be used as the
   2154          *                                        base for conversion, ascribing to each letter its value as given above"
   2155          *                                        (see Note #2a1B1b1A).
   2156          *
   2157          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   2158          *                                   'endptr', provided that 'endptr' is not a null pointer."
   2159          *
   2160          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
   2161          *
   2162          *                           (A) "Upon successful completion, these functions shall return the converted value."
   2163          *
   2164          *                               (1) "If the correct value is outside the range of representable values", either
   2165          *                                    of the following "shall be returned" :
   2166          *                                   (a) "{LONG_MIN}" or ...
   2167          *                                   (b) "{LONG_MAX}"
   2168          *
   2169          *                           (B) "If no conversion could be performed, 0 shall be returned."
   2170          *
   2171          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   2172          *                           shall fail if" :
   2173          *
   2174          *                           (A) "[EINVAL] - The value of 'base' is not supported."
   2175          *
   2176          *                           (B) "[ERANGE] - The value to be returned is not representable."
   2177          *
   2178          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   2179          *                           may fail if" :
   2180          *
   2181          *                           (A) "[EINVAL] - No conversion could be performed."
   2182          *
   2183          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   2184          *
   2185          *                   (a) Valid parse string integer :
   2186          *
   2187          *                           pstr      = "     ABCDE xyz"
   2188          *                           nbr_base  = 16
   2189          *
   2190          *                           nbr       = 703710
   2191          *                           pstr_next = " xyz"
   2192          *
   2193          *
   2194          *                   (b) Invalid parse string integer :
   2195          *
   2196          *                           pstr      = "     ABCDE"
   2197          *                           nbr_base  = 10
   2198          *
   2199          *                           nbr       =  0
   2200          *                           pstr_next = pstr = "     ABCDE"
   2201          *
   2202          *
   2203          *                   (c) Valid hexadecimal parse string integer :
   2204          *
   2205          *                           pstr      = "     0xGABCDE"
   2206          *                           nbr_base  = 16
   2207          *
   2208          *                           nbr       =  0
   2209          *                           pstr_next = "xGABCDE"
   2210          *
   2211          *
   2212          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   2213          *                               following invalid hexadecimal characters) :
   2214          *
   2215          *                           pstr      = "     0xGABCDE"
   2216          *                           nbr_base  =  0
   2217          *
   2218          *                           nbr       =  0
   2219          *                           pstr_next = "xGABCDE"
   2220          *
   2221          *
   2222          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   2223          *                               following invalid octal       characters) :
   2224          *
   2225          *                           pstr      = "     0GABCDE"
   2226          *                           nbr_base  =  0
   2227          *
   2228          *                           nbr       =  0
   2229          *                           pstr_next = "GABCDE"
   2230          *
   2231          *$PAGE*
   2232          *                   (f) Parse string integer overflow :
   2233          *
   2234          *                           pstr      = "   12345678901234567890*123456"
   2235          *                           nbr_base  = 10
   2236          *
   2237          *                           nbr       = DEF_INT_32S_MAX_VAL
   2238          *                           pstr_next = "*123456"
   2239          *
   2240          *
   2241          *                   (g) Parse string integer underflow :
   2242          *
   2243          *                           pstr     = "  -12345678901234567890*123456"
   2244          *                           nbr_base = 10
   2245          *
   2246          *                           nbr       = DEF_INT_32S_MIN_VAL
   2247          *                           pstr_next = "*123456"
   2248          *
   2249          *********************************************************************************************************
   2250          */
   2251          

   \                                 In section .text, align 2, keep-with-next
   2252          CPU_INT32S  Str_ParseNbr_Int32S (CPU_CHAR     *pstr,
   2253                                           CPU_CHAR    **pstr_next,
   2254                                           CPU_INT08U    nbr_base)
   2255          {
   \                     Str_ParseNbr_Int32S:
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   2256              CPU_INT32S   nbr;
   2257              CPU_INT32U   nbr_abs;
   2258              CPU_BOOLEAN  nbr_neg;
   2259          
   2260          
   2261              nbr_abs = Str_ParseNbr_Int32((CPU_CHAR    *) pstr,          /* Parse/convert str ...                                */
   2262                                           (CPU_CHAR   **) pstr_next,
   2263                                           (CPU_INT08U   ) nbr_base,
   2264                                           (CPU_BOOLEAN  ) DEF_YES,       /* ... as signed int (see Note #2a2).                   */
   2265                                           (CPU_BOOLEAN *)&nbr_neg);
   \   0000000A   0xA801             ADD      R0,SP,#+4
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x0032             MOVS     R2,R6
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       Str_ParseNbr_Int32
   \   0000001C   0x4680             MOV      R8,R0
   2266          
   2267              if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
   \   0000001E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD107             BNE.N    ??Str_ParseNbr_Int32S_0
   2268                  nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
   2269                                                                              :  (CPU_INT32S)nbr_abs;
   \   00000026   0xF118 0x4F00      CMN      R8,#-2147483648
   \   0000002A   0xD302             BCC.N    ??Str_ParseNbr_Int32S_1
   \   0000002C   0xF07F 0x4700      MVNS     R7,#-2147483648
   \   00000030   0xE009             B.N      ??Str_ParseNbr_Int32S_2
   \                     ??Str_ParseNbr_Int32S_1:
   \   00000032   0x4647             MOV      R7,R8
   \   00000034   0xE007             B.N      ??Str_ParseNbr_Int32S_2
   2270              } else {
   2271                  nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
   2272                                                                              : -(CPU_INT32S)nbr_abs;
   \                     ??Str_ParseNbr_Int32S_0:
   \   00000036   0xF118 0x4F00      CMN      R8,#-2147483648
   \   0000003A   0xD302             BCC.N    ??Str_ParseNbr_Int32S_3
   \   0000003C   0xF05F 0x4700      MOVS     R7,#-2147483648
   \   00000040   0xE001             B.N      ??Str_ParseNbr_Int32S_2
   \                     ??Str_ParseNbr_Int32S_3:
   \   00000042   0xF1D8 0x0700      RSBS     R7,R8,#+0
   2273              }
   2274          
   2275              return (nbr);
   \                     ??Str_ParseNbr_Int32S_2:
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2276          }
   2277          
   2278          
   2279          /*$PAGE*/
   2280          /*
   2281          *********************************************************************************************************
   2282          *********************************************************************************************************
   2283          *                                           LOCAL FUNCTIONS
   2284          *********************************************************************************************************
   2285          *********************************************************************************************************
   2286          */
   2287          
   2288          /*
   2289          *********************************************************************************************************
   2290          *                                         Str_FmtNbr_Int32()
   2291          *
   2292          * Description : Format 32-bit integer into a multi-digit character string.
   2293          *
   2294          * Argument(s) : nbr             Number           to format.
   2295          *
   2296          *               nbr_dig         Number of digits to format (see Note #1).
   2297          *
   2298          *               nbr_base        Base   of number to format (see Note #2).
   2299          *
   2300          *               nbr_neg         Indicates whether number to format is negative :
   2301          *
   2302          *                                   DEF_NO          Number is non-negative.
   2303          *                                   DEF_YES         Number is     negative.
   2304          *
   2305          *               lead_char       Prepend leading character  (see Note #3) :
   2306          *
   2307          *                                   '\0'                    Do NOT prepend leading character to string.
   2308          *                                     Printable character          Prepend leading character to string.
   2309          *                                   Unprintable character   Do NOT format string (see Note #6b).
   2310          *
   2311          *               lower_case      Format alphabetic characters (if any) in lower case :
   2312          *
   2313          *                                   DEF_NO          Format alphabetic characters in upper case.
   2314          *                                   DEF_YES         Format alphabetic characters in lower case.
   2315          *
   2316          *               nul             Append terminating NULL-character (see Note #4) :
   2317          *
   2318          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   2319          *                                   DEF_YES                Append terminating NULL-character to string.
   2320          *
   2321          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   2322          *
   2323          * Return(s)   : Pointer to formatted string, if NO errors (see Note #6).
   2324          *
   2325          *               Pointer to NULL,             otherwise.
   2326          *
   2327          * Caller(s)   : Str_FmtNbr_Int32U(),
   2328          *               Str_FmtNbr_Int32S().
   2329          *
   2330          * Note(s)     : (1) (a) The maximum number of digits to format for 32-bit integer numbers :
   2331          *
   2332          *
   2333          *                               Maximum Number of             [  log (Number)      ]
   2334          *                             32-bit Integer Digits  =  floor [ -------------- + 1 ]
   2335          *                                   to Format                 [   log (Base)       ]
   2336          *
   2337          *                               where
   2338          *                                       Number                  Number to format
   2339          *                                       Base            Base of number to format
   2340          *
   2341          *                   (b) (1) If the number of digits to format ('nbr_dig') is less than the number of
   2342          *                           significant integer digits of the number to format ('nbr'); then the most-
   2343          *                           significant digits of the formatted number will be truncated.
   2344          *
   2345          *                               Example :
   2346          *
   2347          *                                   nbr     = 23456
   2348          *                                   nbr_dig = 3
   2349          *
   2350          *                                   pstr    = "456"
   2351          *
   2352          *                       (2) If number to format ('nbr') is negative but the most-significant digits of
   2353          *                           the formatted number are truncated (see Note #2a); the negative sign still
   2354          *                           prefixes the truncated formatted number.
   2355          *
   2356          *                               Example :
   2357          *
   2358          *                                   nbr     = -23456
   2359          *                                   nbr_dig =  3
   2360          *
   2361          *                                   pstr    = "-456"
   2362          *$PAGE*
   2363          *               (2) The number's base MUST be between 2 & 36, inclusive.
   2364          *
   2365          *               (3) (a) Leading character option prepends leading characters prior to the first non-zero
   2366          *                       digit.  The number of leading characters is such that the total number of integer
   2367          *                       digits is equal to the requested number of integer digits to format ('nbr_dig').
   2368          *
   2369          *                   (b) Leading character MUST be a printable ASCII character.
   2370          *
   2371          *                   (c) (1) If the value of the number to format is     zero  ...
   2372          *                       (2) ... & the number of digits to format is non-zero, ...
   2373          *                       (3) ... but NO leading character available;           ...
   2374          *                       (4) ... then one digit of '0' value is formatted.
   2375          *
   2376          *                           This is NOT a leading character; but a single integer digit of '0' value.
   2377          *
   2378          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   2379          *                       array formatting.
   2380          *
   2381          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   2382          *                       terminate option DISABLED will cause character string run-on.
   2383          *
   2384          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   2385          *
   2386          *                   (b) To prevent character buffer overrun :
   2387          *
   2388          *                           Character array size MUST be  >=  ('nbr_dig'         +
   2389          *                                                              1 negative sign   +
   2390          *                                                              1 'NUL' terminator)  characters
   2391          *               (6) String format terminates when :
   2392          *
   2393          *                   (a) Format string pointer is passed a NULL pointer.
   2394          *                       (1) No string format performed; NULL pointer returned.
   2395          *
   2396          *                   (b) Base is passed an invalid base (see Note #2).
   2397          *                       (1) No string format performed; NULL pointer returned.
   2398          *
   2399          *                   (c) Lead character is NOT a printable character (see Note #3b).
   2400          *                       (1) No string format performed; NULL pointer returned.
   2401          *
   2402          *                   (d) Number successfully formatted into character string array.
   2403          *********************************************************************************************************
   2404          */
   2405          

   \                                 In section .text, align 2, keep-with-next
   2406          static  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
   2407                                               CPU_INT08U    nbr_dig,
   2408                                               CPU_INT08U    nbr_base,
   2409                                               CPU_BOOLEAN   nbr_neg,
   2410                                               CPU_CHAR      lead_char,
   2411                                               CPU_BOOLEAN   lower_case,
   2412                                               CPU_BOOLEAN   nul,
   2413                                               CPU_CHAR     *pstr)
   2414          {
   \                     Str_FmtNbr_Int32:
   \   00000000   0xE92D 0x4FF9      PUSH     {R0,R3-R11,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   2415              CPU_CHAR     *pstr_fmt;
   2416              CPU_INT32U    nbr_fmt;
   2417              CPU_INT32U    nbr_exp;
   2418              CPU_INT32U    nbr_dig_val;
   2419              CPU_INT08U    log_floor;
   2420              CPU_INT08U    i;
   2421              CPU_BOOLEAN   ovf;
   2422              CPU_BOOLEAN   print_char;
   2423          
   2424          
   2425          /*$PAGE*/
   2426              if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
   \   0000000A   0x980F             LDR      R0,[SP, #+60]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??Str_FmtNbr_Int32_0
   2427                  return ((CPU_CHAR *)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE092             B.N      ??Str_FmtNbr_Int32_1
   2428              }
   2429                                                                          /* Rtn NULL if invalid base (see Note #6b).             */
   2430              if ((nbr_base <  2) ||
   2431                  (nbr_base > 36)) {
   \                     ??Str_FmtNbr_Int32_0:
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D02             CMP      R5,#+2
   \   00000018   0xDB02             BLT.N    ??Str_FmtNbr_Int32_2
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D25             CMP      R5,#+37
   \   0000001E   0xDB01             BLT.N    ??Str_FmtNbr_Int32_3
   2432                  return ((CPU_CHAR *)0);
   \                     ??Str_FmtNbr_Int32_2:
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE08A             B.N      ??Str_FmtNbr_Int32_1
   2433              }
   2434          
   2435              if (lead_char == (CPU_CHAR)'\0') {                          /* If lead char NOT avail,                   ...        */
   \                     ??Str_FmtNbr_Int32_3:
   \   00000024   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD124             BNE.N    ??Str_FmtNbr_Int32_4
   2436                  log_floor = 1;                                          /* ... calc floor of nbr digs (see Note #1a) ...        */
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x4681             MOV      R9,R0
   2437                  nbr_exp   = nbr_base;
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x46AB             MOV      R11,R5
   2438                  ovf       = DEF_NO;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2439                  while ((nbr_exp <= nbr) &&
   2440                         (ovf     == DEF_NO)) {
   \                     ??Str_FmtNbr_Int32_5:
   \   0000003A   0x9801             LDR      R0,[SP, #+4]
   \   0000003C   0x4558             CMP      R0,R11
   \   0000003E   0xD313             BCC.N    ??Str_FmtNbr_Int32_6
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD10F             BNE.N    ??Str_FmtNbr_Int32_6
   2441                      if (nbr_exp <= Str_MultOvfThTbl_Int32U[nbr_base]) {
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x....             LDR.N    R0,??DataTable1
   \   0000004C   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000050   0x4558             CMP      R0,R11
   \   00000052   0xD303             BCC.N    ??Str_FmtNbr_Int32_7
   2442                          nbr_exp *= nbr_base;
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0xFB05 0xFB0B      MUL      R11,R5,R11
   \   0000005A   0xE002             B.N      ??Str_FmtNbr_Int32_8
   2443                      } else {
   2444                          ovf      = DEF_YES;
   \                     ??Str_FmtNbr_Int32_7:
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2445                      }
   2446                      log_floor++;
   \                     ??Str_FmtNbr_Int32_8:
   \   00000062   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000066   0xE7E8             B.N      ??Str_FmtNbr_Int32_5
   2447                  }
   2448                  if (nbr_dig > log_floor) {
   \                     ??Str_FmtNbr_Int32_6:
   \   00000068   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x45A1             CMP      R9,R4
   \   00000070   0xD20D             BCS.N    ??Str_FmtNbr_Int32_9
   2449                      nbr_dig = log_floor;                                /* ... & lim max nbr digs.                              */
   \   00000072   0x464C             MOV      R4,R9
   \   00000074   0xE00B             B.N      ??Str_FmtNbr_Int32_9
   2450                  }
   2451          
   2452              } else {
   2453                  print_char = ASCII_IsPrint(lead_char);
   \                     ??Str_FmtNbr_Int32_4:
   \   00000076   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \   0000007A   0x.... 0x....      BL       ASCII_IsPrint
   \   0000007E   0xF88D 0x0001      STRB     R0,[SP, #+1]
   2454                  if (print_char != DEF_YES) {                            /* Rtn NULL if lead char non-printable (see Note #6c).  */
   \   00000082   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD001             BEQ.N    ??Str_FmtNbr_Int32_9
   2455                      return ((CPU_CHAR *)0);
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE055             B.N      ??Str_FmtNbr_Int32_1
   2456                  }
   2457              }
   2458          
   2459          
   2460              nbr_fmt  = nbr;
   \                     ??Str_FmtNbr_Int32_9:
   \   0000008E   0x9801             LDR      R0,[SP, #+4]
   \   00000090   0x0007             MOVS     R7,R0
   2461              pstr_fmt = pstr;
   \   00000092   0x980F             LDR      R0,[SP, #+60]
   \   00000094   0x0006             MOVS     R6,R0
   2462          
   2463              if (nbr_neg == DEF_YES) {                                   /* If nbr neg                 ...                       */
   \   00000096   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000009A   0x2801             CMP      R0,#+1
   \   0000009C   0xD105             BNE.N    ??Str_FmtNbr_Int32_10
   2464                  if (nbr_dig > 0) {                                      /* ... & if at least one dig, ...                       */
   \   0000009E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A0   0x2C00             CMP      R4,#+0
   \   000000A2   0xD002             BEQ.N    ??Str_FmtNbr_Int32_10
   2465                     *pstr_fmt++ = '-';                                   /* ... prepend a neg sign.                              */
   \   000000A4   0x202D             MOVS     R0,#+45
   \   000000A6   0x7030             STRB     R0,[R6, #+0]
   \   000000A8   0x1C76             ADDS     R6,R6,#+1
   2466                  }
   2467              }
   2468          
   2469              pstr_fmt += nbr_dig;                                        /* Start fmt from least significant dig.                */
   \                     ??Str_FmtNbr_Int32_10:
   \   000000AA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AC   0x19A6             ADDS     R6,R4,R6
   2470          
   2471              if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
   \   000000AE   0xF89D 0x0038      LDRB     R0,[SP, #+56]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD001             BEQ.N    ??Str_FmtNbr_Int32_11
   2472                 *pstr_fmt = (CPU_CHAR)'\0';
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x7030             STRB     R0,[R6, #+0]
   2473              }
   2474              pstr_fmt--;
   \                     ??Str_FmtNbr_Int32_11:
   \   000000BA   0x1E76             SUBS     R6,R6,#+1
   2475          
   2476              if (nbr_dig > 0) {
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x2C00             CMP      R4,#+0
   \   000000C0   0xD03A             BEQ.N    ??Str_FmtNbr_Int32_12
   2477                  for (i = 1; i <= nbr_dig; i++) {                        /* Fmt str for desired nbr digs.                        */
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0x4682             MOV      R10,R0
   \                     ??Str_FmtNbr_Int32_13:
   \   000000C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000CC   0x4554             CMP      R4,R10
   \   000000CE   0xD333             BCC.N    ??Str_FmtNbr_Int32_12
   2478                      if ((nbr_fmt >  0) ||                               /* If fmt nbr > 0              (see Note #3c1), ...     */
   2479                          (nbr_dig == 1) ||                               /* ... OR exactly 1 dig to fmt (see Note #3c2), ...     */
   2480                          (i       == 1)) {                               /* ... OR on one's  dig to fmt;                 ...     */
   \   000000D0   0x2F00             CMP      R7,#+0
   \   000000D2   0xD107             BNE.N    ??Str_FmtNbr_Int32_14
   \   000000D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D6   0x2C01             CMP      R4,#+1
   \   000000D8   0xD004             BEQ.N    ??Str_FmtNbr_Int32_14
   \   000000DA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000DE   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000E2   0xD11B             BNE.N    ??Str_FmtNbr_Int32_15
   2481                                                                          /* ... calc & fmt dig val;                      ...     */
   2482                          nbr_dig_val = nbr_fmt % nbr_base;
   \                     ??Str_FmtNbr_Int32_14:
   \   000000E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E6   0xFBB7 0xF0F5      UDIV     R0,R7,R5
   \   000000EA   0xFB05 0x7010      MLS      R0,R5,R0,R7
   \   000000EE   0x4680             MOV      R8,R0
   2483                          if (nbr_dig_val <= 9) {
   \   000000F0   0xF1B8 0x0F0A      CMP      R8,#+10
   \   000000F4   0xD204             BCS.N    ??Str_FmtNbr_Int32_16
   2484                             *pstr_fmt-- = (CPU_CHAR)(nbr_dig_val + '0');
   \   000000F6   0xF118 0x0030      ADDS     R0,R8,#+48
   \   000000FA   0x7030             STRB     R0,[R6, #+0]
   \   000000FC   0x1E76             SUBS     R6,R6,#+1
   \   000000FE   0xE015             B.N      ??Str_FmtNbr_Int32_17
   2485                          } else {
   2486                              if (lower_case !=  DEF_YES) {
   \                     ??Str_FmtNbr_Int32_16:
   \   00000100   0xF89D 0x0034      LDRB     R0,[SP, #+52]
   \   00000104   0x2801             CMP      R0,#+1
   \   00000106   0xD004             BEQ.N    ??Str_FmtNbr_Int32_18
   2487                                 *pstr_fmt--  = (CPU_CHAR)((nbr_dig_val - 10) + 'A');
   \   00000108   0xF118 0x0037      ADDS     R0,R8,#+55
   \   0000010C   0x7030             STRB     R0,[R6, #+0]
   \   0000010E   0x1E76             SUBS     R6,R6,#+1
   \   00000110   0xE00C             B.N      ??Str_FmtNbr_Int32_17
   2488                              } else {
   2489                                 *pstr_fmt--  = (CPU_CHAR)((nbr_dig_val - 10) + 'a');
   \                     ??Str_FmtNbr_Int32_18:
   \   00000112   0xF118 0x0057      ADDS     R0,R8,#+87
   \   00000116   0x7030             STRB     R0,[R6, #+0]
   \   00000118   0x1E76             SUBS     R6,R6,#+1
   \   0000011A   0xE007             B.N      ??Str_FmtNbr_Int32_17
   2490                              }
   2491                          }
   2492          
   2493                      } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
   \                     ??Str_FmtNbr_Int32_15:
   \   0000011C   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD003             BEQ.N    ??Str_FmtNbr_Int32_17
   2494                         *pstr_fmt-- = (CPU_CHAR)lead_char;               /* ... fmt lead char.                                   */
   \   00000124   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \   00000128   0x7030             STRB     R0,[R6, #+0]
   \   0000012A   0x1E76             SUBS     R6,R6,#+1
   2495                      }
   2496          
   2497                      nbr_fmt /= nbr_base;                                /* Shift nbr to next more significant dig.              */
   \                     ??Str_FmtNbr_Int32_17:
   \   0000012C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000012E   0xFBB7 0xF7F5      UDIV     R7,R7,R5
   2498                  }
   \   00000132   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   00000136   0xE7C6             B.N      ??Str_FmtNbr_Int32_13
   2499              }
   2500          
   2501          
   2502              return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6d).                 */
   \                     ??Str_FmtNbr_Int32_12:
   \   00000138   0x980F             LDR      R0,[SP, #+60]
   \                     ??Str_FmtNbr_Int32_1:
   \   0000013A   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2503          }
   2504          
   2505          
   2506          /*$PAGE*/
   2507          /*
   2508          *********************************************************************************************************
   2509          *                                        Str_ParseNbr_Int32()
   2510          *
   2511          * Description : Parse 32-bit integer from string.
   2512          *
   2513          * Argument(s) : pstr            Pointer to string (see Notes #1 & #2a).
   2514          *
   2515          *               pstr_next       Pointer to a variable to ... :
   2516          *
   2517          *                                   (a) Return a pointer to first character following the integer string,
   2518          *                                           if NO errors (see Note  #2a2B2);
   2519          *                                   (b) Return a pointer to 'pstr',
   2520          *                                           otherwise    (see Note  #2a2A2).
   2521          *
   2522          *               nbr_base        Base of number to parse  (see Notes #2a1B1 & #2a2B1).
   2523          *
   2524          *               nbr_signed      Indicates whether number to parse is signed :
   2525          *
   2526          *                                   DEF_NO                  Number is unsigned.
   2527          *                                   DEF_YES                 Number is   signed.
   2528          *
   2529          *               pnbr_neg        Pointer to a variable to return if the parsed (signed) number is negative :
   2530          *
   2531          *                                   DEF_NO                  Number is non-negative.
   2532          *                                   DEF_YES                 Number is     negative.
   2533          *
   2534          * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
   2535          *
   2536          *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
   2537          *
   2538          *               0,                   otherwise                            (see Note #2a3B).
   2539          *
   2540          * Caller(s)   : Str_ParseNbr_Int32U(),
   2541          *               Str_ParseNbr_Int32S().
   2542          *
   2543          * Note(s)     : (1) String buffer NOT modified.
   2544          *
   2545          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
   2546          *                       functions shall convert the initial portion of the string pointed to by 'str' to a
   2547          *                       type long ... representation" :
   2548          *
   2549          *                       (1) "First, they decompose the input string into three parts" :
   2550          *
   2551          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   2552          *                                by isspace()]."
   2553          *
   2554          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   2555          *                                    input string, starting with the first non-white-space character that is of
   2556          *                                    the expected form.  The subject sequence shall contain no characters if the
   2557          *                                    input string is empty or consists entirely of white-space characters."
   2558          *
   2559          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   2560          *                                    determined by the value of 'base'" :
   2561          *
   2562          *                                   (a) "If the value of 'base' is 0, the expected form of the subject sequence
   2563          *                                        is that of a decimal constant, octal constant, or hexadecimal constant" :
   2564          *
   2565          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   2566          *                                            sequence of decimal digits."
   2567          *
   2568          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   2569          *                                            a sequence of the digits '0' to '7' only."
   2570          *
   2571          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   2572          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   2573          *                                            (or 'F') with values 10 to 15 respectively."
   2574          *
   2575          *                                   (b) "If the value of 'base' is between 2 and 36, the expected form of the
   2576          *                                        subject sequence is a sequence of letters and digits representing an
   2577          *                                        integer with the radix specified by 'base'" :
   2578          *
   2579          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   2580          *                                                ascribed the values 10 to 35"; ...
   2581          *                                           (B) "only letters whose ascribed values are less than that of base
   2582          *                                                are permitted."
   2583          *
   2584          *                                       (2) (A) "If the value of 'base' is 16, the characters '0x' or '0X' may
   2585          *                                                optionally precede the sequence of letters and digits."
   2586          *
   2587          *                                           (B) Although NO specification states that "if the value of 'base'
   2588          *                                               is" 8, the '0' character "may optionally precede the sequence
   2589          *                                               of letters and digits"; it seems reasonable to allow the '0'
   2590          *                                               character to be optionally parsed.
   2591          *$PAGE*
   2592          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   2593          *
   2594          *                                   (a) It does NOT seem reasonable to parse & convert a negative number
   2595          *                                       integer string into an unsigned integer.  However, a negative sign
   2596          *                                       for an unsigned integer will automatically be parsed as an invalid
   2597          *                                       character (see Note #2aC1).
   2598          *
   2599          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   2600          *                                   (b) "including the terminating null byte of the input string" ...
   2601          *                               (2) "other than a sign or a permissible letter or digit."
   2602          *
   2603          *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
   2604          *
   2605          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   2606          *
   2607          *                               (1) "no conversion is performed"; ...
   2608          *                               (2) "the value of 'str' is stored in the object pointed to by 'endptr',
   2609          *                                    provided that 'endptr' is not a null pointer."
   2610          *
   2611          *                           (B) "If the subject sequence has the expected form" :
   2612          *
   2613          *                               (1) (a) "and the value of 'base' is 0, the sequence of characters starting with
   2614          *                                        the first digit shall be interpreted as an integer constant."
   2615          *
   2616          *                                   (b) "and the value of 'base' is between 2 and 36, it shall be used as the
   2617          *                                        base for conversion, ascribing to each letter its value as given above"
   2618          *                                        (see Note #2a1B1b1A).
   2619          *
   2620          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   2621          *                                   'endptr', provided that 'endptr' is not a null pointer."
   2622          *
   2623          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
   2624          *
   2625          *                           (A) "Upon successful completion, these functions shall return the converted value."
   2626          *                               (1) "If the correct value is outside the range of representable values, {LONG_MIN}
   2627          *                                    [or] {LONG_MAX} ... shall be returned."
   2628          *
   2629          *                           (B) "If no conversion could be performed, 0 shall be returned."
   2630          *
   2631          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   2632          *                           shall fail if" :
   2633          *
   2634          *                           (A) "[EINVAL] - The value of 'base' is not supported."
   2635          *
   2636          *                           (B) "[ERANGE] - The value to be returned is not representable."
   2637          *
   2638          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   2639          *                           may fail if" :
   2640          *
   2641          *                           (A) "[EINVAL] - No conversion could be performed."
   2642          *$PAGE*
   2643          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   2644          *
   2645          *                   (a) Valid parse string integer :
   2646          *
   2647          *                           pstr      = "     ABCDE xyz"
   2648          *                           nbr_base  = 16
   2649          *
   2650          *                           nbr       = 703710
   2651          *                           pstr_next = " xyz"
   2652          *
   2653          *
   2654          *                   (b) Invalid parse string integer :
   2655          *
   2656          *                           pstr      = "     ABCDE"
   2657          *                           nbr_base  = 10
   2658          *
   2659          *                           nbr       =  0
   2660          *                           pstr_next = pstr = "     ABCDE"
   2661          *
   2662          *
   2663          *                   (c) Valid hexadecimal parse string integer :
   2664          *
   2665          *                           pstr      = "     0xGABCDE"
   2666          *                           nbr_base  = 16
   2667          *
   2668          *                           nbr       =  0
   2669          *                           pstr_next = "xGABCDE"
   2670          *
   2671          *
   2672          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   2673          *                               following invalid hexadecimal characters) :
   2674          *
   2675          *                           pstr      = "     0xGABCDE"
   2676          *                           nbr_base  =  0
   2677          *
   2678          *                           nbr       =  0
   2679          *                           pstr_next = "xGABCDE"
   2680          *
   2681          *
   2682          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   2683          *                               following invalid octal       characters) :
   2684          *
   2685          *                           pstr      = "     0GABCDE"
   2686          *                           nbr_base  =  0
   2687          *
   2688          *                           nbr       =  0
   2689          *                           pstr_next = "GABCDE"
   2690          *
   2691          *
   2692          *                   (f) Parse string integer overflow :
   2693          *
   2694          *                           pstr      = "   12345678901234567890*123456"
   2695          *                           nbr_base  = 10
   2696          *
   2697          *                           nbr       = DEF_INT_32U_MAX_VAL
   2698          *                           pstr_next = "*123456"
   2699          *
   2700          *
   2701          *                   (g) Parse string integer underflow :
   2702          *
   2703          *                           pstr      = "  -12345678901234567890*123456"
   2704          *                           nbr_base  = 10
   2705          *
   2706          *                           nbr       = DEF_INT_32S_MIN_VAL
   2707          *                           pstr_next = "*123456"
   2708          *
   2709          *
   2710          *               (4) String parse terminates when :
   2711          *
   2712          *                   (a) Base passed an invalid base (see Note #2a1B1b).
   2713          *                       (1) No conversion performed; zero returned.
   2714          *
   2715          *                   (b) (1) Parse string passed a NULL pointer OR empty integer sequence (see Note #2a2A).
   2716          *                           (A) No conversion performed; zero returned.
   2717          *
   2718          *                       (2) Invalid parse string character found (see Note #2a1C).
   2719          *                           (A) Parsed integer returned.
   2720          *                           (B) 'pstr_next' points to invalid character.
   2721          *
   2722          *                       (3) Entire  parse string converted (see Note #2a2B).
   2723          *                           (A) Parsed integer returned.
   2724          *                           (B) 'pstr_next' points to terminating NULL character.
   2725          *
   2726          *               (5) Pointers to variables that return values MUST be initialized PRIOR to all other
   2727          *                   validation or function handling in case of any error(s).
   2728          *********************************************************************************************************
   2729          */
   2730          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
   2731          static  CPU_INT32U  Str_ParseNbr_Int32 (CPU_CHAR      *pstr,
   2732                                                  CPU_CHAR     **pstr_next,
   2733                                                  CPU_INT08U     nbr_base,
   2734                                                  CPU_BOOLEAN    nbr_signed,
   2735                                                  CPU_BOOLEAN   *pnbr_neg)
   2736          {
   \                     Str_ParseNbr_Int32:
   \   00000000   0xE92D 0x4FF9      PUSH     {R0,R3-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   2737              CPU_CHAR     *pstr_parse;
   2738              CPU_CHAR     *pstr_parse_nbr;
   2739              CPU_CHAR      parse_char;
   2740              CPU_INT08U    parse_dig;
   2741              CPU_INT32U    nbr;
   2742              CPU_BOOLEAN   nbr_dig;
   2743              CPU_BOOLEAN   nbr_alpha;
   2744              CPU_BOOLEAN   nbr_hex;
   2745              CPU_BOOLEAN   nbr_hex_lower;
   2746              CPU_BOOLEAN   whitespace;
   2747              CPU_BOOLEAN   neg;
   2748              CPU_BOOLEAN   ovf;
   2749              CPU_BOOLEAN   done;
   2750          
   2751                                                                          /* Init rtn vals for err (see Note #5).                  */
   2752              if (pstr_next != (CPU_CHAR **)0) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD001             BEQ.N    ??Str_ParseNbr_Int32_0
   2753                 *pstr_next  = (CPU_CHAR  *)pstr;
   \   0000000E   0x9803             LDR      R0,[SP, #+12]
   \   00000010   0x6020             STR      R0,[R4, #+0]
   2754              }
   2755          
   2756              if (pnbr_neg != (CPU_BOOLEAN *)0) {
   \                     ??Str_ParseNbr_Int32_0:
   \   00000012   0x980E             LDR      R0,[SP, #+56]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??Str_ParseNbr_Int32_1
   2757                 *pnbr_neg  = (CPU_BOOLEAN  )DEF_NO;
   \   00000018   0x980E             LDR      R0,[SP, #+56]
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x7001             STRB     R1,[R0, #+0]
   2758              }
   2759          
   2760          
   2761              if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
   \                     ??Str_ParseNbr_Int32_1:
   \   0000001E   0x9803             LDR      R0,[SP, #+12]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD101             BNE.N    ??Str_ParseNbr_Int32_2
   2762                  return ((CPU_INT32U)0);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE100             B.N      ??Str_ParseNbr_Int32_3
   2763              }
   2764                                                                          /* Rtn zero if invalid base (see Note #4a).             */
   2765              if ((nbr_base == 1) ||
   2766                  (nbr_base > 36)) {
   \                     ??Str_ParseNbr_Int32_2:
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD002             BEQ.N    ??Str_ParseNbr_Int32_4
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D25             CMP      R5,#+37
   \   00000032   0xDB01             BLT.N    ??Str_ParseNbr_Int32_5
   2767                  return ((CPU_INT32U)0);
   \                     ??Str_ParseNbr_Int32_4:
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE0F8             B.N      ??Str_ParseNbr_Int32_3
   2768              }
   2769          
   2770          
   2771                                                                          /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
   2772              pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
   \                     ??Str_ParseNbr_Int32_5:
   \   00000038   0x9803             LDR      R0,[SP, #+12]
   \   0000003A   0x4683             MOV      R11,R0
   2773          
   2774              whitespace = ASCII_IsSpace(*pstr_parse);
   \   0000003C   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000040   0x.... 0x....      BL       ASCII_IsSpace
   \   00000044   0xF88D 0x0002      STRB     R0,[SP, #+2]
   2775              while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
   \                     ??Str_ParseNbr_Int32_6:
   \   00000048   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD108             BNE.N    ??Str_ParseNbr_Int32_7
   2776                  pstr_parse++;
   \   00000050   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2777                  whitespace = ASCII_IsSpace(*pstr_parse);
   \   00000054   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000058   0x.... 0x....      BL       ASCII_IsSpace
   \   0000005C   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000060   0xE7F2             B.N      ??Str_ParseNbr_Int32_6
   2778              }
   2779          
   2780              switch (*pstr_parse) {
   \                     ??Str_ParseNbr_Int32_7:
   \   00000062   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000066   0x282B             CMP      R0,#+43
   \   00000068   0xD002             BEQ.N    ??Str_ParseNbr_Int32_8
   \   0000006A   0x282D             CMP      R0,#+45
   \   0000006C   0xD006             BEQ.N    ??Str_ParseNbr_Int32_9
   \   0000006E   0xE00F             B.N      ??Str_ParseNbr_Int32_10
   2781                  case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
   2782                       pstr_parse++;
   \                     ??Str_ParseNbr_Int32_8:
   \   00000070   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2783                       neg = DEF_NO;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2784                       break;
   \   0000007A   0xE00C             B.N      ??Str_ParseNbr_Int32_11
   2785          
   2786          
   2787                  case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
   2788                       if (nbr_signed == DEF_YES) {
   \                     ??Str_ParseNbr_Int32_9:
   \   0000007C   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   00000080   0x2801             CMP      R0,#+1
   \   00000082   0xD101             BNE.N    ??Str_ParseNbr_Int32_12
   2789                           pstr_parse++;
   \   00000084   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2790                       }
   2791                       neg = DEF_YES;
   \                     ??Str_ParseNbr_Int32_12:
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2792                       break;
   \   0000008E   0xE002             B.N      ??Str_ParseNbr_Int32_11
   2793          
   2794          
   2795                  default:
   2796                       neg = DEF_NO;
   \                     ??Str_ParseNbr_Int32_10:
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2797                       break;
   2798              }
   2799          
   2800          
   2801          /*$PAGE*/
   2802                                                                          /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
   2803              pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
   \                     ??Str_ParseNbr_Int32_11:
   \   00000096   0xF8CD 0xB008      STR      R11,[SP, #+8]
   2804          
   2805              switch (nbr_base) {
   \   0000009A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009C   0x0028             MOVS     R0,R5
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD004             BEQ.N    ??Str_ParseNbr_Int32_13
   \   000000A2   0x2808             CMP      R0,#+8
   \   000000A4   0xD026             BEQ.N    ??Str_ParseNbr_Int32_14
   \   000000A6   0x2810             CMP      R0,#+16
   \   000000A8   0xD02B             BEQ.N    ??Str_ParseNbr_Int32_15
   \   000000AA   0xE047             B.N      ??Str_ParseNbr_Int32_16
   2806                  case  0:                                                /* Determine unspecified nbr base (see Notes #2a1B1a).  */
   2807                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_13:
   \   000000AC   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   000000B0   0x2830             CMP      R0,#+48
   \   000000B2   0xD11C             BNE.N    ??Str_ParseNbr_Int32_17
   2808                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
   \   000000B4   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2809                            switch (*pstr_parse) {
   \   000000B8   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   000000BC   0x2858             CMP      R0,#+88
   \   000000BE   0xD001             BEQ.N    ??Str_ParseNbr_Int32_18
   \   000000C0   0x2878             CMP      R0,#+120
   \   000000C2   0xD111             BNE.N    ??Str_ParseNbr_Int32_19
   2810                                case 'x':                                 /* For '0x' prefix, ...                                 */
   2811                                case 'X':
   2812                                     nbr_base   = 16;                     /* ... set nbr base = 16    (see Note #2a1B1a3).        */
   \                     ??Str_ParseNbr_Int32_18:
   \   000000C4   0x2010             MOVS     R0,#+16
   \   000000C6   0x0005             MOVS     R5,R0
   2813                                     parse_char = (CPU_CHAR)(*(pstr_parse + 1));
   \   000000C8   0xF89B 0x0001      LDRB     R0,[R11, #+1]
   \   000000CC   0x0006             MOVS     R6,R0
   2814                                     nbr_hex    =  ASCII_IsDigHex(parse_char);
   \   000000CE   0x0030             MOVS     R0,R6
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0x.... 0x....      BL       ASCII_IsDigHex
   \   000000D6   0xF88D 0x0001      STRB     R0,[SP, #+1]
   2815                                     if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
   \   000000DA   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000DE   0x2801             CMP      R0,#+1
   \   000000E0   0xD101             BNE.N    ??Str_ParseNbr_Int32_20
   2816                                         pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
   \   000000E2   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2817                                     }
   2818                                     break;
   \                     ??Str_ParseNbr_Int32_20:
   \   000000E6   0xE004             B.N      ??Str_ParseNbr_Int32_21
   2819          
   2820          
   2821                                default:                                  /* For '0'  prefix, ...                                 */
   2822                                     nbr_base =  8;                       /* ... set nbr base =  8    (see Note #2a1B1a2).        */
   \                     ??Str_ParseNbr_Int32_19:
   \   000000E8   0x2008             MOVS     R0,#+8
   \   000000EA   0x0005             MOVS     R5,R0
   2823                                     break;
   \   000000EC   0xE001             B.N      ??Str_ParseNbr_Int32_21
   2824                            }
   2825          
   2826                       } else {                                           /* For non-'0' prefix, ...                              */
   2827                           nbr_base = 10;                                 /* ... set nbr base = 10    (see Note #2a1B1a1).        */
   \                     ??Str_ParseNbr_Int32_17:
   \   000000EE   0x200A             MOVS     R0,#+10
   \   000000F0   0x0005             MOVS     R5,R0
   2828                       }
   2829                       break;
   \                     ??Str_ParseNbr_Int32_21:
   \   000000F2   0xE023             B.N      ??Str_ParseNbr_Int32_22
   2830          
   2831          
   2832                  case  8:                                                /* See Note #2a1B1a2.                                   */
   2833                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_14:
   \   000000F4   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   000000F8   0x2830             CMP      R0,#+48
   \   000000FA   0xD101             BNE.N    ??Str_ParseNbr_Int32_23
   2834                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
   \   000000FC   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2835                       }
   2836                       break;
   \                     ??Str_ParseNbr_Int32_23:
   \   00000100   0xE01C             B.N      ??Str_ParseNbr_Int32_22
   2837          
   2838          
   2839                  case 16:                                                /* See Note #2a1B1a3.                                   */
   2840                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_15:
   \   00000102   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000106   0x2830             CMP      R0,#+48
   \   00000108   0xD117             BNE.N    ??Str_ParseNbr_Int32_24
   2841                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
   \   0000010A   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2842                            switch (*pstr_parse) {
   \   0000010E   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000112   0x2858             CMP      R0,#+88
   \   00000114   0xD001             BEQ.N    ??Str_ParseNbr_Int32_25
   \   00000116   0x2878             CMP      R0,#+120
   \   00000118   0xD10F             BNE.N    ??Str_ParseNbr_Int32_26
   2843                                case 'x':
   2844                                case 'X':
   2845                                     parse_char = (CPU_CHAR)(*(pstr_parse + 1));
   \                     ??Str_ParseNbr_Int32_25:
   \   0000011A   0xF89B 0x0001      LDRB     R0,[R11, #+1]
   \   0000011E   0x0006             MOVS     R6,R0
   2846                                     nbr_hex    =  ASCII_IsDigHex(parse_char);
   \   00000120   0x0030             MOVS     R0,R6
   \   00000122   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000124   0x.... 0x....      BL       ASCII_IsDigHex
   \   00000128   0xF88D 0x0001      STRB     R0,[SP, #+1]
   2847                                     if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
   \   0000012C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000130   0x2801             CMP      R0,#+1
   \   00000132   0xD101             BNE.N    ??Str_ParseNbr_Int32_27
   2848                                         pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
   \   00000134   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2849                                     }
   2850                                     break;
   \                     ??Str_ParseNbr_Int32_27:
   \   00000138   0xE7FF             B.N      ??Str_ParseNbr_Int32_24
   2851          
   2852          
   2853                                default:
   2854                                     break;
   2855                            }
   2856                       }
   2857                       break;
   \                     ??Str_ParseNbr_Int32_26:
   \                     ??Str_ParseNbr_Int32_24:
   \   0000013A   0xE7FF             B.N      ??Str_ParseNbr_Int32_22
   2858          
   2859          
   2860                  default:                                                /* See Note #2a1B1b.                                    */
   2861                       break;
   2862              }
   2863          
   2864          
   2865          /*$PAGE*/
   2866                                                                          /* ------------------ PARSE INT STR ------------------- */
   2867              nbr  = 0;
   \                     ??Str_ParseNbr_Int32_16:
   \                     ??Str_ParseNbr_Int32_22:
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x4680             MOV      R8,R0
   2868              ovf  = DEF_NO;
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0x4681             MOV      R9,R0
   2869              done = DEF_NO;
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x4682             MOV      R10,R0
   2870          
   2871              while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
   \                     ??Str_ParseNbr_Int32_28:
   \   00000148   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000014C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000150   0xD151             BNE.N    ??Str_ParseNbr_Int32_29
   2872                  parse_char = (CPU_CHAR)*pstr_parse;
   \   00000152   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000156   0x0006             MOVS     R6,R0
   2873                  nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
   \   00000158   0x0030             MOVS     R0,R6
   \   0000015A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015C   0x.... 0x....      BL       ASCII_IsAlphaNum
   \   00000160   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2874                  if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
   \   00000164   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000168   0x2801             CMP      R0,#+1
   \   0000016A   0xD141             BNE.N    ??Str_ParseNbr_Int32_30
   2875                                                                          /* ... convert parse char into nbr dig.                 */
   2876                      nbr_dig = ASCII_IsDig(parse_char);
   \   0000016C   0x0030             MOVS     R0,R6
   \   0000016E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000170   0x.... 0x....      BL       ASCII_IsDig
   \   00000174   0xF88D 0x0005      STRB     R0,[SP, #+5]
   2877                      if (nbr_dig == DEF_YES) {
   \   00000178   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000017C   0x2801             CMP      R0,#+1
   \   0000017E   0xD103             BNE.N    ??Str_ParseNbr_Int32_31
   2878                          parse_dig = (CPU_INT08U)(parse_char - '0');
   \   00000180   0xF1B6 0x0030      SUBS     R0,R6,#+48
   \   00000184   0x0007             MOVS     R7,R0
   \   00000186   0xE010             B.N      ??Str_ParseNbr_Int32_32
   2879                      } else {
   2880                          nbr_hex_lower = ASCII_IsLower(parse_char);
   \                     ??Str_ParseNbr_Int32_31:
   \   00000188   0x0030             MOVS     R0,R6
   \   0000018A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000018C   0x.... 0x....      BL       ASCII_IsLower
   \   00000190   0xF88D 0x0003      STRB     R0,[SP, #+3]
   2881                          if (nbr_hex_lower == DEF_YES) {
   \   00000194   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000198   0x2801             CMP      R0,#+1
   \   0000019A   0xD103             BNE.N    ??Str_ParseNbr_Int32_33
   2882                              parse_dig = (CPU_INT08U)((parse_char - 'a') + 10);
   \   0000019C   0xF1B6 0x0057      SUBS     R0,R6,#+87
   \   000001A0   0x0007             MOVS     R7,R0
   \   000001A2   0xE002             B.N      ??Str_ParseNbr_Int32_32
   2883                          } else {
   2884                              parse_dig = (CPU_INT08U)((parse_char - 'A') + 10);
   \                     ??Str_ParseNbr_Int32_33:
   \   000001A4   0xF1B6 0x0037      SUBS     R0,R6,#+55
   \   000001A8   0x0007             MOVS     R7,R0
   2885                          }
   2886                      }
   2887          
   2888                      if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
   \                     ??Str_ParseNbr_Int32_32:
   \   000001AA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001AE   0x42AF             CMP      R7,R5
   \   000001B0   0xD21B             BCS.N    ??Str_ParseNbr_Int32_34
   2889                          if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
   \   000001B2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001B6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001BA   0xD113             BNE.N    ??Str_ParseNbr_Int32_35
   2890                              if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
   \   000001BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001BE   0x....             LDR.N    R0,??DataTable1
   \   000001C0   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   000001C4   0x4540             CMP      R0,R8
   \   000001C6   0xD30B             BCC.N    ??Str_ParseNbr_Int32_36
   2891                                                                          /* ... merge parse char dig into nbr.                   */
   2892                                  nbr *= nbr_base;
   \   000001C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001CA   0xFB05 0xF808      MUL      R8,R5,R8
   2893                                  nbr += parse_dig;
   \   000001CE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001D0   0xEB17 0x0808      ADDS     R8,R7,R8
   2894                                  if (nbr < parse_dig) {
   \   000001D4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001D6   0x45B8             CMP      R8,R7
   \   000001D8   0xD204             BCS.N    ??Str_ParseNbr_Int32_35
   2895                                      ovf = DEF_YES;
   \   000001DA   0x2001             MOVS     R0,#+1
   \   000001DC   0x4681             MOV      R9,R0
   \   000001DE   0xE001             B.N      ??Str_ParseNbr_Int32_35
   2896                                  }
   2897                              } else {
   2898                                  ovf = DEF_YES;
   \                     ??Str_ParseNbr_Int32_36:
   \   000001E0   0x2001             MOVS     R0,#+1
   \   000001E2   0x4681             MOV      R9,R0
   2899                              }
   2900                          }
   2901                          pstr_parse++;
   \                     ??Str_ParseNbr_Int32_35:
   \   000001E4   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000001E8   0xE7AE             B.N      ??Str_ParseNbr_Int32_28
   2902          
   2903                      } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
   2904                          done = DEF_YES;
   \                     ??Str_ParseNbr_Int32_34:
   \   000001EA   0x2001             MOVS     R0,#+1
   \   000001EC   0x4682             MOV      R10,R0
   \   000001EE   0xE7AB             B.N      ??Str_ParseNbr_Int32_28
   2905                      }
   2906          
   2907                  } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
   2908                      done = DEF_YES;
   \                     ??Str_ParseNbr_Int32_30:
   \   000001F0   0x2001             MOVS     R0,#+1
   \   000001F2   0x4682             MOV      R10,R0
   \   000001F4   0xE7A8             B.N      ??Str_ParseNbr_Int32_28
   2909                  }
   2910              }
   2911          
   2912              if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
   \                     ??Str_ParseNbr_Int32_29:
   \   000001F6   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001FA   0xF1B9 0x0F01      CMP      R9,#+1
   \   000001FE   0xD102             BNE.N    ??Str_ParseNbr_Int32_37
   2913                  nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
   \   00000200   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000204   0x4680             MOV      R8,R0
   2914              }
   2915          
   2916          
   2917              if (pstr_next != (CPU_CHAR **)0) {
   \                     ??Str_ParseNbr_Int32_37:
   \   00000206   0x2C00             CMP      R4,#+0
   \   00000208   0xD007             BEQ.N    ??Str_ParseNbr_Int32_38
   2918                  if (pstr_parse != pstr_parse_nbr) {                     /* If final parse str != init'l parse nbr str,       .. */
   \   0000020A   0x9802             LDR      R0,[SP, #+8]
   \   0000020C   0x4583             CMP      R11,R0
   \   0000020E   0xD002             BEQ.N    ??Str_ParseNbr_Int32_39
   2919                     *pstr_next   = pstr_parse;                           /* .. rtn   parse str's next char (see Note #2a2B2); .. */
   \   00000210   0xF8C4 0xB000      STR      R11,[R4, #+0]
   \   00000214   0xE001             B.N      ??Str_ParseNbr_Int32_38
   2920                  } else {
   2921                     *pstr_next   = pstr;                                 /* .. else rtn initial parse str  (see Note #2a2A2).    */
   \                     ??Str_ParseNbr_Int32_39:
   \   00000216   0x9803             LDR      R0,[SP, #+12]
   \   00000218   0x6020             STR      R0,[R4, #+0]
   2922                  }
   2923              }
   2924          
   2925              if (pnbr_neg != (CPU_BOOLEAN *)0) {
   \                     ??Str_ParseNbr_Int32_38:
   \   0000021A   0x980E             LDR      R0,[SP, #+56]
   \   0000021C   0x2800             CMP      R0,#+0
   \   0000021E   0xD003             BEQ.N    ??Str_ParseNbr_Int32_40
   2926                 *pnbr_neg  = (CPU_BOOLEAN  )neg;                         /* Rtn neg nbr status.                                  */
   \   00000220   0x980E             LDR      R0,[SP, #+56]
   \   00000222   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000226   0x7001             STRB     R1,[R0, #+0]
   2927              }
   2928          
   2929          
   2930              return (nbr);
   \                     ??Str_ParseNbr_Int32_40:
   \   00000228   0x4640             MOV      R0,R8
   \                     ??Str_ParseNbr_Int32_3:
   \   0000022A   0xB005             ADD      SP,SP,#+20
   \   0000022C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2931          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     Str_MultOvfThTbl_Int32U
   2932          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Str_Cat
        16   -> Str_Cat_N
      12   Str_Cat_N
      16   Str_Char
        16   -> Str_Char_N
      24   Str_Char_Last
        24   -> Str_Len
       8   Str_Char_N
      16   Str_Cmp
        16   -> Str_Cmp_N
      16   Str_CmpIgnoreCase
        16   -> Str_CmpIgnoreCase_N
      20   Str_CmpIgnoreCase_N
      16   Str_Cmp_N
      16   Str_Copy
        16   -> Str_Copy_N
      12   Str_Copy_N
      48   Str_FmtNbr_Int32
        48   -> ASCII_IsPrint
      64   Str_FmtNbr_Int32S
        64   -> Str_FmtNbr_Int32
      56   Str_FmtNbr_Int32U
        56   -> Str_FmtNbr_Int32
      16   Str_Len
        16   -> Str_Len_N
       0   Str_Len_N
      56   Str_ParseNbr_Int32
        56   -> ASCII_IsAlphaNum
        56   -> ASCII_IsDig
        56   -> ASCII_IsDigHex
        56   -> ASCII_IsLower
        56   -> ASCII_IsSpace
      32   Str_ParseNbr_Int32S
        32   -> Str_ParseNbr_Int32
      24   Str_ParseNbr_Int32U
        24   -> Str_ParseNbr_Int32
      40   Str_Str
        40   -> Str_Cmp_N
        40   -> Str_Len


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      24  Str_Cat
     102  Str_Cat_N
      26  Str_Char
      58  Str_Char_Last
      76  Str_Char_N
      26  Str_Cmp
      26  Str_CmpIgnoreCase
     472  Str_CmpIgnoreCase_N
     180  Str_Cmp_N
      24  Str_Copy
      80  Str_Copy_N
     318  Str_FmtNbr_Int32
      86  Str_FmtNbr_Int32S
      68  Str_FmtNbr_Int32U
      20  Str_Len
      28  Str_Len_N
     148  Str_MultOvfThTbl_Int32U
     560  Str_ParseNbr_Int32
      76  Str_ParseNbr_Int32S
      32  Str_ParseNbr_Int32U
     150  Str_Str

 
   148 bytes in section .rodata
 2 436 bytes in section .text
 
 2 436 bytes of CODE  memory
   148 bytes of CONST memory

Errors: none
Warnings: none
