###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:13 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_eeprom.c                          #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_eeprom.c -lCN                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\ -o D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë #
#                    \RTU_1.2\project\iar\Debug\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\lpc177x_8x_eeprom.lst                      #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\lpc177x_8x_eeprom.o                         #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Drivers\source\lpc177x_8x_eeprom.c
      1          /**********************************************************************
      2          * $Id$		lpc177x_8x_eeprom.c			2011-06-02
      3          *//**
      4          * @file		lpc177x_8x_eeprom.c
      5          * @brief	Contains all functions support for EEPROM firmware library on
      6          *			LPC177x_8x
      7          * @version	1.0
      8          * @date		02. June. 2011
      9          * @author	NXP MCU SW Application Team
     10          * 
     11          * Copyright(C) 2011, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          **********************************************************************/
     26          
     27          /* Peripheral group ----------------------------------------------------------- */
     28          /** @addtogroup EEPROM
     29           * @{
     30           */
     31          
     32          /* Includes ------------------------------------------------------------------- */
     33          #include "lpc177x_8x_eeprom.h"
     34          #include "lpc177x_8x_clkpwr.h"
     35          
     36          /* Public Functions ----------------------------------------------------------- */
     37          
     38          /*********************************************************************//**
     39           * @brief 		Initial EEPROM
     40           * @param[in]	None
     41           * @return 		None
     42           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     43          void EEPROM_Init(void)
     44          {
   \                     EEPROM_Init:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     45          	uint32_t val, cclk;
     46          	LPC_EEPROM->PWRDWN = 0x0;
   \   00000002   0x....             LDR.N    R0,??DataTable4  ;; 0x200098
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #+0]
     47          	/* EEPROM is automate turn on after reset */
     48          	/* Setting clock:
     49          	 * EEPROM required a 375kHz. This clock is generated by dividing the
     50          	 * system bus clock.
     51          	 */
     52             	cclk = CLKPWR_GetCLK(CLKPWR_CLKTYPE_CPU);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       CLKPWR_GetCLK
   \   0000000E   0x0005             MOVS     R5,R0
     53          	val = (cclk/375000)-1;
   \   00000010   0x....             LDR.N    R0,??DataTable4_1  ;; 0x5b8d8
   \   00000012   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x0004             MOVS     R4,R0
     54          	LPC_EEPROM->CLKDIV = val;
   \   0000001A   0x....             LDR.N    R0,??DataTable4_2  ;; 0x200094
   \   0000001C   0x6004             STR      R4,[R0, #+0]
     55          
     56          	/* Setting wait state */
     57          	val  = ((((cclk / 1000000) * 15) / 1000) + 1);
   \   0000001E   0x....             LDR.N    R0,??DataTable4_3  ;; 0xf4240
   \   00000020   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000024   0x210F             MOVS     R1,#+15
   \   00000026   0x4348             MULS     R0,R1,R0
   \   00000028   0xF44F 0x717A      MOV      R1,#+1000
   \   0000002C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x0004             MOVS     R4,R0
     58          	val |= (((((cclk / 1000000) * 55) / 1000) + 1) << 8);
   \   00000034   0x....             LDR.N    R0,??DataTable4_3  ;; 0xf4240
   \   00000036   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   0000003A   0x2137             MOVS     R1,#+55
   \   0000003C   0x4348             MULS     R0,R1,R0
   \   0000003E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000042   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xEA54 0x2400      ORRS     R4,R4,R0, LSL #+8
     59          	val |= (((((cclk / 1000000) * 35) / 1000) + 1) << 16);
   \   0000004C   0x....             LDR.N    R0,??DataTable4_3  ;; 0xf4240
   \   0000004E   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000052   0x2123             MOVS     R1,#+35
   \   00000054   0x4348             MULS     R0,R1,R0
   \   00000056   0xF44F 0x717A      MOV      R1,#+1000
   \   0000005A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
     60          	LPC_EEPROM->WSTATE = val;
   \   00000064   0x....             LDR.N    R0,??DataTable4_4  ;; 0x200090
   \   00000066   0x6004             STR      R4,[R0, #+0]
     61          }
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     62          
     63          /*********************************************************************//**
     64           * @brief 		Write data to EEPROM at specific address
     65           * @param[in]	address EEPROM address that start to write data, it must be
     66           * 				in range 0..0x1000
     67           * 				mode	Write mode, should be:
     68           * 					- MODE_8_BIT	: write 8 bit mode
     69           * 					- MODE_16_BIT	: write 16 bit mode
     70           * 					- MODE_32_BIT	: write 32 bit mode
     71           * 				data	buffer that contain data that will be written to buffer
     72           * 				count	number written data
     73           * @return 		None
     74           * @note		This function actually write data into EEPROM memory and automatically
     75           * 				write into next page if current page is overflowed
     76           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     77          void EEPROM_Write(uint16_t page_offset, uint16_t page_address, void* data, EEPROM_Mode_Type mode, uint32_t count)
     78          {
   \                     EEPROM_Write:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9D04             LDR      R5,[SP, #+16]
     79          	uint32_t i;
     80          #ifdef __IAR_SYSTEMS_ICC__
     81          #if (mode == MODE_8_BIT)
     82                  uint8_t *tmp = (uint8_t *)data;
   \   00000004   0x0017             MOVS     R7,R2
     83          #elif (mode == MODE_16_BIT)
     84                  uint16_t *tmp = (uint16_t *)data;
     85          #else
     86                  uint32_t *tmp = (uint32_t *)data;
     87          #endif
     88          #endif
     89          
     90          	LPC_EEPROM->INT_CLR_STATUS = ((1 << EEPROM_ENDOF_RW)|(1 << EEPROM_ENDOF_PROG));
   \   00000006   0x....             LDR.N    R4,??DataTable4_5  ;; 0x200fe8
   \   00000008   0xF05F 0x5CA0      MOVS     R12,#+335544320
   \   0000000C   0xF8C4 0xC000      STR      R12,[R4, #+0]
     91          	//check page_offset
     92          	if(mode == MODE_16_BIT){
   \   00000010   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000012   0x2B01             CMP      R3,#+1
   \   00000014   0xD102             BNE.N    ??EEPROM_Write_0
     93          		if((page_offset & 0x01)!=0) while(1);
   \   00000016   0x07C4             LSLS     R4,R0,#+31
   \   00000018   0xD509             BPL.N    ??EEPROM_Write_1
   \                     ??EEPROM_Write_2:
   \   0000001A   0xE7FE             B.N      ??EEPROM_Write_2
     94          	}
     95          	else if(mode == MODE_32_BIT){
   \                     ??EEPROM_Write_0:
   \   0000001C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001E   0x2B02             CMP      R3,#+2
   \   00000020   0xD105             BNE.N    ??EEPROM_Write_1
     96          	 	if((page_offset & 0x03)!=0) while(1);
   \   00000022   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000026   0xEA10 0x0F0C      TST      R0,R12
   \   0000002A   0xD000             BEQ.N    ??EEPROM_Write_1
   \                     ??EEPROM_Write_3:
   \   0000002C   0xE7FE             B.N      ??EEPROM_Write_3
     97          	}
     98          	LPC_EEPROM->ADDR = EEPROM_PAGE_OFFSET(page_offset);
   \                     ??EEPROM_Write_1:
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0xF010 0x043F      ANDS     R4,R0,#0x3F
   \   00000034   0x.... 0x....      LDR.W    R12,??DataTable4_6  ;; 0x200084
   \   00000038   0xF8CC 0x4000      STR      R4,[R12, #+0]
     99          	LPC_EEPROM->INT_CLR_STATUS = (1 << EEPROM_ENDOF_RW);
   \   0000003C   0x....             LDR.N    R4,??DataTable4_5  ;; 0x200fe8
   \   0000003E   0xF05F 0x6C80      MOVS     R12,#+67108864
   \   00000042   0xF8C4 0xC000      STR      R12,[R4, #+0]
    100          	for(i=0;i<count;i++)
   \   00000046   0x2400             MOVS     R4,#+0
   \   00000048   0x0026             MOVS     R6,R4
   \                     ??EEPROM_Write_4:
   \   0000004A   0x42AE             CMP      R6,R5
   \   0000004C   0xD26B             BCS.N    ??EEPROM_Write_5
    101          	{
    102          		//update data to page register
    103          		if(mode == MODE_8_BIT){
   \   0000004E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000050   0x2B00             CMP      R3,#+0
   \   00000052   0xD10C             BNE.N    ??EEPROM_Write_6
    104          			LPC_EEPROM->CMD = EEPROM_CMD_8_BIT_WRITE;
   \   00000054   0x....             LDR.N    R4,??DataTable4_7  ;; 0x200080
   \   00000056   0xF05F 0x0C03      MOVS     R12,#+3
   \   0000005A   0xF8C4 0xC000      STR      R12,[R4, #+0]
    105          #ifdef __IAR_SYSTEMS_ICC__
    106                                  LPC_EEPROM -> WDATA = *tmp;
   \   0000005E   0x783C             LDRB     R4,[R7, #+0]
   \   00000060   0x.... 0x....      LDR.W    R12,??DataTable4_8  ;; 0x200088
   \   00000064   0xF8CC 0x4000      STR      R4,[R12, #+0]
    107                                  tmp++;
   \   00000068   0x1C7F             ADDS     R7,R7,#+1
    108          #else
    109          			LPC_EEPROM -> WDATA = *(((uint8_t *)data)++);
    110          #endif
    111          			page_offset +=1;
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \   0000006C   0xE01B             B.N      ??EEPROM_Write_7
    112          		}
    113          		else if(mode == MODE_16_BIT){
   \                     ??EEPROM_Write_6:
   \   0000006E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000070   0x2B01             CMP      R3,#+1
   \   00000072   0xD10C             BNE.N    ??EEPROM_Write_8
    114          			LPC_EEPROM->CMD = EEPROM_CMD_16_BIT_WRITE;
   \   00000074   0x....             LDR.N    R4,??DataTable4_7  ;; 0x200080
   \   00000076   0xF05F 0x0C04      MOVS     R12,#+4
   \   0000007A   0xF8C4 0xC000      STR      R12,[R4, #+0]
    115          #ifdef __IAR_SYSTEMS_ICC__
    116                                  LPC_EEPROM -> WDATA = *tmp;
   \   0000007E   0x783C             LDRB     R4,[R7, #+0]
   \   00000080   0x.... 0x....      LDR.W    R12,??DataTable4_8  ;; 0x200088
   \   00000084   0xF8CC 0x4000      STR      R4,[R12, #+0]
    117                                  tmp++;
   \   00000088   0x1C7F             ADDS     R7,R7,#+1
    118          #else
    119          			LPC_EEPROM -> WDATA = *(((uint16_t *)data)++);
    120          #endif
    121          			page_offset +=2;
   \   0000008A   0x1C80             ADDS     R0,R0,#+2
   \   0000008C   0xE00B             B.N      ??EEPROM_Write_7
    122          		}
    123          		else{
    124          			LPC_EEPROM->CMD = EEPROM_CMD_32_BIT_WRITE;
   \                     ??EEPROM_Write_8:
   \   0000008E   0x....             LDR.N    R4,??DataTable4_7  ;; 0x200080
   \   00000090   0xF05F 0x0C05      MOVS     R12,#+5
   \   00000094   0xF8C4 0xC000      STR      R12,[R4, #+0]
    125          #ifdef __IAR_SYSTEMS_ICC__
    126                                  LPC_EEPROM -> WDATA = *tmp;
   \   00000098   0x783C             LDRB     R4,[R7, #+0]
   \   0000009A   0x.... 0x....      LDR.W    R12,??DataTable4_8  ;; 0x200088
   \   0000009E   0xF8CC 0x4000      STR      R4,[R12, #+0]
    127                                  tmp++;
   \   000000A2   0x1C7F             ADDS     R7,R7,#+1
    128          #else
    129          			LPC_EEPROM -> WDATA = *(((uint32_t *)data)++);
    130          #endif
    131          			page_offset +=4;
   \   000000A4   0x1D00             ADDS     R0,R0,#+4
    132          		}
    133          		if((page_offset >= EEPROM_PAGE_NUM)|(i==count-1)){
   \                     ??EEPROM_Write_7:
   \   000000A6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A8   0x2840             CMP      R0,#+64
   \   000000AA   0xDB01             BLT.N    ??EEPROM_Write_9
   \   000000AC   0x2401             MOVS     R4,#+1
   \   000000AE   0xE000             B.N      ??EEPROM_Write_10
   \                     ??EEPROM_Write_9:
   \   000000B0   0x2400             MOVS     R4,#+0
   \                     ??EEPROM_Write_10:
   \   000000B2   0xF1B5 0x0C01      SUBS     R12,R5,#+1
   \   000000B6   0x4566             CMP      R6,R12
   \   000000B8   0xD102             BNE.N    ??EEPROM_Write_11
   \   000000BA   0xF05F 0x0C01      MOVS     R12,#+1
   \   000000BE   0xE001             B.N      ??EEPROM_Write_12
   \                     ??EEPROM_Write_11:
   \   000000C0   0xF05F 0x0C00      MOVS     R12,#+0
   \                     ??EEPROM_Write_12:
   \   000000C4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C6   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   000000CA   0xEA5C 0x0404      ORRS     R4,R12,R4
   \   000000CE   0x2C00             CMP      R4,#+0
   \   000000D0   0xD017             BEQ.N    ??EEPROM_Write_13
    134          			//update to EEPROM memory
    135          			LPC_EEPROM->INT_CLR_STATUS = (0x1 << EEPROM_ENDOF_PROG);
   \   000000D2   0x....             LDR.N    R4,??DataTable4_5  ;; 0x200fe8
   \   000000D4   0xF05F 0x5C80      MOVS     R12,#+268435456
   \   000000D8   0xF8C4 0xC000      STR      R12,[R4, #+0]
    136          			LPC_EEPROM->ADDR = EEPROM_PAGE_ADRESS(page_address);
   \   000000DC   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000DE   0xF011 0x043F      ANDS     R4,R1,#0x3F
   \   000000E2   0x01A4             LSLS     R4,R4,#+6
   \   000000E4   0x.... 0x....      LDR.W    R12,??DataTable4_6  ;; 0x200084
   \   000000E8   0xF8CC 0x4000      STR      R4,[R12, #+0]
    137          			LPC_EEPROM->CMD = EEPROM_CMD_ERASE_PRG_PAGE;
   \   000000EC   0x....             LDR.N    R4,??DataTable4_7  ;; 0x200080
   \   000000EE   0xF05F 0x0C06      MOVS     R12,#+6
   \   000000F2   0xF8C4 0xC000      STR      R12,[R4, #+0]
    138          			while(!((LPC_EEPROM->INT_STATUS >> 28)&0x01));
   \                     ??EEPROM_Write_14:
   \   000000F6   0x....             LDR.N    R4,??DataTable4_9  ;; 0x200fe0
   \   000000F8   0x6824             LDR      R4,[R4, #+0]
   \   000000FA   0xF3C4 0x7400      UBFX     R4,R4,#+28,#+1
   \   000000FE   0x2C00             CMP      R4,#+0
   \   00000100   0xD0F9             BEQ.N    ??EEPROM_Write_14
    139          		}
    140          		if(page_offset >= EEPROM_PAGE_NUM)
   \                     ??EEPROM_Write_13:
   \   00000102   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000104   0x2840             CMP      R0,#+64
   \   00000106   0xDB0C             BLT.N    ??EEPROM_Write_15
    141          		{
    142          			page_offset = 0;
   \   00000108   0x2400             MOVS     R4,#+0
   \   0000010A   0x0020             MOVS     R0,R4
    143          			page_address +=1;
   \   0000010C   0x1C49             ADDS     R1,R1,#+1
    144          			LPC_EEPROM->ADDR =0;
   \   0000010E   0x....             LDR.N    R4,??DataTable4_6  ;; 0x200084
   \   00000110   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000114   0xF8C4 0xC000      STR      R12,[R4, #+0]
    145          			if(page_address > EEPROM_PAGE_NUM - 1) page_address = 0;
   \   00000118   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000011A   0x2940             CMP      R1,#+64
   \   0000011C   0xDB01             BLT.N    ??EEPROM_Write_15
   \   0000011E   0x2400             MOVS     R4,#+0
   \   00000120   0x0021             MOVS     R1,R4
    146          		}
    147          	}
   \                     ??EEPROM_Write_15:
   \   00000122   0x1C76             ADDS     R6,R6,#+1
   \   00000124   0xE791             B.N      ??EEPROM_Write_4
    148          }
   \                     ??EEPROM_Write_5:
   \   00000126   0xBCF0             POP      {R4-R7}
   \   00000128   0x4770             BX       LR               ;; return
    149          
    150          /*********************************************************************//**
    151           * @brief 		Read data to EEPROM at specific address
    152           * @param[in]
    153           * 				data	buffer that contain data that will be written to buffer
    154           * 				mode	Read mode, should be:
    155           * 					- MODE_8_BIT	: write 8 bit mode
    156           * 					- MODE_16_BIT	: write 16 bit mode
    157           * 					- MODE_32_BIT	: write 32 bit mode
    158           * 				size	number read data (bytes)
    159           * @return 		data	buffer that contain data that will be read to buffer
    160           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    161          void EEPROM_Read(uint16_t page_offset, uint16_t page_address, void* data, EEPROM_Mode_Type mode, uint32_t count)
    162          {
   \                     EEPROM_Read:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9C04             LDR      R4,[SP, #+16]
    163                  uint32_t i;
    164          #ifdef __IAR_SYSTEMS_ICC__
    165          #if (mode == MODE_8_BIT)
    166                  uint8_t *tmp = (uint8_t *)data;
   \   00000004   0x0016             MOVS     R6,R2
    167          #elif (mode == MODE_16_BIT)
    168                  uint16_t *tmp = (uint16_t *)data;
    169          #else
    170                  uint32_t *tmp = (uint32_t *)data;
    171          #endif
    172          #endif
    173          	LPC_EEPROM->INT_CLR_STATUS = ((1 << EEPROM_ENDOF_RW)|(1 << EEPROM_ENDOF_PROG));
   \   00000006   0x....             LDR.N    R7,??DataTable4_5  ;; 0x200fe8
   \   00000008   0xF05F 0x5CA0      MOVS     R12,#+335544320
   \   0000000C   0xF8C7 0xC000      STR      R12,[R7, #+0]
    174          	LPC_EEPROM->ADDR = EEPROM_PAGE_ADRESS(page_address)|EEPROM_PAGE_OFFSET(page_offset);
   \   00000010   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0xF011 0x073F      ANDS     R7,R1,#0x3F
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0xF010 0x0C3F      ANDS     R12,R0,#0x3F
   \   0000001C   0xEA5C 0x1787      ORRS     R7,R12,R7, LSL #+6
   \   00000020   0x.... 0x....      LDR.W    R12,??DataTable4_6  ;; 0x200084
   \   00000024   0xF8CC 0x7000      STR      R7,[R12, #+0]
    175          	if(mode == MODE_8_BIT)
   \   00000028   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002A   0x2B00             CMP      R3,#+0
   \   0000002C   0xD105             BNE.N    ??EEPROM_Read_0
    176          		LPC_EEPROM->CMD = EEPROM_CMD_8_BIT_READ|EEPROM_CMD_RDPREFETCH;
   \   0000002E   0x....             LDR.N    R7,??DataTable4_7  ;; 0x200080
   \   00000030   0xF05F 0x0C08      MOVS     R12,#+8
   \   00000034   0xF8C7 0xC000      STR      R12,[R7, #+0]
   \   00000038   0xE015             B.N      ??EEPROM_Read_1
    177          	else if(mode == MODE_16_BIT){
   \                     ??EEPROM_Read_0:
   \   0000003A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003C   0x2B01             CMP      R3,#+1
   \   0000003E   0xD107             BNE.N    ??EEPROM_Read_2
    178          		LPC_EEPROM->CMD = EEPROM_CMD_16_BIT_READ|EEPROM_CMD_RDPREFETCH;
   \   00000040   0x....             LDR.N    R7,??DataTable4_7  ;; 0x200080
   \   00000042   0xF05F 0x0C09      MOVS     R12,#+9
   \   00000046   0xF8C7 0xC000      STR      R12,[R7, #+0]
    179          		//check page_offset
    180          		if((page_offset &0x01)!=0)
   \   0000004A   0x07C7             LSLS     R7,R0,#+31
   \   0000004C   0xD50B             BPL.N    ??EEPROM_Read_1
    181          			while(1);
   \                     ??EEPROM_Read_3:
   \   0000004E   0xE7FE             B.N      ??EEPROM_Read_3
    182          	}
    183          	else{
    184          		LPC_EEPROM->CMD = EEPROM_CMD_32_BIT_READ|EEPROM_CMD_RDPREFETCH;
   \                     ??EEPROM_Read_2:
   \   00000050   0x....             LDR.N    R7,??DataTable4_7  ;; 0x200080
   \   00000052   0xF05F 0x0C0A      MOVS     R12,#+10
   \   00000056   0xF8C7 0xC000      STR      R12,[R7, #+0]
    185          		//page_offset must be a multiple of 0x04
    186          		if((page_offset & 0x03)!=0)
   \   0000005A   0xF05F 0x0C03      MOVS     R12,#+3
   \   0000005E   0xEA10 0x0F0C      TST      R0,R12
   \   00000062   0xD000             BEQ.N    ??EEPROM_Read_1
    187          			while(1);
   \                     ??EEPROM_Read_4:
   \   00000064   0xE7FE             B.N      ??EEPROM_Read_4
    188          	}
    189          
    190          	//read and store data in buffer
    191          	for(i=0;i<count;i++){
   \                     ??EEPROM_Read_1:
   \   00000066   0x2700             MOVS     R7,#+0
   \   00000068   0x003D             MOVS     R5,R7
   \                     ??EEPROM_Read_5:
   \   0000006A   0x42A5             CMP      R5,R4
   \   0000006C   0xD24C             BCS.N    ??EEPROM_Read_6
    192          		 LPC_EEPROM->INT_CLR_STATUS = (1 << EEPROM_ENDOF_RW);
   \   0000006E   0x....             LDR.N    R7,??DataTable4_5  ;; 0x200fe8
   \   00000070   0xF05F 0x6C80      MOVS     R12,#+67108864
   \   00000074   0xF8C7 0xC000      STR      R12,[R7, #+0]
    193          		 if(mode == MODE_8_BIT){
   \   00000078   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000007A   0x2B00             CMP      R3,#+0
   \   0000007C   0xD105             BNE.N    ??EEPROM_Read_7
    194          #ifdef __IAR_SYSTEMS_ICC__
    195                              *tmp = (uint8_t)(LPC_EEPROM -> RDATA);
   \   0000007E   0x....             LDR.N    R7,??DataTable4_10  ;; 0x20008c
   \   00000080   0x683F             LDR      R7,[R7, #+0]
   \   00000082   0x7037             STRB     R7,[R6, #+0]
    196                              tmp++;
   \   00000084   0x1C76             ADDS     R6,R6,#+1
    197          #else
    198          			 *(((uint8_t *)data)++) = (uint8_t)(LPC_EEPROM -> RDATA);
    199          #endif
    200          			 page_offset +=1;
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0xE00D             B.N      ??EEPROM_Read_8
    201          		 }
    202          		 else if (mode == MODE_16_BIT)
   \                     ??EEPROM_Read_7:
   \   0000008A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000008C   0x2B01             CMP      R3,#+1
   \   0000008E   0xD105             BNE.N    ??EEPROM_Read_9
    203          		 {
    204          #ifdef __IAR_SYSTEMS_ICC__
    205                                *tmp =  (uint16_t)(LPC_EEPROM -> RDATA);
   \   00000090   0x....             LDR.N    R7,??DataTable4_10  ;; 0x20008c
   \   00000092   0x683F             LDR      R7,[R7, #+0]
   \   00000094   0x7037             STRB     R7,[R6, #+0]
    206                                tmp++;
   \   00000096   0x1C76             ADDS     R6,R6,#+1
    207          #else
    208          			 *(((uint16_t *)data)++) = (uint16_t)(LPC_EEPROM -> RDATA);
    209          #endif
    210          			 page_offset +=2;
   \   00000098   0x1C80             ADDS     R0,R0,#+2
   \   0000009A   0xE004             B.N      ??EEPROM_Read_8
    211          		 }
    212          		 else{
    213          #ifdef __IAR_SYSTEMS_ICC__
    214                             *tmp = (uint32_t)(LPC_EEPROM ->RDATA);
   \                     ??EEPROM_Read_9:
   \   0000009C   0x....             LDR.N    R7,??DataTable4_10  ;; 0x20008c
   \   0000009E   0x683F             LDR      R7,[R7, #+0]
   \   000000A0   0x7037             STRB     R7,[R6, #+0]
    215                             tmp++;
   \   000000A2   0x1C76             ADDS     R6,R6,#+1
    216          #else
    217          			 *(((uint32_t *)data)++) = (uint32_t)(LPC_EEPROM ->RDATA);
    218          #endif
    219          			 page_offset +=4;
   \   000000A4   0x1D00             ADDS     R0,R0,#+4
    220          		 }
    221          		 while(!((LPC_EEPROM->INT_STATUS >> 26)&0x01));
   \                     ??EEPROM_Read_8:
   \   000000A6   0x....             LDR.N    R7,??DataTable4_9  ;; 0x200fe0
   \   000000A8   0x683F             LDR      R7,[R7, #+0]
   \   000000AA   0xF3C7 0x6780      UBFX     R7,R7,#+26,#+1
   \   000000AE   0x2F00             CMP      R7,#+0
   \   000000B0   0xD0F9             BEQ.N    ??EEPROM_Read_8
    222          		 if(page_offset >= EEPROM_PAGE_SIZE) {
   \   000000B2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B4   0x2840             CMP      R0,#+64
   \   000000B6   0xDB25             BLT.N    ??EEPROM_Read_10
    223          			 page_offset = 0;
   \   000000B8   0x2700             MOVS     R7,#+0
   \   000000BA   0x0038             MOVS     R0,R7
    224          			 page_address++;
   \   000000BC   0x1C49             ADDS     R1,R1,#+1
    225          			 LPC_EEPROM->ADDR = EEPROM_PAGE_ADRESS(page_address)|EEPROM_PAGE_OFFSET(page_offset);
   \   000000BE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000C0   0xF011 0x073F      ANDS     R7,R1,#0x3F
   \   000000C4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C6   0xF010 0x0C3F      ANDS     R12,R0,#0x3F
   \   000000CA   0xEA5C 0x1787      ORRS     R7,R12,R7, LSL #+6
   \   000000CE   0x.... 0x....      LDR.W    R12,??DataTable4_6  ;; 0x200084
   \   000000D2   0xF8CC 0x7000      STR      R7,[R12, #+0]
    226          			 if(mode == MODE_8_BIT)
   \   000000D6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000D8   0x2B00             CMP      R3,#+0
   \   000000DA   0xD105             BNE.N    ??EEPROM_Read_11
    227          			 	LPC_EEPROM->CMD = EEPROM_CMD_8_BIT_READ|EEPROM_CMD_RDPREFETCH;
   \   000000DC   0x....             LDR.N    R7,??DataTable4_7  ;; 0x200080
   \   000000DE   0xF05F 0x0C08      MOVS     R12,#+8
   \   000000E2   0xF8C7 0xC000      STR      R12,[R7, #+0]
   \   000000E6   0xE00D             B.N      ??EEPROM_Read_10
    228          			 else if(mode == MODE_16_BIT)
   \                     ??EEPROM_Read_11:
   \   000000E8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000EA   0x2B01             CMP      R3,#+1
   \   000000EC   0xD105             BNE.N    ??EEPROM_Read_12
    229          				LPC_EEPROM->CMD = EEPROM_CMD_16_BIT_READ|EEPROM_CMD_RDPREFETCH;
   \   000000EE   0x....             LDR.N    R7,??DataTable4_7  ;; 0x200080
   \   000000F0   0xF05F 0x0C09      MOVS     R12,#+9
   \   000000F4   0xF8C7 0xC000      STR      R12,[R7, #+0]
   \   000000F8   0xE004             B.N      ??EEPROM_Read_10
    230          			 else
    231          			 	LPC_EEPROM->CMD = EEPROM_CMD_32_BIT_READ|EEPROM_CMD_RDPREFETCH;
   \                     ??EEPROM_Read_12:
   \   000000FA   0x....             LDR.N    R7,??DataTable4_7  ;; 0x200080
   \   000000FC   0xF05F 0x0C0A      MOVS     R12,#+10
   \   00000100   0xF8C7 0xC000      STR      R12,[R7, #+0]
    232          		 }
    233          	}
   \                     ??EEPROM_Read_10:
   \   00000104   0x1C6D             ADDS     R5,R5,#+1
   \   00000106   0xE7B0             B.N      ??EEPROM_Read_5
    234          }
   \                     ??EEPROM_Read_6:
   \   00000108   0xBCF0             POP      {R4-R7}
   \   0000010A   0x4770             BX       LR               ;; return
    235          
    236          /*********************************************************************//**
    237           * @brief 		Erase to EEPROM at specific address
    238           * @param[in]	address EEPROM address that start to read data, should be
    239           * 				in range: 0..4096
    240           * 				mode	Read mode, should be:
    241           * 					- MODE_8_BIT	: write 8 bit mode
    242           * 					- MODE_16_BIT	: write 16 bit mode
    243           * 					- MODE_32_BIT	: write 32 bit mode
    244           * 				size	number read data
    245           * 					- byte unit in MODE_8_BIT
    246           * 					- word unit in MODE_16_BIT
    247           * 					- double word unit in MODE_32_BIT
    248           * @return 		data	buffer that contain data that will be read to buffer
    249           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    250          void EEPROM_Erase(uint32_t address)
    251          {
    252          	uint32_t i;
    253          	//clear page register
    254          	LPC_EEPROM->CMD = EEPROM_CMD_8_BIT_WRITE;
   \                     EEPROM_Erase:
   \   00000000   0x....             LDR.N    R2,??DataTable4_7  ;; 0x200080
   \   00000002   0x2303             MOVS     R3,#+3
   \   00000004   0x6013             STR      R3,[R2, #+0]
    255          	for(i=0;i<64;i++)
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0011             MOVS     R1,R2
   \                     ??EEPROM_Erase_0:
   \   0000000A   0x2940             CMP      R1,#+64
   \   0000000C   0xD20A             BCS.N    ??EEPROM_Erase_1
    256          	{
    257          		LPC_EEPROM -> WDATA = 0;
   \   0000000E   0x....             LDR.N    R2,??DataTable4_8  ;; 0x200088
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x6013             STR      R3,[R2, #+0]
    258          		while(!((LPC_EEPROM->INT_STATUS >> 26)&0x01));
   \                     ??EEPROM_Erase_2:
   \   00000014   0x....             LDR.N    R2,??DataTable4_9  ;; 0x200fe0
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0xF3C2 0x6280      UBFX     R2,R2,#+26,#+1
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD0F9             BEQ.N    ??EEPROM_Erase_2
    259          	}
   \   00000020   0x1C49             ADDS     R1,R1,#+1
   \   00000022   0xE7F2             B.N      ??EEPROM_Erase_0
    260          
    261          	LPC_EEPROM->INT_CLR_STATUS = (0x1 << EEPROM_ENDOF_PROG);
   \                     ??EEPROM_Erase_1:
   \   00000024   0x....             LDR.N    R2,??DataTable4_5  ;; 0x200fe8
   \   00000026   0xF05F 0x5380      MOVS     R3,#+268435456
   \   0000002A   0x6013             STR      R3,[R2, #+0]
    262          	LPC_EEPROM->ADDR = EEPROM_PAGE_ADRESS(address);
   \   0000002C   0xF010 0x023F      ANDS     R2,R0,#0x3F
   \   00000030   0x0192             LSLS     R2,R2,#+6
   \   00000032   0x....             LDR.N    R3,??DataTable4_6  ;; 0x200084
   \   00000034   0x601A             STR      R2,[R3, #+0]
    263          	LPC_EEPROM->CMD = EEPROM_CMD_ERASE_PRG_PAGE;
   \   00000036   0x....             LDR.N    R2,??DataTable4_7  ;; 0x200080
   \   00000038   0x2306             MOVS     R3,#+6
   \   0000003A   0x6013             STR      R3,[R2, #+0]
    264          	while(!((LPC_EEPROM->INT_STATUS >> 28)&0x01));
   \                     ??EEPROM_Erase_3:
   \   0000003C   0x....             LDR.N    R2,??DataTable4_9  ;; 0x200fe0
   \   0000003E   0x6812             LDR      R2,[R2, #+0]
   \   00000040   0xF3C2 0x7200      UBFX     R2,R2,#+28,#+1
   \   00000044   0x2A00             CMP      R2,#+0
   \   00000046   0xD0F9             BEQ.N    ??EEPROM_Erase_3
    265          }
   \   00000048   0x4770             BX       LR               ;; return
    266          
    267          /*********************************************************************//**
    268           * @brief 		Enable/Disable EEPROM power down mdoe
    269           * @param[in]	NewState	PowerDown mode state, should be:
    270           * 					- ENABLE: Enable power down mode
    271           * 					- DISABLE: Disable power down mode
    272           * @return 		None
    273           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    274          void EEPROM_PowerDown(FunctionalState NewState)
    275          {
    276          	if(NewState == ENABLE)
   \                     EEPROM_PowerDown:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD103             BNE.N    ??EEPROM_PowerDown_0
    277          		LPC_EEPROM->PWRDWN = 0x1;
   \   00000006   0x....             LDR.N    R1,??DataTable4  ;; 0x200098
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x600A             STR      R2,[R1, #+0]
   \   0000000C   0xE002             B.N      ??EEPROM_PowerDown_1
    278          	else
    279          		LPC_EEPROM->PWRDWN = 0x0;
   \                     ??EEPROM_PowerDown_0:
   \   0000000E   0x....             LDR.N    R1,??DataTable4  ;; 0x200098
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x600A             STR      R2,[R1, #+0]
    280          }
   \                     ??EEPROM_PowerDown_1:
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x00200098         DC32     0x200098

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x0005B8D8         DC32     0x5b8d8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x00200094         DC32     0x200094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x00200090         DC32     0x200090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x00200FE8         DC32     0x200fe8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x00200084         DC32     0x200084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x00200080         DC32     0x200080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x00200088         DC32     0x200088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x00200FE0         DC32     0x200fe0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x0020008C         DC32     0x20008c
    281          
    282          
    283          /**
    284           * @}
    285           */
    286          
    287          /* --------------------------------- End Of File ------------------------------ */
    288          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   EEPROM_Erase
      16   EEPROM_Init
        16   -> CLKPWR_GetCLK
       0   EEPROM_PowerDown
      16   EEPROM_Read
      16   EEPROM_Write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      74  EEPROM_Erase
     106  EEPROM_Init
      22  EEPROM_PowerDown
     268  EEPROM_Read
     298  EEPROM_Write

 
 812 bytes in section .text
 
 812 bytes of CODE memory

Errors: none
Warnings: none
