###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      24/Mar/2017  09:24:33 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\桌面\RTU_1.2\cmsis\Drivers\source\lpc177x_8x #
#                    _gpio.c                                                  #
#    Command line =  D:\wangfan2\桌面\RTU_1.2\cmsis\Drivers\source\lpc177x_8x #
#                    _gpio.c -lCN D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\ #
#                    List\ -o D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\Obj\ #
#                     --no_cse --no_unroll --no_inline --no_code_motion       #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\桌面\RTU_1.2\project\iar\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\ADC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RTC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\TILT\ -I  #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RDLevel\  #
#                    -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RS232\ #
#                     -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\OS-v2 #
#                    \ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\Vibr #
#                    ationString\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\ #
#                    ..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\ucos2\uCOS-II #
#                    \Source\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\u #
#                    cos2\uC-LIB\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\ #
#                    ..\ucos2\uC-CPU\ -I D:\wangfan2\桌面\RTU_1.2\project\iar #
#                    \..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I                #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\cmsis\Drivers #
#                    \source\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\c #
#                    msis\Drivers\include\ -I D:\wangfan2\桌面\RTU_1.2\projec #
#                    t\iar\..\..\app\ -I D:\wangfan2\桌面\RTU_1.2\project\iar #
#                    \..\..\uC-Probe\Target\Plugins\uCOS-II\ -I               #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Workspaces\ -I                            #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Source\ -I D:\wangfan2\桌面\RTU_1.2\proje #
#                    ct\iar\..\..\uC-Probe\Target\Communication\Generic\Sourc #
#                    e\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Prob #
#                    e\Target\Communication\Generic\RS-232\Source\ -I         #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\Ports\NXP\LPC17xx\ -I    #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\OS\uCOS-II\ -I           #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\cmsis\Core\CM #
#                    3\CoreSupport\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\. #
#                    .\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\ -I  #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\DEVI #
#                    CE_BT\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\Hua #
#                    ceApp\DEVICE_COM\ -I D:\wangfan2\桌面\RTU_1.2\project\ia #
#                    r\..\..\HuaceApp\DEVICE_GPRS\ -I                         #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\DEVI #
#                    CE_GPS\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\Hu #
#                    aceApp\DEVICE_RADIO\ -I D:\wangfan2\桌面\RTU_1.2\project #
#                    \iar\..\..\HuaceApp\iap\ -I                              #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\FatFs\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\USB\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\bsp\spi_flash #
#                    \ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp #
#                    \LED\ -On --use_c++_inline                               #
#    List file    =  D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\List\lpc177x_ #
#                    8x_gpio.lst                                              #
#    Object file  =  D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\Obj\lpc177x_8 #
#                    x_gpio.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\桌面\RTU_1.2\cmsis\Drivers\source\lpc177x_8x_gpio.c
      1          /**********************************************************************
      2          * $Id$		lpc177x_8x_gpio.c			2011-06-02
      3          *//**
      4          * @file		lpc177x_8x_gpio.c
      5          * @brief	Contains all functions support for GPIO firmware library
      6          *			on LPC177x_8x
      7          * @version	1.0
      8          * @date		02. June. 2011
      9          * @author	NXP MCU SW Application Team
     10          * 
     11          * Copyright(C) 2011, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          **********************************************************************/
     26          
     27          /* Peripheral group ----------------------------------------------------------- */
     28          /** @addtogroup GPIO
     29           * @{
     30           */
     31          
     32          /* Includes ------------------------------------------------------------------- */
     33          #include "lpc177x_8x_gpio.h"
     34          
     35          /* Private Functions ---------------------------------------------------------- */
     36          
     37          static LPC_GPIO_TypeDef *GPIO_GetPointer(uint8_t portNum);
     38          static GPIO_HalfWord_TypeDef *FIO_HalfWordGetPointer(uint8_t portNum);
     39          static GPIO_Byte_TypeDef *FIO_ByteGetPointer(uint8_t portNum);
     40          
     41          /*********************************************************************//**
     42           * @brief		Get pointer to GPIO peripheral due to GPIO port
     43           * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
     44           * @return		Pointer to GPIO peripheral
     45           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     46          static LPC_GPIO_TypeDef *GPIO_GetPointer(uint8_t portNum)
     47          {
   \                     GPIO_GetPointer:
   \   00000000   0x0001             MOVS     R1,R0
     48          	LPC_GPIO_TypeDef *pGPIO = NULL;
   \   00000002   0x2000             MOVS     R0,#+0
     49          
     50          	switch (portNum)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD008             BEQ.N    ??GPIO_GetPointer_0
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD00C             BEQ.N    ??GPIO_GetPointer_1
   \   0000000E   0xD308             BCC.N    ??GPIO_GetPointer_2
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD00F             BEQ.N    ??GPIO_GetPointer_3
   \   00000014   0xD30B             BCC.N    ??GPIO_GetPointer_4
   \   00000016   0x2905             CMP      R1,#+5
   \   00000018   0xD00F             BEQ.N    ??GPIO_GetPointer_5
   \   0000001A   0xE011             B.N      ??GPIO_GetPointer_6
     51          	{
     52          		case 0:
     53          			pGPIO = LPC_GPIO0;
   \                     ??GPIO_GetPointer_0:
   \   0000001C   0x....             LDR.N    R2,??DataTable5  ;; 0x20098000
   \   0000001E   0x0010             MOVS     R0,R2
     54          			break;
   \   00000020   0xE00E             B.N      ??GPIO_GetPointer_7
     55          
     56          		case 1:
     57          			pGPIO = LPC_GPIO1;
   \                     ??GPIO_GetPointer_2:
   \   00000022   0x....             LDR.N    R2,??DataTable5_1  ;; 0x20098020
   \   00000024   0x0010             MOVS     R0,R2
     58          			break;
   \   00000026   0xE00B             B.N      ??GPIO_GetPointer_7
     59          
     60          		case 2:
     61          			pGPIO = LPC_GPIO2;
   \                     ??GPIO_GetPointer_1:
   \   00000028   0x....             LDR.N    R2,??DataTable5_2  ;; 0x20098040
   \   0000002A   0x0010             MOVS     R0,R2
     62          			break;
   \   0000002C   0xE008             B.N      ??GPIO_GetPointer_7
     63          
     64          		case 3:
     65          			pGPIO = LPC_GPIO3;
   \                     ??GPIO_GetPointer_4:
   \   0000002E   0x....             LDR.N    R2,??DataTable5_3  ;; 0x20098060
   \   00000030   0x0010             MOVS     R0,R2
     66          			break;
   \   00000032   0xE005             B.N      ??GPIO_GetPointer_7
     67          
     68          		case 4:
     69          			pGPIO = LPC_GPIO4;
   \                     ??GPIO_GetPointer_3:
   \   00000034   0x....             LDR.N    R2,??DataTable5_4  ;; 0x20098080
   \   00000036   0x0010             MOVS     R0,R2
     70          			break;
   \   00000038   0xE002             B.N      ??GPIO_GetPointer_7
     71                                  
     72                          case 5:
     73          			pGPIO = LPC_GPIO5;
   \                     ??GPIO_GetPointer_5:
   \   0000003A   0x....             LDR.N    R2,??DataTable5_5  ;; 0x200980a0
   \   0000003C   0x0010             MOVS     R0,R2
     74                                  break;
   \   0000003E   0xE7FF             B.N      ??GPIO_GetPointer_7
     75          		default:
     76          			break;
     77          	}
     78          
     79          	return pGPIO;
   \                     ??GPIO_GetPointer_6:
   \                     ??GPIO_GetPointer_7:
   \   00000040   0x4770             BX       LR               ;; return
     80          }
     81          
     82          /*********************************************************************//**
     83           * @brief		Get pointer to FIO peripheral in halfword accessible style
     84           * 				due to FIO port
     85           * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
     86           * @return		Pointer to FIO peripheral
     87           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     88          static GPIO_HalfWord_TypeDef *FIO_HalfWordGetPointer(uint8_t portNum)
     89          {
   \                     FIO_HalfWordGetPointer:
   \   00000000   0x0001             MOVS     R1,R0
     90          	GPIO_HalfWord_TypeDef *pFIO = NULL;
   \   00000002   0x2000             MOVS     R0,#+0
     91          
     92          	switch (portNum)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD008             BEQ.N    ??FIO_HalfWordGetPointer_0
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD00C             BEQ.N    ??FIO_HalfWordGetPointer_1
   \   0000000E   0xD308             BCC.N    ??FIO_HalfWordGetPointer_2
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD00F             BEQ.N    ??FIO_HalfWordGetPointer_3
   \   00000014   0xD30B             BCC.N    ??FIO_HalfWordGetPointer_4
   \   00000016   0x2905             CMP      R1,#+5
   \   00000018   0xD00F             BEQ.N    ??FIO_HalfWordGetPointer_5
   \   0000001A   0xE011             B.N      ??FIO_HalfWordGetPointer_6
     93          	{
     94          		case 0:
     95          			pFIO = GPIO0_HalfWord;
   \                     ??FIO_HalfWordGetPointer_0:
   \   0000001C   0x....             LDR.N    R2,??DataTable5  ;; 0x20098000
   \   0000001E   0x0010             MOVS     R0,R2
     96          			break;
   \   00000020   0xE00E             B.N      ??FIO_HalfWordGetPointer_7
     97          
     98          		case 1:
     99          			pFIO = GPIO1_HalfWord;
   \                     ??FIO_HalfWordGetPointer_2:
   \   00000022   0x....             LDR.N    R2,??DataTable5_1  ;; 0x20098020
   \   00000024   0x0010             MOVS     R0,R2
    100          			break;
   \   00000026   0xE00B             B.N      ??FIO_HalfWordGetPointer_7
    101          
    102          		case 2:
    103          			pFIO = GPIO2_HalfWord;
   \                     ??FIO_HalfWordGetPointer_1:
   \   00000028   0x....             LDR.N    R2,??DataTable5_2  ;; 0x20098040
   \   0000002A   0x0010             MOVS     R0,R2
    104          			break;
   \   0000002C   0xE008             B.N      ??FIO_HalfWordGetPointer_7
    105          
    106          		case 3:
    107          			pFIO = GPIO3_HalfWord;
   \                     ??FIO_HalfWordGetPointer_4:
   \   0000002E   0x....             LDR.N    R2,??DataTable5_3  ;; 0x20098060
   \   00000030   0x0010             MOVS     R0,R2
    108          			break;
   \   00000032   0xE005             B.N      ??FIO_HalfWordGetPointer_7
    109          
    110          		case 4:
    111          			pFIO = GPIO4_HalfWord;
   \                     ??FIO_HalfWordGetPointer_3:
   \   00000034   0x....             LDR.N    R2,??DataTable5_4  ;; 0x20098080
   \   00000036   0x0010             MOVS     R0,R2
    112          			break;
   \   00000038   0xE002             B.N      ??FIO_HalfWordGetPointer_7
    113          
    114          		case 5:
    115          			pFIO = GPIO5_HalfWord;
   \                     ??FIO_HalfWordGetPointer_5:
   \   0000003A   0x....             LDR.N    R2,??DataTable5_5  ;; 0x200980a0
   \   0000003C   0x0010             MOVS     R0,R2
    116          			break;
   \   0000003E   0xE7FF             B.N      ??FIO_HalfWordGetPointer_7
    117          
    118          		default:
    119          			break;
    120          	}
    121          
    122          	return pFIO;
   \                     ??FIO_HalfWordGetPointer_6:
   \                     ??FIO_HalfWordGetPointer_7:
   \   00000040   0x4770             BX       LR               ;; return
    123          }
    124          
    125          /*********************************************************************//**
    126           * @brief		Get pointer to FIO peripheral in byte accessible style
    127           * 				due to FIO port
    128           * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
    129           * @return		Pointer to FIO peripheral
    130           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    131          static GPIO_Byte_TypeDef *FIO_ByteGetPointer(uint8_t portNum)
    132          {
   \                     FIO_ByteGetPointer:
   \   00000000   0x0001             MOVS     R1,R0
    133          	GPIO_Byte_TypeDef *pFIO = NULL;
   \   00000002   0x2000             MOVS     R0,#+0
    134          
    135          	switch (portNum)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD006             BEQ.N    ??FIO_ByteGetPointer_0
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD00A             BEQ.N    ??FIO_ByteGetPointer_1
   \   0000000E   0xD306             BCC.N    ??FIO_ByteGetPointer_2
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD00D             BEQ.N    ??FIO_ByteGetPointer_3
   \   00000014   0xD309             BCC.N    ??FIO_ByteGetPointer_4
   \   00000016   0xE00E             B.N      ??FIO_ByteGetPointer_5
    136          	{
    137          		case 0:
    138          			pFIO = GPIO0_Byte;
   \                     ??FIO_ByteGetPointer_0:
   \   00000018   0x....             LDR.N    R2,??DataTable5  ;; 0x20098000
   \   0000001A   0x0010             MOVS     R0,R2
    139          			break;
   \   0000001C   0xE00B             B.N      ??FIO_ByteGetPointer_6
    140          
    141          		case 1:
    142          			pFIO = GPIO1_Byte;
   \                     ??FIO_ByteGetPointer_2:
   \   0000001E   0x....             LDR.N    R2,??DataTable5_1  ;; 0x20098020
   \   00000020   0x0010             MOVS     R0,R2
    143          			break;
   \   00000022   0xE008             B.N      ??FIO_ByteGetPointer_6
    144          
    145          		case 2:
    146          			pFIO = GPIO2_Byte;
   \                     ??FIO_ByteGetPointer_1:
   \   00000024   0x....             LDR.N    R2,??DataTable5_2  ;; 0x20098040
   \   00000026   0x0010             MOVS     R0,R2
    147          			break;
   \   00000028   0xE005             B.N      ??FIO_ByteGetPointer_6
    148          
    149          		case 3:
    150          			pFIO = GPIO3_Byte;
   \                     ??FIO_ByteGetPointer_4:
   \   0000002A   0x....             LDR.N    R2,??DataTable5_3  ;; 0x20098060
   \   0000002C   0x0010             MOVS     R0,R2
    151          			break;
   \   0000002E   0xE002             B.N      ??FIO_ByteGetPointer_6
    152          
    153          		case 4:
    154          			pFIO = GPIO4_Byte;
   \                     ??FIO_ByteGetPointer_3:
   \   00000030   0x....             LDR.N    R2,??DataTable5_4  ;; 0x20098080
   \   00000032   0x0010             MOVS     R0,R2
    155          			break;
   \   00000034   0xE7FF             B.N      ??FIO_ByteGetPointer_6
    156          
    157          		default:
    158          			break;
    159          	}
    160          
    161          	return pFIO;
   \                     ??FIO_ByteGetPointer_5:
   \                     ??FIO_ByteGetPointer_6:
   \   00000036   0x4770             BX       LR               ;; return
    162          }
    163          
    164          /* End of Private Functions --------------------------------------------------- */
    165          
    166          
    167          /* Public Functions ----------------------------------------------------------- */
    168          /** @addtogroup GPIO_Public_Functions
    169           * @{
    170           */
    171          
    172          
    173          /* GPIO ------------------------------------------------------------------------------ */
    174          
    175          /*********************************************************************//**
    176           * @brief		Set Direction for GPIO port.
    177           * @param[in]	portNum		Port Number value, should be in range from 0 to 4
    178           * @param[in]	bitValue	Value that contains all bits to set direction,
    179           * 							in range from 0 to 0xFFFFFFFF.
    180           * 							example: value 0x5 to set direction for bit 0 and bit 1.
    181           * @param[in]	dir			Direction value, should be:
    182           * 							- 0: Input.
    183           * 							- 1: Output.
    184           * @return		None
    185           *
    186           * Note: All remaining bits that are not activated in bitValue (value '0')
    187           * will not be effected by this function.
    188           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    189          void GPIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir)
    190          {
   \                     GPIO_SetDir:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    191          	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       GPIO_GetPointer
    192          
    193          	if (pGPIO != NULL)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??GPIO_SetDir_0
    194          	{
    195          		// Enable Output
    196          		if (dir)
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD003             BEQ.N    ??GPIO_SetDir_1
    197          		{
    198          			pGPIO->DIR |= bitValue;
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x4329             ORRS     R1,R5,R1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
   \   00000020   0xE002             B.N      ??GPIO_SetDir_0
    199          		}
    200          		// Enable Input
    201          		else
    202          		{
    203          			pGPIO->DIR &= ~bitValue;
   \                     ??GPIO_SetDir_1:
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x43A9             BICS     R1,R1,R5
   \   00000026   0x6001             STR      R1,[R0, #+0]
    204          		}
    205          	}
    206          }
   \                     ??GPIO_SetDir_0:
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    207          
    208          
    209          /*********************************************************************//**
    210           * @brief		Set Value for bits that have output direction on GPIO port.
    211           * @param[in]	portNum		Port number value, should be in range from 0 to 4
    212           * @param[in]	bitValue	Value that contains all bits on GPIO to set,
    213           * 							in range from 0 to 0xFFFFFFFF.
    214           * 							example: value 0x5 to set bit 0 and bit 1.
    215           * @return		None
    216           *
    217           * Note:
    218           * - For all bits that has been set as input direction, this function will
    219           * not effect.
    220           * - For all remaining bits that are not activated in bitValue (value '0')
    221           * will not be effected by this function.
    222           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    223          void GPIO_SetValue(uint8_t portNum, uint32_t bitValue)
    224          {
   \                     GPIO_SetValue:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    225          	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       GPIO_GetPointer
    226          
    227          	if (pGPIO != NULL)
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD000             BEQ.N    ??GPIO_SetValue_0
    228          	{
    229          		pGPIO->SET = bitValue;
   \   00000012   0x6185             STR      R5,[R0, #+24]
    230          	}
    231          }
   \                     ??GPIO_SetValue_0:
   \   00000014   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    232          
    233          /*********************************************************************//**
    234           * @brief		Clear Value for bits that have output direction on GPIO port.
    235           * @param[in]	portNum		Port number value, should be in range from 0 to 4
    236           * @param[in]	bitValue	Value that contains all bits on GPIO to clear,
    237           * 							in range from 0 to 0xFFFFFFFF.
    238           * 							example: value 0x5 to clear bit 0 and bit 1.
    239           * @return		None
    240           *
    241           * Note:
    242           * - For all bits that has been set as input direction, this function will
    243           * not effect.
    244           * - For all remaining bits that are not activated in bitValue (value '0')
    245           * will not be effected by this function.
    246           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    247          void GPIO_ClearValue(uint8_t portNum, uint32_t bitValue)
    248          {
   \                     GPIO_ClearValue:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    249          	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       GPIO_GetPointer
    250          
    251          	if (pGPIO != NULL)
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD000             BEQ.N    ??GPIO_ClearValue_0
    252          	{
    253          		pGPIO->CLR = bitValue;
   \   00000012   0x61C5             STR      R5,[R0, #+28]
    254          	}
    255          }
   \                     ??GPIO_ClearValue_0:
   \   00000014   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    256          
    257          /*********************************************************************//**
    258           * @brief		Output to the GPIO pin an expected value
    259           * @param[in]	portNum		Port number value, should be in range from 0 to 4
    260           * @param[in]	bitValue	Value that contains all bits on GPIO to clear,
    261           * 							in range from 0 to 0xFFFFFFFF.
    262           * 							example: value 0x5 to clear bit 0 and bit 1.
    263           * @return		None
    264           *
    265           * Note:
    266           * - For all bits that has been set as input direction, this function will
    267           * not effect.
    268           * - For all remaining bits that are not activated in bitValue (value '0')
    269           * will not be effected by this function.
    270           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    271          void GPIO_OutputValue(uint8_t portNum, uint32_t bitMask, uint8_t value)
    272          {
   \                     GPIO_OutputValue:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    273              
    274          	if (value == 0)
   \   00000008   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD105             BNE.N    ??GPIO_OutputValue_0
    275          	{
    276          		GPIO_ClearValue(portNum, bitMask);
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       GPIO_ClearValue
   \   00000018   0xE004             B.N      ??GPIO_OutputValue_1
    277          	}
    278          	else
    279          	{
    280          		GPIO_SetValue(portNum, bitMask);
   \                     ??GPIO_OutputValue_0:
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       GPIO_SetValue
    281          	}
    282              
    283              /*
    284              LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
    285          
    286          	if (pGPIO != NULL)
    287          	{
    288          		pGPIO->MASK = (uint32_t)~bitMask;
    289                  pGPIO->PIN = value;
    290          		pGPIO->MASK = (uint32_t)-1;
    291          	}
    292              */
    293          }
   \                     ??GPIO_OutputValue_1:
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    294          
    295          
    296          /*********************************************************************//**
    297           * @brief		Read Current state on port pin that have input direction of GPIO
    298           * @param[in]	portNum		Port number to read value, in range from 0 to 4
    299           * @return		Current value of GPIO port.
    300           *
    301           * Note: Return value contain state of each port pin (bit) on that GPIO regardless
    302           * its direction is input or output.
    303           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    304          uint32_t GPIO_ReadValue(uint8_t portNum)
    305          {
   \                     GPIO_ReadValue:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    306          	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       GPIO_GetPointer
   \   0000000C   0x0001             MOVS     R1,R0
    307          
    308          	if (pGPIO != NULL)
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD001             BEQ.N    ??GPIO_ReadValue_0
    309          	{
    310          		return pGPIO->PIN;
   \   00000012   0x6948             LDR      R0,[R1, #+20]
   \   00000014   0xE000             B.N      ??GPIO_ReadValue_1
    311          	}
    312          
    313          	return (0);
   \                     ??GPIO_ReadValue_0:
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??GPIO_ReadValue_1:
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    314          }
    315          
    316          /*********************************************************************//**
    317           * @brief		Enable GPIO interrupt (just used for P0.0-P0.30, P2.0-P2.13)
    318           * @param[in]	portNum		Port number to read value, should be: 0 or 2
    319           * @param[in]	bitValue	Value that contains all bits on GPIO to enable,
    320           * 							in range from 0 to 0xFFFFFFFF.
    321           * @param[in]	edgeState	state of edge, should be:
    322           * 							- 0: Rising edge
    323           * 							- 1: Falling edge
    324           * @return		None
    325           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    326          void GPIO_IntCmd(uint8_t portNum, uint32_t bitValue, uint8_t edgeState)
    327          {
    328          	if((portNum == 0)&&(edgeState == 0))
   \                     GPIO_IntCmd:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD105             BNE.N    ??GPIO_IntCmd_0
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD102             BNE.N    ??GPIO_IntCmd_0
    329          		LPC_GPIOINT->IO0IntEnR = bitValue;
   \   0000000C   0x....             LDR.N    R3,??DataTable5_6  ;; 0x40028090
   \   0000000E   0x6019             STR      R1,[R3, #+0]
   \   00000010   0xE01B             B.N      ??GPIO_IntCmd_1
    330          	else if ((portNum == 2)&&(edgeState == 0))
   \                     ??GPIO_IntCmd_0:
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD105             BNE.N    ??GPIO_IntCmd_2
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD102             BNE.N    ??GPIO_IntCmd_2
    331          		LPC_GPIOINT->IO2IntEnR = bitValue;
   \   0000001E   0x....             LDR.N    R3,??DataTable5_7  ;; 0x400280b0
   \   00000020   0x6019             STR      R1,[R3, #+0]
   \   00000022   0xE012             B.N      ??GPIO_IntCmd_1
    332          	else if ((portNum == 0)&&(edgeState == 1))
   \                     ??GPIO_IntCmd_2:
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD105             BNE.N    ??GPIO_IntCmd_3
   \   0000002A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   0x2A01             CMP      R2,#+1
   \   0000002E   0xD102             BNE.N    ??GPIO_IntCmd_3
    333          		LPC_GPIOINT->IO0IntEnF = bitValue;
   \   00000030   0x....             LDR.N    R3,??DataTable5_8  ;; 0x40028094
   \   00000032   0x6019             STR      R1,[R3, #+0]
   \   00000034   0xE009             B.N      ??GPIO_IntCmd_1
    334          	else if ((portNum == 2)&&(edgeState == 1))
   \                     ??GPIO_IntCmd_3:
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xD105             BNE.N    ??GPIO_IntCmd_4
   \   0000003C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003E   0x2A01             CMP      R2,#+1
   \   00000040   0xD102             BNE.N    ??GPIO_IntCmd_4
    335          		LPC_GPIOINT->IO2IntEnF = bitValue;
   \   00000042   0x....             LDR.N    R3,??DataTable5_9  ;; 0x400280b4
   \   00000044   0x6019             STR      R1,[R3, #+0]
   \   00000046   0xE000             B.N      ??GPIO_IntCmd_1
    336          	else
    337          		//Error
    338          		while(1);
   \                     ??GPIO_IntCmd_4:
   \   00000048   0xE7FE             B.N      ??GPIO_IntCmd_4
    339          }
   \                     ??GPIO_IntCmd_1:
   \   0000004A   0x4770             BX       LR               ;; return
    340          
    341          /*********************************************************************//**
    342           * @brief		Get GPIO Interrupt Status (just used for P0.0-P0.30, P2.0-P2.13)
    343           * @param[in]	portNum		Port number to read value, should be: 0 or 2
    344           * @param[in]	pinNum		Pin number, should be: 0..30(with port 0) and 0..13
    345           * 							(with port 2)
    346           * @param[in]	edgeState	state of edge, should be:
    347           * 							- 0: Rising edge
    348           * 							- 1: Falling edge
    349           * @return		Bool	could be:
    350           * 						- ENABLE: Interrupt has been generated due to a rising
    351           * 								edge on P0.0
    352           * 						- DISABLE: A rising edge has not been detected on P0.0
    353           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    354          FunctionalState GPIO_GetIntStatus(uint8_t portNum, uint32_t pinNum, uint8_t edgeState)
    355          {
   \                     GPIO_GetIntStatus:
   \   00000000   0x0003             MOVS     R3,R0
    356          	if((portNum == 0) && (edgeState == 0))//Rising Edge
   \   00000002   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD108             BNE.N    ??GPIO_GetIntStatus_0
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD105             BNE.N    ??GPIO_GetIntStatus_0
    357          		return (FunctionalState)(((LPC_GPIOINT->IO0IntStatR)>>pinNum)& 0x1);
   \   0000000E   0x....             LDR.N    R0,??DataTable5_10  ;; 0x40028084
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x40C8             LSRS     R0,R0,R1
   \   00000014   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000018   0xE024             B.N      ??GPIO_GetIntStatus_1
    358          	else if ((portNum == 2) && (edgeState == 0))
   \                     ??GPIO_GetIntStatus_0:
   \   0000001A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001C   0x2B02             CMP      R3,#+2
   \   0000001E   0xD108             BNE.N    ??GPIO_GetIntStatus_2
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD105             BNE.N    ??GPIO_GetIntStatus_2
    359          		return (FunctionalState)(((LPC_GPIOINT->IO2IntStatR)>>pinNum)& 0x1);
   \   00000026   0x....             LDR.N    R0,??DataTable5_11  ;; 0x400280a4
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x40C8             LSRS     R0,R0,R1
   \   0000002C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000030   0xE018             B.N      ??GPIO_GetIntStatus_1
    360          	else if ((portNum == 0) && (edgeState == 1))//Falling Edge
   \                     ??GPIO_GetIntStatus_2:
   \   00000032   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000034   0x2B00             CMP      R3,#+0
   \   00000036   0xD108             BNE.N    ??GPIO_GetIntStatus_3
   \   00000038   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003A   0x2A01             CMP      R2,#+1
   \   0000003C   0xD105             BNE.N    ??GPIO_GetIntStatus_3
    361          		return (FunctionalState)(((LPC_GPIOINT->IO0IntStatF)>>pinNum)& 0x1);
   \   0000003E   0x....             LDR.N    R0,??DataTable5_12  ;; 0x40028088
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x40C8             LSRS     R0,R0,R1
   \   00000044   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000048   0xE00C             B.N      ??GPIO_GetIntStatus_1
    362          	else if ((portNum == 2) && (edgeState == 1))
   \                     ??GPIO_GetIntStatus_3:
   \   0000004A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000004C   0x2B02             CMP      R3,#+2
   \   0000004E   0xD108             BNE.N    ??GPIO_GetIntStatus_4
   \   00000050   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000052   0x2A01             CMP      R2,#+1
   \   00000054   0xD105             BNE.N    ??GPIO_GetIntStatus_4
    363          		return (FunctionalState)(((LPC_GPIOINT->IO2IntStatF)>>pinNum)& 0x1);
   \   00000056   0x....             LDR.N    R0,??DataTable5_13  ;; 0x400280a8
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x40C8             LSRS     R0,R0,R1
   \   0000005C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000060   0xE000             B.N      ??GPIO_GetIntStatus_1
    364          	else
    365          		//Error
    366          		while(1);
   \                     ??GPIO_GetIntStatus_4:
   \   00000062   0xE7FE             B.N      ??GPIO_GetIntStatus_4
   \                     ??GPIO_GetIntStatus_1:
   \   00000064   0x4770             BX       LR               ;; return
    367          }
    368          /*********************************************************************//**
    369           * @brief		Clear GPIO interrupt (just used for P0.0-P0.30, P2.0-P2.13)
    370           * @param[in]	portNum		Port number to read value, should be: 0 or 2
    371           * @param[in]	bitValue	Value that contains all bits on GPIO to enable,
    372           * 							in range from 0 to 0xFFFFFFFF.
    373           * @return		None
    374           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    375          void GPIO_ClearInt(uint8_t portNum, uint32_t bitValue)
    376          {
    377          	if(portNum == 0)
   \                     GPIO_ClearInt:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??GPIO_ClearInt_0
    378          		LPC_GPIOINT->IO0IntClr = bitValue;
   \   00000006   0x....             LDR.N    R2,??DataTable5_14  ;; 0x4002808c
   \   00000008   0x6011             STR      R1,[R2, #+0]
   \   0000000A   0xE006             B.N      ??GPIO_ClearInt_1
    379          	else if (portNum == 2)
   \                     ??GPIO_ClearInt_0:
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD102             BNE.N    ??GPIO_ClearInt_2
    380          		LPC_GPIOINT->IO2IntClr = bitValue;
   \   00000012   0x....             LDR.N    R2,??DataTable5_15  ;; 0x400280ac
   \   00000014   0x6011             STR      R1,[R2, #+0]
   \   00000016   0xE000             B.N      ??GPIO_ClearInt_1
    381          	else
    382          		//Invalid portNum
    383          		while(1);
   \                     ??GPIO_ClearInt_2:
   \   00000018   0xE7FE             B.N      ??GPIO_ClearInt_2
    384          }
   \                     ??GPIO_ClearInt_1:
   \   0000001A   0x4770             BX       LR               ;; return
    385          
    386          /* FIO word accessible ----------------------------------------------------------------- */
    387          /* Stub function for FIO (word-accessible) style */
    388          
    389          /**
    390           * @brief The same with GPIO_SetDir()
    391           */

   \                                 In section .text, align 2, keep-with-next
    392          void FIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir)
    393          {
   \                     FIO_SetDir:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    394          	GPIO_SetDir(portNum, bitValue, dir);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       GPIO_SetDir
    395          }
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    396          
    397          /**
    398           * @brief The same with GPIO_SetValue()
    399           */

   \                                 In section .text, align 2, keep-with-next
    400          void FIO_SetValue(uint8_t portNum, uint32_t bitValue)
    401          {
   \                     FIO_SetValue:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    402          	GPIO_SetValue(portNum, bitValue);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       GPIO_SetValue
    403          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    404          
    405          /**
    406           * @brief The same with GPIO_ClearValue()
    407           */

   \                                 In section .text, align 2, keep-with-next
    408          void FIO_ClearValue(uint8_t portNum, uint32_t bitValue)
    409          {
   \                     FIO_ClearValue:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    410          	GPIO_ClearValue(portNum, bitValue);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       GPIO_ClearValue
    411          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    412          
    413          /**
    414           * @brief The same with GPIO_ReadValue()
    415           */

   \                                 In section .text, align 2, keep-with-next
    416          uint32_t FIO_ReadValue(uint8_t portNum)
    417          {
   \                     FIO_ReadValue:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    418          	return (GPIO_ReadValue(portNum));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       GPIO_ReadValue
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    419          }
    420          
    421          /**
    422           * @brief The same with GPIO_IntCmd()
    423           */

   \                                 In section .text, align 2, keep-with-next
    424          void FIO_IntCmd(uint8_t portNum, uint32_t bitValue, uint8_t edgeState)
    425          {
   \                     FIO_IntCmd:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    426          	GPIO_IntCmd(portNum, bitValue, edgeState);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       GPIO_IntCmd
    427          }
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    428          
    429          /**
    430           * @brief The same with GPIO_GetIntStatus()
    431           */

   \                                 In section .text, align 2, keep-with-next
    432          FunctionalState FIO_GetIntStatus(uint8_t portNum, uint32_t pinNum, uint8_t edgeState)
    433          {
   \                     FIO_GetIntStatus:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    434          	return (GPIO_GetIntStatus(portNum, pinNum, edgeState));
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       GPIO_GetIntStatus
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    435          }
    436          
    437          /**
    438           * @brief The same with GPIO_ClearInt()
    439           */

   \                                 In section .text, align 2, keep-with-next
    440          void FIO_ClearInt(uint8_t portNum, uint32_t bitValue)
    441          {
   \                     FIO_ClearInt:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    442          	GPIO_ClearInt(portNum, bitValue);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       GPIO_ClearInt
    443          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    444          /*********************************************************************//**
    445           * @brief		Set mask value for bits in FIO port
    446           * @param[in]	portNum		Port number, in range from 0 to 4
    447           * @param[in]	bitValue	Value that contains all bits in to set,
    448           * 							in range from 0 to 0xFFFFFFFF.
    449           * @param[in]	maskValue	Mask value contains state value for each bit:
    450           * 							- 0: not mask.
    451           * 							- 1: mask.
    452           * @return		None
    453           *
    454           * Note:
    455           * - All remaining bits that are not activated in bitValue (value '0')
    456           * will not be effected by this function.
    457           * - After executing this function, in mask register, value '0' on each bit
    458           * enables an access to the corresponding physical pin via a read or write access,
    459           * while value '1' on bit (masked) that corresponding pin will not be changed
    460           * with write access and if read, will not be reflected in the updated pin.
    461           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    462          void FIO_SetMask(uint8_t portNum, uint32_t bitValue, uint8_t maskValue)
    463          {
   \                     FIO_SetMask:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    464          	LPC_GPIO_TypeDef *pFIO = GPIO_GetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       GPIO_GetPointer
    465          
    466          	if(pFIO != NULL)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??FIO_SetMask_0
    467          	{
    468          		// Mask
    469          		if (maskValue)
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD003             BEQ.N    ??FIO_SetMask_1
    470          		{
    471          			pFIO->MASK |= bitValue;
   \   0000001A   0x6901             LDR      R1,[R0, #+16]
   \   0000001C   0x4329             ORRS     R1,R5,R1
   \   0000001E   0x6101             STR      R1,[R0, #+16]
   \   00000020   0xE002             B.N      ??FIO_SetMask_0
    472          		}
    473          		// Un-mask
    474          		else
    475          		{
    476          			pFIO->MASK &= ~bitValue;
   \                     ??FIO_SetMask_1:
   \   00000022   0x6901             LDR      R1,[R0, #+16]
   \   00000024   0x43A9             BICS     R1,R1,R5
   \   00000026   0x6101             STR      R1,[R0, #+16]
    477          		}
    478          	}
    479          }
   \                     ??FIO_SetMask_0:
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    480          
    481          
    482          /* FIO halfword accessible ------------------------------------------------------------- */
    483          
    484          /*********************************************************************//**
    485           * @brief		Set direction for FIO port in halfword accessible style
    486           * @param[in]	portNum		Port number, in range from 0 to 4
    487           * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
    488           * @param[in]	bitValue	Value that contains all bits in to set direction,
    489           * 							in range from 0 to 0xFFFF.
    490           * @param[in]	dir			Direction value, should be:
    491           * 							- 0: Input.
    492           * 							- 1: Output.
    493           * @return		None
    494           *
    495           * Note: All remaining bits that are not activated in bitValue (value '0')
    496           * will not be effected by this function.
    497           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    498          void FIO_HalfWordSetDir(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t dir)
    499          {
   \                     FIO_HalfWordSetDir:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    500          	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       FIO_HalfWordGetPointer
    501          
    502          	if(pFIO != NULL)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD017             BEQ.N    ??FIO_HalfWordSetDir_0
    503          	{
    504          		// Output direction
    505          		if (dir)
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD00A             BEQ.N    ??FIO_HalfWordSetDir_1
    506          		{
    507          			// Upper
    508          			if(halfwordNum)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD003             BEQ.N    ??FIO_HalfWordSetDir_2
    509          			{
    510          				pFIO->FIODIRU |= bitValue;
   \   00000022   0x8841             LDRH     R1,[R0, #+2]
   \   00000024   0x4331             ORRS     R1,R6,R1
   \   00000026   0x8041             STRH     R1,[R0, #+2]
   \   00000028   0xE00D             B.N      ??FIO_HalfWordSetDir_0
    511          			}
    512          			// lower
    513          			else
    514          			{
    515          				pFIO->FIODIRL |= bitValue;
   \                     ??FIO_HalfWordSetDir_2:
   \   0000002A   0x8801             LDRH     R1,[R0, #+0]
   \   0000002C   0x4331             ORRS     R1,R6,R1
   \   0000002E   0x8001             STRH     R1,[R0, #+0]
   \   00000030   0xE009             B.N      ??FIO_HalfWordSetDir_0
    516          			}
    517          		}
    518          		// Input direction
    519          		else
    520          		{
    521          			// Upper
    522          			if(halfwordNum)
   \                     ??FIO_HalfWordSetDir_1:
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD003             BEQ.N    ??FIO_HalfWordSetDir_3
    523          			{
    524          				pFIO->FIODIRU &= ~bitValue;
   \   00000038   0x8841             LDRH     R1,[R0, #+2]
   \   0000003A   0x43B1             BICS     R1,R1,R6
   \   0000003C   0x8041             STRH     R1,[R0, #+2]
   \   0000003E   0xE002             B.N      ??FIO_HalfWordSetDir_0
    525          			}
    526          			// lower
    527          			else
    528          			{
    529          				pFIO->FIODIRL &= ~bitValue;
   \                     ??FIO_HalfWordSetDir_3:
   \   00000040   0x8801             LDRH     R1,[R0, #+0]
   \   00000042   0x43B1             BICS     R1,R1,R6
   \   00000044   0x8001             STRH     R1,[R0, #+0]
    530          			}
    531          		}
    532          	}
    533          }
   \                     ??FIO_HalfWordSetDir_0:
   \   00000046   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    534          
    535          
    536          /*********************************************************************//**
    537           * @brief		Set mask value for bits in FIO port in halfword accessible style
    538           * @param[in]	portNum		Port number, in range from 0 to 4
    539           * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
    540           * @param[in]	bitValue	Value that contains all bits in to set,
    541           * 							in range from 0 to 0xFFFF.
    542           * @param[in]	maskValue	Mask value contains state value for each bit:
    543           * 					- 0: not mask.
    544           * 					- 1: mask.
    545           * @return		None
    546           *
    547           * Note:
    548           * - All remaining bits that are not activated in bitValue (value '0')
    549           * will not be effected by this function.
    550           * - After executing this function, in mask register, value '0' on each bit
    551           * enables an access to the corresponding physical pin via a read or write access,
    552           * while value '1' on bit (masked) that corresponding pin will not be changed
    553           * with write access and if read, will not be reflected in the updated pin.
    554           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    555          void FIO_HalfWordSetMask(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t maskValue)
    556          {
   \                     FIO_HalfWordSetMask:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    557          	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       FIO_HalfWordGetPointer
    558          
    559          	if(pFIO != NULL)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD017             BEQ.N    ??FIO_HalfWordSetMask_0
    560          	{
    561          		// Mask
    562          		if (maskValue)
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD00A             BEQ.N    ??FIO_HalfWordSetMask_1
    563          		{
    564          			// Upper
    565          			if(halfwordNum)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD003             BEQ.N    ??FIO_HalfWordSetMask_2
    566          			{
    567          				pFIO->FIOMASKU |= bitValue;
   \   00000022   0x8A41             LDRH     R1,[R0, #+18]
   \   00000024   0x4331             ORRS     R1,R6,R1
   \   00000026   0x8241             STRH     R1,[R0, #+18]
   \   00000028   0xE00D             B.N      ??FIO_HalfWordSetMask_0
    568          			}
    569          			// lower
    570          			else
    571          			{
    572          				pFIO->FIOMASKL |= bitValue;
   \                     ??FIO_HalfWordSetMask_2:
   \   0000002A   0x8A01             LDRH     R1,[R0, #+16]
   \   0000002C   0x4331             ORRS     R1,R6,R1
   \   0000002E   0x8201             STRH     R1,[R0, #+16]
   \   00000030   0xE009             B.N      ??FIO_HalfWordSetMask_0
    573          			}
    574          		}
    575          		// Un-mask
    576          		else
    577          		{
    578          			// Upper
    579          			if(halfwordNum)
   \                     ??FIO_HalfWordSetMask_1:
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD003             BEQ.N    ??FIO_HalfWordSetMask_3
    580          			{
    581          				pFIO->FIOMASKU &= ~bitValue;
   \   00000038   0x8A41             LDRH     R1,[R0, #+18]
   \   0000003A   0x43B1             BICS     R1,R1,R6
   \   0000003C   0x8241             STRH     R1,[R0, #+18]
   \   0000003E   0xE002             B.N      ??FIO_HalfWordSetMask_0
    582          			}
    583          			// lower
    584          			else
    585          			{
    586          				pFIO->FIOMASKL &= ~bitValue;
   \                     ??FIO_HalfWordSetMask_3:
   \   00000040   0x8A01             LDRH     R1,[R0, #+16]
   \   00000042   0x43B1             BICS     R1,R1,R6
   \   00000044   0x8201             STRH     R1,[R0, #+16]
    587          			}
    588          		}
    589          	}
    590          }
   \                     ??FIO_HalfWordSetMask_0:
   \   00000046   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    591          
    592          
    593          /*********************************************************************//**
    594           * @brief		Set bits for FIO port in halfword accessible style
    595           * @param[in]	portNum		Port number, in range from 0 to 4
    596           * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
    597           * @param[in]	bitValue	Value that contains all bits in to set,
    598           * 							in range from 0 to 0xFFFF.
    599           * @return		None
    600           *
    601           * Note:
    602           * - For all bits that has been set as input direction, this function will
    603           * not effect.
    604           * - For all remaining bits that are not activated in bitValue (value '0')
    605           * will not be effected by this function.
    606           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    607          void FIO_HalfWordSetValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue)
    608          {
   \                     FIO_HalfWordSetValue:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    609          	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       FIO_HalfWordGetPointer
    610          
    611          	if(pFIO != NULL)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD005             BEQ.N    ??FIO_HalfWordSetValue_0
    612          	{
    613          		// Upper
    614          		if(halfwordNum)
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD001             BEQ.N    ??FIO_HalfWordSetValue_1
    615          		{
    616          			pFIO->FIOSETU = bitValue;
   \   0000001A   0x8346             STRH     R6,[R0, #+26]
   \   0000001C   0xE000             B.N      ??FIO_HalfWordSetValue_0
    617          		}
    618          		// lower
    619          		else
    620          		{
    621          			pFIO->FIOSETL = bitValue;
   \                     ??FIO_HalfWordSetValue_1:
   \   0000001E   0x8306             STRH     R6,[R0, #+24]
    622          		}
    623          	}
    624          }
   \                     ??FIO_HalfWordSetValue_0:
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    625          
    626          
    627          /*********************************************************************//**
    628           * @brief		Clear bits for FIO port in halfword accessible style
    629           * @param[in]	portNum		Port number, in range from 0 to 4
    630           * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
    631           * @param[in]	bitValue	Value that contains all bits in to clear,
    632           * 							in range from 0 to 0xFFFF.
    633           * @return		None
    634           *
    635           * Note:
    636           * - For all bits that has been set as input direction, this function will
    637           * not effect.
    638           * - For all remaining bits that are not activated in bitValue (value '0')
    639           * will not be effected by this function.
    640           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    641          void FIO_HalfWordClearValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue)
    642          {
   \                     FIO_HalfWordClearValue:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    643          	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       FIO_HalfWordGetPointer
    644          
    645          	if(pFIO != NULL)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD005             BEQ.N    ??FIO_HalfWordClearValue_0
    646          	{
    647          		// Upper
    648          		if(halfwordNum)
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD001             BEQ.N    ??FIO_HalfWordClearValue_1
    649          		{
    650          			pFIO->FIOCLRU = bitValue;
   \   0000001A   0x83C6             STRH     R6,[R0, #+30]
   \   0000001C   0xE000             B.N      ??FIO_HalfWordClearValue_0
    651          		}
    652          		// lower
    653          		else
    654          		{
    655          			pFIO->FIOCLRL = bitValue;
   \                     ??FIO_HalfWordClearValue_1:
   \   0000001E   0x8386             STRH     R6,[R0, #+28]
    656          		}
    657          	}
    658          }
   \                     ??FIO_HalfWordClearValue_0:
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    659          
    660          
    661          /*********************************************************************//**
    662           * @brief		Read Current state on port pin that have input direction of GPIO
    663           * 				in halfword accessible style.
    664           * @param[in]	portNum		Port number, in range from 0 to 4
    665           * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
    666           * @return		Current value of FIO port pin of specified halfword.
    667           * Note: Return value contain state of each port pin (bit) on that FIO regardless
    668           * its direction is input or output.
    669           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    670          uint16_t FIO_HalfWordReadValue(uint8_t portNum, uint8_t halfwordNum)
    671          {
   \                     FIO_HalfWordReadValue:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    672          	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       FIO_HalfWordGetPointer
   \   0000000E   0x0001             MOVS     R1,R0
    673          
    674          	if(pFIO != NULL)
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD006             BEQ.N    ??FIO_HalfWordReadValue_0
    675          	{
    676          		// Upper
    677          		if(halfwordNum)
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD001             BEQ.N    ??FIO_HalfWordReadValue_1
    678          		{
    679          			return (pFIO->FIOPINU);
   \   0000001A   0x8AC8             LDRH     R0,[R1, #+22]
   \   0000001C   0xE002             B.N      ??FIO_HalfWordReadValue_2
    680          		}
    681          		// lower
    682          		else
    683          		{
    684          			return (pFIO->FIOPINL);
   \                     ??FIO_HalfWordReadValue_1:
   \   0000001E   0x8A88             LDRH     R0,[R1, #+20]
   \   00000020   0xE000             B.N      ??FIO_HalfWordReadValue_2
    685          		}
    686          	}
    687          
    688          	return (0);
   \                     ??FIO_HalfWordReadValue_0:
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??FIO_HalfWordReadValue_2:
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    689          }
    690          
    691          
    692          /* FIO Byte accessible ------------------------------------------------------------ */
    693          
    694          /*********************************************************************//**
    695           * @brief		Set direction for FIO port in byte accessible style
    696           * @param[in]	portNum		Port number, in range from 0 to 4
    697           * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
    698           * @param[in]	bitValue	Value that contains all bits in to set direction,
    699           * 							in range from 0 to 0xFF.
    700           * @param[in]	dir			Direction value, should be:
    701           * 							- 0: Input.
    702           * 							- 1: Output.
    703           * @return		None
    704           *
    705           * Note: All remaining bits that are not activated in bitValue (value '0')
    706           * will not be effected by this function.
    707           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    708          void FIO_ByteSetDir(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t dir)
    709          {
   \                     FIO_ByteSetDir:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    710          	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       FIO_ByteGetPointer
    711          
    712          	if(pFIO != NULL)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD013             BEQ.N    ??FIO_ByteSetDir_0
    713          	{
    714          		// Output direction
    715          		if (dir)
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD008             BEQ.N    ??FIO_ByteSetDir_1
    716          		{
    717          			if (/*(byteNum >= 0) && */(byteNum <= 3))
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xDA0D             BGE.N    ??FIO_ByteSetDir_0
    718          			{
    719          				pFIO->FIODIR[byteNum] |= bitValue;
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x5C29             LDRB     R1,[R5, R0]
   \   00000026   0x4331             ORRS     R1,R6,R1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x5429             STRB     R1,[R5, R0]
   \   0000002C   0xE007             B.N      ??FIO_ByteSetDir_0
    720          			}
    721          		}
    722          		// Input direction
    723          		else
    724          		{
    725          			if (/*(byteNum >= 0) && */(byteNum <= 3))
   \                     ??FIO_ByteSetDir_1:
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D04             CMP      R5,#+4
   \   00000032   0xDA04             BGE.N    ??FIO_ByteSetDir_0
    726          			{
    727          				pFIO->FIODIR[byteNum] &= ~bitValue;
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x5C29             LDRB     R1,[R5, R0]
   \   00000038   0x43B1             BICS     R1,R1,R6
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x5429             STRB     R1,[R5, R0]
    728          			}
    729          		}
    730          	}
    731          }
   \                     ??FIO_ByteSetDir_0:
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    732          
    733          /*********************************************************************//**
    734           * @brief		Set mask value for bits in FIO port in byte accessible style
    735           * @param[in]	portNum		Port number, in range from 0 to 4
    736           * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
    737           * @param[in]	bitValue	Value that contains all bits in to set mask,
    738           * 							in range from 0 to 0xFF.
    739           * @param[in]	maskValue	Mask value contains state value for each bit:
    740           * 							- 0: not mask.
    741           * 							- 1: mask.
    742           * @return		None
    743           *
    744           * Note:
    745           * - All remaining bits that are not activated in bitValue (value '0')
    746           * will not be effected by this function.
    747           * - After executing this function, in mask register, value '0' on each bit
    748           * enables an access to the corresponding physical pin via a read or write access,
    749           * while value '1' on bit (masked) that corresponding pin will not be changed
    750           * with write access and if read, will not be reflected in the updated pin.
    751           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    752          void FIO_ByteSetMask(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t maskValue)
    753          {
   \                     FIO_ByteSetMask:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    754          	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       FIO_ByteGetPointer
    755          
    756          	if(pFIO != NULL)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD017             BEQ.N    ??FIO_ByteSetMask_0
    757          	{
    758          		// Mask
    759          		if (maskValue)
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD00A             BEQ.N    ??FIO_ByteSetMask_1
    760          		{
    761          			if (/*(byteNum >= 0) && */(byteNum <= 3))
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xDA11             BGE.N    ??FIO_ByteSetMask_0
    762          			{
    763          				pFIO->FIOMASK[byteNum] |= bitValue;
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x1829             ADDS     R1,R5,R0
   \   00000026   0x7C09             LDRB     R1,[R1, #+16]
   \   00000028   0x4331             ORRS     R1,R6,R1
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x182A             ADDS     R2,R5,R0
   \   0000002E   0x7411             STRB     R1,[R2, #+16]
   \   00000030   0xE009             B.N      ??FIO_ByteSetMask_0
    764          			}
    765          		}
    766          		// Un-mask
    767          		else {
    768          			if (/*(byteNum >= 0) && */(byteNum <= 3))
   \                     ??FIO_ByteSetMask_1:
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D04             CMP      R5,#+4
   \   00000036   0xDA06             BGE.N    ??FIO_ByteSetMask_0
    769          			{
    770          				pFIO->FIOMASK[byteNum] &= ~bitValue;
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x1829             ADDS     R1,R5,R0
   \   0000003C   0x7C09             LDRB     R1,[R1, #+16]
   \   0000003E   0x43B1             BICS     R1,R1,R6
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x182A             ADDS     R2,R5,R0
   \   00000044   0x7411             STRB     R1,[R2, #+16]
    771          			}
    772          		}
    773          	}
    774          }
   \                     ??FIO_ByteSetMask_0:
   \   00000046   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    775          
    776          
    777          /*********************************************************************//**
    778           * @brief		Set bits for FIO port in byte accessible style
    779           * @param[in]	portNum		Port number, in range from 0 to 4
    780           * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
    781           * @param[in]	bitValue	Value that contains all bits in to set,
    782           * 							in range from 0 to 0xFF.
    783           * @return		None
    784           *
    785           * Note:
    786           * - For all bits that has been set as input direction, this function will
    787           * not effect.
    788           * - For all remaining bits that are not activated in bitValue (value '0')
    789           * will not be effected by this function.
    790           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    791          void FIO_ByteSetValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue)
    792          {
   \                     FIO_ByteSetValue:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    793          	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       FIO_ByteGetPointer
    794          
    795          	if (pFIO != NULL) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD005             BEQ.N    ??FIO_ByteSetValue_0
    796          		if (/*(byteNum >= 0) && */(byteNum <= 3))
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D04             CMP      R5,#+4
   \   00000018   0xDA02             BGE.N    ??FIO_ByteSetValue_0
    797          		{
    798          			pFIO->FIOSET[byteNum] = bitValue;
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x1829             ADDS     R1,R5,R0
   \   0000001E   0x760E             STRB     R6,[R1, #+24]
    799          		}
    800          	}
    801          }
   \                     ??FIO_ByteSetValue_0:
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    802          
    803          
    804          /*********************************************************************//**
    805           * @brief		Clear bits for FIO port in byte accessible style
    806           * @param[in]	portNum		Port number, in range from 0 to 4
    807           * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
    808           * @param[in]	bitValue	Value that contains all bits in to clear,
    809           * 							in range from 0 to 0xFF.
    810           * @return		None
    811           *
    812           * Note:
    813           * - For all bits that has been set as input direction, this function will
    814           * not effect.
    815           * - For all remaining bits that are not activated in bitValue (value '0')
    816           * will not be effected by this function.
    817           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    818          void FIO_ByteClearValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue)
    819          {
   \                     FIO_ByteClearValue:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    820          	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       FIO_ByteGetPointer
    821          
    822          	if (pFIO != NULL)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD005             BEQ.N    ??FIO_ByteClearValue_0
    823          	{
    824          		if (/*(byteNum >= 0) && */(byteNum <= 3))
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D04             CMP      R5,#+4
   \   00000018   0xDA02             BGE.N    ??FIO_ByteClearValue_0
    825          		{
    826          			pFIO->FIOCLR[byteNum] = bitValue;
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x1829             ADDS     R1,R5,R0
   \   0000001E   0x770E             STRB     R6,[R1, #+28]
    827          		}
    828          	}
    829          }
   \                     ??FIO_ByteClearValue_0:
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    830          
    831          
    832          /*********************************************************************//**
    833           * @brief		Read Current state on port pin that have input direction of GPIO
    834           * 				in byte accessible style.
    835           * @param[in]	portNum		Port number, in range from 0 to 4
    836           * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
    837           * @return		Current value of FIO port pin of specified byte part.
    838           * Note: Return value contain state of each port pin (bit) on that FIO regardless
    839           * its direction is input or output.
    840           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    841          uint8_t FIO_ByteReadValue(uint8_t portNum, uint8_t byteNum)
    842          {
   \                     FIO_ByteReadValue:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    843          	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       FIO_ByteGetPointer
   \   0000000E   0x0001             MOVS     R1,R0
    844          
    845          	if (pFIO != NULL)
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD006             BEQ.N    ??FIO_ByteReadValue_0
    846          	{
    847          		if (/*(byteNum >= 0) && */(byteNum <= 3))
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D04             CMP      R5,#+4
   \   00000018   0xDA03             BGE.N    ??FIO_ByteReadValue_0
    848          		{
    849          			return (pFIO->FIOPIN[byteNum]);
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x1868             ADDS     R0,R5,R1
   \   0000001E   0x7D00             LDRB     R0,[R0, #+20]
   \   00000020   0xE000             B.N      ??FIO_ByteReadValue_1
    850          		}
    851          	}
    852          	return (0);
   \                     ??FIO_ByteReadValue_0:
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??FIO_ByteReadValue_1:
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    853          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x20098000         DC32     0x20098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x20098020         DC32     0x20098020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x20098040         DC32     0x20098040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x20098060         DC32     0x20098060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x20098080         DC32     0x20098080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x200980A0         DC32     0x200980a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x40028090         DC32     0x40028090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x400280B0         DC32     0x400280b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x40028094         DC32     0x40028094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x400280B4         DC32     0x400280b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x40028084         DC32     0x40028084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x400280A4         DC32     0x400280a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x40028088         DC32     0x40028088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x400280A8         DC32     0x400280a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x4002808C         DC32     0x4002808c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x400280AC         DC32     0x400280ac
    854          
    855          /**
    856           * @}
    857           */
    858          
    859          //#endif /* _GPIO */
    860          
    861          /**
    862           * @}
    863           */
    864          
    865          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   FIO_ByteClearValue
        16   -> FIO_ByteGetPointer
       0   FIO_ByteGetPointer
      16   FIO_ByteReadValue
        16   -> FIO_ByteGetPointer
      24   FIO_ByteSetDir
        24   -> FIO_ByteGetPointer
      24   FIO_ByteSetMask
        24   -> FIO_ByteGetPointer
      16   FIO_ByteSetValue
        16   -> FIO_ByteGetPointer
      16   FIO_ClearInt
        16   -> GPIO_ClearInt
      16   FIO_ClearValue
        16   -> GPIO_ClearValue
      16   FIO_GetIntStatus
        16   -> GPIO_GetIntStatus
      16   FIO_HalfWordClearValue
        16   -> FIO_HalfWordGetPointer
       0   FIO_HalfWordGetPointer
      16   FIO_HalfWordReadValue
        16   -> FIO_HalfWordGetPointer
      24   FIO_HalfWordSetDir
        24   -> FIO_HalfWordGetPointer
      24   FIO_HalfWordSetMask
        24   -> FIO_HalfWordGetPointer
      16   FIO_HalfWordSetValue
        16   -> FIO_HalfWordGetPointer
      16   FIO_IntCmd
        16   -> GPIO_IntCmd
       8   FIO_ReadValue
         8   -> GPIO_ReadValue
      16   FIO_SetDir
        16   -> GPIO_SetDir
      16   FIO_SetMask
        16   -> GPIO_GetPointer
      16   FIO_SetValue
        16   -> GPIO_SetValue
       0   GPIO_ClearInt
      16   GPIO_ClearValue
        16   -> GPIO_GetPointer
       0   GPIO_GetIntStatus
       0   GPIO_GetPointer
       0   GPIO_IntCmd
      16   GPIO_OutputValue
        16   -> GPIO_ClearValue
        16   -> GPIO_SetValue
       8   GPIO_ReadValue
         8   -> GPIO_GetPointer
      16   GPIO_SetDir
        16   -> GPIO_GetPointer
      16   GPIO_SetValue
        16   -> GPIO_GetPointer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      34  FIO_ByteClearValue
      56  FIO_ByteGetPointer
      38  FIO_ByteReadValue
      64  FIO_ByteSetDir
      72  FIO_ByteSetMask
      34  FIO_ByteSetValue
      18  FIO_ClearInt
      18  FIO_ClearValue
      24  FIO_GetIntStatus
      34  FIO_HalfWordClearValue
      66  FIO_HalfWordGetPointer
      38  FIO_HalfWordReadValue
      72  FIO_HalfWordSetDir
      72  FIO_HalfWordSetMask
      34  FIO_HalfWordSetValue
      24  FIO_IntCmd
      14  FIO_ReadValue
      24  FIO_SetDir
      42  FIO_SetMask
      18  FIO_SetValue
      28  GPIO_ClearInt
      22  GPIO_ClearValue
     102  GPIO_GetIntStatus
      66  GPIO_GetPointer
      76  GPIO_IntCmd
      38  GPIO_OutputValue
      26  GPIO_ReadValue
      42  GPIO_SetDir
      22  GPIO_SetValue

 
 1 282 bytes in section .text
 
 1 282 bytes of CODE memory

Errors: none
Warnings: none
