###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      20/Mar/2017  17:17:58 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\桌面\RTU_1.2\cmsis\Drivers\source\lpc177x_8x #
#                    _i2c.c                                                   #
#    Command line =  D:\wangfan2\桌面\RTU_1.2\cmsis\Drivers\source\lpc177x_8x #
#                    _i2c.c -lCN D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\L #
#                    ist\ -o D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\Obj\  #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\桌面\RTU_1.2\project\iar\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\ADC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RTC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\TILT\ -I  #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RDLevel\  #
#                    -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\RS232\ #
#                     -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\OS-v2 #
#                    \ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\BSP\Vibr #
#                    ationString\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\ #
#                    ..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\ucos2\uCOS-II #
#                    \Source\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\u #
#                    cos2\uC-LIB\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\ #
#                    ..\ucos2\uC-CPU\ -I D:\wangfan2\桌面\RTU_1.2\project\iar #
#                    \..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I                #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\cmsis\Drivers #
#                    \source\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\c #
#                    msis\Drivers\include\ -I D:\wangfan2\桌面\RTU_1.2\projec #
#                    t\iar\..\..\app\ -I D:\wangfan2\桌面\RTU_1.2\project\iar #
#                    \..\..\uC-Probe\Target\Plugins\uCOS-II\ -I               #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Workspaces\ -I                            #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Source\ -I D:\wangfan2\桌面\RTU_1.2\proje #
#                    ct\iar\..\..\uC-Probe\Target\Communication\Generic\Sourc #
#                    e\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Prob #
#                    e\Target\Communication\Generic\RS-232\Source\ -I         #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\Ports\NXP\LPC17xx\ -I    #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\OS\uCOS-II\ -I           #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\cmsis\Core\CM #
#                    3\CoreSupport\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\. #
#                    .\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\ -I  #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\DEVI #
#                    CE_BT\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\Hua #
#                    ceApp\DEVICE_COM\ -I D:\wangfan2\桌面\RTU_1.2\project\ia #
#                    r\..\..\HuaceApp\DEVICE_GPRS\ -I                         #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp\DEVI #
#                    CE_GPS\ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\Hu #
#                    aceApp\DEVICE_RADIO\ -I D:\wangfan2\桌面\RTU_1.2\project #
#                    \iar\..\..\HuaceApp\iap\ -I                              #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\FatFs\ -I     #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\USB\ -I       #
#                    D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\bsp\spi_flash #
#                    \ -I D:\wangfan2\桌面\RTU_1.2\project\iar\..\..\HuaceApp #
#                    \LED\ -On --use_c++_inline                               #
#    List file    =  D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\List\lpc177x_ #
#                    8x_i2c.lst                                               #
#    Object file  =  D:\wangfan2\桌面\RTU_1.2\project\iar\Debug\Obj\lpc177x_8 #
#                    x_i2c.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\桌面\RTU_1.2\cmsis\Drivers\source\lpc177x_8x_i2c.c
      1          /**********************************************************************
      2          * $Id$		lpc177x_8x_i2c.c			2011-06-02
      3          *//**
      4          * @file		lpc177x_8x_i2c.c
      5          * @brief	Contains all functions support for I2C firmware library
      6          *			on LPC177x_8x
      7          * @version	1.0
      8          * @date		02. June. 2011
      9          * @author	NXP MCU SW Application Team
     10          * 
     11          * Copyright(C) 2011, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          **********************************************************************/
     26          
     27          /* Peripheral group ----------------------------------------------------------- */
     28          /** @addtogroup I2C
     29           * @{
     30           */
     31          
     32          /* Includes ------------------------------------------------------------------- */
     33          #include "lpc177x_8x_i2c.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable10  ;; 0xe000e100
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable10_1  ;; 0xe000e180
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
     34          #include "lpc177x_8x_clkpwr.h"
     35          #include "lpc177x_8x_pinsel.h"
     36          #include <Global.h>
     37          
     38          /* Private Types -------------------------------------------------------------- */
     39          /** @defgroup I2C_Private_Types I2C Private Types
     40           * @{
     41           */
     42          
     43          /**
     44           * @brief I2C device configuration structure type
     45           */
     46          typedef struct
     47          {
     48            uint32_t      txrx_setup; 						/* Transmission setup */
     49            int32_t		dir;								/* Current direction phase, 0 - write, 1 - read */
     50          } I2C_CFG_T;
     51          
     52          /**
     53           * @}
     54           */
     55          
     56          /* Private Variables ---------------------------------------------------------- */
     57          /**
     58           * @brief II2C driver data for I2C0, I2C1 and I2C2
     59           */

   \                                 In section .bss, align 4
     60          static I2C_CFG_T i2cdat[3];
   \                     i2cdat:
   \   00000000                      DS8 24
     61          

   \                                 In section .bss, align 4
     62          static uint32_t I2C_MasterComplete[3];
   \                     I2C_MasterComplete:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     63          static uint32_t I2C_SlaveComplete[3];
   \                     I2C_SlaveComplete:
   \   00000000                      DS8 12
     64          

   \                                 In section .bss, align 4
     65          static uint32_t I2C_MonitorBufferIndex;
   \                     I2C_MonitorBufferIndex:
   \   00000000                      DS8 4
     66          
     67          /* Private Functions ---------------------------------------------------------- */
     68          
     69          /* Get pointer to expected I2C */
     70          static LPC_I2C_TypeDef* I2C_GetPointer(en_I2C_unitId compId);
     71          
     72          /* Get I2C number */
     73          //static int32_t I2C_getNum(LPC_I2C_TypeDef *I2Cx);
     74          
     75          /* Generate a start condition on I2C bus (in master mode only) */
     76          static uint32_t I2C_Start (LPC_I2C_TypeDef *I2Cx);
     77          
     78          /* Generate a stop condition on I2C bus (in master mode only) */
     79          static void I2C_Stop (LPC_I2C_TypeDef *I2Cx);
     80          
     81          /* I2C send byte subroutine */
     82          static uint32_t I2C_SendByte (LPC_I2C_TypeDef *I2Cx, uint8_t databyte);
     83          
     84          /* I2C get byte subroutine */
     85          static uint32_t I2C_GetByte (LPC_I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack);
     86          
     87          /* I2C set clock (hz) */
     88          //static void I2C_SetClock (LPC_I2C_TypeDef *I2Cx, uint32_t target_clock);
     89          
     90          /*--------------------------------------------------------------------------------*/
     91          
     92          /********************************************************************//**
     93           * @brief		Convert from I2C peripheral to number
     94           * @param[in]	I2Cx: I2C peripheral selected, should be:
     95           * 				- LPC_I2C0
     96           * 				- LPC_I2C1
     97           * 				- LPC_I2C2
     98           * @return 		I2C number, could be: 0..2
     99           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    100          static LPC_I2C_TypeDef* I2C_GetPointer(en_I2C_unitId compId)
    101          {
   \                     I2C_GetPointer:
   \   00000000   0x0001             MOVS     R1,R0
    102          	LPC_I2C_TypeDef* pI2C;
    103          
    104          	switch (compId)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD003             BEQ.N    ??I2C_GetPointer_0
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xD009             BEQ.N    ??I2C_GetPointer_1
   \   0000000C   0xD304             BCC.N    ??I2C_GetPointer_2
   \   0000000E   0xE00B             B.N      ??I2C_GetPointer_3
    105          	{
    106          		case I2C_0:
    107          			pI2C = LPC_I2C0;
   \                     ??I2C_GetPointer_0:
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable10_2  ;; 0x4001c000
   \   00000014   0x0010             MOVS     R0,R2
    108          			break;
   \   00000016   0xE009             B.N      ??I2C_GetPointer_4
    109          
    110          		case I2C_1:
    111          			pI2C = LPC_I2C1;
   \                     ??I2C_GetPointer_2:
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable10_3  ;; 0x4005c000
   \   0000001C   0x0010             MOVS     R0,R2
    112          			break;
   \   0000001E   0xE005             B.N      ??I2C_GetPointer_4
    113          
    114          		case I2C_2:
    115          			pI2C = LPC_I2C2;
   \                     ??I2C_GetPointer_1:
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable10_4  ;; 0x400a0000
   \   00000024   0x0010             MOVS     R0,R2
    116          			break;
   \   00000026   0xE001             B.N      ??I2C_GetPointer_4
    117          
    118          		default:
    119          			pI2C = NULL;
   \                     ??I2C_GetPointer_3:
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x0010             MOVS     R0,R2
    120          			break;
    121          	}
    122          
    123          	return pI2C;
   \                     ??I2C_GetPointer_4:
   \   0000002C   0x4770             BX       LR               ;; return
    124          }
    125          
    126          
    127          /********************************************************************//**
    128           * @brief		Convert from I2C peripheral to number
    129           * @param[in]	I2Cx: I2C peripheral selected, should be:
    130           * 				- LPC_I2C0
    131           * 				- LPC_I2C1
    132           * 				- LPC_I2C2
    133           * @return 		I2C number, could be: 0..2
    134           *********************************************************************/
    135          /*
    136          static int32_t I2C_getNum(LPC_I2C_TypeDef *I2Cx)
    137          {
    138          	if (I2Cx == LPC_I2C0)
    139          	{
    140          		return (0);
    141          	}
    142          	else if (I2Cx == LPC_I2C1)
    143          	{
    144          		return (1);
    145          	}
    146          	else if (I2Cx == LPC_I2C2)
    147          	{
    148          		return (2);
    149          	}
    150          
    151          	return (-1);
    152          }
    153          */
    154          /********************************************************************//**
    155           * @brief		Generate a start condition on I2C bus (in master mode only)
    156           * @param[in]	I2Cx: I2C peripheral selected, should be:
    157           * 				- LPC_I2C0
    158           * 				- LPC_I2C1
    159           * 				- LPC_I2C2
    160           * @return 		value of I2C status register after generate a start condition
    161           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    162          static uint32_t I2C_Start (LPC_I2C_TypeDef *I2Cx)
    163          {
   \                     I2C_Start:
   \   00000000   0x0001             MOVS     R1,R0
    164          	uint32_t i = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    165                  I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x6188             STR      R0,[R1, #+24]
    166          
    167          	I2Cx->CONSET = I2C_I2CONSET_STA;
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    168          
    169          	// Wait for complete
    170          	while (!(I2Cx->CONSET & I2C_I2CONSET_SI))
   \                     ??I2C_Start_0:
   \   0000000C   0x6808             LDR      R0,[R1, #+0]
   \   0000000E   0x0700             LSLS     R0,R0,#+28
   \   00000010   0xD406             BMI.N    ??I2C_Start_1
    171                  {
    172                      i++;
   \   00000012   0x1C52             ADDS     R2,R2,#+1
    173                      if(i >= 0xffff)
   \   00000014   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000018   0x4282             CMP      R2,R0
   \   0000001A   0xD3F7             BCC.N    ??I2C_Start_0
    174                      {             
    175                          return i;                
   \   0000001C   0x0010             MOVS     R0,R2
   \   0000001E   0xE004             B.N      ??I2C_Start_2
    176                      }
    177                  }
    178          	I2Cx->CONCLR = I2C_I2CONCLR_STAC;
   \                     ??I2C_Start_1:
   \   00000020   0x2020             MOVS     R0,#+32
   \   00000022   0x6188             STR      R0,[R1, #+24]
    179          
    180          	return (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
   \   00000024   0x6848             LDR      R0,[R1, #+4]
   \   00000026   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \                     ??I2C_Start_2:
   \   0000002A   0x4770             BX       LR               ;; return
    181          }
    182          
    183          /********************************************************************//**
    184           * @brief		Generate a stop condition on I2C bus (in master mode only)
    185           * @param[in]	I2Cx: I2C peripheral selected, should be:
    186           * 				- LPC_I2C0
    187           * 				- LPC_I2C1
    188           * 				- LPC_I2C2
    189           * @return 		None
    190           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    191          static void I2C_Stop (LPC_I2C_TypeDef *I2Cx)
    192          {
    193          	/* Make sure start bit is not active */
    194          	if (I2Cx->CONSET & I2C_I2CONSET_STA)
   \                     I2C_Stop:
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x0689             LSLS     R1,R1,#+26
   \   00000004   0xD501             BPL.N    ??I2C_Stop_0
    195          	{
    196          		I2Cx->CONCLR = I2C_I2CONCLR_STAC;
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0x6181             STR      R1,[R0, #+24]
    197          	}
    198          
    199          	I2Cx->CONSET = I2C_I2CONSET_STO;
   \                     ??I2C_Stop_0:
   \   0000000A   0x2110             MOVS     R1,#+16
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    200          
    201          	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   0000000E   0x2108             MOVS     R1,#+8
   \   00000010   0x6181             STR      R1,[R0, #+24]
    202          }
   \   00000012   0x4770             BX       LR               ;; return
    203          
    204          /********************************************************************//**
    205           * @brief		Send a byte
    206           * @param[in]	I2Cx: I2C peripheral selected, should be:
    207           * 				- LPC_I2C0
    208           * 				- LPC_I2C1
    209           * 				- LPC_I2C2
    210           * @param[in]	databyte: number of byte
    211           * @return 		value of I2C status register after sending
    212           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    213          static uint32_t I2C_SendByte (LPC_I2C_TypeDef *I2Cx, uint8_t databyte)
    214          {
   \                     I2C_SendByte:
   \   00000000   0x0002             MOVS     R2,R0
    215          	uint32_t i = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    216          	/* Make sure start bit is not active */
    217          	if (I2Cx->CONSET & I2C_I2CONSET_STA)
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x0680             LSLS     R0,R0,#+26
   \   00000008   0xD501             BPL.N    ??I2C_SendByte_0
    218          	{
    219          		I2Cx->CONCLR = I2C_I2CONCLR_STAC;
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x6190             STR      R0,[R2, #+24]
    220          	}
    221          
    222          	I2Cx->DAT = databyte & I2C_I2DAT_BITMASK;
   \                     ??I2C_SendByte_0:
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x6091             STR      R1,[R2, #+8]
    223          
    224          	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   00000012   0x2008             MOVS     R0,#+8
   \   00000014   0x6190             STR      R0,[R2, #+24]
    225          
    226          	while (!(I2Cx->CONSET & I2C_I2CONSET_SI))
   \                     ??I2C_SendByte_1:
   \   00000016   0x6810             LDR      R0,[R2, #+0]
   \   00000018   0x0700             LSLS     R0,R0,#+28
   \   0000001A   0xD406             BMI.N    ??I2C_SendByte_2
    227          	{
    228          		i++;
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
    229          		if(i >= 0xffff)
   \   0000001E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000022   0x4283             CMP      R3,R0
   \   00000024   0xD3F7             BCC.N    ??I2C_SendByte_1
    230          		{             
    231          			return i;                
   \   00000026   0x0018             MOVS     R0,R3
   \   00000028   0xE002             B.N      ??I2C_SendByte_3
    232          		}
    233          	}
    234          
    235          	return (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
   \                     ??I2C_SendByte_2:
   \   0000002A   0x6850             LDR      R0,[R2, #+4]
   \   0000002C   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \                     ??I2C_SendByte_3:
   \   00000030   0x4770             BX       LR               ;; return
    236          }
    237          
    238          /********************************************************************//**
    239           * @brief		Get a byte
    240           * @param[in]	I2Cx: I2C peripheral selected, should be:
    241           * 				- LPC_I2C0
    242           * 				- LPC_I2C1
    243           * 				- LPC_I2C2
    244           * @param[out]	retdat	pointer to return data
    245           * @param[in]	ack		assert acknowledge or not, should be: TRUE/FALSE
    246           * @return 		value of I2C status register after sending
    247           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    248          static uint32_t I2C_GetByte (LPC_I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack)
    249          {
    250          	if (ack == TRUE)
   \                     I2C_GetByte:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A01             CMP      R2,#+1
   \   00000004   0xD102             BNE.N    ??I2C_GetByte_0
    251          	{
    252          		I2Cx->CONSET = I2C_I2CONSET_AA;
   \   00000006   0x2304             MOVS     R3,#+4
   \   00000008   0x6003             STR      R3,[R0, #+0]
   \   0000000A   0xE001             B.N      ??I2C_GetByte_1
    253          	}
    254          	else
    255          	{
    256          		I2Cx->CONCLR = I2C_I2CONCLR_AAC;
   \                     ??I2C_GetByte_0:
   \   0000000C   0x2304             MOVS     R3,#+4
   \   0000000E   0x6183             STR      R3,[R0, #+24]
    257          	}
    258          
    259          	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_GetByte_1:
   \   00000010   0x2308             MOVS     R3,#+8
   \   00000012   0x6183             STR      R3,[R0, #+24]
    260          
    261          	while (!(I2Cx->CONSET & I2C_I2CONSET_SI));
   \                     ??I2C_GetByte_2:
   \   00000014   0x6803             LDR      R3,[R0, #+0]
   \   00000016   0x071B             LSLS     R3,R3,#+28
   \   00000018   0xD5FC             BPL.N    ??I2C_GetByte_2
    262          
    263          	*retdat = (uint8_t) (I2Cx->DAT & I2C_I2DAT_BITMASK);
   \   0000001A   0x6883             LDR      R3,[R0, #+8]
   \   0000001C   0x700B             STRB     R3,[R1, #+0]
    264          
    265          	return (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000024   0x4770             BX       LR               ;; return
    266          }
    267          
    268          /*********************************************************************//**
    269           * @brief 		Setup clock rate for I2C peripheral
    270           * @param[in] 	I2Cx	I2C peripheral selected, should be:
    271           * 				- LPC_I2C0
    272           * 				- LPC_I2C1
    273           * 				- LPC_I2C2
    274           * @param[in]	target_clock : clock of SSP (Hz)
    275           * @return 		None
    276           ***********************************************************************/
    277          /*
    278          static void I2C_SetClock (LPC_I2C_TypeDef *I2Cx, uint32_t target_clock)
    279          {
    280          	uint32_t temp;
    281          
    282          	temp = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER) / target_clock;
    283          
    284          	// Set the I2C clock value to register
    285          	I2Cx->SCLH = (uint32_t)(temp / 2);
    286          
    287          	I2Cx->SCLL = (uint32_t)(temp - I2Cx->SCLH);
    288          }
    289          */
    290          
    291          /* End of Private Functions --------------------------------------------------- */
    292          
    293          
    294          /* Public Functions ----------------------------------------------------------- */
    295          /** @addtogroup I2C_Public_Functions
    296           * @{
    297           */
    298          
    299          /********************************************************************//**
    300           * @brief		Initializes the I2Cx peripheral with specified parameter.
    301           * @param[in]	I2Cx	I2C peripheral selected, should be
    302           * 				- LPC_I2C0
    303           * 				- LPC_I2C1
    304           * 				- LPC_I2C2
    305           * @param[in]	clockrate Target clock rate value to initialized I2C
    306           * 				peripheral (Hz)
    307           * @return 		None
    308           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    309          void I2C_Init(uint8_t i2cId, uint32_t clockrate)
    310          {
   \                     I2C_Init:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    311          	uint32_t clkSetting, clkRate;
    312          
    313          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       I2C_GetPointer
   \   00000010   0x4680             MOV      R8,R0
    314          
    315          	switch (i2cId)
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD003             BEQ.N    ??I2C_Init_0
   \   00000018   0x2C02             CMP      R4,#+2
   \   0000001A   0xD008             BEQ.N    ??I2C_Init_1
   \   0000001C   0xD303             BCC.N    ??I2C_Init_2
   \   0000001E   0xE00A             B.N      ??I2C_Init_3
    316          	{
    317          		case I2C_0:
    318          			clkSetting = CLKPWR_PCONP_PCI2C0;
   \                     ??I2C_Init_0:
   \   00000020   0x2080             MOVS     R0,#+128
   \   00000022   0x0006             MOVS     R6,R0
    319          			break;
   \   00000024   0xE008             B.N      ??I2C_Init_4
    320          
    321          
    322          		case I2C_1:
    323          			clkSetting = CLKPWR_PCONP_PCI2C1;
   \                     ??I2C_Init_2:
   \   00000026   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000002A   0x0006             MOVS     R6,R0
    324          			break;
   \   0000002C   0xE004             B.N      ??I2C_Init_4
    325          
    326          		case I2C_2:
    327          			clkSetting = CLKPWR_PCONP_PCI2C2;
   \                     ??I2C_Init_1:
   \   0000002E   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000032   0x0006             MOVS     R6,R0
    328          			break;
   \   00000034   0xE000             B.N      ??I2C_Init_4
    329          
    330          		default:
    331          
    332          			return;
   \                     ??I2C_Init_3:
   \   00000036   0xE014             B.N      ??I2C_Init_5
    333          	}
    334          
    335          	CLKPWR_ConfigPPWR (clkSetting, ENABLE);
   \                     ??I2C_Init_4:
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    336          
    337          	/* Set clock rate */
    338          	clkRate= CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER) / clockrate;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       CLKPWR_GetCLK
   \   00000046   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   0000004A   0x0007             MOVS     R7,R0
    339          
    340          	/* Set the I2C clock value to register */
    341          	I2Cx->SCLH = (uint32_t)(clkRate / 2);
   \   0000004C   0x0878             LSRS     R0,R7,#+1
   \   0000004E   0xF8C8 0x0010      STR      R0,[R8, #+16]
    342          
    343          	I2Cx->SCLL = (uint32_t)(clkRate - I2Cx->SCLH);
   \   00000052   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   00000056   0x1A38             SUBS     R0,R7,R0
   \   00000058   0xF8C8 0x0014      STR      R0,[R8, #+20]
    344          
    345              /* Set I2C operation to default */
    346              I2Cx->CONCLR = (I2C_I2CONCLR_AAC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_I2ENC);
   \   0000005C   0x2064             MOVS     R0,#+100
   \   0000005E   0xF8C8 0x0018      STR      R0,[R8, #+24]
    347          }
   \                     ??I2C_Init_5:
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    348          
    349          /*********************************************************************//**
    350           * @brief		De-initializes the I2C peripheral registers to their
    351           *                  default reset values.
    352           * @param[in]	I2Cx	I2C peripheral selected, should be
    353           *  			- LPC_I2C0
    354           * 				- LPC_I2C1
    355           * 				- LPC_I2C2
    356           * @return 		None
    357           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    358          void I2C_DeInit(uint8_t i2cId)
    359          {
   \                     I2C_DeInit:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    360          	uint32_t clkSetting;
    361          
    362          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       I2C_GetPointer
   \   0000000C   0x0006             MOVS     R6,R0
    363          
    364          	/* Disable I2C control */
    365          	I2Cx->CONCLR = I2C_I2CONCLR_I2ENC;
   \   0000000E   0x2040             MOVS     R0,#+64
   \   00000010   0x61B0             STR      R0,[R6, #+24]
    366          
    367          	switch (i2cId)
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD003             BEQ.N    ??I2C_DeInit_0
   \   00000018   0x2C02             CMP      R4,#+2
   \   0000001A   0xD008             BEQ.N    ??I2C_DeInit_1
   \   0000001C   0xD303             BCC.N    ??I2C_DeInit_2
   \   0000001E   0xE00A             B.N      ??I2C_DeInit_3
    368          	{
    369          		case I2C_0:
    370          			clkSetting = CLKPWR_PCONP_PCI2C0;
   \                     ??I2C_DeInit_0:
   \   00000020   0x2080             MOVS     R0,#+128
   \   00000022   0x0005             MOVS     R5,R0
    371          			break;
   \   00000024   0xE008             B.N      ??I2C_DeInit_4
    372          
    373          
    374          		case I2C_1:
    375          			clkSetting = CLKPWR_PCONP_PCI2C1;
   \                     ??I2C_DeInit_2:
   \   00000026   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000002A   0x0005             MOVS     R5,R0
    376          			break;
   \   0000002C   0xE004             B.N      ??I2C_DeInit_4
    377          
    378          		case I2C_2:
    379          			clkSetting = CLKPWR_PCONP_PCI2C2;
   \                     ??I2C_DeInit_1:
   \   0000002E   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000032   0x0005             MOVS     R5,R0
    380          			break;
   \   00000034   0xE000             B.N      ??I2C_DeInit_4
    381          
    382          		default:
    383          
    384          			return;
   \                     ??I2C_DeInit_3:
   \   00000036   0xE003             B.N      ??I2C_DeInit_5
    385          	}
    386          
    387          	CLKPWR_ConfigPPWR (clkSetting, DISABLE);
   \                     ??I2C_DeInit_4:
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    388          }
   \                     ??I2C_DeInit_5:
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
    389          
    390          /*********************************************************************//**
    391           * @brief		Enable or disable I2C peripheral's operation
    392           * @param[in]	I2Cx I2C peripheral selected, should be
    393           *  			- LPC_I2C0
    394           * 				- LPC_I2C1
    395           * 				- LPC_I2C2
    396           * @param[in]	NewState New State of I2Cx peripheral's operation
    397           * @return 		none
    398           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    399          void I2C_Cmd(uint8_t i2cId, FunctionalState NewState)
    400          {
   \                     I2C_Cmd:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    401          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       I2C_GetPointer
    402          
    403          	if (NewState == ENABLE)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xD102             BNE.N    ??I2C_Cmd_0
    404          	{
    405          		I2Cx->CONSET = I2C_I2CONSET_I2EN;
   \   00000014   0x2140             MOVS     R1,#+64
   \   00000016   0x6001             STR      R1,[R0, #+0]
   \   00000018   0xE001             B.N      ??I2C_Cmd_1
    406          	}
    407          	else
    408          	{
    409          		I2Cx->CONCLR = I2C_I2CONCLR_I2ENC;
   \                     ??I2C_Cmd_0:
   \   0000001A   0x2140             MOVS     R1,#+64
   \   0000001C   0x6181             STR      R1,[R0, #+24]
    410          	}
    411          }
   \                     ??I2C_Cmd_1:
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    412          
    413          /*********************************************************************//**
    414           * @brief 		Enable/Disable interrupt for I2C peripheral
    415           * @param[in]	I2Cx	I2C peripheral selected, should be:
    416           * 				- LPC_I2C0
    417           * 				- LPC_I2C1
    418           * 				- LPC_I2C2
    419           * @param[in]	NewState	New State of I2C peripheral interrupt in NVIC core
    420           * 				should be:
    421           * 				- ENABLE: enable interrupt for this I2C peripheral
    422           * 				- DISABLE: disable interrupt for this I2C peripheral
    423           * @return 		None
    424           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    425          void I2C_IntCmd (uint8_t i2cId, Bool NewState)
    426          {
   \                     I2C_IntCmd:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    427          	IRQn_Type irq;
    428          
    429          	switch (i2cId)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD003             BEQ.N    ??I2C_IntCmd_0
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD007             BEQ.N    ??I2C_IntCmd_1
   \   00000010   0xD303             BCC.N    ??I2C_IntCmd_2
   \   00000012   0xE008             B.N      ??I2C_IntCmd_3
    430          	{
    431          		case I2C_0:
    432          			irq = I2C0_IRQn;
   \                     ??I2C_IntCmd_0:
   \   00000014   0x200A             MOVS     R0,#+10
   \   00000016   0x0006             MOVS     R6,R0
    433          			break;
   \   00000018   0xE006             B.N      ??I2C_IntCmd_4
    434          
    435          		case I2C_1:
    436          			irq = I2C1_IRQn;
   \                     ??I2C_IntCmd_2:
   \   0000001A   0x200B             MOVS     R0,#+11
   \   0000001C   0x0006             MOVS     R6,R0
    437          			break;
   \   0000001E   0xE003             B.N      ??I2C_IntCmd_4
    438          
    439          		case I2C_2:
    440          			irq = I2C2_IRQn;
   \                     ??I2C_IntCmd_1:
   \   00000020   0x200C             MOVS     R0,#+12
   \   00000022   0x0006             MOVS     R6,R0
    441          			break;
   \   00000024   0xE000             B.N      ??I2C_IntCmd_4
    442          
    443          		default:
    444          
    445          			return;
   \                     ??I2C_IntCmd_3:
   \   00000026   0xE00B             B.N      ??I2C_IntCmd_5
    446          	}
    447          
    448          	if (NewState)
   \                     ??I2C_IntCmd_4:
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD004             BEQ.N    ??I2C_IntCmd_6
    449          	{
    450          		NVIC_EnableIRQ(irq);
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       NVIC_EnableIRQ
   \   00000036   0xE003             B.N      ??I2C_IntCmd_7
    451          	}
    452          	else
    453          	{
    454          		NVIC_DisableIRQ(irq);
   \                     ??I2C_IntCmd_6:
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000003C   0x.... 0x....      BL       NVIC_DisableIRQ
    455          	}
    456          
    457              return;
   \                     ??I2C_IntCmd_7:
   \                     ??I2C_IntCmd_5:
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
    458          }
    459          
    460          
    461          /*********************************************************************//**
    462           * @brief 		General Master Interrupt handler for I2C peripheral
    463           * @param[in]	I2Cx	I2C peripheral selected, should be:
    464           * 				- LPC_I2C
    465           * 				- LPC_I2C1
    466           * 				- LPC_I2C2
    467           * @return 		None
    468           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    469          void I2C_MasterHandler(uint8_t i2cId)
    470          {
   \                     I2C_MasterHandler:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    471          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       I2C_GetPointer
   \   0000000C   0x0005             MOVS     R5,R0
    472          
    473          	uint8_t returnCode;
    474          	I2C_M_SETUP_Type *txrx_setup;
    475          
    476          	txrx_setup = (I2C_M_SETUP_Type *) i2cdat[i2cId].txrx_setup;
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000014   0xF850 0x0034      LDR      R0,[R0, R4, LSL #+3]
   \   00000018   0x0007             MOVS     R7,R0
    477          
    478          	returnCode = (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
   \   0000001A   0x6868             LDR      R0,[R5, #+4]
   \   0000001C   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000020   0x0006             MOVS     R6,R0
    479          
    480          	// Save current status
    481          	txrx_setup->status = returnCode;
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0x627E             STR      R6,[R7, #+36]
    482          
    483          	// there's no relevant information
    484          	if (returnCode == I2C_I2STAT_NO_INF)
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x2EF8             CMP      R6,#+248
   \   0000002A   0xD102             BNE.N    ??I2C_MasterHandler_0
    485          	{
    486          		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   0000002C   0x2008             MOVS     R0,#+8
   \   0000002E   0x61A8             STR      R0,[R5, #+24]
    487          		return;
   \   00000030   0xE0F0             B.N      ??I2C_MasterHandler_1
    488          	}
    489          
    490          	/* ----------------------------- TRANSMIT PHASE --------------------------*/
    491          	if (i2cdat[i2cId].dir == 0)
   \                     ??I2C_MasterHandler_0:
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000038   0xEB10 0x00C4      ADDS     R0,R0,R4, LSL #+3
   \   0000003C   0x6840             LDR      R0,[R0, #+4]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD159             BNE.N    ??I2C_MasterHandler_2
    492          	{
    493          		switch (returnCode)
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0x2808             CMP      R0,#+8
   \   00000048   0xD00C             BEQ.N    ??I2C_MasterHandler_3
   \   0000004A   0x2810             CMP      R0,#+16
   \   0000004C   0xD00A             BEQ.N    ??I2C_MasterHandler_3
   \   0000004E   0x2818             CMP      R0,#+24
   \   00000050   0xD017             BEQ.N    ??I2C_MasterHandler_4
   \   00000052   0x2820             CMP      R0,#+32
   \   00000054   0xD045             BEQ.N    ??I2C_MasterHandler_5
   \   00000056   0x2828             CMP      R0,#+40
   \   00000058   0xD013             BEQ.N    ??I2C_MasterHandler_4
   \   0000005A   0x2830             CMP      R0,#+48
   \   0000005C   0xD041             BEQ.N    ??I2C_MasterHandler_5
   \   0000005E   0x2838             CMP      R0,#+56
   \   00000060   0xD044             BEQ.N    ??I2C_MasterHandler_6
   \   00000062   0xE047             B.N      ??I2C_MasterHandler_7
    494          		{
    495          			/* A start/repeat start condition has been transmitted -------------------*/
    496          			case I2C_I2STAT_M_TX_START:
    497          
    498          			case I2C_I2STAT_M_TX_RESTART:
    499          				I2Cx->CONCLR = I2C_I2CONCLR_STAC;
   \                     ??I2C_MasterHandler_3:
   \   00000064   0x2020             MOVS     R0,#+32
   \   00000066   0x61A8             STR      R0,[R5, #+24]
    500          				/*
    501          				 * If there's any transmit data, then start to
    502          				 * send SLA+W right now, otherwise check whether if there's
    503          				 * any receive data for next state.
    504          				 */
    505          				if ((txrx_setup->tx_data != NULL) && (txrx_setup->tx_length != 0))
   \   00000068   0x6878             LDR      R0,[R7, #+4]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD008             BEQ.N    ??I2C_MasterHandler_8
   \   0000006E   0x68B8             LDR      R0,[R7, #+8]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD005             BEQ.N    ??I2C_MasterHandler_8
    506          				{
    507          					I2Cx->DAT = (txrx_setup->sl_addr7bit << 1);
   \   00000074   0x6838             LDR      R0,[R7, #+0]
   \   00000076   0x0040             LSLS     R0,R0,#+1
   \   00000078   0x60A8             STR      R0,[R5, #+8]
    508          					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   0000007A   0x2008             MOVS     R0,#+8
   \   0000007C   0x61A8             STR      R0,[R5, #+24]
    509          				}
    510          				else
    511          				{
    512          					goto next_stage;
    513          				}
    514          
    515          				break;
   \   0000007E   0xE0C9             B.N      ??I2C_MasterHandler_9
   \                     ??I2C_MasterHandler_8:
   \   00000080   0xE010             B.N      ??I2C_MasterHandler_10
    516          
    517          			/* SLA+W has been transmitted, ACK has been received ----------------------*/
    518          			case I2C_I2STAT_M_TX_SLAW_ACK:
    519          
    520          			/* Data has been transmitted, ACK has been received */
    521          			case I2C_I2STAT_M_TX_DAT_ACK:
    522          				/* Send more data */
    523          				if ((txrx_setup->tx_count < txrx_setup->tx_length) && (txrx_setup->tx_data != NULL))
   \                     ??I2C_MasterHandler_4:
   \   00000082   0x68F8             LDR      R0,[R7, #+12]
   \   00000084   0x68B9             LDR      R1,[R7, #+8]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD20C             BCS.N    ??I2C_MasterHandler_10
   \   0000008A   0x6878             LDR      R0,[R7, #+4]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD009             BEQ.N    ??I2C_MasterHandler_10
    524          				{
    525          					I2Cx->DAT =  *(uint8_t *)(txrx_setup->tx_data + txrx_setup->tx_count);
   \   00000090   0x68F8             LDR      R0,[R7, #+12]
   \   00000092   0x6879             LDR      R1,[R7, #+4]
   \   00000094   0x5C40             LDRB     R0,[R0, R1]
   \   00000096   0x60A8             STR      R0,[R5, #+8]
    526          
    527          					txrx_setup->tx_count++;
   \   00000098   0x68F8             LDR      R0,[R7, #+12]
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
   \   0000009C   0x60F8             STR      R0,[R7, #+12]
    528          
    529          					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   0000009E   0x2008             MOVS     R0,#+8
   \   000000A0   0x61A8             STR      R0,[R5, #+24]
   \   000000A2   0xE01D             B.N      ??I2C_MasterHandler_11
    530          				}
    531          				// no more data, switch to next stage
    532          				else
    533          				{
    534          	next_stage:
    535          					// change direction
    536          					i2cdat[i2cId].dir = 1;
   \                     ??I2C_MasterHandler_10:
   \   000000A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   000000AA   0xEB10 0x00C4      ADDS     R0,R0,R4, LSL #+3
   \   000000AE   0x2101             MOVS     R1,#+1
   \   000000B0   0x6041             STR      R1,[R0, #+4]
    537          
    538          					// Check if any data to receive
    539          					if ((txrx_setup->rx_length != 0) && (txrx_setup->rx_data != NULL))
   \   000000B2   0x6978             LDR      R0,[R7, #+20]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD00E             BEQ.N    ??I2C_MasterHandler_12
   \   000000B8   0x6938             LDR      R0,[R7, #+16]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD00B             BEQ.N    ??I2C_MasterHandler_12
    540          					{
    541          							// check whether if we need to issue an repeat start
    542          							if ((txrx_setup->tx_length != 0) && (txrx_setup->tx_data != NULL))
   \   000000BE   0x68B8             LDR      R0,[R7, #+8]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD007             BEQ.N    ??I2C_MasterHandler_13
   \   000000C4   0x6878             LDR      R0,[R7, #+4]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD004             BEQ.N    ??I2C_MasterHandler_13
    543          							{
    544          								// Send out an repeat start command
    545          								I2Cx->CONSET = I2C_I2CONSET_STA;
   \   000000CA   0x2020             MOVS     R0,#+32
   \   000000CC   0x6028             STR      R0,[R5, #+0]
    546          
    547          								I2Cx->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
   \   000000CE   0x200C             MOVS     R0,#+12
   \   000000D0   0x61A8             STR      R0,[R5, #+24]
   \   000000D2   0xE005             B.N      ??I2C_MasterHandler_11
    548          							}
    549          							// Don't need issue an repeat start, just goto send SLA+R
    550          							else
    551          							{
    552          								goto send_slar;
   \                     ??I2C_MasterHandler_13:
   \   000000D4   0xE031             B.N      ??I2C_MasterHandler_14
    553          							}
    554          					}
    555          					// no more data send, the go to end stage now
    556          					else
    557          					{
    558          						// success, goto end stage
    559          						txrx_setup->status |= I2C_SETUP_STATUS_DONE;
   \                     ??I2C_MasterHandler_12:
   \   000000D6   0x6A78             LDR      R0,[R7, #+36]
   \   000000D8   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000DC   0x6278             STR      R0,[R7, #+36]
    560          
    561          						goto end_stage;
   \   000000DE   0xE08B             B.N      ??I2C_MasterHandler_15
    562          					}
    563          				}
    564          				break;
   \                     ??I2C_MasterHandler_11:
   \   000000E0   0xE098             B.N      ??I2C_MasterHandler_9
    565          
    566          			/* SLA+W has been transmitted, NACK has been received ----------------------*/
    567          			case I2C_I2STAT_M_TX_SLAW_NACK:
    568          
    569          			/* Data has been transmitted, NACK has been received -----------------------*/
    570          			case I2C_I2STAT_M_TX_DAT_NACK:
    571          				// update status
    572          				txrx_setup->status |= I2C_SETUP_STATUS_NOACKF;
   \                     ??I2C_MasterHandler_5:
   \   000000E2   0x6A78             LDR      R0,[R7, #+36]
   \   000000E4   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000E8   0x6278             STR      R0,[R7, #+36]
    573          				goto retry;
   \   000000EA   0xE077             B.N      ??I2C_MasterHandler_16
    574          
    575          			/* Arbitration lost in SLA+R/W or Data bytes -------------------------------*/
    576          			case I2C_I2STAT_M_TX_ARB_LOST:
    577          				// update status
    578          				txrx_setup->status |= I2C_SETUP_STATUS_ARBF;
   \                     ??I2C_MasterHandler_6:
   \   000000EC   0x6A78             LDR      R0,[R7, #+36]
   \   000000EE   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000000F2   0x6278             STR      R0,[R7, #+36]
    579          
    580          			default:
    581          				goto retry;
   \                     ??I2C_MasterHandler_7:
   \   000000F4   0xE072             B.N      ??I2C_MasterHandler_16
    582          		}
    583          	}
    584          
    585          	/* ----------------------------- RECEIVE PHASE --------------------------*/
    586          	else if (i2cdat[i2cId].dir == 1)
   \                     ??I2C_MasterHandler_2:
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   000000FC   0xEB10 0x00C4      ADDS     R0,R0,R4, LSL #+3
   \   00000100   0x6840             LDR      R0,[R0, #+4]
   \   00000102   0x2801             CMP      R0,#+1
   \   00000104   0xF040 0x8086      BNE.W    ??I2C_MasterHandler_9
    587          	{
    588          		switch (returnCode)
   \   00000108   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000010A   0x0030             MOVS     R0,R6
   \   0000010C   0x2808             CMP      R0,#+8
   \   0000010E   0xD00C             BEQ.N    ??I2C_MasterHandler_17
   \   00000110   0x2810             CMP      R0,#+16
   \   00000112   0xD00A             BEQ.N    ??I2C_MasterHandler_17
   \   00000114   0x2838             CMP      R0,#+56
   \   00000116   0xD05D             BEQ.N    ??I2C_MasterHandler_18
   \   00000118   0x2840             CMP      R0,#+64
   \   0000011A   0xD01B             BEQ.N    ??I2C_MasterHandler_19
   \   0000011C   0x2848             CMP      R0,#+72
   \   0000011E   0xD054             BEQ.N    ??I2C_MasterHandler_20
   \   00000120   0x2850             CMP      R0,#+80
   \   00000122   0xD024             BEQ.N    ??I2C_MasterHandler_21
   \   00000124   0x2858             CMP      R0,#+88
   \   00000126   0xD03D             BEQ.N    ??I2C_MasterHandler_22
   \   00000128   0xE058             B.N      ??I2C_MasterHandler_16
    589          		{
    590          				/* A start/repeat start condition has been transmitted ---------------------*/
    591          			case I2C_I2STAT_M_RX_START:
    592          
    593          			case I2C_I2STAT_M_RX_RESTART:
    594          				I2Cx->CONCLR = I2C_I2CONCLR_STAC;
   \                     ??I2C_MasterHandler_17:
   \   0000012A   0x2020             MOVS     R0,#+32
   \   0000012C   0x61A8             STR      R0,[R5, #+24]
    595          				/*
    596          				 * If there's any receive data, then start to
    597          				 * send SLA+R right now, otherwise check whether if there's
    598          				 * any receive data for end of state.
    599          				 */
    600          				if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_length != 0))
   \   0000012E   0x6938             LDR      R0,[R7, #+16]
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD00A             BEQ.N    ??I2C_MasterHandler_23
   \   00000134   0x6978             LDR      R0,[R7, #+20]
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD007             BEQ.N    ??I2C_MasterHandler_23
    601          				{
    602          	send_slar:
    603          					I2Cx->DAT = (txrx_setup->sl_addr7bit << 1) | 0x01;
   \                     ??I2C_MasterHandler_14:
   \   0000013A   0x6838             LDR      R0,[R7, #+0]
   \   0000013C   0x0040             LSLS     R0,R0,#+1
   \   0000013E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000142   0x60A8             STR      R0,[R5, #+8]
    604          					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   00000144   0x2008             MOVS     R0,#+8
   \   00000146   0x61A8             STR      R0,[R5, #+24]
    605          				}
    606          				else
    607          				{
    608          					// Success, goto end stage
    609          					txrx_setup->status |= I2C_SETUP_STATUS_DONE;
    610          					goto end_stage;
    611          				}
    612          
    613          				break;
   \   00000148   0xE064             B.N      ??I2C_MasterHandler_9
   \                     ??I2C_MasterHandler_23:
   \   0000014A   0x6A78             LDR      R0,[R7, #+36]
   \   0000014C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000150   0x6278             STR      R0,[R7, #+36]
   \   00000152   0xE051             B.N      ??I2C_MasterHandler_15
    614          
    615          			/* SLA+R has been transmitted, ACK has been received -----------------*/
    616          			case I2C_I2STAT_M_RX_SLAR_ACK:
    617          				if (txrx_setup->rx_count < (txrx_setup->rx_length - 1))
   \                     ??I2C_MasterHandler_19:
   \   00000154   0x69B8             LDR      R0,[R7, #+24]
   \   00000156   0x6979             LDR      R1,[R7, #+20]
   \   00000158   0x1E49             SUBS     R1,R1,#+1
   \   0000015A   0x4288             CMP      R0,R1
   \   0000015C   0xD202             BCS.N    ??I2C_MasterHandler_24
    618          				{
    619          					/*Data will be received,  ACK will be return*/
    620          					I2Cx->CONSET = I2C_I2CONSET_AA;
   \   0000015E   0x2004             MOVS     R0,#+4
   \   00000160   0x6028             STR      R0,[R5, #+0]
   \   00000162   0xE001             B.N      ??I2C_MasterHandler_25
    621          				}
    622          				else
    623          				{
    624          					/*Last data will be received,  NACK will be return*/
    625          					I2Cx->CONCLR = I2C_I2CONSET_AA;
   \                     ??I2C_MasterHandler_24:
   \   00000164   0x2004             MOVS     R0,#+4
   \   00000166   0x61A8             STR      R0,[R5, #+24]
    626          				}
    627          
    628          				I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_MasterHandler_25:
   \   00000168   0x2008             MOVS     R0,#+8
   \   0000016A   0x61A8             STR      R0,[R5, #+24]
    629          				break;
   \   0000016C   0xE052             B.N      ??I2C_MasterHandler_9
    630          
    631          			/* Data has been received, ACK has been returned ----------------------*/
    632          			case I2C_I2STAT_M_RX_DAT_ACK:
    633          				// Note save data and increase counter first, then check later
    634          				/* Save data  */
    635          				if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_count < txrx_setup->rx_length))
   \                     ??I2C_MasterHandler_21:
   \   0000016E   0x6938             LDR      R0,[R7, #+16]
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0xD00A             BEQ.N    ??I2C_MasterHandler_26
   \   00000174   0x69B8             LDR      R0,[R7, #+24]
   \   00000176   0x6979             LDR      R1,[R7, #+20]
   \   00000178   0x4288             CMP      R0,R1
   \   0000017A   0xD206             BCS.N    ??I2C_MasterHandler_26
    636          				{
    637          					*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (I2Cx->DAT & I2C_I2DAT_BITMASK);
   \   0000017C   0x69B8             LDR      R0,[R7, #+24]
   \   0000017E   0x6939             LDR      R1,[R7, #+16]
   \   00000180   0x68AA             LDR      R2,[R5, #+8]
   \   00000182   0x5442             STRB     R2,[R0, R1]
    638          
    639          					txrx_setup->rx_count++;
   \   00000184   0x69B8             LDR      R0,[R7, #+24]
   \   00000186   0x1C40             ADDS     R0,R0,#+1
   \   00000188   0x61B8             STR      R0,[R7, #+24]
    640          				}
    641          				if (txrx_setup->rx_count < (txrx_setup->rx_length - 1))
   \                     ??I2C_MasterHandler_26:
   \   0000018A   0x69B8             LDR      R0,[R7, #+24]
   \   0000018C   0x6979             LDR      R1,[R7, #+20]
   \   0000018E   0x1E49             SUBS     R1,R1,#+1
   \   00000190   0x4288             CMP      R0,R1
   \   00000192   0xD202             BCS.N    ??I2C_MasterHandler_27
    642          				{
    643          					/*Data will be received,  ACK will be return*/
    644          					I2Cx->CONSET = I2C_I2CONSET_AA;
   \   00000194   0x2004             MOVS     R0,#+4
   \   00000196   0x6028             STR      R0,[R5, #+0]
   \   00000198   0xE001             B.N      ??I2C_MasterHandler_28
    645          				}
    646          				else
    647          				{
    648          					/*Last data will be received,  NACK will be return*/
    649          					I2Cx->CONCLR = I2C_I2CONSET_AA;
   \                     ??I2C_MasterHandler_27:
   \   0000019A   0x2004             MOVS     R0,#+4
   \   0000019C   0x61A8             STR      R0,[R5, #+24]
    650          				}
    651          
    652          				I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_MasterHandler_28:
   \   0000019E   0x2008             MOVS     R0,#+8
   \   000001A0   0x61A8             STR      R0,[R5, #+24]
    653          				break;
   \   000001A2   0xE037             B.N      ??I2C_MasterHandler_9
    654          
    655          			/* Data has been received, NACK has been return -------------------------*/
    656          			case I2C_I2STAT_M_RX_DAT_NACK:
    657          				/* Save the last data */
    658          				if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_count < txrx_setup->rx_length))
   \                     ??I2C_MasterHandler_22:
   \   000001A4   0x6938             LDR      R0,[R7, #+16]
   \   000001A6   0x2800             CMP      R0,#+0
   \   000001A8   0xD00A             BEQ.N    ??I2C_MasterHandler_29
   \   000001AA   0x69B8             LDR      R0,[R7, #+24]
   \   000001AC   0x6979             LDR      R1,[R7, #+20]
   \   000001AE   0x4288             CMP      R0,R1
   \   000001B0   0xD206             BCS.N    ??I2C_MasterHandler_29
    659          				{
    660          					*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (I2Cx->DAT & I2C_I2DAT_BITMASK);
   \   000001B2   0x69B8             LDR      R0,[R7, #+24]
   \   000001B4   0x6939             LDR      R1,[R7, #+16]
   \   000001B6   0x68AA             LDR      R2,[R5, #+8]
   \   000001B8   0x5442             STRB     R2,[R0, R1]
    661          
    662          					txrx_setup->rx_count++;
   \   000001BA   0x69B8             LDR      R0,[R7, #+24]
   \   000001BC   0x1C40             ADDS     R0,R0,#+1
   \   000001BE   0x61B8             STR      R0,[R7, #+24]
    663          				}
    664          				// success, go to end stage
    665          				txrx_setup->status |= I2C_SETUP_STATUS_DONE;
   \                     ??I2C_MasterHandler_29:
   \   000001C0   0x6A78             LDR      R0,[R7, #+36]
   \   000001C2   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000001C6   0x6278             STR      R0,[R7, #+36]
    666          
    667          				goto end_stage;
   \   000001C8   0xE016             B.N      ??I2C_MasterHandler_15
    668          
    669          			/* SLA+R has been transmitted, NACK has been received ------------------*/
    670          			case I2C_I2STAT_M_RX_SLAR_NACK:
    671          				// update status
    672          				txrx_setup->status |= I2C_SETUP_STATUS_NOACKF;
   \                     ??I2C_MasterHandler_20:
   \   000001CA   0x6A78             LDR      R0,[R7, #+36]
   \   000001CC   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000001D0   0x6278             STR      R0,[R7, #+36]
    673          				goto retry;
   \   000001D2   0xE003             B.N      ??I2C_MasterHandler_16
    674          
    675          			/* Arbitration lost ----------------------------------------------------*/
    676          			case I2C_I2STAT_M_RX_ARB_LOST:
    677          				// update status
    678          				txrx_setup->status |= I2C_SETUP_STATUS_ARBF;
   \                     ??I2C_MasterHandler_18:
   \   000001D4   0x6A78             LDR      R0,[R7, #+36]
   \   000001D6   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000001DA   0x6278             STR      R0,[R7, #+36]
    679          
    680          			default:
    681          	retry:
    682          				// check if retransmission is available
    683          				if (txrx_setup->retransmissions_count < txrx_setup->retransmissions_max)
   \                     ??I2C_MasterHandler_16:
   \   000001DC   0x6A38             LDR      R0,[R7, #+32]
   \   000001DE   0x69F9             LDR      R1,[R7, #+28]
   \   000001E0   0x4288             CMP      R0,R1
   \   000001E2   0xD209             BCS.N    ??I2C_MasterHandler_15
    684          				{
    685          					// Clear tx count
    686          					txrx_setup->tx_count = 0;
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0x60F8             STR      R0,[R7, #+12]
    687          
    688          					I2Cx->CONSET = I2C_I2CONSET_STA;
   \   000001E8   0x2020             MOVS     R0,#+32
   \   000001EA   0x6028             STR      R0,[R5, #+0]
    689          
    690          					I2Cx->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
   \   000001EC   0x200C             MOVS     R0,#+12
   \   000001EE   0x61A8             STR      R0,[R5, #+24]
    691          
    692          					txrx_setup->retransmissions_count++;
   \   000001F0   0x6A38             LDR      R0,[R7, #+32]
   \   000001F2   0x1C40             ADDS     R0,R0,#+1
   \   000001F4   0x6238             STR      R0,[R7, #+32]
   \   000001F6   0xE00D             B.N      ??I2C_MasterHandler_30
    693          				}
    694          				// End of stage
    695          				else
    696          				{
    697          	end_stage:
    698          					// Disable interrupt
    699          					I2C_IntCmd(i2cId, (Bool)0);
   \                     ??I2C_MasterHandler_15:
   \   000001F8   0x2100             MOVS     R1,#+0
   \   000001FA   0x0020             MOVS     R0,R4
   \   000001FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FE   0x.... 0x....      BL       I2C_IntCmd
    700          
    701          					// Send stop
    702          					I2C_Stop(I2Cx);
   \   00000202   0x0028             MOVS     R0,R5
   \   00000204   0x.... 0x....      BL       I2C_Stop
    703          
    704          					I2C_MasterComplete[i2cId] = TRUE;
   \   00000208   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   0000020E   0x2101             MOVS     R1,#+1
   \   00000210   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
    705          				}
    706          				break;
    707          		}
    708          	}
    709          }
   \                     ??I2C_MasterHandler_30:
   \                     ??I2C_MasterHandler_9:
   \                     ??I2C_MasterHandler_1:
   \   00000214   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    710          
    711          
    712          /*********************************************************************//**
    713           * @brief 		General Slave Interrupt handler for I2C peripheral
    714           * @param[in]	I2Cx	I2C peripheral selected, should be:
    715           *  			- LPC_I2C0
    716           *  			- LPC_I2C1
    717           *  			- LPC_I2C2
    718           * @return 		None
    719           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    720          void I2C_SlaveHandler (uint8_t i2cId)
    721          {
   \                     I2C_SlaveHandler:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    722          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       I2C_GetPointer
   \   0000000E   0x0005             MOVS     R5,R0
    723          
    724          	uint8_t returnCode;
    725          	I2C_S_SETUP_Type *txrx_setup;
    726          	uint32_t timeout;
    727          
    728          	txrx_setup = (I2C_S_SETUP_Type *) i2cdat[i2cId].txrx_setup;
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000016   0xF850 0x0034      LDR      R0,[R0, R4, LSL #+3]
   \   0000001A   0x0007             MOVS     R7,R0
    729          
    730          	returnCode = (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
   \   0000001C   0x6868             LDR      R0,[R5, #+4]
   \   0000001E   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000022   0x0006             MOVS     R6,R0
    731          	// Save current status
    732          	txrx_setup->status = returnCode;
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x61BE             STR      R6,[R7, #+24]
    733          	// there's no relevant information
    734          	if (returnCode == I2C_I2STAT_NO_INF)
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x2EF8             CMP      R6,#+248
   \   0000002C   0xD102             BNE.N    ??I2C_SlaveHandler_0
    735          	{
    736          		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   0000002E   0x2008             MOVS     R0,#+8
   \   00000030   0x61A8             STR      R0,[R5, #+24]
    737          
    738          		return;
   \   00000032   0xE07C             B.N      ??I2C_SlaveHandler_1
    739          	}
    740          
    741          
    742          	switch (returnCode)
   \                     ??I2C_SlaveHandler_0:
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0x2860             CMP      R0,#+96
   \   0000003A   0xD018             BEQ.N    ??I2C_SlaveHandler_2
   \   0000003C   0x2870             CMP      R0,#+112
   \   0000003E   0xD016             BEQ.N    ??I2C_SlaveHandler_2
   \   00000040   0x2880             CMP      R0,#+128
   \   00000042   0xD019             BEQ.N    ??I2C_SlaveHandler_3
   \   00000044   0x2888             CMP      R0,#+136
   \   00000046   0xD02A             BEQ.N    ??I2C_SlaveHandler_4
   \   00000048   0x2890             CMP      R0,#+144
   \   0000004A   0xD015             BEQ.N    ??I2C_SlaveHandler_3
   \   0000004C   0x2898             CMP      R0,#+152
   \   0000004E   0xD026             BEQ.N    ??I2C_SlaveHandler_4
   \   00000050   0x28A0             CMP      R0,#+160
   \   00000052   0xD027             BEQ.N    ??I2C_SlaveHandler_5
   \   00000054   0x28A8             CMP      R0,#+168
   \   00000056   0xD042             BEQ.N    ??I2C_SlaveHandler_6
   \   00000058   0x28B8             CMP      R0,#+184
   \   0000005A   0xD040             BEQ.N    ??I2C_SlaveHandler_6
   \   0000005C   0x28C0             CMP      R0,#+192
   \   0000005E   0xD051             BEQ.N    ??I2C_SlaveHandler_7
   \   00000060   0x28F8             CMP      R0,#+248
   \   00000062   0xD157             BNE.N    ??I2C_SlaveHandler_8
    743          	{
    744          
    745          		/* No status information */
    746          		case I2C_I2STAT_NO_INF:
    747          			I2Cx->CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHandler_9:
   \   00000064   0x2004             MOVS     R0,#+4
   \   00000066   0x6028             STR      R0,[R5, #+0]
    748          			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   00000068   0x2008             MOVS     R0,#+8
   \   0000006A   0x61A8             STR      R0,[R5, #+24]
    749          			break;
   \   0000006C   0xE05F             B.N      ??I2C_SlaveHandler_10
    750          
    751          		/* Reading phase -------------------------------------------------------- */
    752          		/* Own SLA+R has been received, ACK has been returned */
    753          		case I2C_I2STAT_S_RX_SLAW_ACK:
    754          
    755          		/* General call address has been received, ACK has been returned */
    756          		case I2C_I2STAT_S_RX_GENCALL_ACK:
    757          			I2Cx->CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHandler_2:
   \   0000006E   0x2004             MOVS     R0,#+4
   \   00000070   0x6028             STR      R0,[R5, #+0]
    758          			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   00000072   0x2008             MOVS     R0,#+8
   \   00000074   0x61A8             STR      R0,[R5, #+24]
    759          			break;
   \   00000076   0xE05A             B.N      ??I2C_SlaveHandler_10
    760          
    761          		/* Previously addressed with own SLA;
    762          		 * DATA byte has been received;
    763          		 * ACK has been returned */
    764          		case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
    765          
    766          		/* DATA has been received, ACK hasn been return */
    767          		case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
    768          			/*
    769          			 * All data bytes that over-flow the specified receive
    770          			 * data length, just ignore them.
    771          			 */
    772          			if ((txrx_setup->rx_count < txrx_setup->rx_length) && (txrx_setup->rx_data != NULL))
   \                     ??I2C_SlaveHandler_3:
   \   00000078   0x6978             LDR      R0,[R7, #+20]
   \   0000007A   0x6939             LDR      R1,[R7, #+16]
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD209             BCS.N    ??I2C_SlaveHandler_11
   \   00000080   0x68F8             LDR      R0,[R7, #+12]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD006             BEQ.N    ??I2C_SlaveHandler_11
    773          			{
    774          				*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (uint8_t)I2Cx->DAT;
   \   00000086   0x6978             LDR      R0,[R7, #+20]
   \   00000088   0x68F9             LDR      R1,[R7, #+12]
   \   0000008A   0x68AA             LDR      R2,[R5, #+8]
   \   0000008C   0x5442             STRB     R2,[R0, R1]
    775          
    776          				txrx_setup->rx_count++;
   \   0000008E   0x6978             LDR      R0,[R7, #+20]
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0x6178             STR      R0,[R7, #+20]
    777          			}
    778          
    779          			I2Cx->CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHandler_11:
   \   00000094   0x2004             MOVS     R0,#+4
   \   00000096   0x6028             STR      R0,[R5, #+0]
    780          			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   00000098   0x2008             MOVS     R0,#+8
   \   0000009A   0x61A8             STR      R0,[R5, #+24]
    781          
    782          			break;
   \   0000009C   0xE047             B.N      ??I2C_SlaveHandler_10
    783          
    784          		/* Previously addressed with own SLA;
    785          		 * DATA byte has been received;
    786          		 * NOT ACK has been returned */
    787          		case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
    788          
    789          		/* DATA has been received, NOT ACK has been returned */
    790          		case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
    791          			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_SlaveHandler_4:
   \   0000009E   0x2008             MOVS     R0,#+8
   \   000000A0   0x61A8             STR      R0,[R5, #+24]
    792          			break;
   \   000000A2   0xE044             B.N      ??I2C_SlaveHandler_10
    793          
    794          		/*
    795          		 * Note that: Return code only let us know a stop condition mixed
    796          		 * with a repeat start condition in the same code value.
    797          		 * So we should provide a time-out. In case this is really a stop
    798          		 * condition, this will return back after time out condition. Otherwise,
    799          		 * next session that is slave receive data will be completed.
    800          		 */
    801          
    802          		/* A Stop or a repeat start condition */
    803          		case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
    804          			// Temporally lock the interrupt for timeout condition
    805          			I2C_IntCmd((en_I2C_unitId)i2cId, (Bool)0);
   \                     ??I2C_SlaveHandler_5:
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x.... 0x....      BL       I2C_IntCmd
    806          
    807          			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   000000AE   0x2008             MOVS     R0,#+8
   \   000000B0   0x61A8             STR      R0,[R5, #+24]
    808          			// enable time out
    809          			timeout = I2C_SLAVE_TIME_OUT;
   \   000000B2   0xF45F 0x3080      MOVS     R0,#+65536
   \   000000B6   0x4680             MOV      R8,R0
    810          			while(1)
    811          			{
    812          				if (I2Cx->CONSET & I2C_I2CONSET_SI)
   \                     ??I2C_SlaveHandler_12:
   \   000000B8   0x6828             LDR      R0,[R5, #+0]
   \   000000BA   0x0700             LSLS     R0,R0,#+28
   \   000000BC   0xD505             BPL.N    ??I2C_SlaveHandler_13
    813          				{
    814          					// re-Enable interrupt
    815          					I2C_IntCmd((en_I2C_unitId)i2cId, (Bool)1);
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x0020             MOVS     R0,R4
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0x.... 0x....      BL       I2C_IntCmd
    816          
    817          					break;
    818          				}
    819          				else
    820          				{
    821          					timeout--;
    822          
    823          					if (timeout == 0)
    824          					{
    825          						// timeout occur, it's really a stop condition
    826          						txrx_setup->status |= I2C_SETUP_STATUS_DONE;
    827          
    828          						goto s_int_end;
    829          					}
    830          				}
    831          			}
    832          			break;
   \   000000C8   0xE031             B.N      ??I2C_SlaveHandler_10
   \                     ??I2C_SlaveHandler_13:
   \   000000CA   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   000000CE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000D2   0xD1F1             BNE.N    ??I2C_SlaveHandler_12
   \   000000D4   0x69B8             LDR      R0,[R7, #+24]
   \   000000D6   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000DA   0x61B8             STR      R0,[R7, #+24]
   \   000000DC   0xE01A             B.N      ??I2C_SlaveHandler_8
    833          
    834          		/* Writing phase -------------------------------------------------------- */
    835          		/* Own SLA+R has been received, ACK has been returned */
    836          		case I2C_I2STAT_S_TX_SLAR_ACK:
    837          
    838          		/* Data has been transmitted, ACK has been received */
    839          		case I2C_I2STAT_S_TX_DAT_ACK:
    840          			/*
    841          			 * All data bytes that over-flow the specified receive
    842          			 * data length, just ignore them.
    843          			 */
    844          			if ((txrx_setup->tx_count < txrx_setup->tx_length) && (txrx_setup->tx_data != NULL))
   \                     ??I2C_SlaveHandler_6:
   \   000000DE   0x68B8             LDR      R0,[R7, #+8]
   \   000000E0   0x6879             LDR      R1,[R7, #+4]
   \   000000E2   0x4288             CMP      R0,R1
   \   000000E4   0xD209             BCS.N    ??I2C_SlaveHandler_14
   \   000000E6   0x6838             LDR      R0,[R7, #+0]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD006             BEQ.N    ??I2C_SlaveHandler_14
    845          			{
    846          				I2Cx->DAT = *(uint8_t *) (txrx_setup->tx_data + txrx_setup->tx_count);
   \   000000EC   0x68B8             LDR      R0,[R7, #+8]
   \   000000EE   0x6839             LDR      R1,[R7, #+0]
   \   000000F0   0x5C40             LDRB     R0,[R0, R1]
   \   000000F2   0x60A8             STR      R0,[R5, #+8]
    847          
    848          				txrx_setup->tx_count++;
   \   000000F4   0x68B8             LDR      R0,[R7, #+8]
   \   000000F6   0x1C40             ADDS     R0,R0,#+1
   \   000000F8   0x60B8             STR      R0,[R7, #+8]
    849          			}
    850          
    851          			I2Cx->CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHandler_14:
   \   000000FA   0x2004             MOVS     R0,#+4
   \   000000FC   0x6028             STR      R0,[R5, #+0]
    852          			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   000000FE   0x2008             MOVS     R0,#+8
   \   00000100   0x61A8             STR      R0,[R5, #+24]
    853          
    854          			break;
   \   00000102   0xE014             B.N      ??I2C_SlaveHandler_10
    855          
    856          		/* Data has been transmitted, NACK has been received,
    857          		 * that means there's no more data to send, exit now */
    858          		/*
    859          		 * Note: Don't wait for stop event since in slave transmit mode,
    860          		 * since there no proof lets us know when a stop signal has been received
    861          		 * on slave side.
    862          		 */
    863          		case I2C_I2STAT_S_TX_DAT_NACK:
    864          			I2Cx->CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHandler_7:
   \   00000104   0x2004             MOVS     R0,#+4
   \   00000106   0x6028             STR      R0,[R5, #+0]
    865          			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   00000108   0x2008             MOVS     R0,#+8
   \   0000010A   0x61A8             STR      R0,[R5, #+24]
    866          			txrx_setup->status |= I2C_SETUP_STATUS_DONE;
   \   0000010C   0x69B8             LDR      R0,[R7, #+24]
   \   0000010E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000112   0x61B8             STR      R0,[R7, #+24]
    867          			goto s_int_end;
    868          
    869          		// Other status must be captured
    870          		default:
    871          	s_int_end:
    872          			// Disable interrupt
    873          			I2C_IntCmd((en_I2C_unitId)i2cId, (Bool)0);
   \                     ??I2C_SlaveHandler_8:
   \   00000114   0x2100             MOVS     R1,#+0
   \   00000116   0x0020             MOVS     R0,R4
   \   00000118   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   0x.... 0x....      BL       I2C_IntCmd
    874          
    875          			I2Cx->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
   \   0000011E   0x202C             MOVS     R0,#+44
   \   00000120   0x61A8             STR      R0,[R5, #+24]
    876          
    877          			I2C_SlaveComplete[i2cId] = TRUE;
   \   00000122   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable10_7
   \   00000128   0x2101             MOVS     R1,#+1
   \   0000012A   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
    878          			break;
    879          	}
    880          }
   \                     ??I2C_SlaveHandler_10:
   \                     ??I2C_SlaveHandler_1:
   \   0000012E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    881          
    882          /*********************************************************************//**
    883           * @brief 		Transmit and Receive data in master mode
    884           * @param[in]	I2Cx			I2C peripheral selected, should be:
    885           *  			- LPC_I2C0
    886           * 				- LPC_I2C1
    887           * 				- LPC_I2C2
    888           * @param[in]	TransferCfg		Pointer to a I2C_M_SETUP_Type structure that
    889           * 								contains specified information about the
    890           * 								configuration for master transfer.
    891           * @param[in]	Opt				a I2C_TRANSFER_OPT_Type type that selected for
    892           * 								interrupt or polling mode.
    893           * @return 		SUCCESS or ERROR
    894           *
    895           * Note:
    896           * - In case of using I2C to transmit data only, either transmit length set to 0
    897           * or transmit data pointer set to NULL.
    898           * - In case of using I2C to receive data only, either receive length set to 0
    899           * or receive data pointer set to NULL.
    900           * - In case of using I2C to transmit followed by receive data, transmit length,
    901           * transmit data pointer, receive length and receive data pointer should be set
    902           * corresponding.
    903           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    904          Status I2C_MasterTransferData(uint8_t i2cId, I2C_M_SETUP_Type *TransferCfg,
    905          																	I2C_TRANSFER_OPT_Type Opt)
    906          {
   \                     I2C_MasterTransferData:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    907          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       I2C_GetPointer
   \   00000014   0x0007             MOVS     R7,R0
    908          
    909          	uint8_t *txdat;
    910          	uint8_t *rxdat;
    911          	uint32_t CodeStatus;
    912          	uint8_t tmp;
    913          
    914          	// reset all default state
    915          	txdat = (uint8_t *) TransferCfg->tx_data;
   \   00000016   0x6868             LDR      R0,[R5, #+4]
   \   00000018   0x4680             MOV      R8,R0
    916          	rxdat = (uint8_t *) TransferCfg->rx_data;
   \   0000001A   0x6928             LDR      R0,[R5, #+16]
   \   0000001C   0x4681             MOV      R9,R0
    917          
    918          	// Reset I2C setup value to default state
    919          	TransferCfg->tx_count = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x60E8             STR      R0,[R5, #+12]
    920          	TransferCfg->rx_count = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x61A8             STR      R0,[R5, #+24]
    921          	TransferCfg->status = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6268             STR      R0,[R5, #+36]
    922          
    923          	if (Opt == I2C_TRANSFER_POLLING)
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E00             CMP      R6,#+0
   \   0000002E   0xF040 0x80EF      BNE.W    ??I2C_MasterTransferData_0
    924          	{
    925          		/* First Start condition -------------------------------------------------------------- */
    926          		TransferCfg->retransmissions_count = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6228             STR      R0,[R5, #+32]
    927          retry:
    928          		// reset all default state
    929          		txdat = (uint8_t *) TransferCfg->tx_data;
   \                     ??I2C_MasterTransferData_1:
   \   00000036   0x6868             LDR      R0,[R5, #+4]
   \   00000038   0x4680             MOV      R8,R0
    930          		rxdat = (uint8_t *) TransferCfg->rx_data;
   \   0000003A   0x6928             LDR      R0,[R5, #+16]
   \   0000003C   0x4681             MOV      R9,R0
    931          
    932          		// Reset I2C setup value to default state
    933          		TransferCfg->tx_count = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x60E8             STR      R0,[R5, #+12]
    934          		TransferCfg->rx_count = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x61A8             STR      R0,[R5, #+24]
    935          
    936          		CodeStatus = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x4682             MOV      R10,R0
    937          
    938          		// Start command
    939          		CodeStatus = I2C_Start(I2Cx);
   \   0000004A   0x0038             MOVS     R0,R7
   \   0000004C   0x.... 0x....      BL       I2C_Start
   \   00000050   0x4682             MOV      R10,R0
    940                          if(CodeStatus == 0xffff)
   \   00000052   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000056   0x4582             CMP      R10,R0
   \   00000058   0xD10A             BNE.N    ??I2C_MasterTransferData_2
    941                          {
    942                              if(bSenok == 0)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable10_8
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD103             BNE.N    ??I2C_MasterTransferData_3
    943                              bSenValid = 0;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x7001             STRB     R1,[R0, #+0]
    944                              return ERROR;
   \                     ??I2C_MasterTransferData_3:
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE0E8             B.N      ??I2C_MasterTransferData_4
    945                          }
    946                              
    947          		if ((CodeStatus != I2C_I2STAT_M_TX_START) && (CodeStatus != I2C_I2STAT_M_TX_RESTART))
   \                     ??I2C_MasterTransferData_2:
   \   00000070   0xF1BA 0x0F08      CMP      R10,#+8
   \   00000074   0xD00D             BEQ.N    ??I2C_MasterTransferData_5
   \   00000076   0xF1BA 0x0F10      CMP      R10,#+16
   \   0000007A   0xD00A             BEQ.N    ??I2C_MasterTransferData_5
    948          		{
    949          			TransferCfg->retransmissions_count++;
   \   0000007C   0x6A28             LDR      R0,[R5, #+32]
   \   0000007E   0x1C40             ADDS     R0,R0,#+1
   \   00000080   0x6228             STR      R0,[R5, #+32]
    950          			if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max)
   \   00000082   0x69E8             LDR      R0,[R5, #+28]
   \   00000084   0x6A29             LDR      R1,[R5, #+32]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD202             BCS.N    ??I2C_MasterTransferData_6
    951          			{
    952          				// save status
    953          				TransferCfg->status = CodeStatus;
   \   0000008A   0xF8C5 0xA024      STR      R10,[R5, #+36]
    954          
    955          				goto error;
   \   0000008E   0xE0BA             B.N      ??I2C_MasterTransferData_7
    956          			}
    957          			else
    958          			{
    959          				goto retry;
   \                     ??I2C_MasterTransferData_6:
   \   00000090   0xE7D1             B.N      ??I2C_MasterTransferData_1
    960          			}
    961          		}
    962          
    963          		/* In case of sending data first --------------------------------------------------- */
    964          		if ((TransferCfg->tx_length != 0) && (TransferCfg->tx_data != NULL))
   \                     ??I2C_MasterTransferData_5:
   \   00000092   0x68A8             LDR      R0,[R5, #+8]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD037             BEQ.N    ??I2C_MasterTransferData_8
   \   00000098   0x6868             LDR      R0,[R5, #+4]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD034             BEQ.N    ??I2C_MasterTransferData_8
    965          		{
    966          			/* Send slave address + WR direction bit = 0 ----------------------------------- */
    967          			CodeStatus = I2C_SendByte(I2Cx, (TransferCfg->sl_addr7bit << 1));
   \   0000009E   0x6828             LDR      R0,[R5, #+0]
   \   000000A0   0x0041             LSLS     R1,R0,#+1
   \   000000A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A4   0x0038             MOVS     R0,R7
   \   000000A6   0x.... 0x....      BL       I2C_SendByte
   \   000000AA   0x4682             MOV      R10,R0
    968          
    969          			if (CodeStatus != I2C_I2STAT_M_TX_SLAW_ACK)
   \   000000AC   0xF1BA 0x0F18      CMP      R10,#+24
   \   000000B0   0xD00B             BEQ.N    ??I2C_MasterTransferData_9
    970          			{
    971          				TransferCfg->retransmissions_count++;
   \   000000B2   0x6A28             LDR      R0,[R5, #+32]
   \   000000B4   0x1C40             ADDS     R0,R0,#+1
   \   000000B6   0x6228             STR      R0,[R5, #+32]
    972          
    973          				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max)
   \   000000B8   0x69E8             LDR      R0,[R5, #+28]
   \   000000BA   0x6A29             LDR      R1,[R5, #+32]
   \   000000BC   0x4288             CMP      R0,R1
   \   000000BE   0xD203             BCS.N    ??I2C_MasterTransferData_10
    974          				{
    975          					// save status
    976          					TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
   \   000000C0   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   000000C4   0x6268             STR      R0,[R5, #+36]
    977          
    978          					goto error;
   \   000000C6   0xE09E             B.N      ??I2C_MasterTransferData_7
    979          				}
    980          				else
    981          				{
    982          					goto retry;
   \                     ??I2C_MasterTransferData_10:
   \   000000C8   0xE7B5             B.N      ??I2C_MasterTransferData_1
    983          				}
    984          			}
    985          
    986          			/* Send a number of data bytes ---------------------------------------- */
    987          			while (TransferCfg->tx_count < TransferCfg->tx_length)
   \                     ??I2C_MasterTransferData_9:
   \   000000CA   0x68E8             LDR      R0,[R5, #+12]
   \   000000CC   0x68A9             LDR      R1,[R5, #+8]
   \   000000CE   0x4288             CMP      R0,R1
   \   000000D0   0xD21A             BCS.N    ??I2C_MasterTransferData_8
    988          			{
    989          				CodeStatus = I2C_SendByte(I2Cx, *txdat);
   \   000000D2   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   000000D6   0x0038             MOVS     R0,R7
   \   000000D8   0x.... 0x....      BL       I2C_SendByte
   \   000000DC   0x4682             MOV      R10,R0
    990          
    991          				if (CodeStatus != I2C_I2STAT_M_TX_DAT_ACK)
   \   000000DE   0xF1BA 0x0F28      CMP      R10,#+40
   \   000000E2   0xD00B             BEQ.N    ??I2C_MasterTransferData_11
    992          				{
    993          					TransferCfg->retransmissions_count++;
   \   000000E4   0x6A28             LDR      R0,[R5, #+32]
   \   000000E6   0x1C40             ADDS     R0,R0,#+1
   \   000000E8   0x6228             STR      R0,[R5, #+32]
    994          
    995          					if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max)
   \   000000EA   0x69E8             LDR      R0,[R5, #+28]
   \   000000EC   0x6A29             LDR      R1,[R5, #+32]
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xD203             BCS.N    ??I2C_MasterTransferData_12
    996          					{
    997          						// save status
    998          						TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
   \   000000F2   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   000000F6   0x6268             STR      R0,[R5, #+36]
    999          
   1000          						goto error;
   \   000000F8   0xE085             B.N      ??I2C_MasterTransferData_7
   1001          					}
   1002          					else
   1003          					{
   1004          						goto retry;
   \                     ??I2C_MasterTransferData_12:
   \   000000FA   0xE79C             B.N      ??I2C_MasterTransferData_1
   1005          					}
   1006          				}
   1007          
   1008          				txdat++;
   \                     ??I2C_MasterTransferData_11:
   \   000000FC   0xF118 0x0801      ADDS     R8,R8,#+1
   1009          
   1010          				TransferCfg->tx_count++;
   \   00000100   0x68E8             LDR      R0,[R5, #+12]
   \   00000102   0x1C40             ADDS     R0,R0,#+1
   \   00000104   0x60E8             STR      R0,[R5, #+12]
   \   00000106   0xE7E0             B.N      ??I2C_MasterTransferData_9
   1011          			}
   1012          		}
   1013          
   1014          		/* Second Start condition (Repeat Start) ------------------------------------------- */
   1015          		if ((TransferCfg->tx_length != 0) && (TransferCfg->tx_data != NULL) \
   1016          				&& (TransferCfg->rx_length != 0) && (TransferCfg->rx_data != NULL))
   \                     ??I2C_MasterTransferData_8:
   \   00000108   0x68A8             LDR      R0,[R5, #+8]
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD01D             BEQ.N    ??I2C_MasterTransferData_13
   \   0000010E   0x6868             LDR      R0,[R5, #+4]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD01A             BEQ.N    ??I2C_MasterTransferData_13
   \   00000114   0x6968             LDR      R0,[R5, #+20]
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD017             BEQ.N    ??I2C_MasterTransferData_13
   \   0000011A   0x6928             LDR      R0,[R5, #+16]
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD014             BEQ.N    ??I2C_MasterTransferData_13
   1017          		{
   1018          			CodeStatus = I2C_Start(I2Cx);
   \   00000120   0x0038             MOVS     R0,R7
   \   00000122   0x.... 0x....      BL       I2C_Start
   \   00000126   0x4682             MOV      R10,R0
   1019          
   1020          			if ((CodeStatus != I2C_I2STAT_M_RX_START) \
   1021          					&& (CodeStatus != I2C_I2STAT_M_RX_RESTART))
   \   00000128   0xF1BA 0x0F08      CMP      R10,#+8
   \   0000012C   0xD00D             BEQ.N    ??I2C_MasterTransferData_13
   \   0000012E   0xF1BA 0x0F10      CMP      R10,#+16
   \   00000132   0xD00A             BEQ.N    ??I2C_MasterTransferData_13
   1022          			{
   1023          				TransferCfg->retransmissions_count++;
   \   00000134   0x6A28             LDR      R0,[R5, #+32]
   \   00000136   0x1C40             ADDS     R0,R0,#+1
   \   00000138   0x6228             STR      R0,[R5, #+32]
   1024          
   1025          				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max)
   \   0000013A   0x69E8             LDR      R0,[R5, #+28]
   \   0000013C   0x6A29             LDR      R1,[R5, #+32]
   \   0000013E   0x4288             CMP      R0,R1
   \   00000140   0xD202             BCS.N    ??I2C_MasterTransferData_14
   1026          				{
   1027          					// Update status
   1028          					TransferCfg->status = CodeStatus;
   \   00000142   0xF8C5 0xA024      STR      R10,[R5, #+36]
   1029          					goto error;
   \   00000146   0xE05E             B.N      ??I2C_MasterTransferData_7
   1030          				}
   1031          				else
   1032          				{
   1033          					goto retry;
   \                     ??I2C_MasterTransferData_14:
   \   00000148   0xE775             B.N      ??I2C_MasterTransferData_1
   1034          				}
   1035          			}
   1036          		}
   1037          
   1038          		/* Then, start reading after sending data -------------------------------------- */
   1039          		if ((TransferCfg->rx_length != 0) && (TransferCfg->rx_data != NULL))
   \                     ??I2C_MasterTransferData_13:
   \   0000014A   0x6968             LDR      R0,[R5, #+20]
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xD055             BEQ.N    ??I2C_MasterTransferData_15
   \   00000150   0x6928             LDR      R0,[R5, #+16]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD052             BEQ.N    ??I2C_MasterTransferData_15
   1040          		{
   1041          			/* Send slave address + RD direction bit = 1 ----------------------------------- */
   1042          
   1043          			CodeStatus = I2C_SendByte(I2Cx, ((TransferCfg->sl_addr7bit << 1) | 0x01));
   \   00000156   0x6828             LDR      R0,[R5, #+0]
   \   00000158   0x0040             LSLS     R0,R0,#+1
   \   0000015A   0xF050 0x0101      ORRS     R1,R0,#0x1
   \   0000015E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000160   0x0038             MOVS     R0,R7
   \   00000162   0x.... 0x....      BL       I2C_SendByte
   \   00000166   0x4682             MOV      R10,R0
   1044          
   1045          			if (CodeStatus != I2C_I2STAT_M_RX_SLAR_ACK)
   \   00000168   0xF1BA 0x0F40      CMP      R10,#+64
   \   0000016C   0xD00B             BEQ.N    ??I2C_MasterTransferData_16
   1046          			{
   1047          				TransferCfg->retransmissions_count++;
   \   0000016E   0x6A28             LDR      R0,[R5, #+32]
   \   00000170   0x1C40             ADDS     R0,R0,#+1
   \   00000172   0x6228             STR      R0,[R5, #+32]
   1048          
   1049          				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max)
   \   00000174   0x69E8             LDR      R0,[R5, #+28]
   \   00000176   0x6A29             LDR      R1,[R5, #+32]
   \   00000178   0x4288             CMP      R0,R1
   \   0000017A   0xD203             BCS.N    ??I2C_MasterTransferData_17
   1050          				{
   1051          					// update status
   1052          					TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
   \   0000017C   0xF45A 0x7000      ORRS     R0,R10,#0x200
   \   00000180   0x6268             STR      R0,[R5, #+36]
   1053          
   1054          					goto error;
   \   00000182   0xE040             B.N      ??I2C_MasterTransferData_7
   1055          				}
   1056          				else
   1057          				{
   1058          					goto retry;
   \                     ??I2C_MasterTransferData_17:
   \   00000184   0xE757             B.N      ??I2C_MasterTransferData_1
   1059          				}
   1060          			}
   1061          
   1062          			/* Receive a number of data bytes ------------------------------------------------- */
   1063          			while (TransferCfg->rx_count < TransferCfg->rx_length)
   \                     ??I2C_MasterTransferData_16:
   \   00000186   0x69A8             LDR      R0,[R5, #+24]
   \   00000188   0x6969             LDR      R1,[R5, #+20]
   \   0000018A   0x4288             CMP      R0,R1
   \   0000018C   0xD236             BCS.N    ??I2C_MasterTransferData_15
   1064          			{
   1065          				/*
   1066          				 * Note that: if data length is only one, the master should not
   1067          				 * issue an ACK signal on bus after reading to avoid of next data frame
   1068          				 * on slave side
   1069          				 */
   1070          				if (TransferCfg->rx_count < (TransferCfg->rx_length - 1))
   \   0000018E   0x69A8             LDR      R0,[R5, #+24]
   \   00000190   0x6969             LDR      R1,[R5, #+20]
   \   00000192   0x1E49             SUBS     R1,R1,#+1
   \   00000194   0x4288             CMP      R0,R1
   \   00000196   0xD213             BCS.N    ??I2C_MasterTransferData_18
   1071          				{
   1072          					// Issue an ACK signal for next data frame
   1073          					CodeStatus = I2C_GetByte(I2Cx, &tmp, (Bool)1);
   \   00000198   0x2201             MOVS     R2,#+1
   \   0000019A   0xA900             ADD      R1,SP,#+0
   \   0000019C   0x0038             MOVS     R0,R7
   \   0000019E   0x.... 0x....      BL       I2C_GetByte
   \   000001A2   0x4682             MOV      R10,R0
   1074          
   1075          					if (CodeStatus != I2C_I2STAT_M_RX_DAT_ACK)
   \   000001A4   0xF1BA 0x0F50      CMP      R10,#+80
   \   000001A8   0xD01E             BEQ.N    ??I2C_MasterTransferData_19
   1076          					{
   1077          						TransferCfg->retransmissions_count++;
   \   000001AA   0x6A28             LDR      R0,[R5, #+32]
   \   000001AC   0x1C40             ADDS     R0,R0,#+1
   \   000001AE   0x6228             STR      R0,[R5, #+32]
   1078          
   1079          						if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max)
   \   000001B0   0x69E8             LDR      R0,[R5, #+28]
   \   000001B2   0x6A29             LDR      R1,[R5, #+32]
   \   000001B4   0x4288             CMP      R0,R1
   \   000001B6   0xD202             BCS.N    ??I2C_MasterTransferData_20
   1080          						{
   1081          							// update status
   1082          							TransferCfg->status = CodeStatus;
   \   000001B8   0xF8C5 0xA024      STR      R10,[R5, #+36]
   1083          
   1084          							goto error;
   \   000001BC   0xE023             B.N      ??I2C_MasterTransferData_7
   1085          						}
   1086          						else
   1087          						{
   1088          							goto retry;
   \                     ??I2C_MasterTransferData_20:
   \   000001BE   0xE73A             B.N      ??I2C_MasterTransferData_1
   1089          						}
   1090          					}
   1091          				}
   1092          				else
   1093          				{
   1094          					// Do not issue an ACK signal
   1095          					CodeStatus = I2C_GetByte(I2Cx, &tmp, (Bool)0);
   \                     ??I2C_MasterTransferData_18:
   \   000001C0   0x2200             MOVS     R2,#+0
   \   000001C2   0xA900             ADD      R1,SP,#+0
   \   000001C4   0x0038             MOVS     R0,R7
   \   000001C6   0x.... 0x....      BL       I2C_GetByte
   \   000001CA   0x4682             MOV      R10,R0
   1096          
   1097          					if (CodeStatus != I2C_I2STAT_M_RX_DAT_NACK)
   \   000001CC   0xF1BA 0x0F58      CMP      R10,#+88
   \   000001D0   0xD00A             BEQ.N    ??I2C_MasterTransferData_19
   1098          					{
   1099          						TransferCfg->retransmissions_count++;
   \   000001D2   0x6A28             LDR      R0,[R5, #+32]
   \   000001D4   0x1C40             ADDS     R0,R0,#+1
   \   000001D6   0x6228             STR      R0,[R5, #+32]
   1100          
   1101          						if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max)
   \   000001D8   0x69E8             LDR      R0,[R5, #+28]
   \   000001DA   0x6A29             LDR      R1,[R5, #+32]
   \   000001DC   0x4288             CMP      R0,R1
   \   000001DE   0xD202             BCS.N    ??I2C_MasterTransferData_21
   1102          						{
   1103          							// update status
   1104          							TransferCfg->status = CodeStatus;
   \   000001E0   0xF8C5 0xA024      STR      R10,[R5, #+36]
   1105          
   1106          							goto error;
   \   000001E4   0xE00F             B.N      ??I2C_MasterTransferData_7
   1107          						}
   1108          						else
   1109          						{
   1110          							goto retry;
   \                     ??I2C_MasterTransferData_21:
   \   000001E6   0xE726             B.N      ??I2C_MasterTransferData_1
   1111          						}
   1112          					}
   1113          				}
   1114          
   1115          				*rxdat++ = tmp;
   \                     ??I2C_MasterTransferData_19:
   \   000001E8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001EC   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000001F0   0xF119 0x0901      ADDS     R9,R9,#+1
   1116          
   1117          				TransferCfg->rx_count++;
   \   000001F4   0x69A8             LDR      R0,[R5, #+24]
   \   000001F6   0x1C40             ADDS     R0,R0,#+1
   \   000001F8   0x61A8             STR      R0,[R5, #+24]
   \   000001FA   0xE7C4             B.N      ??I2C_MasterTransferData_16
   1118          			}
   1119          		}
   1120          
   1121          		/* Send STOP condition ------------------------------------------------- */
   1122          		I2C_Stop(I2Cx);
   \                     ??I2C_MasterTransferData_15:
   \   000001FC   0x0038             MOVS     R0,R7
   \   000001FE   0x.... 0x....      BL       I2C_Stop
   1123          
   1124          		return SUCCESS;
   \   00000202   0x2001             MOVS     R0,#+1
   \   00000204   0xE01D             B.N      ??I2C_MasterTransferData_4
   1125          
   1126          error:
   1127          		// Send stop condition
   1128          		I2C_Stop(I2Cx);
   \                     ??I2C_MasterTransferData_7:
   \   00000206   0x0038             MOVS     R0,R7
   \   00000208   0x.... 0x....      BL       I2C_Stop
   1129          
   1130          		return ERROR;
   \   0000020C   0x2000             MOVS     R0,#+0
   \   0000020E   0xE018             B.N      ??I2C_MasterTransferData_4
   1131          	}
   1132          
   1133          	else if (Opt == I2C_TRANSFER_INTERRUPT)
   \                     ??I2C_MasterTransferData_0:
   \   00000210   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000212   0x2E01             CMP      R6,#+1
   \   00000214   0xD114             BNE.N    ??I2C_MasterTransferData_22
   1134          	{
   1135          		// Setup tx_rx data, callback and interrupt handler
   1136          		i2cdat[i2cId].txrx_setup = (uint32_t) TransferCfg;
   \   00000216   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000218   0x....             LDR.N    R0,??DataTable10_5
   \   0000021A   0xF840 0x5034      STR      R5,[R0, R4, LSL #+3]
   1137          
   1138          		// Set direction phase, write first
   1139          		i2cdat[i2cId].dir = 0;
   \   0000021E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000220   0x....             LDR.N    R0,??DataTable10_5
   \   00000222   0xEB10 0x00C4      ADDS     R0,R0,R4, LSL #+3
   \   00000226   0x2100             MOVS     R1,#+0
   \   00000228   0x6041             STR      R1,[R0, #+4]
   1140          
   1141          		/* First Start condition -------------------------------------------------------------- */
   1142          		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   0000022A   0x2008             MOVS     R0,#+8
   \   0000022C   0x61B8             STR      R0,[R7, #+24]
   1143          		I2Cx->CONSET = I2C_I2CONSET_STA;
   \   0000022E   0x2020             MOVS     R0,#+32
   \   00000230   0x6038             STR      R0,[R7, #+0]
   1144          
   1145          		I2C_IntCmd(i2cId, (Bool)1);
   \   00000232   0x2101             MOVS     R1,#+1
   \   00000234   0x0020             MOVS     R0,R4
   \   00000236   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000238   0x.... 0x....      BL       I2C_IntCmd
   1146          
   1147          		return (SUCCESS);
   \   0000023C   0x2001             MOVS     R0,#+1
   \   0000023E   0xE000             B.N      ??I2C_MasterTransferData_4
   1148          	}
   1149          
   1150          	return ERROR;
   \                     ??I2C_MasterTransferData_22:
   \   00000240   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterTransferData_4:
   \   00000242   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1151          }
   1152          
   1153          /*********************************************************************//**
   1154           * @brief 		Receive and Transmit data in slave mode
   1155           * @param[in]	I2Cx			I2C peripheral selected, should be
   1156           *    			- LPC_I2C0
   1157           * 				- LPC_I2C1
   1158           * 				- LPC_I2C2
   1159           * @param[in]	TransferCfg		Pointer to a I2C_S_SETUP_Type structure that
   1160           * 								contains specified information about the
   1161           * 								configuration for master transfer.
   1162           * @param[in]	Opt				I2C_TRANSFER_OPT_Type type that selected for
   1163           * 								interrupt or polling mode.
   1164           * @return 		SUCCESS or ERROR
   1165           *
   1166           * Note:
   1167           * The mode of slave's operation depends on the command sent from master on
   1168           * the I2C bus. If the master send a SLA+W command, this sub-routine will
   1169           * use receive data length and receive data pointer. If the master send a SLA+R
   1170           * command, this sub-routine will use transmit data length and transmit data
   1171           * pointer.
   1172           * If the master issue an repeat start command or a stop command, the slave will
   1173           * enable an time out condition, during time out condition, if there's no activity
   1174           * on I2C bus, the slave will exit, otherwise (i.e. the master send a SLA+R/W),
   1175           * the slave then switch to relevant operation mode. The time out should be used
   1176           * because the return status code can not show difference from stop and repeat
   1177           * start command in slave operation.
   1178           * In case of the expected data length from master is greater than data length
   1179           * that slave can support:
   1180           * - In case of reading operation (from master): slave will return I2C_I2DAT_IDLE_CHAR
   1181           * value.
   1182           * - In case of writing operation (from master): slave will ignore remain data from master.
   1183           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1184          Status I2C_SlaveTransferData(uint8_t i2cId, I2C_S_SETUP_Type *TransferCfg,
   1185          																	I2C_TRANSFER_OPT_Type Opt)
   1186          {
   \                     I2C_SlaveTransferData:
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1187          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       I2C_GetPointer
   \   00000010   0x0006             MOVS     R6,R0
   1188          
   1189          	uint8_t *txdat;
   1190          	uint8_t *rxdat;
   1191          	uint32_t CodeStatus;
   1192          	uint32_t timeout;
   1193          	int32_t time_en;
   1194          
   1195          	// reset all default state
   1196          	txdat = (uint8_t *) TransferCfg->tx_data;
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x0007             MOVS     R7,R0
   1197          	rxdat = (uint8_t *) TransferCfg->rx_data;
   \   00000016   0x68E8             LDR      R0,[R5, #+12]
   \   00000018   0x4680             MOV      R8,R0
   1198          	// Reset I2C setup value to default state
   1199          	TransferCfg->tx_count = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x60A8             STR      R0,[R5, #+8]
   1200          	TransferCfg->rx_count = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6168             STR      R0,[R5, #+20]
   1201          	TransferCfg->status = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x61A8             STR      R0,[R5, #+24]
   1202          
   1203          
   1204          	// Polling option
   1205          	if (Opt == I2C_TRANSFER_POLLING)
   \   00000026   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF040 0x8082      BNE.W    ??I2C_SlaveTransferData_0
   1206          	{
   1207          		/* Set AA bit to ACK command on I2C bus */
   1208          		I2Cx->CONSET = I2C_I2CONSET_AA;
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0x6030             STR      R0,[R6, #+0]
   1209          
   1210          		/* Clear SI bit to be ready ... */
   1211          		I2Cx->CONCLR = (I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC);
   \   00000034   0x2028             MOVS     R0,#+40
   \   00000036   0x61B0             STR      R0,[R6, #+24]
   1212          
   1213          		time_en = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4683             MOV      R11,R0
   1214          		timeout = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x4682             MOV      R10,R0
   1215          
   1216          		while (1)
   1217          		{
   1218          			/* Check SI flag ready */
   1219          			if (I2Cx->CONSET & I2C_I2CONSET_SI)
   \                     ??I2C_SlaveTransferData_1:
   \   00000040   0x6830             LDR      R0,[R6, #+0]
   \   00000042   0x0700             LSLS     R0,R0,#+28
   \   00000044   0xD566             BPL.N    ??I2C_SlaveTransferData_2
   1220          			{
   1221          				time_en = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x4683             MOV      R11,R0
   1222          
   1223          				switch (CodeStatus = (I2Cx->STAT & I2C_STAT_CODE_BITMASK))
   \   0000004A   0x6870             LDR      R0,[R6, #+4]
   \   0000004C   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000050   0x4681             MOV      R9,R0
   \   00000052   0x2860             CMP      R0,#+96
   \   00000054   0xD018             BEQ.N    ??I2C_SlaveTransferData_3
   \   00000056   0x2870             CMP      R0,#+112
   \   00000058   0xD016             BEQ.N    ??I2C_SlaveTransferData_3
   \   0000005A   0x2880             CMP      R0,#+128
   \   0000005C   0xD019             BEQ.N    ??I2C_SlaveTransferData_4
   \   0000005E   0x2888             CMP      R0,#+136
   \   00000060   0xD02B             BEQ.N    ??I2C_SlaveTransferData_5
   \   00000062   0x2890             CMP      R0,#+144
   \   00000064   0xD015             BEQ.N    ??I2C_SlaveTransferData_4
   \   00000066   0x2898             CMP      R0,#+152
   \   00000068   0xD027             BEQ.N    ??I2C_SlaveTransferData_5
   \   0000006A   0x28A0             CMP      R0,#+160
   \   0000006C   0xD028             BEQ.N    ??I2C_SlaveTransferData_6
   \   0000006E   0x28A8             CMP      R0,#+168
   \   00000070   0xD02D             BEQ.N    ??I2C_SlaveTransferData_7
   \   00000072   0x28B8             CMP      R0,#+184
   \   00000074   0xD02B             BEQ.N    ??I2C_SlaveTransferData_7
   \   00000076   0x28C0             CMP      R0,#+192
   \   00000078   0xD03B             BEQ.N    ??I2C_SlaveTransferData_8
   \   0000007A   0x28F8             CMP      R0,#+248
   \   0000007C   0xD142             BNE.N    ??I2C_SlaveTransferData_9
   1224          				{
   1225          					/* No status information */
   1226          					case I2C_I2STAT_NO_INF:
   1227          						I2Cx->CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveTransferData_10:
   \   0000007E   0x2004             MOVS     R0,#+4
   \   00000080   0x6030             STR      R0,[R6, #+0]
   1228          						I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   00000082   0x2008             MOVS     R0,#+8
   \   00000084   0x61B0             STR      R0,[R6, #+24]
   1229          						break;
   \   00000086   0xE7DB             B.N      ??I2C_SlaveTransferData_1
   1230          
   1231          					/* Reading phase -------------------------------------------------------- */
   1232          					/* Own SLA+R has been received, ACK has been returned */
   1233          					case I2C_I2STAT_S_RX_SLAW_ACK:
   1234          
   1235          					/* General call address has been received, ACK has been returned */
   1236          					case I2C_I2STAT_S_RX_GENCALL_ACK:
   1237          						I2Cx->CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveTransferData_3:
   \   00000088   0x2004             MOVS     R0,#+4
   \   0000008A   0x6030             STR      R0,[R6, #+0]
   1238          						I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   0000008C   0x2008             MOVS     R0,#+8
   \   0000008E   0x61B0             STR      R0,[R6, #+24]
   1239          						break;
   \   00000090   0xE7D6             B.N      ??I2C_SlaveTransferData_1
   1240          
   1241          					/* Previously addressed with own SLA;
   1242          					 * DATA byte has been received;
   1243          					 * ACK has been returned */
   1244          					case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
   1245          
   1246          					/* DATA has been received, ACK hasn been return */
   1247          					case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
   1248          						/*
   1249          						 * All data bytes that over-flow the specified receive
   1250          						 * data length, just ignore them.
   1251          						 */
   1252          						if ((TransferCfg->rx_count < TransferCfg->rx_length) && (TransferCfg->rx_data != NULL))
   \                     ??I2C_SlaveTransferData_4:
   \   00000092   0x6968             LDR      R0,[R5, #+20]
   \   00000094   0x6929             LDR      R1,[R5, #+16]
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD20A             BCS.N    ??I2C_SlaveTransferData_11
   \   0000009A   0x68E8             LDR      R0,[R5, #+12]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD007             BEQ.N    ??I2C_SlaveTransferData_11
   1253          						{
   1254          							*rxdat++ = (uint8_t)I2Cx->DAT;
   \   000000A0   0x68B0             LDR      R0,[R6, #+8]
   \   000000A2   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000000A6   0xF118 0x0801      ADDS     R8,R8,#+1
   1255          
   1256          							TransferCfg->rx_count++;
   \   000000AA   0x6968             LDR      R0,[R5, #+20]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x6168             STR      R0,[R5, #+20]
   1257          						}
   1258          
   1259          						I2Cx->CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveTransferData_11:
   \   000000B0   0x2004             MOVS     R0,#+4
   \   000000B2   0x6030             STR      R0,[R6, #+0]
   1260          						I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   000000B4   0x2008             MOVS     R0,#+8
   \   000000B6   0x61B0             STR      R0,[R6, #+24]
   1261          						break;
   \   000000B8   0xE7C2             B.N      ??I2C_SlaveTransferData_1
   1262          
   1263          					/* Previously addressed with own SLA;
   1264          					 * DATA byte has been received;
   1265          					 * NOT ACK has been returned */
   1266          					case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
   1267          
   1268          					/* DATA has been received, NOT ACK has been returned */
   1269          					case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
   1270          						I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_SlaveTransferData_5:
   \   000000BA   0x2008             MOVS     R0,#+8
   \   000000BC   0x61B0             STR      R0,[R6, #+24]
   1271          						break;
   \   000000BE   0xE7BF             B.N      ??I2C_SlaveTransferData_1
   1272          
   1273          					/*
   1274          					 * Note that: Return code only let us know a stop condition mixed
   1275          					 * with a repeat start condition in the same code value.
   1276          					 * So we should provide a time-out. In case this is really a stop
   1277          					 * condition, this will return back after time out condition. Otherwise,
   1278          					 * next session that is slave receive data will be completed.
   1279          					 */
   1280          
   1281          					/* A Stop or a repeat start condition */
   1282          					case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
   1283          						I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_SlaveTransferData_6:
   \   000000C0   0x2008             MOVS     R0,#+8
   \   000000C2   0x61B0             STR      R0,[R6, #+24]
   1284          						// enable time out
   1285          						time_en = 1;
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x4683             MOV      R11,R0
   1286          						timeout = 0;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x4682             MOV      R10,R0
   1287          						break;
   \   000000CC   0xE7B8             B.N      ??I2C_SlaveTransferData_1
   1288          
   1289          					/* Writing phase -------------------------------------------------------- */
   1290          					/* Own SLA+R has been received, ACK has been returned */
   1291          					case I2C_I2STAT_S_TX_SLAR_ACK:
   1292          
   1293          					/* Data has been transmitted, ACK has been received */
   1294          					case I2C_I2STAT_S_TX_DAT_ACK:
   1295          						/*
   1296          						 * All data bytes that over-flow the specified receive
   1297          						 * data length, just ignore them.
   1298          						 */
   1299          						if ((TransferCfg->tx_count < TransferCfg->tx_length) && (TransferCfg->tx_data != NULL))
   \                     ??I2C_SlaveTransferData_7:
   \   000000CE   0x68A8             LDR      R0,[R5, #+8]
   \   000000D0   0x6869             LDR      R1,[R5, #+4]
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xD208             BCS.N    ??I2C_SlaveTransferData_12
   \   000000D6   0x6828             LDR      R0,[R5, #+0]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD005             BEQ.N    ??I2C_SlaveTransferData_12
   1300          						{
   1301          							I2Cx->DAT = *txdat++;
   \   000000DC   0x7838             LDRB     R0,[R7, #+0]
   \   000000DE   0x60B0             STR      R0,[R6, #+8]
   \   000000E0   0x1C7F             ADDS     R7,R7,#+1
   1302          
   1303          							TransferCfg->tx_count++;
   \   000000E2   0x68A8             LDR      R0,[R5, #+8]
   \   000000E4   0x1C40             ADDS     R0,R0,#+1
   \   000000E6   0x60A8             STR      R0,[R5, #+8]
   1304          						}
   1305          
   1306          						I2Cx->CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveTransferData_12:
   \   000000E8   0x2004             MOVS     R0,#+4
   \   000000EA   0x6030             STR      R0,[R6, #+0]
   1307          						I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   000000EC   0x2008             MOVS     R0,#+8
   \   000000EE   0x61B0             STR      R0,[R6, #+24]
   1308          						break;
   \   000000F0   0xE7A6             B.N      ??I2C_SlaveTransferData_1
   1309          
   1310          					/* Data has been transmitted, NACK has been received,
   1311          					 * that means there's no more data to send, exit now */
   1312          					/*
   1313          					 * Note: Don't wait for stop event since in slave transmit mode,
   1314          					 * since there no proof lets us know when a stop signal has been received
   1315          					 * on slave side.
   1316          					 */
   1317          					case I2C_I2STAT_S_TX_DAT_NACK:
   1318          						I2Cx->CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveTransferData_8:
   \   000000F2   0x2004             MOVS     R0,#+4
   \   000000F4   0x6030             STR      R0,[R6, #+0]
   1319          						I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   000000F6   0x2008             MOVS     R0,#+8
   \   000000F8   0x61B0             STR      R0,[R6, #+24]
   1320          						// enable time out
   1321          						time_en = 1;
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0x4683             MOV      R11,R0
   1322          						timeout = 0;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x4682             MOV      R10,R0
   1323          						break;
   \   00000102   0xE79D             B.N      ??I2C_SlaveTransferData_1
   1324          
   1325          					// Other status must be captured
   1326          					default:
   1327          						I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_SlaveTransferData_9:
   \   00000104   0x2008             MOVS     R0,#+8
   \   00000106   0x61B0             STR      R0,[R6, #+24]
   1328          						goto s_error;
   1329          				}
   1330          			}
   1331          			else if (time_en)
   1332          			{
   1333          				if (timeout++ > I2C_SLAVE_TIME_OUT)
   1334          				{
   1335          					// it's really a stop condition, goto end stage
   1336          					goto s_end_stage;
   1337          				}
   1338          			}
   1339          		}
   1340          
   1341          s_end_stage:
   1342          		/* Clear AA bit to disable ACK on I2C bus */
   1343          		I2Cx->CONCLR = I2C_I2CONCLR_AAC;
   1344          
   1345          		// Check if there's no error during operation
   1346          		// Update status
   1347          		TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_DONE;
   1348          		return SUCCESS;
   1349          
   1350          s_error:
   1351          		/* Clear AA bit to disable ACK on I2C bus */
   1352          		I2Cx->CONCLR = I2C_I2CONCLR_AAC;
   \   00000108   0x2004             MOVS     R0,#+4
   \   0000010A   0x61B0             STR      R0,[R6, #+24]
   1353          
   1354          		// Update status
   1355          		TransferCfg->status = CodeStatus;
   \   0000010C   0xF8C5 0x9018      STR      R9,[R5, #+24]
   1356          		return ERROR;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0xE029             B.N      ??I2C_SlaveTransferData_13
   \                     ??I2C_SlaveTransferData_2:
   \   00000114   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000118   0xD092             BEQ.N    ??I2C_SlaveTransferData_1
   \   0000011A   0x4650             MOV      R0,R10
   \   0000011C   0xF110 0x0A01      ADDS     R10,R0,#+1
   \   00000120   0xF1B0 0x1F01      CMP      R0,#+65537
   \   00000124   0xD38C             BCC.N    ??I2C_SlaveTransferData_1
   \   00000126   0x2004             MOVS     R0,#+4
   \   00000128   0x61B0             STR      R0,[R6, #+24]
   \   0000012A   0xF459 0x6080      ORRS     R0,R9,#0x400
   \   0000012E   0x61A8             STR      R0,[R5, #+24]
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0xE019             B.N      ??I2C_SlaveTransferData_13
   1357          	}
   1358          
   1359          	else if (Opt == I2C_TRANSFER_INTERRUPT)
   \                     ??I2C_SlaveTransferData_0:
   \   00000134   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000138   0x2801             CMP      R0,#+1
   \   0000013A   0xD114             BNE.N    ??I2C_SlaveTransferData_14
   1360          	{
   1361          		// Setup tx_rx data, callback and interrupt handler
   1362          		i2cdat[i2cId].txrx_setup = (uint32_t) TransferCfg;
   \   0000013C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013E   0x....             LDR.N    R0,??DataTable10_5
   \   00000140   0xF840 0x5034      STR      R5,[R0, R4, LSL #+3]
   1363          
   1364          		// Set direction phase, read first
   1365          		i2cdat[i2cId].dir = 1;
   \   00000144   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000146   0x....             LDR.N    R0,??DataTable10_5
   \   00000148   0xEB10 0x00C4      ADDS     R0,R0,R4, LSL #+3
   \   0000014C   0x2101             MOVS     R1,#+1
   \   0000014E   0x6041             STR      R1,[R0, #+4]
   1366          
   1367          		// Enable AA
   1368          		I2Cx->CONSET = I2C_I2CONSET_AA;
   \   00000150   0x2004             MOVS     R0,#+4
   \   00000152   0x6030             STR      R0,[R6, #+0]
   1369          		I2Cx->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
   \   00000154   0x2028             MOVS     R0,#+40
   \   00000156   0x61B0             STR      R0,[R6, #+24]
   1370          		I2C_IntCmd(i2cId, (Bool)1);
   \   00000158   0x2101             MOVS     R1,#+1
   \   0000015A   0x0020             MOVS     R0,R4
   \   0000015C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015E   0x.... 0x....      BL       I2C_IntCmd
   1371          
   1372          		return (SUCCESS);
   \   00000162   0x2001             MOVS     R0,#+1
   \   00000164   0xE000             B.N      ??I2C_SlaveTransferData_13
   1373          	}
   1374          
   1375          	return ERROR;
   \                     ??I2C_SlaveTransferData_14:
   \   00000166   0x2000             MOVS     R0,#+0
   \                     ??I2C_SlaveTransferData_13:
   \   00000168   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1376          }
   1377          
   1378          /*********************************************************************//**
   1379           * @brief		Set Own slave address in I2C peripheral corresponding to
   1380           * 				parameter specified in OwnSlaveAddrConfigStruct.
   1381           * @param[in]	I2Cx	I2C peripheral selected, should be
   1382           *    			- LPC_I2C0
   1383           * 				- LPC_I2C1
   1384           * 				- LPC_I2C2
   1385           * @param[in]	OwnSlaveAddrConfigStruct	Pointer to a I2C_OWNSLAVEADDR_CFG_Type
   1386           * 				structure that contains the configuration information for the
   1387          *               specified I2C slave address.
   1388           * @return 		None
   1389           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1390          void I2C_SetOwnSlaveAddr(uint8_t i2cId, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct)
   1391          {
   \                     I2C_SetOwnSlaveAddr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1392          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       I2C_GetPointer
   1393          
   1394          	uint32_t tmp;
   1395          
   1396          	tmp = (((uint32_t)(OwnSlaveAddrConfigStruct->SlaveAddr_7bit << 1)) \
   1397          			| ((OwnSlaveAddrConfigStruct->GeneralCallState == ENABLE) ? 0x01 : 0x00))& I2C_I2ADR_BITMASK;
   \   0000000E   0x78AA             LDRB     R2,[R5, #+2]
   \   00000010   0x2A01             CMP      R2,#+1
   \   00000012   0xD101             BNE.N    ??I2C_SetOwnSlaveAddr_0
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xE000             B.N      ??I2C_SetOwnSlaveAddr_1
   \                     ??I2C_SetOwnSlaveAddr_0:
   \   00000018   0x2100             MOVS     R1,#+0
   \                     ??I2C_SetOwnSlaveAddr_1:
   \   0000001A   0x786A             LDRB     R2,[R5, #+1]
   \   0000001C   0xEA51 0x0142      ORRS     R1,R1,R2, LSL #+1
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   1398          
   1399          	switch (OwnSlaveAddrConfigStruct->SlaveAddrChannel)
   \   00000022   0x782A             LDRB     R2,[R5, #+0]
   \   00000024   0x2A00             CMP      R2,#+0
   \   00000026   0xD005             BEQ.N    ??I2C_SetOwnSlaveAddr_2
   \   00000028   0x2A02             CMP      R2,#+2
   \   0000002A   0xD00F             BEQ.N    ??I2C_SetOwnSlaveAddr_3
   \   0000002C   0xD308             BCC.N    ??I2C_SetOwnSlaveAddr_4
   \   0000002E   0x2A03             CMP      R2,#+3
   \   00000030   0xD012             BEQ.N    ??I2C_SetOwnSlaveAddr_5
   \   00000032   0xE016             B.N      ??I2C_SetOwnSlaveAddr_6
   1400          	{
   1401          		case 0:
   1402          			I2Cx->ADR0 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_2:
   \   00000034   0x60C1             STR      R1,[R0, #+12]
   1403          
   1404          			I2Cx->MASK0 = I2C_I2MASK_MASK((uint32_t) \
   1405          							(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   00000036   0x78EA             LDRB     R2,[R5, #+3]
   \   00000038   0xF012 0x02FE      ANDS     R2,R2,#0xFE
   \   0000003C   0x6302             STR      R2,[R0, #+48]
   1406          			break;
   \   0000003E   0xE010             B.N      ??I2C_SetOwnSlaveAddr_6
   1407          
   1408          		case 1:
   1409          			I2Cx->ADR1 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_4:
   \   00000040   0x6201             STR      R1,[R0, #+32]
   1410          
   1411          			I2Cx->MASK1 = I2C_I2MASK_MASK((uint32_t) \
   1412          							(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   00000042   0x78EA             LDRB     R2,[R5, #+3]
   \   00000044   0xF012 0x02FE      ANDS     R2,R2,#0xFE
   \   00000048   0x6342             STR      R2,[R0, #+52]
   1413          			break;
   \   0000004A   0xE00A             B.N      ??I2C_SetOwnSlaveAddr_6
   1414          
   1415          		case 2:
   1416          			I2Cx->ADR2 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_3:
   \   0000004C   0x6241             STR      R1,[R0, #+36]
   1417          
   1418          			I2Cx->MASK2 = I2C_I2MASK_MASK((uint32_t) \
   1419          							(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   0000004E   0x78EA             LDRB     R2,[R5, #+3]
   \   00000050   0xF012 0x02FE      ANDS     R2,R2,#0xFE
   \   00000054   0x6382             STR      R2,[R0, #+56]
   1420          			break;
   \   00000056   0xE004             B.N      ??I2C_SetOwnSlaveAddr_6
   1421          
   1422          		case 3:
   1423          			I2Cx->ADR3 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_5:
   \   00000058   0x6281             STR      R1,[R0, #+40]
   1424          
   1425          			I2Cx->MASK3 = I2C_I2MASK_MASK((uint32_t) \
   1426          							(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   0000005A   0x78EA             LDRB     R2,[R5, #+3]
   \   0000005C   0xF012 0x02FE      ANDS     R2,R2,#0xFE
   \   00000060   0x63C2             STR      R2,[R0, #+60]
   1427          			break;
   1428          	}
   1429          }
   \                     ??I2C_SetOwnSlaveAddr_6:
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1430          
   1431          
   1432          /*********************************************************************//**
   1433           * @brief		Configures functionality in I2C monitor mode
   1434           * @param[in]	I2Cx	I2C peripheral selected, should be
   1435           *   			- LPC_I2C0
   1436           * 				- LPC_I2C1
   1437           * 				- LPC_I2C2
   1438           * @param[in]	MonitorCfgType Monitor Configuration type, should be:
   1439           * 				- I2C_MONITOR_CFG_SCL_OUTPUT: I2C module can 'stretch'
   1440           * 				the clock line (hold it low) until it has had time to
   1441           * 				respond to an I2C interrupt.
   1442           * 				- I2C_MONITOR_CFG_MATCHALL: When this bit is set to '1'
   1443           * 				and the I2C is in monitor mode, an interrupt will be
   1444           * 				generated on ANY address received.
   1445           * @param[in]	NewState New State of this function, should be:
   1446           * 				- ENABLE: Enable this function.
   1447           * 				- DISABLE: Disable this function.
   1448           * @return		None
   1449           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1450          void I2C_MonitorModeConfig(uint8_t i2cId, uint32_t MonitorCfgType, FunctionalState NewState)
   1451          {
   \                     I2C_MonitorModeConfig:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1452          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       I2C_GetPointer
   1453          
   1454          	if (NewState == ENABLE)
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E01             CMP      R6,#+1
   \   00000014   0xD103             BNE.N    ??I2C_MonitorModeConfig_0
   1455          	{
   1456          		I2Cx->MMCTRL |= MonitorCfgType;
   \   00000016   0x69C1             LDR      R1,[R0, #+28]
   \   00000018   0x4329             ORRS     R1,R5,R1
   \   0000001A   0x61C1             STR      R1,[R0, #+28]
   \   0000001C   0xE005             B.N      ??I2C_MonitorModeConfig_1
   1457          	}
   1458          	else
   1459          	{
   1460          		I2Cx->MMCTRL &= (~MonitorCfgType) & I2C_I2MMCTRL_BITMASK;
   \                     ??I2C_MonitorModeConfig_0:
   \   0000001E   0x69C1             LDR      R1,[R0, #+28]
   \   00000020   0x43EA             MVNS     R2,R5
   \   00000022   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   00000026   0x4011             ANDS     R1,R2,R1
   \   00000028   0x61C1             STR      R1,[R0, #+28]
   1461          	}
   1462          }
   \                     ??I2C_MonitorModeConfig_1:
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
   1463          
   1464          
   1465          /*********************************************************************//**
   1466           * @brief		Enable/Disable I2C monitor mode
   1467           * @param[in]	I2Cx	I2C peripheral selected, should be
   1468           *    			- LPC_I2C0
   1469           * 				- LPC_I2C1
   1470           * 				- LPC_I2C2
   1471           * @param[in]	NewState New State of this function, should be:
   1472           * 				- ENABLE: Enable monitor mode.
   1473           * 				- DISABLE: Disable monitor mode.
   1474           * @return		None
   1475           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1476          void I2C_MonitorModeCmd(uint8_t i2cId, FunctionalState NewState)
   1477          {
   \                     I2C_MonitorModeCmd:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1478          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       I2C_GetPointer
   1479          
   1480          	if (NewState == ENABLE)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xD108             BNE.N    ??I2C_MonitorModeCmd_0
   1481          	{
   1482          		I2Cx->MMCTRL |= I2C_I2MMCTRL_MM_ENA;
   \   00000014   0x69C1             LDR      R1,[R0, #+28]
   \   00000016   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000001A   0x61C1             STR      R1,[R0, #+28]
   1483          		I2Cx->CONSET = I2C_I2CONSET_AA;
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x6001             STR      R1,[R0, #+0]
   1484          		I2Cx->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
   \   00000020   0x2128             MOVS     R1,#+40
   \   00000022   0x6181             STR      R1,[R0, #+24]
   \   00000024   0xE005             B.N      ??I2C_MonitorModeCmd_1
   1485          	}
   1486          	else
   1487          	{
   1488          		I2Cx->MMCTRL &= (~I2C_I2MMCTRL_MM_ENA) & I2C_I2MMCTRL_BITMASK;
   \                     ??I2C_MonitorModeCmd_0:
   \   00000026   0x69C1             LDR      R1,[R0, #+28]
   \   00000028   0xF011 0x0106      ANDS     R1,R1,#0x6
   \   0000002C   0x61C1             STR      R1,[R0, #+28]
   1489          		I2Cx->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_AAC;
   \   0000002E   0x212C             MOVS     R1,#+44
   \   00000030   0x6181             STR      R1,[R0, #+24]
   1490          	}
   1491          
   1492          	I2C_MonitorBufferIndex = 0;
   \                     ??I2C_MonitorModeCmd_1:
   \   00000032   0x....             LDR.N    R1,??DataTable10_10
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x600A             STR      R2,[R1, #+0]
   1493          }
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1494          
   1495          
   1496          /*********************************************************************//**
   1497           * @brief		Get data from I2C data buffer in monitor mode.
   1498           * @param[in]	I2Cx	I2C peripheral selected, should be
   1499           *    			- LPC_I2C0
   1500           * 				- LPC_I2C1
   1501           * 				- LPC_I2C2
   1502           * @return		None
   1503           * Note:	In monitor mode, the I2C module may lose the ability to stretch
   1504           * the clock (stall the bus) if the ENA_SCL bit is not set. This means that
   1505           * the processor will have a limited amount of time to read the contents of
   1506           * the data received on the bus. If the processor reads the DAT shift
   1507           * register, as it ordinarily would, it could have only one bit-time to
   1508           * respond to the interrupt before the received data is overwritten by
   1509           * new data.
   1510           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1511          uint8_t I2C_MonitorGetDatabuffer(uint8_t i2cId)
   1512          {
   \                     I2C_MonitorGetDatabuffer:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1513          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       I2C_GetPointer
   1514          
   1515          	return ((uint8_t)(I2Cx->DATA_BUFFER));
   \   0000000C   0x6AC0             LDR      R0,[R0, #+44]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   1516          }
   1517          
   1518          /*********************************************************************//**
   1519           * @brief		Get data from I2C data buffer in monitor mode.
   1520           * @param[in]	I2Cx	I2C peripheral selected, should be
   1521           *    			- LPC_I2C0
   1522           * 				- LPC_I2C1
   1523           * 				- LPC_I2C2
   1524           * @return		None
   1525           * Note:	In monitor mode, the I2C module may lose the ability to stretch
   1526           * the clock (stall the bus) if the ENA_SCL bit is not set. This means that
   1527           * the processor will have a limited amount of time to read the contents of
   1528           * the data received on the bus. If the processor reads the DAT shift
   1529           * register, as it ordinarily would, it could have only one bit-time to
   1530           * respond to the interrupt before the received data is overwritten by
   1531           * new data.
   1532           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1533          BOOL_8 I2C_MonitorHandler(uint8_t i2cId, uint8_t *buffer, uint32_t size)
   1534          {
   \                     I2C_MonitorHandler:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1535          	LPC_I2C_TypeDef* I2Cx = I2C_GetPointer((en_I2C_unitId)i2cId);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       I2C_GetPointer
   \   00000010   0x0001             MOVS     R1,R0
   1536          
   1537          	BOOL_8 ret=FALSE;
   \   00000012   0x2000             MOVS     R0,#+0
   1538          
   1539          	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
   \   00000014   0x2208             MOVS     R2,#+8
   \   00000016   0x618A             STR      R2,[R1, #+24]
   1540          
   1541          	buffer[I2C_MonitorBufferIndex] = (uint8_t)(I2Cx->DATA_BUFFER);
   \   00000018   0x....             LDR.N    R2,??DataTable10_10
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0x6ACB             LDR      R3,[R1, #+44]
   \   0000001E   0x5553             STRB     R3,[R2, R5]
   1542          
   1543          	I2C_MonitorBufferIndex++;
   \   00000020   0x....             LDR.N    R2,??DataTable10_10
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0x1C52             ADDS     R2,R2,#+1
   \   00000026   0x....             LDR.N    R3,??DataTable10_10
   \   00000028   0x601A             STR      R2,[R3, #+0]
   1544          
   1545          	if(I2C_MonitorBufferIndex >= size)
   \   0000002A   0x....             LDR.N    R2,??DataTable10_10
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x42B2             CMP      R2,R6
   \   00000030   0xD301             BCC.N    ??I2C_MonitorHandler_0
   1546          	{
   1547          		ret = TRUE;
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x0010             MOVS     R0,R2
   1548          	}
   1549          	return ret;
   \                     ??I2C_MonitorHandler_0:
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
   1550          }
   1551          /*********************************************************************//**
   1552           * @brief 		Get status of Master Transfer
   1553           * @param[in]	I2Cx	I2C peripheral selected, should be:
   1554           *  			- LPC_I2C0
   1555           * 				- LPC_I2C1
   1556           * 				- LPC_I2C2
   1557           * @return 		Master transfer status, could be:
   1558           * 				- TRUE	master transfer completed
   1559           * 				- FALSE master transfer have not completed yet
   1560           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1561          uint32_t I2C_MasterTransferComplete(uint8_t i2cId)
   1562          {
   \                     I2C_MasterTransferComplete:
   \   00000000   0x0001             MOVS     R1,R0
   1563          	uint32_t retval;
   1564          
   1565          	retval = I2C_MasterComplete[i2cId];
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x....             LDR.N    R2,??DataTable10_6
   \   00000006   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \   0000000A   0x0010             MOVS     R0,R2
   1566          
   1567          	I2C_MasterComplete[i2cId] = FALSE;
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x....             LDR.N    R2,??DataTable10_6
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   1568          
   1569          	return retval;
   \   00000016   0x4770             BX       LR               ;; return
   1570          }
   1571          
   1572          /*********************************************************************//**
   1573           * @brief 		Get status of Slave Transfer
   1574           * @param[in]	I2Cx	I2C peripheral selected, should be:
   1575           * 				- LPC_I2C0
   1576           * 				- LPC_I2C1
   1577           * 				- LPC_I2C2
   1578           * @return 		Complete status, could be: TRUE/FALSE
   1579           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1580          uint32_t I2C_SlaveTransferComplete(uint8_t i2cId)
   1581          {
   \                     I2C_SlaveTransferComplete:
   \   00000000   0x0001             MOVS     R1,R0
   1582          	uint32_t retval;
   1583          
   1584          	retval = I2C_SlaveComplete[i2cId];
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x....             LDR.N    R2,??DataTable10_7
   \   00000006   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \   0000000A   0x0010             MOVS     R0,R2
   1585          
   1586          	I2C_SlaveComplete[i2cId] = FALSE;
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x....             LDR.N    R2,??DataTable10_7
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   1587          
   1588          	return retval;
   \   00000016   0x4770             BX       LR               ;; return
   1589          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x4001C000         DC32     0x4001c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x4005C000         DC32     0x4005c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x400A0000         DC32     0x400a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     i2cdat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     I2C_MasterComplete

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     I2C_SlaveComplete

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     bSenok

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     bSenValid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     I2C_MonitorBufferIndex
   1590          
   1591          
   1592          
   1593          /**
   1594           * @}
   1595           */
   1596          
   1597          
   1598          /**
   1599           * @}
   1600           */
   1601          
   1602          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   I2C_Cmd
        16   -> I2C_GetPointer
      16   I2C_DeInit
        16   -> CLKPWR_ConfigPPWR
        16   -> I2C_GetPointer
       0   I2C_GetByte
       0   I2C_GetPointer
      24   I2C_Init
        24   -> CLKPWR_ConfigPPWR
        24   -> CLKPWR_GetCLK
        24   -> I2C_GetPointer
      16   I2C_IntCmd
        16   -> NVIC_DisableIRQ
        16   -> NVIC_EnableIRQ
      24   I2C_MasterHandler
        24   -> I2C_GetPointer
        24   -> I2C_IntCmd
        24   -> I2C_Stop
       0   I2C_MasterTransferComplete
      40   I2C_MasterTransferData
        40   -> I2C_GetByte
        40   -> I2C_GetPointer
        40   -> I2C_IntCmd
        40   -> I2C_SendByte
        40   -> I2C_Start
        40   -> I2C_Stop
       8   I2C_MonitorGetDatabuffer
         8   -> I2C_GetPointer
      16   I2C_MonitorHandler
        16   -> I2C_GetPointer
      16   I2C_MonitorModeCmd
        16   -> I2C_GetPointer
      16   I2C_MonitorModeConfig
        16   -> I2C_GetPointer
       0   I2C_SendByte
      16   I2C_SetOwnSlaveAddr
        16   -> I2C_GetPointer
      24   I2C_SlaveHandler
        24   -> I2C_GetPointer
        24   -> I2C_IntCmd
       0   I2C_SlaveTransferComplete
      40   I2C_SlaveTransferData
        40   -> I2C_GetPointer
        40   -> I2C_IntCmd
       0   I2C_Start
       0   I2C_Stop
       4   NVIC_DisableIRQ
       4   NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      32  I2C_Cmd
      66  I2C_DeInit
      38  I2C_GetByte
      46  I2C_GetPointer
     102  I2C_Init
      66  I2C_IntCmd
      12  I2C_MasterComplete
     534  I2C_MasterHandler
      24  I2C_MasterTransferComplete
     582  I2C_MasterTransferData
       4  I2C_MonitorBufferIndex
      18  I2C_MonitorGetDatabuffer
      58  I2C_MonitorHandler
      58  I2C_MonitorModeCmd
      44  I2C_MonitorModeConfig
      50  I2C_SendByte
     100  I2C_SetOwnSlaveAddr
      12  I2C_SlaveComplete
     306  I2C_SlaveHandler
      24  I2C_SlaveTransferComplete
     364  I2C_SlaveTransferData
      44  I2C_Start
      20  I2C_Stop
      26  NVIC_DisableIRQ
      26  NVIC_EnableIRQ
      24  i2cdat

 
    52 bytes in section .bss
 2 672 bytes in section .text
 
 2 672 bytes of CODE memory
    52 bytes of DATA memory

Errors: none
Warnings: none
