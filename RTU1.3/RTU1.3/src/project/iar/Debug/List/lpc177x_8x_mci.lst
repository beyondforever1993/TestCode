###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:41 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_mci.c                             #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_mci.c -lCN                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\ -o D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë #
#                    \RTU_1.2\project\iar\Debug\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\lpc177x_8x_mci.lst                         #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\lpc177x_8x_mci.o                            #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Drivers\source\lpc177x_8x_mci.c
      1          /**********************************************************************
      2          * $Id$         lpc177x_8x_mci.c            2011-06-02
      3          *//**
      4          * @file        lpc177x_8x_mci.c
      5          * @brief       Contains all functions support for MCI firmware library
      6          *              on LPC177x_8x
      7          * @version     2.0
      8          * @date        29. June. 2011
      9          * @author      NXP MCU SW Application Team
     10          * 
     11          * Copyright(C) 2011, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          * Permission to use, copy, modify, and distribute this software and its
     26          * documentation is hereby granted, under NXP Semiconductors'
     27          * relevant copyright in the software, without fee, provided that it
     28          * is used in conjunction with NXP Semiconductors microcontrollers.  This
     29          * copyright, permission, and disclaimer notice must appear in all copies of
     30          * this code.
     31          **********************************************************************/
     32          #ifdef __BUILD_WITH_EXAMPLE__
     33          #include "lpc177x_8x_libcfg.h"
     34          #else
     35          #include "lpc177x_8x_libcfg_default.h"
     36          #endif /* __BUILD_WITH_EXAMPLE__ */
     37          
     38          #ifdef _MCI
     39          
     40          #include "LPC177x_8x.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable23  ;; 0xe000e100
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
     41          #include "lpc_types.h"
     42          #include "lpc177x_8x_mci.h"
     43          #include "lpc177x_8x_gpdma.h"
     44          #include "lpc177x_8x_clkpwr.h"
     45          #include "lpc177x_8x_pinsel.h"
     46          
     47          #define DMA_MCI_SIZE                     BLOCK_LENGTH
     48          
     49          #define _SHIFT(x)                        (1 << x)
     50          #define _XSHIFT(x, y)                    (x << y)
     51          
     52          #define SHIFT_(x)                        (1 >> x)
     53          #define XSHIFT_(x, y)                    (x >> y)
     54          
     55          #define MCI_ACMD41_HCS_POS                     (30)
     56          
     57          #define MCI_PWRCTRL_BMASK                      (0xC3)
     58          
     59          #define MCI_PWRCTRL_OPENDRAIN_POS              (6)
     60          #define MCI_PWRCTRL_OPENDRAIN_NUMBIT           (1)
     61          #define MCI_PWRCTRL_OPENDRAIN_BMASK            (0x01)
     62          
     63          

   \                                 In section .bss, align 4
     64          volatile uint32_t Mci_Data_Xfer_End = 0;
   \                     Mci_Data_Xfer_End:
   \   00000000                      DS8 4
     65          

   \                                 In section .bss, align 4
     66          volatile uint32_t Mci_Data_Xfer_ERR = 0;
   \                     Mci_Data_Xfer_ERR:
   \   00000000                      DS8 4
     67          

   \                                 In section .bss, align 1
     68          volatile uint8_t fifo_plane = 0;
   \                     fifo_plane:
   \   00000000                      DS8 1
     69          

   \                                 In section .bss, align 4
     70          volatile uint32_t CardRCA;
   \                     CardRCA:
   \   00000000                      DS8 4
     71          

   \                                 In section .bss, align 1
     72          volatile uint8_t CCS;
   \                     CCS:
   \   00000000                      DS8 1
     73          

   \                                 In section .bss, align 1
     74          volatile en_Mci_CardType MCI_CardType;
   \                     MCI_CardType:
   \   00000000                      DS8 1
     75          
     76          // Terminal Counter flag, Error Counter flag for Channel 0

   \                                 In section .bss, align 4
     77          uint32_t dmaWrCh_TermianalCnt = 0, dmaWrCh_ErrorCnt = 0;
   \                     dmaWrCh_TermianalCnt:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     dmaWrCh_ErrorCnt:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     78          uint32_t dmaRdCh_TermianalCnt = 0, dmaRdCh_ErrorCnt = 0;
   \                     dmaRdCh_TermianalCnt:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     dmaRdCh_ErrorCnt:
   \   00000000                      DS8 4
     79          
     80          
     81          uint32_t MCI_SettingDma(uint8_t* memBuf, uint32_t ChannelNum, uint32_t DMAMode ,uint32_t numOfBlock);
     82          
     83          int32_t MCI_ReadFifo(uint32_t * dest);
     84          int32_t MCI_WriteFifo(uint32_t * src);
     85          
     86          void MCI_TXEnable( void );
     87          void MCI_RXEnable( void );
     88          void MCI_TXDisable( void );
     89          void MCI_RXDisable( void );
     90          
     91          void MCI_CmdProcess( void );
     92          void MCI_DataErrorProcess( void );
     93          void MCI_DataErrorProcess( void );
     94          void MCI_DATA_END_InterruptService( void );
     95          void MCI_FIFOInterruptService( void );
     96          
     97          int32_t MCI_CheckStatus(uint8_t expect_status);
     98          

   \                                 In section .data, align 4
     99          volatile uint8_t* dataSrcBlock = (uint8_t *) MCI_DMA_SRC_ADDR;
   \                     dataSrcBlock:
   \   00000000   0x20000000         DC32 20000000H

   \                                 In section .data, align 4
    100          volatile uint8_t* dataDestBlock = (uint8_t *) MCI_DMA_DST_ADDR;;
   \                     dataDestBlock:
   \   00000000   0x200003E8         DC32 200003E8H
    101          

   \                                 In section .bss, align 4
    102          volatile uint32_t txBlockCnt=0, rxBlockCnt=0;
   \                     txBlockCnt:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     rxBlockCnt:
   \   00000000                      DS8 4
    103          
    104          /** @addtogroup MCI_Private_Functions MCI Private Function
    105          * @ingroup MCI
    106          * @{
    107          */
    108          
    109          #if MCI_DMA_ENABLED
    110          /*********************************************************************//**
    111          * @brief        Do setting GPDMA for MCI working
    112          *
    113          * @param[in]    DMAMode set for the Type of DMA Transfer. It may be memory
    114          *                        to peripheral (M2P) or peripheral to memory (P2M)
    115          *                        in MCI working
    116          *
    117          * @param[in]    ChannelNum    which channel is used for current transfer with 
    118          *                        DMA compent
    119          *
    120          * @param[in]    memBuf    point to a UINT8 buffer. In 2 cases of DMAMode
    121          *                        seperated:
    122          *                        - M2P: it is the source address that hold the
    123          *                        expected buffer to transfer
    124          *                        - P2M: it is the destination address that will store
    125          *                         data that retrieved from the peripheral (the Card in slot)
    126          *
    127          * @return         None
    128          *
    129          * @note        This is only required if DMA support is enabled
    130          **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    131          uint32_t MCI_SettingDma(uint8_t* memBuf, uint32_t ChannelNum, uint32_t DMAMode,uint32_t numOfBlock )
    132          {
   \                     MCI_SettingDma:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    133            GPDMA_Channel_CFG_Type GPDMACfg;
    134            
    135            // Transfer size
    136            GPDMACfg.TransferSize = DMA_MCI_SIZE * numOfBlock;
   \   0000000C   0xF44F 0x7000      MOV      R0,#+512
   \   00000010   0xFB00 0xF007      MUL      R0,R0,R7
   \   00000014   0x9001             STR      R0,[SP, #+4]
    137            // Transfer width
    138            GPDMACfg.TransferWidth = GPDMA_WIDTH_WORD;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x9002             STR      R0,[SP, #+8]
    139            // Transfer type
    140            GPDMACfg.TransferType = DMAMode;
   \   0000001A   0x9605             STR      R6,[SP, #+20]
    141            // Linker List Item - unused
    142            GPDMACfg.DMALLI = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9008             STR      R0,[SP, #+32]
    143            
    144            /* USB RAM is used for test.
    145            Please note, Ethernet has its own SRAM, but GPDMA can't access
    146            that. GPDMA can access USB SRAM and IRAM. Ethernet DMA controller can 
    147            access both IRAM and Ethernet SRAM. */
    148            GPDMACfg.ChannelNum = ChannelNum;
   \   00000020   0x9500             STR      R5,[SP, #+0]
    149            
    150            if ( DMAMode == GPDMA_TRANSFERTYPE_M2P_DEST_CTRL )
   \   00000022   0x2E05             CMP      R6,#+5
   \   00000024   0xD108             BNE.N    ??MCI_SettingDma_0
    151            {
    152              /* Ch0 set for M2P transfer from mempry to MCI FIFO. */
    153              // Source memory
    154              GPDMACfg.SrcMemAddr = (uint32_t)memBuf;
   \   00000026   0x9403             STR      R4,[SP, #+12]
    155              // Destination memory
    156              GPDMACfg.DstMemAddr = (uint32_t)LPC_MCI->FIFO;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x400c0080
   \   0000002C   0x9004             STR      R0,[SP, #+16]
    157              
    158              // Source connection 
    159              GPDMACfg.SrcConn = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x9006             STR      R0,[SP, #+24]
    160              // Destination connection 
    161              GPDMACfg.DstConn = GPDMA_CONN_MCI;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x9007             STR      R0,[SP, #+28]
   \   00000036   0xE00C             B.N      ??MCI_SettingDma_1
    162              
    163            }
    164            else if ( DMAMode == GPDMA_TRANSFERTYPE_P2M_SRC_CTRL )
   \                     ??MCI_SettingDma_0:
   \   00000038   0x2E06             CMP      R6,#+6
   \   0000003A   0xD108             BNE.N    ??MCI_SettingDma_2
    165            {
    166              /* Ch0 set for P2M transfer from MCI FIFO to memory. */
    167              // Source memory
    168              GPDMACfg.SrcMemAddr = (uint32_t)LPC_MCI->FIFO;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x400c0080
   \   00000040   0x9003             STR      R0,[SP, #+12]
    169              // Destination memory
    170              GPDMACfg.DstMemAddr = (uint32_t)memBuf;
   \   00000042   0x9404             STR      R4,[SP, #+16]
    171              
    172              // Source connection 
    173              GPDMACfg.SrcConn = GPDMA_CONN_MCI;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x9006             STR      R0,[SP, #+24]
    174              // Destination connection
    175              GPDMACfg.DstConn = 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x9007             STR      R0,[SP, #+28]
   \   0000004C   0xE001             B.N      ??MCI_SettingDma_1
    176            }
    177            else
    178            {
    179              return ( FALSE );
   \                     ??MCI_SettingDma_2:
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE00B             B.N      ??MCI_SettingDma_3
    180            }
    181            
    182            // Setup channel with given parameter
    183            GPDMA_Setup(&GPDMACfg);
   \                     ??MCI_SettingDma_1:
   \   00000052   0xA800             ADD      R0,SP,#+0
   \   00000054   0x.... 0x....      BL       GPDMA_Setup
    184            
    185            // Enable GPDMA channel 
    186            GPDMA_ChannelCmd(ChannelNum, ENABLE);
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x.... 0x....      BL       GPDMA_ChannelCmd
    187            
    188            /* Enable GPDMA interrupt */
    189            NVIC_EnableIRQ(DMA_IRQn);
   \   00000062   0x201A             MOVS     R0,#+26
   \   00000064   0x.... 0x....      BL       NVIC_EnableIRQ
    190            
    191            return (TRUE);
   \   00000068   0x2001             MOVS     R0,#+1
   \                     ??MCI_SettingDma_3:
   \   0000006A   0xB009             ADD      SP,SP,#+36
   \   0000006C   0xBDF0             POP      {R4-R7,PC}       ;; return
    192          }
    193          
    194          
    195          /*********************************************************************//**
    196          * @brief        GPDMA interrupt handler sub-routine
    197          *
    198          * @param        None
    199          *
    200          * @return       None
    201          *
    202          * @note         This is only executed if DMA support is enabled
    203          **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    204          void MCI_DMA_IRQHandler (void)
    205          {
   \                     MCI_DMA_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    206            // check GPDMA interrupt on channel 0
    207            if (GPDMA_IntGetStatus(GPDMA_STAT_INT, MCI_DMA_WRITE_CHANNEL))
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       GPDMA_IntGetStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD022             BEQ.N    ??MCI_DMA_IRQHandler_0
    208            {
    209              //check interrupt status on channel 0
    210              // Check counter terminal status
    211              if(GPDMA_IntGetStatus(GPDMA_STAT_INTTC, MCI_DMA_WRITE_CHANNEL))
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       GPDMA_IntGetStatus
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD00A             BEQ.N    ??MCI_DMA_IRQHandler_1
    212              {
    213                // Clear terminate counter Interrupt pending
    214                GPDMA_ClearIntPending (GPDMA_STATCLR_INTTC, MCI_DMA_WRITE_CHANNEL);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       GPDMA_ClearIntPending
    215                
    216                dmaWrCh_TermianalCnt++;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable21
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    217              }
    218              if (GPDMA_IntGetStatus(GPDMA_STAT_INTERR, MCI_DMA_WRITE_CHANNEL))
   \                     ??MCI_DMA_IRQHandler_1:
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x.... 0x....      BL       GPDMA_IntGetStatus
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD033             BEQ.N    ??MCI_DMA_IRQHandler_2
    219              {
    220                // Clear error counter Interrupt pending
    221                GPDMA_ClearIntPending (GPDMA_STATCLR_INTERR, MCI_DMA_WRITE_CHANNEL);
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      BL       GPDMA_ClearIntPending
    222                
    223                dmaWrCh_ErrorCnt++;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000050   0x6008             STR      R0,[R1, #+0]
   \   00000052   0xE027             B.N      ??MCI_DMA_IRQHandler_2
    224              }
    225            }
    226            else if (GPDMA_IntGetStatus(GPDMA_STAT_INT, MCI_DMA_READ_CHANNEL))
   \                     ??MCI_DMA_IRQHandler_0:
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      BL       GPDMA_IntGetStatus
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD021             BEQ.N    ??MCI_DMA_IRQHandler_2
    227            {
    228              //check interrupt status on channel 0
    229              // Check counter terminal status
    230              if(GPDMA_IntGetStatus(GPDMA_STAT_INTTC, MCI_DMA_READ_CHANNEL))
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x.... 0x....      BL       GPDMA_IntGetStatus
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD00A             BEQ.N    ??MCI_DMA_IRQHandler_3
    231              {
    232                // Clear terminate counter Interrupt pending
    233                GPDMA_ClearIntPending (GPDMA_STATCLR_INTTC, MCI_DMA_READ_CHANNEL);
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      BL       GPDMA_ClearIntPending
    234                
    235                dmaRdCh_TermianalCnt++;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   00000080   0x6008             STR      R0,[R1, #+0]
    236              }
    237              if (GPDMA_IntGetStatus(GPDMA_STAT_INTERR, MCI_DMA_READ_CHANNEL))
   \                     ??MCI_DMA_IRQHandler_3:
   \   00000082   0x2101             MOVS     R1,#+1
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x.... 0x....      BL       GPDMA_IntGetStatus
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD00A             BEQ.N    ??MCI_DMA_IRQHandler_2
    238              {
    239                // Clear error counter Interrupt pending
    240                GPDMA_ClearIntPending (GPDMA_STATCLR_INTERR, MCI_DMA_READ_CHANNEL);
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x.... 0x....      BL       GPDMA_ClearIntPending
    241                
    242                dmaRdCh_ErrorCnt++;
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable23_2
   \   000000A2   0x6008             STR      R0,[R1, #+0]
    243              }
    244            }
    245          }
   \                     ??MCI_DMA_IRQHandler_2:
   \   000000A4   0xBD01             POP      {R0,PC}          ;; return
    246          #endif
    247          
    248          
    249          /*********************************************************************//**
    250          * @brief        Read data from FIFO (after a transmission with card) to
    251          *                a destination buffer
    252          *
    253          * @param[in]    *dest The buffer to store the data that read from card
    254          *
    255          * @return       MCI_FUNC_OK
    256          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    257          int32_t MCI_ReadFifo(uint32_t * dest) 
    258          {
   \                     MCI_ReadFifo:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0001             MOVS     R1,R0
    259            uint8_t i;
    260            uint8_t start, end;
    261            
    262            if(fifo_plane == 0)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD104             BNE.N    ??MCI_ReadFifo_0
    263            {
    264              start = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0003             MOVS     R3,R0
    265              end = 7;
   \   00000012   0x2007             MOVS     R0,#+7
   \   00000014   0x0004             MOVS     R4,R0
   \   00000016   0xE003             B.N      ??MCI_ReadFifo_1
    266            }
    267            else
    268            {
    269              start = 8;
   \                     ??MCI_ReadFifo_0:
   \   00000018   0x2008             MOVS     R0,#+8
   \   0000001A   0x0003             MOVS     R3,R0
    270              end = 15;
   \   0000001C   0x200F             MOVS     R0,#+15
   \   0000001E   0x0004             MOVS     R4,R0
    271            }
    272            fifo_plane = (fifo_plane) ? 0:1;
   \                     ??MCI_ReadFifo_1:
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??MCI_ReadFifo_2
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE000             B.N      ??MCI_ReadFifo_3
   \                     ??MCI_ReadFifo_2:
   \   0000002E   0x2001             MOVS     R0,#+1
   \                     ??MCI_ReadFifo_3:
   \   00000030   0x.... 0x....      LDR.W    R5,??DataTable23_3
   \   00000034   0x7028             STRB     R0,[R5, #+0]
    273            
    274            for (i = start; i <= end; i++) 
   \   00000036   0x001A             MOVS     R2,R3
   \                     ??MCI_ReadFifo_4:
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003C   0x4294             CMP      R4,R2
   \   0000003E   0xD308             BCC.N    ??MCI_ReadFifo_5
    275            {
    276              *dest = LPC_MCI->FIFO[i];
   \   00000040   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x400c0080
   \   00000046   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    277              
    278              dest++;
   \   0000004C   0x1D09             ADDS     R1,R1,#+4
    279            }
   \   0000004E   0x1C52             ADDS     R2,R2,#+1
   \   00000050   0xE7F2             B.N      ??MCI_ReadFifo_4
    280            
    281            return MCI_FUNC_OK;
   \                     ??MCI_ReadFifo_5:
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBC30             POP      {R4,R5}
   \   00000056   0x4770             BX       LR               ;; return
    282          }
    283          
    284          
    285          /*********************************************************************//**
    286          * @brief        Write data from a source buffer to FIFO for transmission
    287          *
    288          * @param[in]    *src The buffer hold the data need to write to card
    289          *
    290          * @return       MCI_FUNC_OK
    291          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    292          int32_t MCI_WriteFifo(uint32_t * src)
    293          {
   \                     MCI_WriteFifo:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0001             MOVS     R1,R0
    294            uint8_t i;
    295            uint8_t start, end;
    296            
    297            if(fifo_plane == 0)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD104             BNE.N    ??MCI_WriteFifo_0
    298            {
    299              start = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0003             MOVS     R3,R0
    300              end = 7;
   \   00000012   0x2007             MOVS     R0,#+7
   \   00000014   0x0004             MOVS     R4,R0
   \   00000016   0xE003             B.N      ??MCI_WriteFifo_1
    301            }
    302            else
    303            {
    304              start = 8;
   \                     ??MCI_WriteFifo_0:
   \   00000018   0x2008             MOVS     R0,#+8
   \   0000001A   0x0003             MOVS     R3,R0
    305              end = 15;
   \   0000001C   0x200F             MOVS     R0,#+15
   \   0000001E   0x0004             MOVS     R4,R0
    306            }
    307            fifo_plane = (fifo_plane) ? 0:1;
   \                     ??MCI_WriteFifo_1:
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??MCI_WriteFifo_2
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE000             B.N      ??MCI_WriteFifo_3
   \                     ??MCI_WriteFifo_2:
   \   0000002E   0x2001             MOVS     R0,#+1
   \                     ??MCI_WriteFifo_3:
   \   00000030   0x.... 0x....      LDR.W    R5,??DataTable23_3
   \   00000034   0x7028             STRB     R0,[R5, #+0]
    308            
    309            for (i = start; i <= end; i++) 
   \   00000036   0x001A             MOVS     R2,R3
   \                     ??MCI_WriteFifo_4:
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003C   0x4294             CMP      R4,R2
   \   0000003E   0xD308             BCC.N    ??MCI_WriteFifo_5
    310            {
    311              LPC_MCI->FIFO[i] = *src;
   \   00000040   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x400c0080
   \   00000046   0x680D             LDR      R5,[R1, #+0]
   \   00000048   0xF840 0x5022      STR      R5,[R0, R2, LSL #+2]
    312              
    313              src++;
   \   0000004C   0x1D09             ADDS     R1,R1,#+4
    314            }
   \   0000004E   0x1C52             ADDS     R2,R2,#+1
   \   00000050   0xE7F2             B.N      ??MCI_WriteFifo_4
    315            
    316            return MCI_FUNC_OK;
   \                     ??MCI_WriteFifo_5:
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBC30             POP      {R4,R5}
   \   00000056   0x4770             BX       LR               ;; return
    317          }
    318          
    319          
    320          /*********************************************************************//**
    321          * @brief        Enable Transmit data interrupt
    322          *
    323          * @param        None
    324          *
    325          * @return       None
    326          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    327          void MCI_TXEnable( void )
    328          {
    329          #if MCI_DMA_ENABLED
    330            LPC_MCI->MASK0 |= ((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));    /* Enable TX interrupts only */
   \                     MCI_TXEnable:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x400c003c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF240 0x711A      MOVW     R1,#+1818
   \   0000000A   0x4308             ORRS     R0,R1,R0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable25  ;; 0x400c003c
   \   00000010   0x6008             STR      R0,[R1, #+0]
    331          #else
    332            LPC_MCI->MASK0 |= ((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK));    /* FIFO TX interrupts only */
    333          #endif
    334            
    335            return;
   \   00000012   0x4770             BX       LR               ;; return
    336          }
    337          
    338          
    339          /*********************************************************************//**
    340          * @brief        Disable Transmit data interrupt
    341          *
    342          * @param        None
    343          *
    344          * @return       None
    345          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    346          void MCI_TXDisable( void )
    347          {
    348          #if MCI_DMA_ENABLED
    349            LPC_MCI->MASK0 &= ~((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));    /* Enable TX interrupts only */
   \                     MCI_TXDisable:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x400c003c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable23_4  ;; 0xfffff8e5
   \   0000000A   0x4008             ANDS     R0,R1,R0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable25  ;; 0x400c003c
   \   00000010   0x6008             STR      R0,[R1, #+0]
    350          #else
    351            LPC_MCI->MASK0 &= ~((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK));    /* FIFO TX interrupts only */
    352          #endif
    353            
    354            return;
   \   00000012   0x4770             BX       LR               ;; return
    355          }
    356          
    357          
    358          /*********************************************************************//**
    359          * @brief        Enable Receive data interrupt
    360          *
    361          * @param        None
    362          *
    363          * @return       None
    364          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    365          void MCI_RXEnable( void )
    366          {
    367          #if MCI_DMA_ENABLED
    368            LPC_MCI->MASK0 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));    /* Enable RX interrupts only */
   \                     MCI_RXEnable:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x400c003c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF240 0x712A      MOVW     R1,#+1834
   \   0000000A   0x4308             ORRS     R0,R1,R0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable25  ;; 0x400c003c
   \   00000010   0x6008             STR      R0,[R1, #+0]
    369          #else
    370            LPC_MCI->MASK0 |= ((FIFO_RX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_RX_INT_MASK));    /* FIFO RX interrupts only */
    371          #endif
    372            
    373            return;
   \   00000012   0x4770             BX       LR               ;; return
    374          }
    375          
    376          
    377          /*********************************************************************//**
    378          * @brief        Disable Receive data interrupt
    379          *
    380          * @param        None
    381          *
    382          * @return       None
    383          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    384          void MCI_RXDisable( void )
    385          {
    386          #if MCI_DMA_ENABLED
    387            LPC_MCI->MASK0 &= ~((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));    /* Enable TX interrupts only */
   \                     MCI_RXDisable:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x400c003c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable23_5  ;; 0xfffff8d5
   \   0000000A   0x4008             ANDS     R0,R1,R0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable25  ;; 0x400c003c
   \   00000010   0x6008             STR      R0,[R1, #+0]
    388          #else
    389            LPC_MCI->MASK0 &= ~((FIFO_RX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_RX_INT_MASK));    /* FIFO TX interrupts only */
    390          #endif
    391            
    392            return;
   \   00000012   0x4770             BX       LR               ;; return
    393          }
    394          
    395          /*********************************************************************//**
    396          * @brief      Check if the card is in the given state.
    397          *@param       expect_status    expected status
    398          * @details    Continuously get the card status until the card is ready. if its status matches 
    399          *             with the given state, return with success. Else, return MCI_FUNC_ERR_STATE.
    400          *             If the card is still not ready, return MCI_FUNC_NOT_READY.
    401          *
    402          * @param      None
    403          *
    404          * @return     MCI_FUNC_OK if all success
    405          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    406          int32_t MCI_CheckStatus(uint8_t expect_status)
    407          {
   \                     MCI_CheckStatus:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    408            int32_t respValue, retval = MCI_FUNC_FAILED;
   \   00000004   0xF05F 0x35FF      MOVS     R5,#-1
    409            uint32_t retryCnt = 0xFFFF, i;
   \   00000008   0xF64F 0x77FF      MOVW     R7,#+65535
    410            while (retryCnt > 0)
   \                     ??MCI_CheckStatus_0:
   \   0000000C   0x2F00             CMP      R7,#+0
   \   0000000E   0xD022             BEQ.N    ??MCI_CheckStatus_1
    411            {
    412              if (MCI_GetCardStatus(&respValue) != MCI_FUNC_OK)
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       MCI_GetCardStatus
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD11D             BNE.N    ??MCI_CheckStatus_1
    413              {
    414                break;
    415              }
    416              else
    417              {
    418                /* The only valid state is TRANS per MMC and SD state diagram.
    419                RCV state may be seen, but, it happens only when TX_ACTIVE or
    420                RX_ACTIVE occurs before the WRITE_BLOCK and READ_BLOCK cmds are
    421                being sent, which is not a valid sequence. */
    422                if(!(respValue & CARD_STATUS_READY_FOR_DATA ))
   \                     ??MCI_CheckStatus_2:
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x05C0             LSLS     R0,R0,#+23
   \   0000001E   0xD403             BMI.N    ??MCI_CheckStatus_3
    423                {
    424                  retval = MCI_FUNC_NOT_READY;
   \   00000020   0xF07F 0x0004      MVNS     R0,#+4
   \   00000024   0x0005             MOVS     R5,R0
   \   00000026   0xE00F             B.N      ??MCI_CheckStatus_4
    425                }
    426                else if(CARDSTATEOF(respValue) != expect_status)
   \                     ??MCI_CheckStatus_3:
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0xF3C0 0x2043      UBFX     R0,R0,#+9,#+4
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x42A0             CMP      R0,R4
   \   00000032   0xD007             BEQ.N    ??MCI_CheckStatus_5
    427                {
    428                  // If card is in prg state, wait until it changes to trans state
    429                  // when "operation complete"
    430                  if(CARDSTATEOF(respValue) != CARD_STATE_PRG)
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0xF3C0 0x2043      UBFX     R0,R0,#+9,#+4
   \   0000003A   0x2807             CMP      R0,#+7
   \   0000003C   0xD004             BEQ.N    ??MCI_CheckStatus_4
    431                  {
    432                    return MCI_FUNC_ERR_STATE;
   \   0000003E   0xF07F 0x0003      MVNS     R0,#+3
   \   00000042   0xE009             B.N      ??MCI_CheckStatus_6
    433                  }    
    434                }
    435                else
    436                {
    437                  return MCI_FUNC_OK;
   \                     ??MCI_CheckStatus_5:
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE007             B.N      ??MCI_CheckStatus_6
    438                }
    439              }
    440              retryCnt--;
   \                     ??MCI_CheckStatus_4:
   \   00000048   0x1E7F             SUBS     R7,R7,#+1
    441              for(i = 0; i < 0x20; i++);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x0006             MOVS     R6,R0
   \                     ??MCI_CheckStatus_7:
   \   0000004E   0x2E20             CMP      R6,#+32
   \   00000050   0xD2DC             BCS.N    ??MCI_CheckStatus_0
   \   00000052   0x1C76             ADDS     R6,R6,#+1
   \   00000054   0xE7FB             B.N      ??MCI_CheckStatus_7
    442              
    443            }
    444            
    445            return retval;
   \                     ??MCI_CheckStatus_1:
   \   00000056   0x0028             MOVS     R0,R5
   \                     ??MCI_CheckStatus_6:
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    446          }
    447          
    448          
    449          
    450          /*********************************************************************//**
    451          * @brief        Called by MCI interrupt handler to simplify the command
    452          *                process.
    453          *
    454          * @param        None
    455          *
    456          * @return       None
    457          *
    458          * @note         In card initialization, the commnad interrupts are disabled
    459          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    460          void MCI_CmdProcess( void )
    461          {
    462            uint32_t MCIStatus;
    463            
    464            MCIStatus = LPC_MCI->STATUS;
   \                     MCI_CmdProcess:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable25_1  ;; 0x400c0034
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x0008             MOVS     R0,R1
    465            
    466            if ( MCIStatus &  MCI_CMD_CRC_FAIL )
   \   00000008   0x07C1             LSLS     R1,R0,#+31
   \   0000000A   0xD503             BPL.N    ??MCI_CmdProcess_0
    467            {
    468              LPC_MCI->CLEAR =  MCI_CMD_CRC_FAIL;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x400c0038
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x600A             STR      R2,[R1, #+0]
    469            }
    470            
    471            if ( MCIStatus &  MCI_CMD_TIMEOUT )
   \                     ??MCI_CmdProcess_0:
   \   00000014   0x0741             LSLS     R1,R0,#+29
   \   00000016   0xD503             BPL.N    ??MCI_CmdProcess_1
    472            {
    473              LPC_MCI->CLEAR =  MCI_CMD_TIMEOUT;
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x400c0038
   \   0000001C   0x2204             MOVS     R2,#+4
   \   0000001E   0x600A             STR      R2,[R1, #+0]
    474            }
    475            
    476            /* Cmd Resp End or Cmd Sent */
    477            if ( MCIStatus &  MCI_CMD_RESP_END )
   \                     ??MCI_CmdProcess_1:
   \   00000020   0x0641             LSLS     R1,R0,#+25
   \   00000022   0xD503             BPL.N    ??MCI_CmdProcess_2
    478            {
    479              LPC_MCI->CLEAR =  MCI_CMD_RESP_END;
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x400c0038
   \   00000028   0x2240             MOVS     R2,#+64
   \   0000002A   0x600A             STR      R2,[R1, #+0]
    480            }
    481            
    482            if ( MCIStatus &  MCI_CMD_SENT )
   \                     ??MCI_CmdProcess_2:
   \   0000002C   0x0601             LSLS     R1,R0,#+24
   \   0000002E   0xD503             BPL.N    ??MCI_CmdProcess_3
    483            {
    484              LPC_MCI->CLEAR =  MCI_CMD_SENT;
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x400c0038
   \   00000034   0x2280             MOVS     R2,#+128
   \   00000036   0x600A             STR      R2,[R1, #+0]
    485            }
    486            
    487            if ( MCIStatus &  MCI_CMD_ACTIVE )
   \                     ??MCI_CmdProcess_3:
   \   00000038   0x0501             LSLS     R1,R0,#+20
   \   0000003A   0xD504             BPL.N    ??MCI_CmdProcess_4
    488            {
    489              LPC_MCI->CLEAR =  MCI_CMD_ACTIVE;
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x400c0038
   \   00000040   0xF44F 0x6200      MOV      R2,#+2048
   \   00000044   0x600A             STR      R2,[R1, #+0]
    490            }
    491            
    492            return;
   \                     ??MCI_CmdProcess_4:
   \   00000046   0x4770             BX       LR               ;; return
    493          }
    494          
    495          
    496          /*********************************************************************//**
    497          * @brief        Called by MCI interrupt handler to manage error on the bus
    498          *
    499          * @param        None
    500          *
    501          * @return       None
    502          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    503          void MCI_DataErrorProcess( void )
    504          {
    505            uint32_t MCIStatus;
    506            
    507            MCIStatus = LPC_MCI->STATUS;
   \                     MCI_DataErrorProcess:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable25_1  ;; 0x400c0034
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x0008             MOVS     R0,R1
    508            
    509            if ( MCIStatus &  MCI_DATA_CRC_FAIL )
   \   00000008   0x0781             LSLS     R1,R0,#+30
   \   0000000A   0xD503             BPL.N    ??MCI_DataErrorProcess_0
    510            {
    511              LPC_MCI->CLEAR = MCI_DATA_CRC_FAIL;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x400c0038
   \   00000010   0x2202             MOVS     R2,#+2
   \   00000012   0x600A             STR      R2,[R1, #+0]
    512            }
    513            
    514            if ( MCIStatus &  MCI_DATA_TIMEOUT )
   \                     ??MCI_DataErrorProcess_0:
   \   00000014   0x0701             LSLS     R1,R0,#+28
   \   00000016   0xD503             BPL.N    ??MCI_DataErrorProcess_1
    515            {
    516              LPC_MCI->CLEAR =  MCI_DATA_TIMEOUT;
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x400c0038
   \   0000001C   0x2208             MOVS     R2,#+8
   \   0000001E   0x600A             STR      R2,[R1, #+0]
    517            }
    518            
    519            /* Underrun or overrun */
    520            if ( MCIStatus &  MCI_TX_UNDERRUN )
   \                     ??MCI_DataErrorProcess_1:
   \   00000020   0x06C1             LSLS     R1,R0,#+27
   \   00000022   0xD503             BPL.N    ??MCI_DataErrorProcess_2
    521            {
    522              LPC_MCI->CLEAR = MCI_TX_UNDERRUN;
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x400c0038
   \   00000028   0x2210             MOVS     R2,#+16
   \   0000002A   0x600A             STR      R2,[R1, #+0]
    523            }
    524            
    525            if ( MCIStatus &  MCI_RX_OVERRUN )
   \                     ??MCI_DataErrorProcess_2:
   \   0000002C   0x0681             LSLS     R1,R0,#+26
   \   0000002E   0xD503             BPL.N    ??MCI_DataErrorProcess_3
    526            {
    527              LPC_MCI->CLEAR =  MCI_RX_OVERRUN;
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x400c0038
   \   00000034   0x2220             MOVS     R2,#+32
   \   00000036   0x600A             STR      R2,[R1, #+0]
    528            }
    529            
    530            /* Start bit error on data signal */
    531            if ( MCIStatus &  MCI_START_BIT_ERR )
   \                     ??MCI_DataErrorProcess_3:
   \   00000038   0x0581             LSLS     R1,R0,#+22
   \   0000003A   0xD504             BPL.N    ??MCI_DataErrorProcess_4
    532            {
    533              LPC_MCI->CLEAR =  MCI_START_BIT_ERR;
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x400c0038
   \   00000040   0xF44F 0x7200      MOV      R2,#+512
   \   00000044   0x600A             STR      R2,[R1, #+0]
    534            }
    535            
    536            Mci_Data_Xfer_End = 0;
   \                     ??MCI_DataErrorProcess_4:
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x600A             STR      R2,[R1, #+0]
    537            Mci_Data_Xfer_ERR = MCIStatus;
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable26_1
   \   00000052   0x6008             STR      R0,[R1, #+0]
    538            return;
   \   00000054   0x4770             BX       LR               ;; return
    539          }
    540          
    541          
    542          /*********************************************************************//**
    543          * @brief         Called by MCI interrupt handler. This is the last interrupt
    544          *                manipulates the process of the data-block write and read 
    545          *                to/with card
    546          *
    547          * @details       This service is also used with/without DMA support. It simply
    548          *                clears the flag messages the in-process data-block transfer 
    549          *                has been done/ended
    550          *
    551          * @param         None
    552          *
    553          * @return        None
    554          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    555          void MCI_DATA_END_InterruptService( void )
    556          {
   \                     MCI_DATA_END_InterruptService:
   \   00000000   0xB510             PUSH     {R4,LR}
    557            uint32_t MCIStatus;
    558            
    559            MCIStatus = LPC_MCI->STATUS;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable25_1  ;; 0x400c0034
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0004             MOVS     R4,R0
    560            if ( MCIStatus &  MCI_DATA_END )        /* Data end, and Data block end  */
   \   0000000A   0x05E0             LSLS     R0,R4,#+23
   \   0000000C   0xD511             BPL.N    ??MCI_DATA_END_InterruptService_0
    561            {
    562              LPC_MCI->CLEAR = MCI_DATA_END;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable25_2  ;; 0x400c0038
   \   00000012   0xF44F 0x7180      MOV      R1,#+256
   \   00000016   0x6001             STR      R1,[R0, #+0]
    563              
    564              Mci_Data_Xfer_End = 0;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable26
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    565              
    566              Mci_Data_Xfer_ERR = 0;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6001             STR      R1,[R0, #+0]
    567              
    568              MCI_TXDisable();
   \   00000028   0x.... 0x....      BL       MCI_TXDisable
    569              
    570              MCI_RXDisable();
   \   0000002C   0x.... 0x....      BL       MCI_RXDisable
    571              
    572              return;
   \   00000030   0xE007             B.N      ??MCI_DATA_END_InterruptService_1
    573            }
    574            
    575            if ( MCIStatus &  MCI_DATA_BLK_END )
   \                     ??MCI_DATA_END_InterruptService_0:
   \   00000032   0x0560             LSLS     R0,R4,#+21
   \   00000034   0xD505             BPL.N    ??MCI_DATA_END_InterruptService_2
    576            {
    577              LPC_MCI->CLEAR =  MCI_DATA_BLK_END;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable25_2  ;; 0x400c0038
   \   0000003A   0xF44F 0x6180      MOV      R1,#+1024
   \   0000003E   0x6001             STR      R1,[R0, #+0]
    578              
    579              //MCI_TXDisable();
    580              
    581              return;
   \   00000040   0xE7FF             B.N      ??MCI_DATA_END_InterruptService_1
    582            }
    583            
    584            /* Tx active  */
    585            if ( MCIStatus & MCI_TX_ACTIVE )
    586            {
    587              
    588            }
    589            
    590            /* Rx active  */
    591            if ( MCIStatus & MCI_RX_ACTIVE )
    592            {
    593              
    594            }
    595            
    596            return;
   \                     ??MCI_DATA_END_InterruptService_2:
   \                     ??MCI_DATA_END_InterruptService_1:
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    597          }
    598          
    599          
    600          /*********************************************************************//**
    601          * @brief        Called by MCI interrupt handler if requiring to using FIFO
    602          *                for data transferring. It copy data to/from FIFO register
    603          *                from/to a data buffer.
    604          *
    605          * @param        None
    606          *
    607          * @return       None
    608          *
    609          * @note         This function is done without DMA transfer support
    610          **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    611          void MCI_FIFOInterruptService( void )
    612          {
    613          #if !MCI_DMA_ENABLED
    614            uint32_t MCIStatus;
    615            
    616            MCIStatus = LPC_MCI->STATUS;
    617            
    618            if ( MCIStatus & (FIFO_TX_INT_MASK ) )
    619            {
    620              /* empty is multiple of 512 block size */
    621              if ( MCIStatus & MCI_TX_HALF_EMPTY )
    622              {
    623                //There's no data, return
    624                if(dataSrcBlock == NULL)
    625                  return;
    626                
    627                /* write 8 words to fifo */
    628                MCI_WriteFifo((uint32_t *)&dataSrcBlock[txBlockCnt]);
    629                
    630                txBlockCnt += 32;
    631              }
    632              
    633              if (txBlockCnt == BLOCK_LENGTH)    /* block complete */
    634              {
    635                dataSrcBlock += BLOCK_LENGTH;
    636                
    637                txBlockCnt = 0;
    638                
    639                /* disable FIFO int until next block write */
    640                //LPC_MCI->MASK0 &= ~(FIFO_TX_INT_MASK);
    641                
    642                /* wait for SD card to complete sending data i.e MCI_DATA_BLK_END interrupt */
    643              }
    644            }
    645            else if ( MCIStatus & (FIFO_RX_INT_MASK) )
    646            {
    647              /* if using RX_HALF_FULL remove one ReadFIFO below */
    648              if ( MCIStatus & MCI_RX_HALF_FULL )
    649              {
    650                //There's no store data, return
    651                if(dataDestBlock == NULL)
    652                  return;
    653                
    654                /* read 8 words from fifo */
    655                MCI_ReadFifo((uint32_t *)&dataDestBlock[rxBlockCnt]);
    656                
    657                rxBlockCnt += 32;
    658              }
    659              
    660              /* block complete */
    661              if (rxBlockCnt == BLOCK_LENGTH)
    662              {
    663                dataDestBlock += BLOCK_LENGTH;
    664                
    665                rxBlockCnt = 0;
    666              }
    667            }
    668          #endif
    669            
    670            return;
   \                     MCI_FIFOInterruptService:
   \   00000000   0x4770             BX       LR               ;; return
    671          }
    672          
    673          /*********************************************************************//**
    674          * @brief        MCI_IRQHandler is to manage the reasons that cause the 
    675          *               interrupt.
    676          *
    677          * @details      It controls the data-block writing and reading by access 
    678          *               the FIFO register.
    679          *               It handle the state changes on the MCI bus...
    680          *
    681          * @param        None
    682          *
    683          * @return       None
    684          **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    685          void MCI_IRQHandler (void)
    686          {
   \                     MCI_IRQHandler:
   \   00000000   0xB510             PUSH     {R4,LR}
    687            uint32_t MCI_Status;
    688            
    689            MCI_Status = LPC_MCI->STATUS;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable25_1  ;; 0x400c0034
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0004             MOVS     R4,R0
    690            
    691            /* handle MCI_STATUS interrupt */
    692            if ( MCI_Status & DATA_ERR_INT_MASK )
   \   0000000A   0xF240 0x203A      MOVW     R0,#+570
   \   0000000E   0x4204             TST      R4,R0
   \   00000010   0xD002             BEQ.N    ??MCI_IRQHandler_0
    693            {
    694              MCI_DataErrorProcess();
   \   00000012   0x.... 0x....      BL       MCI_DataErrorProcess
    695              
    696              return;
   \   00000016   0xE013             B.N      ??MCI_IRQHandler_1
    697            }
    698            
    699            if ( MCI_Status & DATA_END_INT_MASK )
   \                     ??MCI_IRQHandler_0:
   \   00000018   0xF414 0x6FA0      TST      R4,#0x500
   \   0000001C   0xD002             BEQ.N    ??MCI_IRQHandler_2
    700            {
    701              MCI_DATA_END_InterruptService();
   \   0000001E   0x.... 0x....      BL       MCI_DATA_END_InterruptService
    702              
    703              return;
   \   00000022   0xE00D             B.N      ??MCI_IRQHandler_1
    704            }
    705            else if ( MCI_Status & FIFO_INT_MASK )
   \                     ??MCI_IRQHandler_2:
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0xfc400
   \   00000028   0x4204             TST      R4,R0
   \   0000002A   0xD002             BEQ.N    ??MCI_IRQHandler_3
    706            {
    707              MCI_FIFOInterruptService();
   \   0000002C   0x.... 0x....      BL       MCI_FIFOInterruptService
    708              
    709              return;
   \   00000030   0xE006             B.N      ??MCI_IRQHandler_1
    710            }
    711            else if ( MCI_Status & CMD_INT_MASK )
   \                     ??MCI_IRQHandler_3:
   \   00000032   0xF640 0x00C5      MOVW     R0,#+2245
   \   00000036   0x4204             TST      R4,R0
   \   00000038   0xD002             BEQ.N    ??MCI_IRQHandler_4
    712            {
    713              MCI_CmdProcess();
   \   0000003A   0x.... 0x....      BL       MCI_CmdProcess
    714              
    715              return;
   \   0000003E   0xE7FF             B.N      ??MCI_IRQHandler_1
    716            }
    717          }
   \                     ??MCI_IRQHandler_4:
   \                     ??MCI_IRQHandler_1:
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    718          
    719          
    720          /**
    721          * @}
    722          */
    723          
    724          
    725          
    726          /** @addtogroup MCI_Public_Functions
    727          * @{
    728          */
    729          
    730          /*********************************************************************//**
    731          * @brief        Set MCI clock rate, during initialization phase < 400K
    732          *                during data phase < 20Mhz
    733          *
    734          * @param[in]    ClockRate Clock rate to be set (in Hz)
    735          *
    736          * @return       None
    737          **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    738          void MCI_Set_MCIClock( uint32_t ClockRate )
    739          {
   \                     MCI_Set_MCIClock:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    740            volatile uint32_t i;
    741            uint32_t ClkValue = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    742            uint32_t pclk;
    743            
    744            pclk = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       CLKPWR_GetCLK
   \   0000000E   0x0006             MOVS     R6,R0
    745            
    746            ClkValue = (pclk + 2*ClockRate - 1) /(2*ClockRate); 
   \   00000010   0xEB16 0x0044      ADDS     R0,R6,R4, LSL #+1
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x0061             LSLS     R1,R4,#+1
   \   00000018   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000001C   0x0005             MOVS     R5,R0
    747            if(ClkValue)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD000             BEQ.N    ??MCI_Set_MCIClock_0
    748              ClkValue -= 1;
   \   00000022   0x1E6D             SUBS     R5,R5,#+1
    749            
    750            LPC_MCI->CLOCK = (LPC_MCI->CLOCK & ~(0xFF)) | (1 << 8)  | ClkValue;
   \                     ??MCI_Set_MCIClock_0:
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x400c0004
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0A00             LSRS     R0,R0,#+8
   \   0000002C   0x0200             LSLS     R0,R0,#+8
   \   0000002E   0x4328             ORRS     R0,R5,R0
   \   00000030   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable27  ;; 0x400c0004
   \   00000038   0x6008             STR      R0,[R1, #+0]
    751            
    752            for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK before next write */
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Set_MCIClock_1:
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x2810             CMP      R0,#+16
   \   00000042   0xD203             BCS.N    ??MCI_Set_MCIClock_2
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0xE7F8             B.N      ??MCI_Set_MCIClock_1
    753            
    754            return;
   \                     ??MCI_Set_MCIClock_2:
   \   0000004C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    755          }
    756          
    757          
    758          /**********************************************************************//**
    759          * @brief        Set the Width to 1-bit Bus or 4-bit Bus
    760          *
    761          * @param[in]    width buswidth expected to set
    762          *
    763          * @return       MCI_FUNC_OK in case of success
    764          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    765          int32_t MCI_SetBusWidth( uint32_t width )
    766          {
   \                     MCI_SetBusWidth:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x0004             MOVS     R4,R0
    767            volatile uint32_t i;
    768            uint32_t bus_width = BUS_WIDTH_1BIT;
   \   00000008   0x2500             MOVS     R5,#+0
    769            
    770            //    if ( width == SD_1_BIT )
    771            //    {
    772            //        LPC_MCI->CLOCK &=  ~(1 << 11);    /* 1 bit bus */
    773            //    }
    774            //    else if ( width == SD_4_BIT )
    775            //    {
    776            //        LPC_MCI->CLOCK |=  (1 << 11);/* 4 bit bus */
    777            //        bus_width = BUS_WIDTH_4BITS;
    778            //    }
    779            /** Õë¶ÔMMCÐÞ¸Ä **/
    780            if ( width == SD_1_BIT )
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD10B             BNE.N    ??MCI_SetBusWidth_0
    781            {
    782              LPC_MCI->CLOCK &=  ~(1 << 11);    /* 1 bit bus */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x400c0004
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable27  ;; 0x400c0004
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    783              bus_width = 0x03B70000;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable27_1  ;; 0x3b70000
   \   00000022   0x0005             MOVS     R5,R0
   \   00000024   0xE00C             B.N      ??MCI_SetBusWidth_1
    784            }
    785            else if ( width == SD_4_BIT )
   \                     ??MCI_SetBusWidth_0:
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xD10A             BNE.N    ??MCI_SetBusWidth_1
    786            {
    787              LPC_MCI->CLOCK |=  (1 << 11);/* 4 bit bus */
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x400c0004
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable27  ;; 0x400c0004
   \   00000038   0x6008             STR      R0,[R1, #+0]
    788              bus_width = 0X03B70100;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x3b70100
   \   0000003E   0x0005             MOVS     R5,R0
    789            }
    790            
    791            for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \                     ??MCI_SetBusWidth_1:
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \                     ??MCI_SetBusWidth_2:
   \   00000044   0x9801             LDR      R0,[SP, #+4]
   \   00000046   0x2810             CMP      R0,#+16
   \   00000048   0xD203             BCS.N    ??MCI_SetBusWidth_3
   \   0000004A   0x9801             LDR      R0,[SP, #+4]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0xE7F8             B.N      ??MCI_SetBusWidth_2
    792            
    793            if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
    794                (MCI_CardType == MCI_SDSC_V2_CARD) ||
    795                  (MCI_CardType == MCI_SDHC_SDXC_CARD)) 
   \                     ??MCI_SetBusWidth_3:
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000056   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD00B             BEQ.N    ??MCI_SetBusWidth_4
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000062   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000066   0x2802             CMP      R0,#+2
   \   00000068   0xD005             BEQ.N    ??MCI_SetBusWidth_4
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   0000006E   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000072   0x2803             CMP      R0,#+3
   \   00000074   0xD107             BNE.N    ??MCI_SetBusWidth_5
    796            {
    797              if ( MCI_Acmd_SendBusWidth( bus_width ) != MCI_FUNC_OK )
   \                     ??MCI_SetBusWidth_4:
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0x.... 0x....      BL       MCI_Acmd_SendBusWidth
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD043             BEQ.N    ??MCI_SetBusWidth_6
    798              {
    799                return(MCI_FUNC_FAILED);
   \   00000080   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000084   0xE041             B.N      ??MCI_SetBusWidth_7
    800              }
    801            }
    802            else if( MCI_CardType == MCI_MMC_CARD)
   \                     ??MCI_SetBusWidth_5:
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   0000008A   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xD13A             BNE.N    ??MCI_SetBusWidth_6
    803            {
    804              //Õë¶ÔMMCÐÞ¸Ä
    805              volatile uint32_t i;
    806              uint32_t retryCount;
    807              uint32_t respStatus;
    808              uint32_t respValue[4];
    809              st_Mci_CmdInfo cmdIf;
    810              int32_t retval = MCI_FUNC_FAILED;
   \   00000092   0xF05F 0x38FF      MOVS     R8,#-1
    811              
    812              retryCount = 0x20;            /* reset retry counter */
   \   00000096   0x2020             MOVS     R0,#+32
   \   00000098   0x0006             MOVS     R6,R0
    813              cmdIf.CmdIndex = ACMD6_SET_BUS_WIDTH;
   \   0000009A   0x2006             MOVS     R0,#+6
   \   0000009C   0x9002             STR      R0,[SP, #+8]
    814              cmdIf.Argument = bus_width;
   \   0000009E   0x9503             STR      R5,[SP, #+12]
    815              cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x9004             STR      R0,[SP, #+16]
    816              cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x9005             STR      R0,[SP, #+20]
    817              cmdIf.CmdResp =  (uint32_t *)&respValue[0];
   \   000000A8   0xA807             ADD      R0,SP,#+28
   \   000000AA   0x9006             STR      R0,[SP, #+24]
    818              while ( retryCount > 0 )
   \                     ??MCI_SetBusWidth_8:
   \   000000AC   0x2E00             CMP      R6,#+0
   \   000000AE   0xD029             BEQ.N    ??MCI_SetBusWidth_9
    819              {
    820                /* The card must be in tran state in order to change the bus width */
    821                retval = MCI_CheckStatus(CARD_STATE_TRAN);
   \   000000B0   0x2004             MOVS     R0,#+4
   \   000000B2   0x.... 0x....      BL       MCI_CheckStatus
   \   000000B6   0x4680             MOV      R8,R0
    822                if(retval!= MCI_FUNC_OK)
   \   000000B8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000BC   0xD001             BEQ.N    ??MCI_SetBusWidth_10
    823                  return retval;
   \   000000BE   0x4640             MOV      R0,R8
   \   000000C0   0xE023             B.N      ??MCI_SetBusWidth_7
    824                
    825                respStatus = MCI_CmdResp(&cmdIf);
   \                     ??MCI_SetBusWidth_10:
   \   000000C2   0xA802             ADD      R0,SP,#+8
   \   000000C4   0x.... 0x....      BL       MCI_CmdResp
   \   000000C8   0x0007             MOVS     R7,R0
    826                
    827                if(respStatus)
   \   000000CA   0x2F00             CMP      R7,#+0
   \   000000CC   0xD005             BEQ.N    ??MCI_SetBusWidth_11
    828                {
    829                  retval = MCI_FUNC_FAILED;
   \   000000CE   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000D2   0x4680             MOV      R8,R0
    830                }
    831                else if (respValue[0] & CARD_STATUS_ERR_MASK)
    832                {
    833                  return MCI_FUNC_BAD_PARAMETERS;
    834                }
    835                else
    836                {
    837                  return MCI_CheckStatus(CARD_STATE_TRAN);
    838                }
    839                
    840                for ( i = 0; i < 0x20; i++ );
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0xE00B             B.N      ??MCI_SetBusWidth_12
   \                     ??MCI_SetBusWidth_11:
   \   000000DA   0x9807             LDR      R0,[SP, #+28]
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0xfdf88008
   \   000000E0   0x4208             TST      R0,R1
   \   000000E2   0xD002             BEQ.N    ??MCI_SetBusWidth_13
   \   000000E4   0xF07F 0x0001      MVNS     R0,#+1
   \   000000E8   0xE00F             B.N      ??MCI_SetBusWidth_7
   \                     ??MCI_SetBusWidth_13:
   \   000000EA   0x2004             MOVS     R0,#+4
   \   000000EC   0x.... 0x....      BL       MCI_CheckStatus
   \   000000F0   0xE00B             B.N      ??MCI_SetBusWidth_7
   \                     ??MCI_SetBusWidth_12:
   \   000000F2   0x9800             LDR      R0,[SP, #+0]
   \   000000F4   0x2820             CMP      R0,#+32
   \   000000F6   0xD203             BCS.N    ??MCI_SetBusWidth_14
   \   000000F8   0x9800             LDR      R0,[SP, #+0]
   \   000000FA   0x1C40             ADDS     R0,R0,#+1
   \   000000FC   0x9000             STR      R0,[SP, #+0]
   \   000000FE   0xE7F8             B.N      ??MCI_SetBusWidth_12
    841                
    842                retryCount--;
   \                     ??MCI_SetBusWidth_14:
   \   00000100   0x1E76             SUBS     R6,R6,#+1
   \   00000102   0xE7D3             B.N      ??MCI_SetBusWidth_8
    843              }
    844              
    845              return retval;
   \                     ??MCI_SetBusWidth_9:
   \   00000104   0x4640             MOV      R0,R8
   \   00000106   0xE000             B.N      ??MCI_SetBusWidth_7
    846              
    847            }
    848            return MCI_FUNC_OK;
   \                     ??MCI_SetBusWidth_6:
   \   00000108   0x2000             MOVS     R0,#+0
   \                     ??MCI_SetBusWidth_7:
   \   0000010A   0xB00C             ADD      SP,SP,#+48
   \   0000010C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    849          }
    850          
    851          
    852          /************************************************************************//**
    853          * @brief        Do initialization the MCI block as set its clock, registers,
    854          *                setup NVIC for interrupts, configure the pins used for MCI 
    855          *                function, do initialize the card in slot...
    856          *
    857          * @param[in]    powerActiveLevel the power level to activate the card in slot
    858          *
    859          * @return       MCI_FUNC_OK in case of success
    860          ***************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    861          int32_t MCI_Init(uint8_t powerActiveLevel )
    862          {
   \                     MCI_Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    863            volatile uint32_t i;
    864            
    865            MCI_CardType = MCI_CARD_UNKNOWN;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   0000000A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
    866            
    867            // Following block of code added to ensure card VCC drops to zero
    868            // before card is initialized
    869            
    870            // Force all MCI control pins to basic I/O mode
    871            LPC_IOCON->P1_2  &= ~0x1F; /* SD_CLK @ P1.2 */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0x4002c088
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0940             LSRS     R0,R0,#+5
   \   00000018   0x0140             LSLS     R0,R0,#+5
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0x4002c088
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    872            LPC_IOCON->P1_3  &= ~0x1F; /* SD_CMD @ P1.3 */
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable29_1  ;; 0x4002c08c
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0940             LSRS     R0,R0,#+5
   \   00000028   0x0140             LSLS     R0,R0,#+5
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable29_1  ;; 0x4002c08c
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    873            LPC_IOCON->P1_5  &= ~0x1F; /* SD_PWR @ P1.5 */
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable29_2  ;; 0x4002c094
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x0940             LSRS     R0,R0,#+5
   \   00000038   0x0140             LSLS     R0,R0,#+5
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable29_2  ;; 0x4002c094
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    874            LPC_IOCON->P1_6  &= ~0x1F; /* SD_DAT_0 @ P1.6 */
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable29_3  ;; 0x4002c098
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x0940             LSRS     R0,R0,#+5
   \   00000048   0x0140             LSLS     R0,R0,#+5
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable29_3  ;; 0x4002c098
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    875            LPC_IOCON->P1_7  &= ~0x1F; /* SD_DAT_1 @ P1.7 */
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x4002c09c
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x0940             LSRS     R0,R0,#+5
   \   00000058   0x0140             LSLS     R0,R0,#+5
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x4002c09c
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    876            LPC_IOCON->P1_11 &= ~0x1F; /* SD_DAT_2 @ P1.11 */
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable30_2  ;; 0x4002c0ac
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x0940             LSRS     R0,R0,#+5
   \   00000068   0x0140             LSLS     R0,R0,#+5
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable30_2  ;; 0x4002c0ac
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    877            LPC_IOCON->P1_12 &= 0x1F; /* SD_DAT_3 @ P1.12 */
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable30_3  ;; 0x4002c0b0
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable30_3  ;; 0x4002c0b0
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    878            
    879            // Set all MCI pins to outputs
    880            LPC_GPIO1->DIR |= 0x18EC;
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable30_4  ;; 0x20098020
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xF440 0x50C0      ORR      R0,R0,#0x1800
   \   0000008A   0xF050 0x00EC      ORRS     R0,R0,#0xEC
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable30_4  ;; 0x20098020
   \   00000092   0x6008             STR      R0,[R1, #+0]
    881            
    882            // Force all pins low (except power control pin)
    883            LPC_GPIO1->CLR = 0x1000;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable30_5  ;; 0x2009803c
   \   00000098   0xF44F 0x5180      MOV      R1,#+4096
   \   0000009C   0x6001             STR      R1,[R0, #+0]
    884            LPC_GPIO1->CLR = 0x0800;
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable30_5  ;; 0x2009803c
   \   000000A2   0xF44F 0x6100      MOV      R1,#+2048
   \   000000A6   0x6001             STR      R1,[R0, #+0]
    885            LPC_GPIO1->CLR = 0x0080;
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable30_5  ;; 0x2009803c
   \   000000AC   0x2180             MOVS     R1,#+128
   \   000000AE   0x6001             STR      R1,[R0, #+0]
    886            LPC_GPIO1->CLR = 0x0040;
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable30_5  ;; 0x2009803c
   \   000000B4   0x2140             MOVS     R1,#+64
   \   000000B6   0x6001             STR      R1,[R0, #+0]
    887            
    888            LPC_GPIO1->SET = 0x0020;
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable30_6  ;; 0x20098038
   \   000000BC   0x2120             MOVS     R1,#+32
   \   000000BE   0x6001             STR      R1,[R0, #+0]
    889            
    890            LPC_GPIO1->CLR = 0x0008;
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable30_5  ;; 0x2009803c
   \   000000C4   0x2108             MOVS     R1,#+8
   \   000000C6   0x6001             STR      R1,[R0, #+0]
    891            LPC_GPIO1->CLR = 0x0004;
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable30_5  ;; 0x2009803c
   \   000000CC   0x2104             MOVS     R1,#+4
   \   000000CE   0x6001             STR      R1,[R0, #+0]
    892            
    893            // Crude delay of 50ms at 120MHz
    894            for ( i = 0; i < 0x100000; i++ );
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Init_0:
   \   000000D4   0x9800             LDR      R0,[SP, #+0]
   \   000000D6   0xF5B0 0x1F80      CMP      R0,#+1048576
   \   000000DA   0xD203             BCS.N    ??MCI_Init_1
   \   000000DC   0x9800             LDR      R0,[SP, #+0]
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \   000000E0   0x9000             STR      R0,[SP, #+0]
   \   000000E2   0xE7F7             B.N      ??MCI_Init_0
    895            
    896            LPC_SC->PCONP |= ( 1 << 28 );            /* Enable clock to the MCI block */
   \                     ??MCI_Init_1:
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable32  ;; 0x400fc0c4
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable32  ;; 0x400fc0c4
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    897            
    898            if ( LPC_MCI->CLOCK & (1 << 8) )
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x400c0004
   \   000000F8   0x6800             LDR      R0,[R0, #+0]
   \   000000FA   0x05C0             LSLS     R0,R0,#+23
   \   000000FC   0xD510             BPL.N    ??MCI_Init_2
    899            {
    900              LPC_MCI->CLOCK &= ~(1 << 8);
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x400c0004
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable27  ;; 0x400c0004
   \   0000010C   0x6008             STR      R0,[R1, #+0]
    901              for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Init_3:
   \   00000112   0x9800             LDR      R0,[SP, #+0]
   \   00000114   0x2810             CMP      R0,#+16
   \   00000116   0xD203             BCS.N    ??MCI_Init_2
   \   00000118   0x9800             LDR      R0,[SP, #+0]
   \   0000011A   0x1C40             ADDS     R0,R0,#+1
   \   0000011C   0x9000             STR      R0,[SP, #+0]
   \   0000011E   0xE7F8             B.N      ??MCI_Init_3
    902            }
    903            
    904            if ( LPC_MCI->POWER & 0x02 )
   \                     ??MCI_Init_2:
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable33  ;; 0x400c0000
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0x0780             LSLS     R0,R0,#+30
   \   00000128   0xD50C             BPL.N    ??MCI_Init_4
    905            {
    906              LPC_MCI->POWER = 0x00;
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable33  ;; 0x400c0000
   \   0000012E   0x2100             MOVS     R1,#+0
   \   00000130   0x6001             STR      R1,[R0, #+0]
    907              for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Init_5:
   \   00000136   0x9800             LDR      R0,[SP, #+0]
   \   00000138   0x2810             CMP      R0,#+16
   \   0000013A   0xD203             BCS.N    ??MCI_Init_4
   \   0000013C   0x9800             LDR      R0,[SP, #+0]
   \   0000013E   0x1C40             ADDS     R0,R0,#+1
   \   00000140   0x9000             STR      R0,[SP, #+0]
   \   00000142   0xE7F8             B.N      ??MCI_Init_5
    908            }
    909            
    910            /* Disable all interrupts for now */
    911            LPC_MCI->MASK0 = 0;
   \                     ??MCI_Init_4:
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x400c003c
   \   00000148   0x2100             MOVS     R1,#+0
   \   0000014A   0x6001             STR      R1,[R0, #+0]
    912            
    913            //SD_CLK
    914            PINSEL_ConfigPin(1, 2, 2);
   \   0000014C   0x2202             MOVS     R2,#+2
   \   0000014E   0x2102             MOVS     R1,#+2
   \   00000150   0x2001             MOVS     R0,#+1
   \   00000152   0x.... 0x....      BL       PINSEL_ConfigPin
    915            
    916            //SD_CMD
    917            PINSEL_ConfigPin(1, 3, 2);
   \   00000156   0x2202             MOVS     R2,#+2
   \   00000158   0x2103             MOVS     R1,#+3
   \   0000015A   0x2001             MOVS     R0,#+1
   \   0000015C   0x.... 0x....      BL       PINSEL_ConfigPin
    918            
    919            //SD_PWR
    920            PINSEL_ConfigPin(1, 5, 2);
   \   00000160   0x2202             MOVS     R2,#+2
   \   00000162   0x2105             MOVS     R1,#+5
   \   00000164   0x2001             MOVS     R0,#+1
   \   00000166   0x.... 0x....      BL       PINSEL_ConfigPin
    921            
    922            //SD_DAT_0
    923            PINSEL_ConfigPin(1, 6, 2);
   \   0000016A   0x2202             MOVS     R2,#+2
   \   0000016C   0x2106             MOVS     R1,#+6
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0x.... 0x....      BL       PINSEL_ConfigPin
    924            
    925            //SD_DAT_1
    926            PINSEL_ConfigPin(1, 7, 2);
   \   00000174   0x2202             MOVS     R2,#+2
   \   00000176   0x2107             MOVS     R1,#+7
   \   00000178   0x2001             MOVS     R0,#+1
   \   0000017A   0x.... 0x....      BL       PINSEL_ConfigPin
    927            
    928            //SD_DAT_2
    929            PINSEL_ConfigPin(1, 11, 2);
   \   0000017E   0x2202             MOVS     R2,#+2
   \   00000180   0x210B             MOVS     R1,#+11
   \   00000182   0x2001             MOVS     R0,#+1
   \   00000184   0x.... 0x....      BL       PINSEL_ConfigPin
    930            
    931            //SD_DAT_3
    932            PINSEL_ConfigPin(1, 12, 2);
   \   00000188   0x2202             MOVS     R2,#+2
   \   0000018A   0x210C             MOVS     R1,#+12
   \   0000018C   0x2001             MOVS     R0,#+1
   \   0000018E   0x.... 0x....      BL       PINSEL_ConfigPin
    933            
    934            // SD_PWR is active high (follows the output of the SD Card interface block).
    935            if(powerActiveLevel == LOW_LVL)
   \   00000192   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000194   0x2C00             CMP      R4,#+0
   \   00000196   0xD108             BNE.N    ??MCI_Init_6
    936            {
    937              LPC_SC->SCS &= ~ 0x08;//Becase on EA board SD_PWR is active low
   \   00000198   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x400fc1a0
   \   0000019C   0x6800             LDR      R0,[R0, #+0]
   \   0000019E   0xF030 0x0008      BICS     R0,R0,#0x8
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable33_1  ;; 0x400fc1a0
   \   000001A6   0x6008             STR      R0,[R1, #+0]
   \   000001A8   0xE007             B.N      ??MCI_Init_7
    938            }
    939            else
    940            {
    941              LPC_SC->SCS |= 0x08;
   \                     ??MCI_Init_6:
   \   000001AA   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x400fc1a0
   \   000001AE   0x6800             LDR      R0,[R0, #+0]
   \   000001B0   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable33_1  ;; 0x400fc1a0
   \   000001B8   0x6008             STR      R0,[R1, #+0]
    942            }
    943            
    944            //Setting for timeout problem
    945            LPC_MCI->DATATMR = 0x1FFFFFFF;
   \                     ??MCI_Init_7:
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x400c0024
   \   000001BE   0xF07F 0x4160      MVNS     R1,#-536870912
   \   000001C2   0x6001             STR      R1,[R0, #+0]
    946            
    947            /*set up clocking default mode, clear any registers as needed */
    948            LPC_MCI->COMMAND = 0;
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x400c000c
   \   000001C8   0x2100             MOVS     R1,#+0
   \   000001CA   0x6001             STR      R1,[R0, #+0]
    949            for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \   000001CC   0x2000             MOVS     R0,#+0
   \   000001CE   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Init_8:
   \   000001D0   0x9800             LDR      R0,[SP, #+0]
   \   000001D2   0x2810             CMP      R0,#+16
   \   000001D4   0xD203             BCS.N    ??MCI_Init_9
   \   000001D6   0x9800             LDR      R0,[SP, #+0]
   \   000001D8   0x1C40             ADDS     R0,R0,#+1
   \   000001DA   0x9000             STR      R0,[SP, #+0]
   \   000001DC   0xE7F8             B.N      ??MCI_Init_8
    950            LPC_MCI->DATACTRL = 0;
   \                     ??MCI_Init_9:
   \   000001DE   0x.... 0x....      LDR.W    R0,??DataTable34_2  ;; 0x400c002c
   \   000001E2   0x2100             MOVS     R1,#+0
   \   000001E4   0x6001             STR      R1,[R0, #+0]
    951            for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \   000001E6   0x2000             MOVS     R0,#+0
   \   000001E8   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Init_10:
   \   000001EA   0x9800             LDR      R0,[SP, #+0]
   \   000001EC   0x2810             CMP      R0,#+16
   \   000001EE   0xD203             BCS.N    ??MCI_Init_11
   \   000001F0   0x9800             LDR      R0,[SP, #+0]
   \   000001F2   0x1C40             ADDS     R0,R0,#+1
   \   000001F4   0x9000             STR      R0,[SP, #+0]
   \   000001F6   0xE7F8             B.N      ??MCI_Init_10
    952            LPC_MCI->CLEAR = 0x7FF;        /* clear all pending interrupts */
   \                     ??MCI_Init_11:
   \   000001F8   0x.... 0x....      LDR.W    R0,??DataTable25_2  ;; 0x400c0038
   \   000001FC   0xF240 0x71FF      MOVW     R1,#+2047
   \   00000200   0x6001             STR      R1,[R0, #+0]
    953            
    954            LPC_MCI->POWER = 0x02;        /* power up */
   \   00000202   0x.... 0x....      LDR.W    R0,??DataTable33  ;; 0x400c0000
   \   00000206   0x2102             MOVS     R1,#+2
   \   00000208   0x6001             STR      R1,[R0, #+0]
    955            for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \   0000020A   0x2000             MOVS     R0,#+0
   \   0000020C   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Init_12:
   \   0000020E   0x9800             LDR      R0,[SP, #+0]
   \   00000210   0x2810             CMP      R0,#+16
   \   00000212   0xD203             BCS.N    ??MCI_Init_13
   \   00000214   0x9800             LDR      R0,[SP, #+0]
   \   00000216   0x1C40             ADDS     R0,R0,#+1
   \   00000218   0x9000             STR      R0,[SP, #+0]
   \   0000021A   0xE7F8             B.N      ??MCI_Init_12
    956            
    957            
    958            /* delays for the supply output is stable*/
    959            for ( i = 0; i < 0x80000; i++ );
   \                     ??MCI_Init_13:
   \   0000021C   0x2000             MOVS     R0,#+0
   \   0000021E   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Init_14:
   \   00000220   0x9800             LDR      R0,[SP, #+0]
   \   00000222   0xF5B0 0x2F00      CMP      R0,#+524288
   \   00000226   0xD203             BCS.N    ??MCI_Init_15
   \   00000228   0x9800             LDR      R0,[SP, #+0]
   \   0000022A   0x1C40             ADDS     R0,R0,#+1
   \   0000022C   0x9000             STR      R0,[SP, #+0]
   \   0000022E   0xE7F7             B.N      ??MCI_Init_14
    960            
    961            /* During identification phase, the clock should be less than
    962            400Khz. Once we pass this phase, the normal clock can be set up
    963            to 25Mhz on SD card and 20Mhz on MMC card. */
    964            MCI_Set_MCIClock(MCI_SLOW_RATE );
   \                     ??MCI_Init_15:
   \   00000230   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x61a80
   \   00000234   0x.... 0x....      BL       MCI_Set_MCIClock
    965            
    966            LPC_MCI->POWER |= 0x01;        /* bit 1 is set already, from power up to power on */
   \   00000238   0x.... 0x....      LDR.W    R0,??DataTable33  ;; 0x400c0000
   \   0000023C   0x6800             LDR      R0,[R0, #+0]
   \   0000023E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000242   0x.... 0x....      LDR.W    R1,??DataTable33  ;; 0x400c0000
   \   00000246   0x6008             STR      R0,[R1, #+0]
    967            for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \   00000248   0x2000             MOVS     R0,#+0
   \   0000024A   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Init_16:
   \   0000024C   0x9800             LDR      R0,[SP, #+0]
   \   0000024E   0x2810             CMP      R0,#+16
   \   00000250   0xD203             BCS.N    ??MCI_Init_17
   \   00000252   0x9800             LDR      R0,[SP, #+0]
   \   00000254   0x1C40             ADDS     R0,R0,#+1
   \   00000256   0x9000             STR      R0,[SP, #+0]
   \   00000258   0xE7F8             B.N      ??MCI_Init_16
    968            
    969            NVIC_EnableIRQ(MCI_IRQn);
   \                     ??MCI_Init_17:
   \   0000025A   0x201D             MOVS     R0,#+29
   \   0000025C   0x.... 0x....      BL       NVIC_EnableIRQ
    970            
    971            MCI_CardInit();
   \   00000260   0x.... 0x....      BL       MCI_CardInit
    972            
    973            /* During the initialization phase, to simplify the process, the CMD related
    974            interrupts are disabled. The DATA related interrupts are enabled when
    975            the FIFOs are used and just before WRITE_BLOCK READ_BLOCK cmds are issues, and
    976            disabled after the data block has been written and read. Please also note,
    977            before WRITE_BLOCK only TX related data interrupts are enabled, and before
    978            READ_BLOCK only RX related data interrupts are enabled. */
    979            return MCI_FUNC_OK;
   \   00000264   0x2000             MOVS     R0,#+0
   \   00000266   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    980          }
    981          
    982          /************************************************************************//**
    983          * @brief         Set output in open drain mode or pushpull mode
    984          *
    985          * @param[in]    mode the mode going to set
    986          *
    987          * @return         None
    988          ***************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    989          void MCI_SetOutputMode(uint32_t mode)
    990          {
    991            uint32_t i = 0;
   \                     MCI_SetOutputMode:
   \   00000000   0x2100             MOVS     R1,#+0
    992            if(mode == MCI_OUTPUT_MODE_OPENDRAIN)
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD108             BNE.N    ??MCI_SetOutputMode_0
    993            {
    994              /* Set Open Drain output control for MMC */
    995              LPC_MCI->POWER |= (1 << MCI_PWRCTRL_OPENDRAIN_POS) & MCI_PWRCTRL_BMASK;
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable33  ;; 0x400c0000
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0xF052 0x0240      ORRS     R2,R2,#0x40
   \   00000010   0x.... 0x....      LDR.W    R3,??DataTable33  ;; 0x400c0000
   \   00000014   0x601A             STR      R2,[R3, #+0]
   \   00000016   0xE007             B.N      ??MCI_SetOutputMode_1
    996            }
    997            else
    998            {
    999              /* Clear Open Drain output control for SD */
   1000              LPC_MCI->POWER &= (~(1 << MCI_PWRCTRL_OPENDRAIN_POS) & MCI_PWRCTRL_BMASK);
   \                     ??MCI_SetOutputMode_0:
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable33  ;; 0x400c0000
   \   0000001C   0x6812             LDR      R2,[R2, #+0]
   \   0000001E   0xF012 0x0283      ANDS     R2,R2,#0x83
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable33  ;; 0x400c0000
   \   00000026   0x601A             STR      R2,[R3, #+0]
   1001            }
   1002            for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \                     ??MCI_SetOutputMode_1:
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x0011             MOVS     R1,R2
   \                     ??MCI_SetOutputMode_2:
   \   0000002C   0x2910             CMP      R1,#+16
   \   0000002E   0xD201             BCS.N    ??MCI_SetOutputMode_3
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \   00000032   0xE7FB             B.N      ??MCI_SetOutputMode_2
   1003          }
   \                     ??MCI_SetOutputMode_3:
   \   00000034   0x4770             BX       LR               ;; return
   1004          
   1005          
   1006          /************************************************************************//**
   1007          * @brief        The routine is used to send a CMD to the card
   1008          *
   1009          * @param[in]    CmdIndex the command to be sent to cards
   1010          *
   1011          * @param[in]    Argument the argument follows the command
   1012          *
   1013          * @param[in]    ExpectResp the response type for the command. They may be:
   1014          *                - EXPECT_NO_RESP: means no response required
   1015          *                - EXPECT_SHORT_RESP: means a response in a word needed
   1016          *                - EXPECT_LONG_RESP: means a response in 4 words needed
   1017          *
   1018          * @param[in]    AllowTimeout allow timeout the command or not
   1019          *
   1020          * @return       None
   1021          ***************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1022          void MCI_SendCmd(st_Mci_CmdInfo* pCmdIf)
   1023          {
   \                     MCI_SendCmd:
   \   00000000   0xB4F8             PUSH     {R3-R7}
   1024            volatile uint32_t i;
   1025            uint32_t CmdData = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   1026            uint32_t CmdStatus;
   1027            
   1028            uint32_t CmdIndex = pCmdIf->CmdIndex;
   \   00000004   0x6803             LDR      R3,[R0, #+0]
   1029            uint32_t Argument = pCmdIf->Argument;
   \   00000006   0x6844             LDR      R4,[R0, #+4]
   1030            uint32_t ExpectResp = pCmdIf->ExpectResp;
   \   00000008   0x6885             LDR      R5,[R0, #+8]
   1031            uint32_t AllowTimeout = pCmdIf->AllowTimeout;
   \   0000000A   0x68C6             LDR      R6,[R0, #+12]
   1032            
   1033            /* the command engine must be disabled when we modify the argument
   1034            or the peripheral resends */
   1035            while ( (CmdStatus = LPC_MCI->STATUS) & MCI_CMD_ACTIVE )    /* Command in progress. */
   \                     ??MCI_SendCmd_0:
   \   0000000C   0x.... 0x....      LDR.W    R7,??DataTable25_1  ;; 0x400c0034
   \   00000010   0x683F             LDR      R7,[R7, #+0]
   \   00000012   0x003A             MOVS     R2,R7
   \   00000014   0x053F             LSLS     R7,R7,#+20
   \   00000016   0xD515             BPL.N    ??MCI_SendCmd_1
   1036            {
   1037              LPC_MCI->COMMAND = 0;
   \   00000018   0x.... 0x....      LDR.W    R7,??DataTable34_1  ;; 0x400c000c
   \   0000001C   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000020   0xF8C7 0xC000      STR      R12,[R7, #+0]
   1038              for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \   00000024   0x2700             MOVS     R7,#+0
   \   00000026   0x9700             STR      R7,[SP, #+0]
   \                     ??MCI_SendCmd_2:
   \   00000028   0x9F00             LDR      R7,[SP, #+0]
   \   0000002A   0x2F10             CMP      R7,#+16
   \   0000002C   0xD203             BCS.N    ??MCI_SendCmd_3
   \   0000002E   0x9F00             LDR      R7,[SP, #+0]
   \   00000030   0x1C7F             ADDS     R7,R7,#+1
   \   00000032   0x9700             STR      R7,[SP, #+0]
   \   00000034   0xE7F8             B.N      ??MCI_SendCmd_2
   1039              LPC_MCI->CLEAR = CmdStatus | MCI_CMD_ACTIVE;
   \                     ??MCI_SendCmd_3:
   \   00000036   0xF452 0x6700      ORRS     R7,R2,#0x800
   \   0000003A   0x.... 0x....      LDR.W    R12,??DataTable25_2  ;; 0x400c0038
   \   0000003E   0xF8CC 0x7000      STR      R7,[R12, #+0]
   \   00000042   0xE7E3             B.N      ??MCI_SendCmd_0
   1040            }
   1041            
   1042            
   1043            /*set the command details, the CmdIndex should 0 through 0x3F only */
   1044            CmdData |= (CmdIndex & 0x3F);    /* bit 0 through 5 only */
   \                     ??MCI_SendCmd_1:
   \   00000044   0xF013 0x073F      ANDS     R7,R3,#0x3F
   \   00000048   0x4339             ORRS     R1,R7,R1
   1045            
   1046            if ( ExpectResp == EXPECT_NO_RESP )            /* no response */
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD102             BNE.N    ??MCI_SendCmd_4
   1047            {
   1048              CmdData &= ~((1 << 6) | (1 << 7));        /* Clear long response bit as well */
   \   0000004E   0xF031 0x01C0      BICS     R1,R1,#0xC0
   \   00000052   0xE008             B.N      ??MCI_SendCmd_5
   1049            }
   1050            else if ( ExpectResp == EXPECT_SHORT_RESP )    /* expect short response */
   \                     ??MCI_SendCmd_4:
   \   00000054   0x2D01             CMP      R5,#+1
   \   00000056   0xD102             BNE.N    ??MCI_SendCmd_6
   1051            {
   1052              CmdData |= (1 << 6);
   \   00000058   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   0000005C   0xE003             B.N      ??MCI_SendCmd_5
   1053            }
   1054            else if ( ExpectResp == EXPECT_LONG_RESP )    /* expect long response */
   \                     ??MCI_SendCmd_6:
   \   0000005E   0x2D02             CMP      R5,#+2
   \   00000060   0xD101             BNE.N    ??MCI_SendCmd_5
   1055            {
   1056              CmdData |= (1 << 6) | (1 << 7);
   \   00000062   0xF051 0x01C0      ORRS     R1,R1,#0xC0
   1057            }
   1058            
   1059            if ( AllowTimeout == ALLOW_CMD_TIMER )            /* allow timeout or not */
   \                     ??MCI_SendCmd_5:
   \   00000066   0x2E01             CMP      R6,#+1
   \   00000068   0xD102             BNE.N    ??MCI_SendCmd_7
   1060            {
   1061              CmdData &= ~ MCI_DISABLE_CMD_TIMER;
   \   0000006A   0xF431 0x7180      BICS     R1,R1,#0x100
   \   0000006E   0xE001             B.N      ??MCI_SendCmd_8
   1062            }
   1063            else
   1064            {
   1065              CmdData |= MCI_DISABLE_CMD_TIMER;
   \                     ??MCI_SendCmd_7:
   \   00000070   0xF451 0x7180      ORRS     R1,R1,#0x100
   1066            }
   1067            
   1068            /*send the command*/
   1069            CmdData |= (1 << 10);        /* This bit needs to be set last. */
   \                     ??MCI_SendCmd_8:
   \   00000074   0xF451 0x6180      ORRS     R1,R1,#0x400
   1070            
   1071            // clear status register
   1072            LPC_MCI->CLEAR = 0x7FF;
   \   00000078   0x.... 0x....      LDR.W    R7,??DataTable25_2  ;; 0x400c0038
   \   0000007C   0xF240 0x7CFF      MOVW     R12,#+2047
   \   00000080   0xF8C7 0xC000      STR      R12,[R7, #+0]
   1073            
   1074            LPC_MCI->ARGUMENT = Argument;    /* Set the argument first, finally command */
   \   00000084   0x.... 0x....      LDR.W    R7,??DataTable35  ;; 0x400c0008
   \   00000088   0x603C             STR      R4,[R7, #+0]
   1075            
   1076            LPC_MCI->COMMAND = CmdData;
   \   0000008A   0x.... 0x....      LDR.W    R7,??DataTable34_1  ;; 0x400c000c
   \   0000008E   0x6039             STR      R1,[R7, #+0]
   1077            
   1078            for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \   00000090   0x2700             MOVS     R7,#+0
   \   00000092   0x9700             STR      R7,[SP, #+0]
   \                     ??MCI_SendCmd_9:
   \   00000094   0x9F00             LDR      R7,[SP, #+0]
   \   00000096   0x2F10             CMP      R7,#+16
   \   00000098   0xD203             BCS.N    ??MCI_SendCmd_10
   \   0000009A   0x9F00             LDR      R7,[SP, #+0]
   \   0000009C   0x1C7F             ADDS     R7,R7,#+1
   \   0000009E   0x9700             STR      R7,[SP, #+0]
   \   000000A0   0xE7F8             B.N      ??MCI_SendCmd_9
   1079            
   1080            // Wait until command is processed
   1081            while(!LPC_MCI->STATUS);
   \                     ??MCI_SendCmd_10:
   \   000000A2   0x.... 0x....      LDR.W    R7,??DataTable25_1  ;; 0x400c0034
   \   000000A6   0x683F             LDR      R7,[R7, #+0]
   \   000000A8   0x2F00             CMP      R7,#+0
   \   000000AA   0xD0FA             BEQ.N    ??MCI_SendCmd_10
   1082            
   1083            // Wait until command sent
   1084            while(LPC_MCI->STATUS & MCI_CMD_ACTIVE);
   \                     ??MCI_SendCmd_11:
   \   000000AC   0x.... 0x....      LDR.W    R7,??DataTable25_1  ;; 0x400c0034
   \   000000B0   0x683F             LDR      R7,[R7, #+0]
   \   000000B2   0x053F             LSLS     R7,R7,#+20
   \   000000B4   0xD4FA             BMI.N    ??MCI_SendCmd_11
   1085            
   1086            return;
   \   000000B6   0xBCF1             POP      {R0,R4-R7}
   \   000000B8   0x4770             BX       LR               ;; return
   1087          }
   1088          
   1089          
   1090          /************************************************************************//**
   1091          * @brief        The routine is to get the reponse from card after commands.
   1092          *               This function is always used in pair of MCI_SendCmd() func
   1093          *
   1094          * @param[in]    ExpectCmdData specify the command of which the data will be
   1095          *                retrieved. This field should be the same with CmdIndex of
   1096          *                MCI_SendCmd() function.
   1097          *
   1098          * @param[in]    ExpectResp the response type for the command. They may be:
   1099          *                - EXPECT_NO_RESP: means no response required
   1100          *                - EXPECT_SHORT_RESP: means a response in a word needed
   1101          *                - EXPECT_LONG_RESP: means a response in 4 words needed
   1102          *
   1103          * @param[out]   CmdResp the buffer stored the data replied from cards
   1104          *
   1105          * @return       MCI_FUNC_OK in case of success
   1106          ***************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1107          int32_t MCI_GetCmdResp(uint32_t ExpectCmdData, uint32_t ExpectResp, uint32_t *CmdResp)
   1108          {
   \                     MCI_GetCmdResp:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
   1109            uint32_t CmdRespStatus = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   1110            uint32_t LastCmdIndex;
   1111            uint32_t i = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1112            
   1113            if ( ExpectResp == EXPECT_NO_RESP )
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD101             BNE.N    ??MCI_GetCmdResp_0
   1114            {
   1115              return MCI_FUNC_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE078             B.N      ??MCI_GetCmdResp_1
   1116            }
   1117            
   1118            while (1)
   1119            {
   1120              // Get the status of the component
   1121              CmdRespStatus = LPC_MCI->STATUS;
   \                     ??MCI_GetCmdResp_0:
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable25_1  ;; 0x400c0034
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0004             MOVS     R4,R0
   1122              
   1123              if ( CmdRespStatus & (MCI_CMD_TIMEOUT) )
   \   00000018   0x0760             LSLS     R0,R4,#+29
   \   0000001A   0xD515             BPL.N    ??MCI_GetCmdResp_2
   1124              {
   1125                LPC_MCI->CLEAR = CmdRespStatus | MCI_CMD_TIMEOUT;
   \   0000001C   0xF054 0x0004      ORRS     R0,R4,#0x4
   \   00000020   0x.... 0x....      LDR.W    R7,??DataTable25_2  ;; 0x400c0038
   \   00000024   0x6038             STR      R0,[R7, #+0]
   1126                
   1127                LPC_MCI->COMMAND = 0;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x400c000c
   \   0000002A   0x2700             MOVS     R7,#+0
   \   0000002C   0x6007             STR      R7,[R0, #+0]
   1128                LPC_MCI->ARGUMENT = 0xFFFFFFFF;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x400c0008
   \   00000032   0xF05F 0x37FF      MOVS     R7,#-1
   \   00000036   0x6007             STR      R7,[R0, #+0]
   1129                
   1130                for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x0006             MOVS     R6,R0
   \                     ??MCI_GetCmdResp_3:
   \   0000003C   0x2E10             CMP      R6,#+16
   \   0000003E   0xD201             BCS.N    ??MCI_GetCmdResp_4
   \   00000040   0x1C76             ADDS     R6,R6,#+1
   \   00000042   0xE7FB             B.N      ??MCI_GetCmdResp_3
   1131                
   1132                return (CmdRespStatus);
   \                     ??MCI_GetCmdResp_4:
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xE05C             B.N      ??MCI_GetCmdResp_1
   1133              }
   1134              
   1135              if (  CmdRespStatus & MCI_CMD_CRC_FAIL )
   \                     ??MCI_GetCmdResp_2:
   \   00000048   0x07E0             LSLS     R0,R4,#+31
   \   0000004A   0xD522             BPL.N    ??MCI_GetCmdResp_5
   1136              {
   1137                LPC_MCI->CLEAR = CmdRespStatus | MCI_CMD_CRC_FAIL;
   \   0000004C   0xF054 0x0001      ORRS     R0,R4,#0x1
   \   00000050   0x.... 0x....      LDR.W    R7,??DataTable25_2  ;; 0x400c0038
   \   00000054   0x6038             STR      R0,[R7, #+0]
   1138                LastCmdIndex = LPC_MCI->COMMAND & 0x003F;
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x400c000c
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000060   0x0005             MOVS     R5,R0
   1139                
   1140                if ( (LastCmdIndex == CMD1_SEND_OP_COND) || (LastCmdIndex == ACMD41_SEND_APP_OP_COND)
   1141                    || (LastCmdIndex == CMD12_STOP_TRANSMISSION) )
   \   00000062   0x2D01             CMP      R5,#+1
   \   00000064   0xD003             BEQ.N    ??MCI_GetCmdResp_6
   \   00000066   0x2D29             CMP      R5,#+41
   \   00000068   0xD001             BEQ.N    ??MCI_GetCmdResp_6
   \   0000006A   0x2D0C             CMP      R5,#+12
   \   0000006C   0xD10F             BNE.N    ??MCI_GetCmdResp_7
   1142                {
   1143                  LPC_MCI->COMMAND = 0;
   \                     ??MCI_GetCmdResp_6:
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x400c000c
   \   00000072   0x2700             MOVS     R7,#+0
   \   00000074   0x6007             STR      R7,[R0, #+0]
   1144                  LPC_MCI->ARGUMENT = 0xFFFFFFFF;
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x400c0008
   \   0000007A   0xF05F 0x37FF      MOVS     R7,#-1
   \   0000007E   0x6007             STR      R7,[R0, #+0]
   1145                  for ( i = 0; i < 0x10; i++ );    /* delay 3MCLK + 2PCLK  */
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x0006             MOVS     R6,R0
   \                     ??MCI_GetCmdResp_8:
   \   00000084   0x2E10             CMP      R6,#+16
   \   00000086   0xD201             BCS.N    ??MCI_GetCmdResp_9
   \   00000088   0x1C76             ADDS     R6,R6,#+1
   \   0000008A   0xE7FB             B.N      ??MCI_GetCmdResp_8
   1146                  break;            /* ignore CRC error if it's a resp for SEND_OP_COND
   \                     ??MCI_GetCmdResp_9:
   \   0000008C   0xE008             B.N      ??MCI_GetCmdResp_10
   1147                  or STOP_TRANSMISSION. */
   1148                }
   1149                else
   1150                {
   1151                  return (CmdRespStatus);
   \                     ??MCI_GetCmdResp_7:
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0xE037             B.N      ??MCI_GetCmdResp_1
   1152                }
   1153              }
   1154              else if (CmdRespStatus & MCI_CMD_RESP_END)
   \                     ??MCI_GetCmdResp_5:
   \   00000092   0x0660             LSLS     R0,R4,#+25
   \   00000094   0xD5BC             BPL.N    ??MCI_GetCmdResp_0
   1155              {
   1156                LPC_MCI->CLEAR = CmdRespStatus | MCI_CMD_RESP_END;
   \   00000096   0xF054 0x0040      ORRS     R0,R4,#0x40
   \   0000009A   0x.... 0x....      LDR.W    R7,??DataTable25_2  ;; 0x400c0038
   \   0000009E   0x6038             STR      R0,[R7, #+0]
   1157                break;    /* cmd response is received, expecting response */
   1158              }
   1159              
   1160            }
   1161            
   1162            if ((LPC_MCI->RESP_CMD & 0x3F) != ExpectCmdData)
   \                     ??MCI_GetCmdResp_10:
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable36  ;; 0x400c0010
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   000000AA   0x4298             CMP      R0,R3
   \   000000AC   0xD00D             BEQ.N    ??MCI_GetCmdResp_11
   1163            {
   1164              /* If the response is not R1, in the response field, the Expected Cmd data
   1165              won't be the same as the CMD data in SendCmd(). Below four cmds have
   1166              R2 or R3 response. We don't need to check if MCI_RESP_CMD is the same
   1167              as the Expected or not. */
   1168              if ((ExpectCmdData != CMD1_SEND_OP_COND) && (ExpectCmdData != ACMD41_SEND_APP_OP_COND)
   1169                  && (ExpectCmdData != CMD2_ALL_SEND_CID) && (ExpectCmdData != CMD9_SEND_CSD))
   \   000000AE   0x2B01             CMP      R3,#+1
   \   000000B0   0xD00B             BEQ.N    ??MCI_GetCmdResp_11
   \   000000B2   0x2B29             CMP      R3,#+41
   \   000000B4   0xD009             BEQ.N    ??MCI_GetCmdResp_11
   \   000000B6   0x2B02             CMP      R3,#+2
   \   000000B8   0xD007             BEQ.N    ??MCI_GetCmdResp_11
   \   000000BA   0x2B09             CMP      R3,#+9
   \   000000BC   0xD005             BEQ.N    ??MCI_GetCmdResp_11
   1170              {
   1171                CmdRespStatus = INVALID_RESPONSE;    /* Reuse error status */
   \   000000BE   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000C2   0x0004             MOVS     R4,R0
   1172                return (INVALID_RESPONSE);
   \   000000C4   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000C8   0xE01B             B.N      ??MCI_GetCmdResp_1
   1173              }
   1174            }
   1175            
   1176            /* Read MCI_RESP0 register assuming it's not long response. */
   1177            if (CmdResp != NULL)
   \                     ??MCI_GetCmdResp_11:
   \   000000CA   0x2A00             CMP      R2,#+0
   \   000000CC   0xD018             BEQ.N    ??MCI_GetCmdResp_12
   1178            {
   1179              if (ExpectResp == EXPECT_SHORT_RESP)
   \   000000CE   0x2901             CMP      R1,#+1
   \   000000D0   0xD104             BNE.N    ??MCI_GetCmdResp_13
   1180              {
   1181                *(CmdResp + 0) = LPC_MCI->RESP0;
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable36_1  ;; 0x400c0014
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x6010             STR      R0,[R2, #+0]
   \   000000DA   0xE011             B.N      ??MCI_GetCmdResp_12
   1182              }
   1183              else if (ExpectResp == EXPECT_LONG_RESP)
   \                     ??MCI_GetCmdResp_13:
   \   000000DC   0x2902             CMP      R1,#+2
   \   000000DE   0xD10F             BNE.N    ??MCI_GetCmdResp_12
   1184              {
   1185                *(CmdResp + 0) = LPC_MCI->RESP0;
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable36_1  ;; 0x400c0014
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x6010             STR      R0,[R2, #+0]
   1186                *(CmdResp + 1) = LPC_MCI->RESP1;
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable36_2  ;; 0x400c0018
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x6050             STR      R0,[R2, #+4]
   1187                *(CmdResp + 2) = LPC_MCI->RESP2;
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable37  ;; 0x400c001c
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0x6090             STR      R0,[R2, #+8]
   1188                *(CmdResp + 3) = LPC_MCI->RESP3;
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable37_1  ;; 0x400c0020
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x60D0             STR      R0,[R2, #+12]
   1189              }
   1190            }
   1191            
   1192            return MCI_FUNC_OK;
   \                     ??MCI_GetCmdResp_12:
   \   00000100   0x2000             MOVS     R0,#+0
   \                     ??MCI_GetCmdResp_1:
   \   00000102   0xBCF0             POP      {R4-R7}
   \   00000104   0x4770             BX       LR               ;; return
   1193          }
   1194          
   1195          
   1196          /************************************************************************//**
   1197          * @brief        The routine is to send command to cards then get back the 
   1198          *               reponses (if required).
   1199          *
   1200          * @param[in]    CmdIndex the command to be sent to cards
   1201          *
   1202          * @param[in]    Argument the argument follows the command
   1203          *
   1204          * @param[in]    ExpectResp the response type for the command. They may be:
   1205          *                - EXPECT_NO_RESP: means no response required
   1206          *                - EXPECT_SHORT_RESP: means a response in a word needed
   1207          *                - EXPECT_LONG_RESP: means a response in 4 words needed
   1208          *
   1209          * @param[out]    CmdResp the buffer stored the data replied from cards
   1210          *
   1211          * @param[in]    AllowTimeout allow timeout the command or not
   1212          *
   1213          * @return       MCI_FUNC_OK in case of success
   1214          ***************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1215          int32_t MCI_CmdResp(st_Mci_CmdInfo* pCmdIf)
   1216          {
   \                     MCI_CmdResp:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1217            int32_t respStatus;
   1218            uint32_t CmdIndex = pCmdIf->CmdIndex;
   \   00000006   0x6826             LDR      R6,[R4, #+0]
   1219            uint32_t ExpectResp = pCmdIf->ExpectResp;
   \   00000008   0x68A7             LDR      R7,[R4, #+8]
   1220            uint32_t *CmdResp = pCmdIf->CmdResp;
   \   0000000A   0xF8D4 0x8010      LDR      R8,[R4, #+16]
   1221            
   1222            
   1223            MCI_SendCmd(pCmdIf);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       MCI_SendCmd
   1224            
   1225            if((CmdResp != NULL) || (ExpectResp != EXPECT_NO_RESP))
   \   00000014   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000018   0xD101             BNE.N    ??MCI_CmdResp_0
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD006             BEQ.N    ??MCI_CmdResp_1
   1226            {
   1227              respStatus = MCI_GetCmdResp(CmdIndex, ExpectResp, CmdResp);
   \                     ??MCI_CmdResp_0:
   \   0000001E   0x4642             MOV      R2,R8
   \   00000020   0x0039             MOVS     R1,R7
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       MCI_GetCmdResp
   \   00000028   0x0005             MOVS     R5,R0
   \   0000002A   0xE002             B.N      ??MCI_CmdResp_2
   1228            }
   1229            else
   1230            {
   1231              respStatus = MCI_FUNC_BAD_PARAMETERS;
   \                     ??MCI_CmdResp_1:
   \   0000002C   0xF07F 0x0001      MVNS     R0,#+1
   \   00000030   0x0005             MOVS     R5,R0
   1232            }
   1233            
   1234            return respStatus;
   \                     ??MCI_CmdResp_2:
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1235          }
   1236          
   1237          
   1238          /************************************************************************//**
   1239          * @brief        To reset the card, the CMD0 is sent and then the card is put
   1240          *               in idle state. This is the very first command to be sent to
   1241          *               initialize either MMC or SD card.
   1242          *
   1243          * @param        None
   1244          *
   1245          * @return       Always MCI_FUNC_OK
   1246          ***************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1247          int32_t MCI_CardReset(void)
   1248          {
   \                     MCI_CardReset:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1249            st_Mci_CmdInfo cmdIf;
   1250            /* Because CMD0 command to put the device to idle state does not need response 
   1251            since, it's only sending commad */
   1252            cmdIf.CmdIndex = CMD0_GO_IDLE_STATE;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
   1253            cmdIf.Argument = 0x00000000;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   1254            cmdIf.ExpectResp = EXPECT_NO_RESP;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9002             STR      R0,[SP, #+8]
   1255            cmdIf.AllowTimeout = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9003             STR      R0,[SP, #+12]
   1256            cmdIf.CmdResp = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x9004             STR      R0,[SP, #+16]
   1257            MCI_SendCmd(&cmdIf);
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x.... 0x....      BL       MCI_SendCmd
   1258            
   1259            return MCI_FUNC_OK;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xB005             ADD      SP,SP,#+20
   \   00000022   0xBD00             POP      {PC}             ;; return
   1260          }
   1261          
   1262          
   1263          /************************************************************************//**
   1264          * @brief        Send CMD1 (SEND_OP_COND) to card.
   1265          *
   1266          * @param        None
   1267          *
   1268          * @return       MCI_FUNC_OK if all success
   1269          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1270          int32_t MCI_Cmd_SendOpCond( void )
   1271          {
   \                     MCI_Cmd_SendOpCond:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   1272            volatile uint32_t i;
   1273            uint32_t retryCount;
   1274            uint32_t respStatus;
   1275            uint32_t respValue[4];
   1276            st_Mci_CmdInfo cmdIf;
   1277            int32_t retval = MCI_FUNC_FAILED;
   \   00000004   0xF05F 0x36FF      MOVS     R6,#-1
   1278            
   1279            retryCount = 0x200;            /* reset retry counter */
   \   00000008   0xF44F 0x7000      MOV      R0,#+512
   \   0000000C   0x0004             MOVS     R4,R0
   1280            
   1281            cmdIf.CmdIndex = CMD1_SEND_OP_COND;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x9001             STR      R0,[SP, #+4]
   1282            cmdIf.Argument = OCR_INDEX;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable38  ;; 0xc0ff8080
   \   00000016   0x9002             STR      R0,[SP, #+8]
   1283            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x9003             STR      R0,[SP, #+12]
   1284            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x9004             STR      R0,[SP, #+16]
   1285            cmdIf.CmdResp = (uint32_t *)&respValue[0];
   \   00000020   0xA806             ADD      R0,SP,#+24
   \   00000022   0x9005             STR      R0,[SP, #+20]
   1286            /* continuously sends until the busy bit is cleared */
   1287            while ( retryCount > 0 ) 
   \                     ??MCI_Cmd_SendOpCond_0:
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD01E             BEQ.N    ??MCI_Cmd_SendOpCond_1
   1288            {
   1289              respStatus = MCI_CmdResp(&cmdIf);
   \   00000028   0xA801             ADD      R0,SP,#+4
   \   0000002A   0x.... 0x....      BL       MCI_CmdResp
   \   0000002E   0x0005             MOVS     R5,R0
   1290              
   1291              if(respStatus & MCI_CMD_TIMEOUT)
   \   00000030   0x0768             LSLS     R0,R5,#+29
   \   00000032   0xD503             BPL.N    ??MCI_Cmd_SendOpCond_2
   1292              {
   1293                retval = MCI_FUNC_TIMEOUT;
   \   00000034   0xF07F 0x0002      MVNS     R0,#+2
   \   00000038   0x0006             MOVS     R6,R0
   \   0000003A   0xE009             B.N      ??MCI_Cmd_SendOpCond_3
   1294              }
   1295              else if ((respValue[0] & 0x80000000) == 0)
   \                     ??MCI_Cmd_SendOpCond_2:
   \   0000003C   0x9806             LDR      R0,[SP, #+24]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD403             BMI.N    ??MCI_Cmd_SendOpCond_4
   1296              {
   1297                //The card has not finished the power up routine
   1298                retval = MCI_FUNC_BUS_NOT_IDLE;
   \   00000042   0xF07F 0x0002      MVNS     R0,#+2
   \   00000046   0x0006             MOVS     R6,R0
   \   00000048   0xE002             B.N      ??MCI_Cmd_SendOpCond_3
   1299              }
   1300              else
   1301              {
   1302                retval = MCI_FUNC_OK;
   \                     ??MCI_Cmd_SendOpCond_4:
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x0006             MOVS     R6,R0
   1303                break;
   \   0000004E   0xE00A             B.N      ??MCI_Cmd_SendOpCond_1
   1304              }
   1305              
   1306              for ( i = 0; i < 0x20; i++ );
   \                     ??MCI_Cmd_SendOpCond_3:
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Cmd_SendOpCond_5:
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x2820             CMP      R0,#+32
   \   00000058   0xD203             BCS.N    ??MCI_Cmd_SendOpCond_6
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0xE7F8             B.N      ??MCI_Cmd_SendOpCond_5
   1307              
   1308              retryCount--;
   \                     ??MCI_Cmd_SendOpCond_6:
   \   00000062   0x1E64             SUBS     R4,R4,#+1
   \   00000064   0xE7DE             B.N      ??MCI_Cmd_SendOpCond_0
   1309            }
   1310            
   1311            return(retval);
   \                     ??MCI_Cmd_SendOpCond_1:
   \   00000066   0x0030             MOVS     R0,R6
   \   00000068   0xB00A             ADD      SP,SP,#+40
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
   1312          }
   1313          
   1314          
   1315          /************************************************************************//**
   1316          * @brief        Send CMD8 (SEND_IF_COND) for interface condition to card.
   1317          *
   1318          * @param        None
   1319          *
   1320          * @return       MCI_FUNC_OK if all success
   1321          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1322          int32_t MCI_Cmd_SendIfCond(void)
   1323          {
   \                     MCI_Cmd_SendIfCond:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   1324            volatile uint32_t i;
   1325            uint32_t retryCount;
   1326            uint32_t CmdArgument;
   1327            uint32_t respStatus;
   1328            uint32_t respValue[4];
   1329            
   1330            int32_t retval = MCI_FUNC_FAILED;
   \   00000006   0xF05F 0x37FF      MOVS     R7,#-1
   1331            
   1332            uint8_t voltageSupplied = MCI_CMD8_VOLATAGESUPPLIED_27_36;//in range 2.7-3.6V
   \   0000000A   0xF05F 0x0801      MOVS     R8,#+1
   1333            uint8_t checkPattern = 0xAA;
   \   0000000E   0xF05F 0x09AA      MOVS     R9,#+170
   1334            st_Mci_CmdInfo cmdIf;
   1335            
   1336            CmdArgument = (voltageSupplied << MCI_CMD8_VOLTAGESUPPLIED_POS) | (checkPattern << MCI_CMD8_CHECKPATTERN_POS);
   \   00000012   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000016   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000001A   0xEA59 0x2008      ORRS     R0,R9,R8, LSL #+8
   \   0000001E   0x0005             MOVS     R5,R0
   1337            
   1338            retryCount = 20;
   \   00000020   0x2014             MOVS     R0,#+20
   \   00000022   0x0004             MOVS     R4,R0
   1339            
   1340            cmdIf.CmdIndex = CMD8_SEND_IF_COND;
   \   00000024   0x2008             MOVS     R0,#+8
   \   00000026   0x9001             STR      R0,[SP, #+4]
   1341            cmdIf.Argument = CmdArgument;
   \   00000028   0x9502             STR      R5,[SP, #+8]
   1342            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x9003             STR      R0,[SP, #+12]
   1343            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x9004             STR      R0,[SP, #+16]
   1344            cmdIf.CmdResp = (uint32_t *)&respValue[0];
   \   00000032   0xA806             ADD      R0,SP,#+24
   \   00000034   0x9005             STR      R0,[SP, #+20]
   1345            while ( retryCount > 0 )
   \                     ??MCI_Cmd_SendIfCond_0:
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD029             BEQ.N    ??MCI_Cmd_SendIfCond_1
   1346            {
   1347              respStatus = MCI_CmdResp(&cmdIf);
   \   0000003A   0xA801             ADD      R0,SP,#+4
   \   0000003C   0x.... 0x....      BL       MCI_CmdResp
   \   00000040   0x0006             MOVS     R6,R0
   1348              
   1349              if(respStatus & MCI_CMD_TIMEOUT)
   \   00000042   0x0770             LSLS     R0,R6,#+29
   \   00000044   0xD505             BPL.N    ??MCI_Cmd_SendIfCond_2
   1350              {
   1351                //Consider as no response
   1352                retval = MCI_FUNC_TIMEOUT;
   \   00000046   0xF07F 0x0002      MVNS     R0,#+2
   \   0000004A   0x0007             MOVS     R7,R0
   1353              }
   1354              else if (((respValue[0]>>MCI_CMD8_CHECKPATTERN_POS) & MCI_CMD8_CHECKPATTERN_BMASK) != checkPattern)
   1355              {
   1356                return MCI_FUNC_BAD_PARAMETERS;
   1357              }
   1358              else if (((respValue[0] >> MCI_CMD8_VOLTAGESUPPLIED_POS) & MCI_CMD8_VOLTAGESUPPLIED_BMASK)
   1359                       != voltageSupplied)
   1360              {
   1361                return MCI_FUNC_BAD_PARAMETERS;
   1362              }
   1363              else
   1364              {
   1365                return MCI_FUNC_OK;
   1366              }
   1367              
   1368              for ( i = 0; i < 0x20; i++ );
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0xE014             B.N      ??MCI_Cmd_SendIfCond_3
   \                     ??MCI_Cmd_SendIfCond_2:
   \   00000052   0x9806             LDR      R0,[SP, #+24]
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000005A   0x4548             CMP      R0,R9
   \   0000005C   0xD002             BEQ.N    ??MCI_Cmd_SendIfCond_4
   \   0000005E   0xF07F 0x0001      MVNS     R0,#+1
   \   00000062   0xE015             B.N      ??MCI_Cmd_SendIfCond_5
   \                     ??MCI_Cmd_SendIfCond_4:
   \   00000064   0x9806             LDR      R0,[SP, #+24]
   \   00000066   0xF3C0 0x2003      UBFX     R0,R0,#+8,#+4
   \   0000006A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006E   0x4540             CMP      R0,R8
   \   00000070   0xD002             BEQ.N    ??MCI_Cmd_SendIfCond_6
   \   00000072   0xF07F 0x0001      MVNS     R0,#+1
   \   00000076   0xE00B             B.N      ??MCI_Cmd_SendIfCond_5
   \                     ??MCI_Cmd_SendIfCond_6:
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE009             B.N      ??MCI_Cmd_SendIfCond_5
   \                     ??MCI_Cmd_SendIfCond_3:
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x2820             CMP      R0,#+32
   \   00000080   0xD203             BCS.N    ??MCI_Cmd_SendIfCond_7
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0x9000             STR      R0,[SP, #+0]
   \   00000088   0xE7F8             B.N      ??MCI_Cmd_SendIfCond_3
   1369              
   1370              retryCount--;
   \                     ??MCI_Cmd_SendIfCond_7:
   \   0000008A   0x1E64             SUBS     R4,R4,#+1
   \   0000008C   0xE7D3             B.N      ??MCI_Cmd_SendIfCond_0
   1371            }
   1372            
   1373            return retval;
   \                     ??MCI_Cmd_SendIfCond_1:
   \   0000008E   0x0038             MOVS     R0,R7
   \                     ??MCI_Cmd_SendIfCond_5:
   \   00000090   0xB00B             ADD      SP,SP,#+44
   \   00000092   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1374          }
   1375          
   1376          
   1377          /************************************************************************//**
   1378          * @brief        Send CMD55 (APP_CMD) to indicate to the card that the next
   1379          *               command is an application specific command rather than a 
   1380          *               standard command. Before an ACMD, call this routine first
   1381          *
   1382          * @param        None
   1383          *
   1384          * @return       MCI_FUNC_OK if all success
   1385          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1386          int32_t MCI_Cmd_SendACMD( void )
   1387          {
   \                     MCI_Cmd_SendACMD:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   1388            volatile uint32_t i;
   1389            uint32_t retryCount;
   1390            uint32_t CmdArgument;
   1391            uint32_t respStatus;
   1392            uint32_t respValue[4];
   1393            st_Mci_CmdInfo cmdIf;
   1394            int32_t retval = MCI_FUNC_FAILED;
   \   00000004   0xF05F 0x37FF      MOVS     R7,#-1
   1395            
   1396            if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
   1397                (MCI_CardType == MCI_SDSC_V2_CARD) ||
   1398                  (MCI_CardType == MCI_SDHC_SDXC_CARD)) 
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   0000000C   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00B             BEQ.N    ??MCI_Cmd_SendACMD_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000018   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD005             BEQ.N    ??MCI_Cmd_SendACMD_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000024   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xD104             BNE.N    ??MCI_Cmd_SendACMD_1
   1399            {
   1400              CmdArgument = CardRCA;    /* Use the address from SET_RELATIVE_ADDR cmd */
   \                     ??MCI_Cmd_SendACMD_0:
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable39
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0005             MOVS     R5,R0
   \   00000034   0xE001             B.N      ??MCI_Cmd_SendACMD_2
   1401            }
   1402            else            /* if MMC or unknown card type, use 0x0. */
   1403            {
   1404              CmdArgument = 0x00000000;
   \                     ??MCI_Cmd_SendACMD_1:
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0005             MOVS     R5,R0
   1405            }
   1406            
   1407            retryCount = 20;
   \                     ??MCI_Cmd_SendACMD_2:
   \   0000003A   0x2014             MOVS     R0,#+20
   \   0000003C   0x0004             MOVS     R4,R0
   1408            
   1409            cmdIf.CmdIndex = CMD55_APP_CMD;
   \   0000003E   0x2037             MOVS     R0,#+55
   \   00000040   0x9001             STR      R0,[SP, #+4]
   1410            cmdIf.Argument = CmdArgument;
   \   00000042   0x9502             STR      R5,[SP, #+8]
   1411            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x9003             STR      R0,[SP, #+12]
   1412            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x9004             STR      R0,[SP, #+16]
   1413            cmdIf.CmdResp = (uint32_t *)&respValue[0];
   \   0000004C   0xA806             ADD      R0,SP,#+24
   \   0000004E   0x9005             STR      R0,[SP, #+20]
   1414            while ( retryCount > 0 )
   \                     ??MCI_Cmd_SendACMD_3:
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD01D             BEQ.N    ??MCI_Cmd_SendACMD_4
   1415            {
   1416              respStatus = MCI_CmdResp(&cmdIf);
   \   00000054   0xA801             ADD      R0,SP,#+4
   \   00000056   0x.... 0x....      BL       MCI_CmdResp
   \   0000005A   0x0006             MOVS     R6,R0
   1417              
   1418              if(respStatus != 0)
   \   0000005C   0x2E00             CMP      R6,#+0
   \   0000005E   0xD003             BEQ.N    ??MCI_Cmd_SendACMD_5
   1419              {
   1420                retval = MCI_FUNC_FAILED;
   \   00000060   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000064   0x0007             MOVS     R7,R0
   \   00000066   0xE008             B.N      ??MCI_Cmd_SendACMD_6
   1421              }
   1422              else if (respValue[0] & CARD_STATUS_ACMD_ENABLE)
   \                     ??MCI_Cmd_SendACMD_5:
   \   00000068   0x9806             LDR      R0,[SP, #+24]
   \   0000006A   0x0680             LSLS     R0,R0,#+26
   \   0000006C   0xD502             BPL.N    ??MCI_Cmd_SendACMD_7
   1423              {
   1424                retval = MCI_FUNC_OK;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x0007             MOVS     R7,R0
   1425                break;
   \   00000072   0xE00D             B.N      ??MCI_Cmd_SendACMD_4
   1426              }
   1427              else
   1428              {
   1429                retval = MCI_FUNC_NOT_READY;
   \                     ??MCI_Cmd_SendACMD_7:
   \   00000074   0xF07F 0x0004      MVNS     R0,#+4
   \   00000078   0x0007             MOVS     R7,R0
   1430              }
   1431              
   1432              for ( i = 0; i < 0x20; i++ );
   \                     ??MCI_Cmd_SendACMD_6:
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Cmd_SendACMD_8:
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x2820             CMP      R0,#+32
   \   00000082   0xD203             BCS.N    ??MCI_Cmd_SendACMD_9
   \   00000084   0x9800             LDR      R0,[SP, #+0]
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0xE7F8             B.N      ??MCI_Cmd_SendACMD_8
   1433              
   1434              retryCount--;
   \                     ??MCI_Cmd_SendACMD_9:
   \   0000008C   0x1E64             SUBS     R4,R4,#+1
   \   0000008E   0xE7DF             B.N      ??MCI_Cmd_SendACMD_3
   1435            }
   1436            
   1437            return retval;
   \                     ??MCI_Cmd_SendACMD_4:
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0xB00B             ADD      SP,SP,#+44
   \   00000094   0xBDF0             POP      {R4-R7,PC}       ;; return
   1438          }
   1439          
   1440          
   1441          /************************************************************************//**
   1442          * @brief        Send ACMD41 (SEND_APP_OP_COND) to Host Capacity Support (HCS)
   1443          *               information and asks the accessed card to send its operating
   1444          *               condition (OCR).
   1445          *
   1446          * @param[in]    hcsVal input the Host Capacity Support
   1447          *
   1448          * @return       MCI_FUNC_OK if all success
   1449          *
   1450          * @note         If SEND_APP_OP_COND is timeout, the card in the slot is not MMC
   1451          *                type, try this combination to see if we can communicate with
   1452          *                a SD type.
   1453          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1454          int32_t MCI_Acmd_SendOpCond(uint8_t hcsVal)
   1455          {
   \                     MCI_Acmd_SendOpCond:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0004             MOVS     R4,R0
   1456            volatile uint32_t i;
   1457            uint32_t retryCount;
   1458            uint32_t respStatus, argument;
   1459            uint32_t respValue[4];
   1460            st_Mci_CmdInfo cmdIf;
   1461            
   1462            int32_t retval = MCI_FUNC_FAILED;
   \   00000008   0xF05F 0x38FF      MOVS     R8,#-1
   1463            
   1464            argument = OCR_INDEX | (hcsVal << MCI_ACMD41_HCS_POS);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable38  ;; 0xc0ff8080
   \   00000010   0x0007             MOVS     R7,R0
   1465            
   1466            /* timeout on SEND_OP_COND command on MMC, now, try SEND_APP_OP_COND
   1467            command to SD */
   1468            retryCount = 0x2000;            /* reset retry counter */
   \   00000012   0xF44F 0x5000      MOV      R0,#+8192
   \   00000016   0x0005             MOVS     R5,R0
   1469            
   1470            cmdIf.CmdIndex = ACMD41_SEND_APP_OP_COND;
   \   00000018   0x2029             MOVS     R0,#+41
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   1471            cmdIf.Argument = argument;
   \   0000001C   0x9702             STR      R7,[SP, #+8]
   1472            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x9003             STR      R0,[SP, #+12]
   1473            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x9004             STR      R0,[SP, #+16]
   1474            cmdIf.CmdResp = (uint32_t *)&respValue[0];
   \   00000026   0xA806             ADD      R0,SP,#+24
   \   00000028   0x9005             STR      R0,[SP, #+20]
   1475            
   1476            /* Clear Open Drain output control for SD */
   1477            MCI_SetOutputMode(MCI_OUTPUT_MODE_PUSHPULL);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       MCI_SetOutputMode
   1478            
   1479            /* The host repeatedly issues ACMD41 for at least 1 second or */
   1480            /* until the busy bit are set to 1 */
   1481            while ( retryCount > 0 )
   \                     ??MCI_Acmd_SendOpCond_0:
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD02E             BEQ.N    ??MCI_Acmd_SendOpCond_1
   1482            {
   1483              if ((retval = MCI_Cmd_SendACMD()) == MCI_FUNC_OK)
   \   00000034   0x.... 0x....      BL       MCI_Cmd_SendACMD
   \   00000038   0x4680             MOV      R8,R0
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD11E             BNE.N    ??MCI_Acmd_SendOpCond_2
   1484              {   
   1485                respStatus = MCI_CmdResp(&cmdIf);
   \   0000003E   0xA801             ADD      R0,SP,#+4
   \   00000040   0x.... 0x....      BL       MCI_CmdResp
   \   00000044   0x0006             MOVS     R6,R0
   1486                
   1487                if(respStatus & MCI_CMD_TIMEOUT)
   \   00000046   0x0770             LSLS     R0,R6,#+29
   \   00000048   0xD503             BPL.N    ??MCI_Acmd_SendOpCond_3
   1488                {
   1489                  retval = MCI_FUNC_TIMEOUT;
   \   0000004A   0xF07F 0x0002      MVNS     R0,#+2
   \   0000004E   0x4680             MOV      R8,R0
   \   00000050   0xE011             B.N      ??MCI_Acmd_SendOpCond_4
   1490                }
   1491                else if (!(respValue[0] & 0x80000000))
   \                     ??MCI_Acmd_SendOpCond_3:
   \   00000052   0x9806             LDR      R0,[SP, #+24]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD403             BMI.N    ??MCI_Acmd_SendOpCond_5
   1492                {
   1493                  retval = MCI_FUNC_BUS_NOT_IDLE;
   \   00000058   0xF07F 0x0002      MVNS     R0,#+2
   \   0000005C   0x4680             MOV      R8,R0
   \   0000005E   0xE00A             B.N      ??MCI_Acmd_SendOpCond_4
   1494                }
   1495                else
   1496                {
   1497                  CCS = (respValue[0]&(1<<30)) ? 1:0;
   \                     ??MCI_Acmd_SendOpCond_5:
   \   00000060   0x9806             LDR      R0,[SP, #+24]
   \   00000062   0xF3C0 0x7080      UBFX     R0,R0,#+30,#+1
   \   00000066   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable39_1
   \   0000006E   0x7008             STRB     R0,[R1, #+0]
   1498                  retval = MCI_FUNC_OK;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x4680             MOV      R8,R0
   1499                  break;
   \   00000074   0xE00D             B.N      ??MCI_Acmd_SendOpCond_1
   1500                }
   1501              }
   1502              else	/* The command isn't accepted by the card.*/
   1503              {
   1504                return retval;
   1505              }
   1506              
   1507              for ( i = 0; i < 0x20; i++ );
   \                     ??MCI_Acmd_SendOpCond_4:
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x9000             STR      R0,[SP, #+0]
   \   0000007A   0xE001             B.N      ??MCI_Acmd_SendOpCond_6
   \                     ??MCI_Acmd_SendOpCond_2:
   \   0000007C   0x4640             MOV      R0,R8
   \   0000007E   0xE009             B.N      ??MCI_Acmd_SendOpCond_7
   \                     ??MCI_Acmd_SendOpCond_6:
   \   00000080   0x9800             LDR      R0,[SP, #+0]
   \   00000082   0x2820             CMP      R0,#+32
   \   00000084   0xD203             BCS.N    ??MCI_Acmd_SendOpCond_8
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0xE7F8             B.N      ??MCI_Acmd_SendOpCond_6
   1508              
   1509              retryCount--;
   \                     ??MCI_Acmd_SendOpCond_8:
   \   0000008E   0x1E6D             SUBS     R5,R5,#+1
   \   00000090   0xE7CE             B.N      ??MCI_Acmd_SendOpCond_0
   1510            }
   1511            
   1512            return retval;
   \                     ??MCI_Acmd_SendOpCond_1:
   \   00000092   0x4640             MOV      R0,R8
   \                     ??MCI_Acmd_SendOpCond_7:
   \   00000094   0xB00A             ADD      SP,SP,#+40
   \   00000096   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1513          }
   1514          
   1515          /************************************************************************//**
   1516          * @brief         Do initialization for the card in the slot
   1517          *
   1518          * @details        Try CMD1 first for MMC, if it's timeout, try CMD55
   1519          *                and CMD41 for SD, if both failed, initialization faliure,
   1520          *                bailout with unknown card type. Otherwise, return the
   1521          *                card type, either MMC or SD. <<<KHOA_110708: checking>>>
   1522          *
   1523          *                This is followed Figure 4-2: Card Initialization and
   1524          *                Identification Flow (SD mode) in Physical Layer Simplified
   1525          *                Specification Version 2.00 document        
   1526          *
   1527          * @param         None
   1528          *
   1529          * @return        MCI_FUNC_OK if success
   1530          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1531          int32_t MCI_CardInit( void )
   1532          {
   \                     MCI_CardInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1533            volatile uint32_t i;
   1534            int32_t retval = MCI_FUNC_FAILED;
   \   00000004   0xF05F 0x34FF      MOVS     R4,#-1
   1535            
   1536            MCI_CardType = MCI_CARD_UNKNOWN;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   0000000C   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000010   0x7001             STRB     R1,[R0, #+0]
   1537            
   1538            if (MCI_CardReset() != MCI_FUNC_OK)
   \   00000012   0x.... 0x....      BL       MCI_CardReset
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD002             BEQ.N    ??MCI_CardInit_0
   1539            {
   1540              return MCI_FUNC_FAILED;
   \   0000001A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000001E   0xE052             B.N      ??MCI_CardInit_1
   1541            }
   1542            
   1543            /* Clear Open Drain output control for SD */
   1544            MCI_SetOutputMode(MCI_OUTPUT_MODE_PUSHPULL);
   \                     ??MCI_CardInit_0:
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       MCI_SetOutputMode
   1545            
   1546            for ( i = 0; i < 0x3000; i++ );
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_CardInit_2:
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0xF5B0 0x5F40      CMP      R0,#+12288
   \   00000030   0xD203             BCS.N    ??MCI_CardInit_3
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0xE7F7             B.N      ??MCI_CardInit_2
   1547            
   1548            retval = MCI_Cmd_SendIfCond();
   \                     ??MCI_CardInit_3:
   \   0000003A   0x.... 0x....      BL       MCI_Cmd_SendIfCond
   \   0000003E   0x0004             MOVS     R4,R0
   1549            
   1550            if(retval == MCI_FUNC_BAD_PARAMETERS)
   \   00000040   0xF114 0x0F02      CMN      R4,#+2
   \   00000044   0xD101             BNE.N    ??MCI_CardInit_4
   1551            {
   1552              //Unknow card is unusable
   1553              return retval;
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xE03D             B.N      ??MCI_CardInit_1
   1554            }
   1555            
   1556            if(retval == MCI_FUNC_OK) /* Ver2.00 or later*/
   \                     ??MCI_CardInit_4:
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD114             BNE.N    ??MCI_CardInit_5
   1557            {
   1558              //Check in case of High Capacity Supporting Host
   1559              if ((retval = MCI_Acmd_SendOpCond(1)) == MCI_FUNC_OK)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x.... 0x....      BL       MCI_Acmd_SendOpCond
   \   00000054   0x0004             MOVS     R4,R0
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD10E             BNE.N    ??MCI_CardInit_5
   1560              {
   1561                MCI_CardType = MCI_SDSC_V2_CARD;//SDSC
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   0000005E   0x2102             MOVS     R1,#+2
   \   00000060   0x7001             STRB     R1,[R0, #+0]
   1562                
   1563                if(CCS )
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable39_1
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD003             BEQ.N    ??MCI_CardInit_6
   1564                {
   1565                  MCI_CardType = MCI_SDHC_SDXC_CARD;//SDHC or SDXC 
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000070   0x2103             MOVS     R1,#+3
   \   00000072   0x7001             STRB     R1,[R0, #+0]
   1566                }
   1567                
   1568                return MCI_FUNC_OK;    /* Found the card, it's a hD */
   \                     ??MCI_CardInit_6:
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE026             B.N      ??MCI_CardInit_1
   1569              }
   1570            }
   1571            
   1572            if(retval != MCI_FUNC_OK) /* voltage mismatch (ver2.00)or ver1.X SD Card or not SD Card*/
   \                     ??MCI_CardInit_5:
   \   00000078   0x2C00             CMP      R4,#+0
   \   0000007A   0xD00B             BEQ.N    ??MCI_CardInit_7
   1573            {
   1574              
   1575              //Check in case of Standard Capacity Supporting Host
   1576              if ((retval = MCI_Acmd_SendOpCond(0)) == MCI_FUNC_OK)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      BL       MCI_Acmd_SendOpCond
   \   00000082   0x0004             MOVS     R4,R0
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD105             BNE.N    ??MCI_CardInit_7
   1577              {
   1578                MCI_CardType = MCI_SDSC_V1_CARD;//Support Standard Capacity only
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x7001             STRB     R1,[R0, #+0]
   1579                
   1580                return MCI_FUNC_OK;    /* Found the card, it's a SD */
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE018             B.N      ??MCI_CardInit_1
   1581              }
   1582            }
   1583            
   1584            if(retval != MCI_FUNC_OK)
   \                     ??MCI_CardInit_7:
   \   00000094   0x2C00             CMP      R4,#+0
   \   00000096   0xD015             BEQ.N    ??MCI_CardInit_8
   1585            {
   1586              /* Set Open Drain output control for MMC */
   1587              MCI_SetOutputMode(MCI_OUTPUT_MODE_OPENDRAIN);
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x.... 0x....      BL       MCI_SetOutputMode
   1588              
   1589              for ( i = 0; i < 0x3000; i++ );
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_CardInit_9:
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0xF5B0 0x5F40      CMP      R0,#+12288
   \   000000A8   0xD203             BCS.N    ??MCI_CardInit_10
   \   000000AA   0x9800             LDR      R0,[SP, #+0]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x9000             STR      R0,[SP, #+0]
   \   000000B0   0xE7F7             B.N      ??MCI_CardInit_9
   1590              
   1591              /* Try CMD1 first for MMC, if it's timeout, try CMD55 and CMD41 for SD,
   1592              if both failed, initialization faIlure, bailout. */
   1593              if (MCI_Cmd_SendOpCond() == MCI_FUNC_OK)
   \                     ??MCI_CardInit_10:
   \   000000B2   0x.... 0x....      BL       MCI_Cmd_SendOpCond
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD104             BNE.N    ??MCI_CardInit_8
   1594              {
   1595                MCI_CardType = MCI_MMC_CARD;
   \   000000BA   0x....             LDR.N    R0,??DataTable27_3
   \   000000BC   0x2101             MOVS     R1,#+1
   \   000000BE   0x7001             STRB     R1,[R0, #+0]
   1596                
   1597                return MCI_FUNC_OK;    /* Found the card, it's a MMC */
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE000             B.N      ??MCI_CardInit_1
   1598              }
   1599            }
   1600            
   1601            /* tried both MMC and SD card, give up */
   1602            return MCI_FUNC_OK;
   \                     ??MCI_CardInit_8:
   \   000000C4   0x2000             MOVS     R0,#+0
   \                     ??MCI_CardInit_1:
   \   000000C6   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1603          }
   1604          
   1605          
   1606          /************************************************************************//**
   1607          * @brief         Get the type of card that is currently used in the slot
   1608          *
   1609          * @param         None
   1610          *
   1611          * @return        Card Type: MMC Card or SD card
   1612          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1613          en_Mci_CardType MCI_GetCardType(void)
   1614          {
   1615            return MCI_CardType;
   \                     MCI_GetCardType:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39_2
   \   00000004   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000008   0x4770             BX       LR               ;; return
   1616          }
   1617          
   1618          
   1619          /************************************************************************//**
   1620          * @brief         Get the all the Identifier (CID) of the card by sending the 
   1621          *                CMD2 (ALL_SEND_CID) command. Then parse 4-byte data obtained
   1622          *                from the card by the CID meaning.    
   1623          *
   1624          * @param[out]    cidValue the CID Result after parsing the data from the card
   1625          *
   1626          * @return        MCI_FUNC_OK if all success
   1627          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1628          int32_t MCI_GetCID(st_Mci_CardId* cidValue)
   1629          {
   \                     MCI_GetCID:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
   1630            volatile uint32_t i;
   1631            uint32_t retryCount;
   1632            uint32_t respStatus;
   1633            uint32_t respValue[4];
   1634            st_Mci_CmdInfo cmdIf;
   1635            
   1636            /* This command is normally after CMD1(MMC) or ACMD41(SD). */
   1637            retryCount = 0x200;// 0x20;            /* reset retry counter */
   \   00000006   0xF44F 0x7000      MOV      R0,#+512
   \   0000000A   0x0005             MOVS     R5,R0
   1638            
   1639            cmdIf.CmdIndex = CMD2_ALL_SEND_CID;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x9005             STR      R0,[SP, #+20]
   1640            cmdIf.Argument = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9006             STR      R0,[SP, #+24]
   1641            cmdIf.ExpectResp = EXPECT_LONG_RESP;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x9007             STR      R0,[SP, #+28]
   1642            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x9008             STR      R0,[SP, #+32]
   1643            cmdIf.CmdResp = (uint32_t *)&respValue[0];
   \   0000001C   0xA801             ADD      R0,SP,#+4
   \   0000001E   0x9009             STR      R0,[SP, #+36]
   1644            while ( retryCount > 0 )
   \                     ??MCI_GetCID_0:
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD03A             BEQ.N    ??MCI_GetCID_1
   1645            {
   1646              respStatus = MCI_CmdResp(&cmdIf);
   \   00000024   0xA805             ADD      R0,SP,#+20
   \   00000026   0x.... 0x....      BL       MCI_CmdResp
   \   0000002A   0x0006             MOVS     R6,R0
   1647              
   1648              /* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
   1649              //if ((!(respStatus & MCI_CMD_TIMEOUT)) && (!(respStatus & MCI_CMD_CRC_FAIL)))
   1650              if (!(respStatus & MCI_CMD_TIMEOUT))
   \   0000002C   0x0770             LSLS     R0,R6,#+29
   \   0000002E   0xD429             BMI.N    ??MCI_GetCID_2
   1651              {
   1652                // Parsing the data retrieved
   1653                if(cidValue != NULL)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD025             BEQ.N    ??MCI_GetCID_3
   1654                {
   1655                  cidValue->MID = (respValue[0] >> MCI_CID_MANUFACTURER_ID_WPOS) & MCI_CID_MANUFACTURER_ID_WBMASK;
   \   00000034   0x9801             LDR      R0,[SP, #+4]
   \   00000036   0x0E00             LSRS     R0,R0,#+24
   \   00000038   0x7020             STRB     R0,[R4, #+0]
   1656                  
   1657                  cidValue->OID = (respValue[0] >> MCI_CID_OEMAPPLICATION_ID_WPOS) & MCI_CID_OEMAPPLICATION_ID_WBMASK;
   \   0000003A   0x9801             LDR      R0,[SP, #+4]
   \   0000003C   0x0A00             LSRS     R0,R0,#+8
   \   0000003E   0x8060             STRH     R0,[R4, #+2]
   1658                  
   1659                  cidValue->PNM_H = (respValue[0] >> MCI_CID_PRODUCTNAME_ID_H_WPOS) & MCI_CID_PRODUCTNAME_ID_H_WBMASK;
   \   00000040   0x9801             LDR      R0,[SP, #+4]
   \   00000042   0x7120             STRB     R0,[R4, #+4]
   1660                  
   1661                  cidValue->PNM_L = (respValue[1] >> MCI_CID_PRODUCTNAME_ID_L_WPOS) & MCI_CID_PRODUCTNAME_ID_L_WBMASK;
   \   00000044   0x9802             LDR      R0,[SP, #+8]
   \   00000046   0x60A0             STR      R0,[R4, #+8]
   1662                  
   1663                  cidValue->PRV = (respValue[2] >> MCI_CID_PRODUCTREVISION_ID_WPOS) & MCI_CID_PRODUCTREVISION_ID_WBMASK;
   \   00000048   0x9803             LDR      R0,[SP, #+12]
   \   0000004A   0x0E00             LSRS     R0,R0,#+24
   \   0000004C   0x7320             STRB     R0,[R4, #+12]
   1664                  
   1665                  cidValue->PSN = (((respValue[2] >> MCI_CID_PRODUCTSERIALNUM_ID_H_WPOS) & MCI_CID_PRODUCTSERIALNUM_ID_H_WBMASK) << 8)
   1666                    | ((respValue[3] >> MCI_CID_PRODUCTSERIALNUM_ID_L_WPOS) & MCI_CID_PRODUCTSERIALNUM_ID_L_WBMASK);
   \   0000004E   0x9803             LDR      R0,[SP, #+12]
   \   00000050   0x9904             LDR      R1,[SP, #+16]
   \   00000052   0x0E09             LSRS     R1,R1,#+24
   \   00000054   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000058   0x6120             STR      R0,[R4, #+16]
   1667                  
   1668                  cidValue->reserved = (respValue[3] >> MCI_CID_RESERVED_ID_WPOS) & MCI_CID_RESERVED_ID_WBMASK;
   \   0000005A   0x9804             LDR      R0,[SP, #+16]
   \   0000005C   0x0D00             LSRS     R0,R0,#+20
   \   0000005E   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000062   0x7520             STRB     R0,[R4, #+20]
   1669                  
   1670                  cidValue->MDT = (respValue[3] >> MCI_CID_MANUFACTURINGDATE_ID_WPOS) & MCI_CID_MANUFACTURINGDATE_ID_WBMASK;
   \   00000064   0x9804             LDR      R0,[SP, #+16]
   \   00000066   0x0A00             LSRS     R0,R0,#+8
   \   00000068   0x0500             LSLS     R0,R0,#+20       ;; ZeroExtS R0,R0,#+20,#+20
   \   0000006A   0x0D00             LSRS     R0,R0,#+20
   \   0000006C   0x82E0             STRH     R0,[R4, #+22]
   1671                  
   1672                  cidValue->CRC = (respValue[3] >> MCI_CID_CHECKSUM_ID_WPOS) & MCI_CID_CHECKSUM_ID_WBMASK;
   \   0000006E   0x9804             LDR      R0,[SP, #+16]
   \   00000070   0xF3C0 0x0046      UBFX     R0,R0,#+1,#+7
   \   00000074   0x7620             STRB     R0,[R4, #+24]
   1673                  
   1674                  cidValue->unused = (respValue[3] >> MCI_CID_UNUSED_ID_WPOS) & MCI_CID_UNUSED_ID_WBMASK;
   \   00000076   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   0000007A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000007E   0x7660             STRB     R0,[R4, #+25]
   1675                  
   1676                }
   1677                
   1678                return  MCI_FUNC_OK;    /* response is back and correct. */
   \                     ??MCI_GetCID_3:
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE00C             B.N      ??MCI_GetCID_4
   1679              }
   1680              
   1681              
   1682              for ( i = 0; i < 0x20; i++ );
   \                     ??MCI_GetCID_2:
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_GetCID_5:
   \   00000088   0x9800             LDR      R0,[SP, #+0]
   \   0000008A   0x2820             CMP      R0,#+32
   \   0000008C   0xD203             BCS.N    ??MCI_GetCID_6
   \   0000008E   0x9800             LDR      R0,[SP, #+0]
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0xE7F8             B.N      ??MCI_GetCID_5
   1683              
   1684              retryCount--;
   \                     ??MCI_GetCID_6:
   \   00000096   0x1E6D             SUBS     R5,R5,#+1
   \   00000098   0xE7C2             B.N      ??MCI_GetCID_0
   1685            }
   1686            
   1687            return MCI_FUNC_TIMEOUT;
   \                     ??MCI_GetCID_1:
   \   0000009A   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??MCI_GetCID_4:
   \   0000009E   0xB00A             ADD      SP,SP,#+40
   \   000000A0   0xBD70             POP      {R4-R6,PC}       ;; return
   1688          }
   1689          
   1690          
   1691          /************************************************************************//**
   1692          * @brief        Set the address for the card in the slot by sending CMD3 
   1693          *                (SET_RELATIVE_ADDR) command. To get the address of the card
   1694          *                currently in used, needs to call MCI_GetCardAddress()
   1695          *
   1696          * @param        None
   1697          *
   1698          * @return       MCI_FUNC_OK if all success
   1699          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1700          int32_t MCI_SetCardAddress( void )
   1701          {
   \                     MCI_SetCardAddress:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   1702            volatile uint32_t i;
   1703            uint32_t retryCount;
   1704            uint32_t respStatus;
   1705            uint32_t respValue;
   1706            uint32_t CmdArgument;
   1707            st_Mci_CmdInfo cmdIf;
   1708            int32_t retval = MCI_FUNC_FAILED;
   \   00000004   0xF05F 0x37FF      MOVS     R7,#-1
   1709            
   1710            /* If it's a SD card, SET_RELATIVE_ADDR is to get the address
   1711            from the card and use this value in RCA, if it's a MMC, set default
   1712            RCA addr. 0x00010000. */
   1713            if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
   1714                (MCI_CardType == MCI_SDSC_V2_CARD) ||
   1715                  (MCI_CardType == MCI_SDHC_SDXC_CARD))
   \   00000008   0x....             LDR.N    R0,??DataTable27_3
   \   0000000A   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD009             BEQ.N    ??MCI_SetCardAddress_0
   \   00000012   0x....             LDR.N    R0,??DataTable27_3
   \   00000014   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD004             BEQ.N    ??MCI_SetCardAddress_0
   \   0000001C   0x....             LDR.N    R0,??DataTable27_3
   \   0000001E   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000022   0x2803             CMP      R0,#+3
   \   00000024   0xD102             BNE.N    ??MCI_SetCardAddress_1
   1716            {
   1717              CmdArgument = 0;
   \                     ??MCI_SetCardAddress_0:
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0xE002             B.N      ??MCI_SetCardAddress_2
   1718            }
   1719            else            /* If it's unknown or MMC_CARD, fix the RCA address */
   1720            {
   1721              CmdArgument = 0x00010000;
   \                     ??MCI_SetCardAddress_1:
   \   0000002C   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000030   0x0006             MOVS     R6,R0
   1722            }
   1723            
   1724            retryCount = 0x20;            /* reset retry counter */
   \                     ??MCI_SetCardAddress_2:
   \   00000032   0x2020             MOVS     R0,#+32
   \   00000034   0x0004             MOVS     R4,R0
   1725            cmdIf.CmdIndex = CMD3_SET_RELATIVE_ADDR;
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0x9002             STR      R0,[SP, #+8]
   1726            cmdIf.Argument = CmdArgument;
   \   0000003A   0x9603             STR      R6,[SP, #+12]
   1727            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x9004             STR      R0,[SP, #+16]
   1728            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x9005             STR      R0,[SP, #+20]
   1729            cmdIf.CmdResp = &respValue;
   \   00000044   0xA800             ADD      R0,SP,#+0
   \   00000046   0x9006             STR      R0,[SP, #+24]
   1730            while ( retryCount > 0 )
   \                     ??MCI_SetCardAddress_3:
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD035             BEQ.N    ??MCI_SetCardAddress_4
   1731            {
   1732              /* Send CMD3 command repeatedly until the response is back correctly */
   1733              respStatus = MCI_CmdResp(&cmdIf);
   \   0000004C   0xA802             ADD      R0,SP,#+8
   \   0000004E   0x.... 0x....      BL       MCI_CmdResp
   \   00000052   0x0005             MOVS     R5,R0
   1734              
   1735              if(respStatus & MCI_CMD_TIMEOUT)
   \   00000054   0x0768             LSLS     R0,R5,#+29
   \   00000056   0xD503             BPL.N    ??MCI_SetCardAddress_5
   1736              {
   1737                retval = MCI_FUNC_TIMEOUT;
   \   00000058   0xF07F 0x0002      MVNS     R0,#+2
   \   0000005C   0x0007             MOVS     R7,R0
   \   0000005E   0xE020             B.N      ??MCI_SetCardAddress_6
   1738              }
   1739              else if(!((respValue >> RCA_RES_CARD_STATUS_POS)& CARD_STATUS_READY_FOR_DATA))
   \                     ??MCI_SetCardAddress_5:
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0x05C0             LSLS     R0,R0,#+23
   \   00000064   0xD403             BMI.N    ??MCI_SetCardAddress_7
   1740              {
   1741                retval = MCI_FUNC_NOT_READY;
   \   00000066   0xF07F 0x0004      MVNS     R0,#+4
   \   0000006A   0x0007             MOVS     R7,R0
   \   0000006C   0xE019             B.N      ??MCI_SetCardAddress_6
   1742              }
   1743              else if((CARDSTATEOF(respValue) != MCI_CARDSTATE_IDENDTIFIED))
   \                     ??MCI_SetCardAddress_7:
   \   0000006E   0x9800             LDR      R0,[SP, #+0]
   \   00000070   0xF3C0 0x2043      UBFX     R0,R0,#+9,#+4
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xD003             BEQ.N    ??MCI_SetCardAddress_8
   1744              {
   1745                retval = MCI_FUNC_ERR_STATE;
   \   00000078   0xF07F 0x0003      MVNS     R0,#+3
   \   0000007C   0x0007             MOVS     R7,R0
   \   0000007E   0xE010             B.N      ??MCI_SetCardAddress_6
   1746              }
   1747              else
   1748              {
   1749                CardRCA = (respValue >> RCA_RES_NEW_PUBLISHED_RCA_POS) & RCA_RES_NEW_PUBLISHED_RCA_MASK;    /* Save the RCA value from SD card */
   \                     ??MCI_SetCardAddress_8:
   \   00000080   0x9800             LDR      R0,[SP, #+0]
   \   00000082   0x0C00             LSRS     R0,R0,#+16
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable39
   \   00000088   0x6008             STR      R0,[R1, #+0]
   1750                
   1751                CardRCA <<= RCA_ARGUMENT_POS;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable39
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x0400             LSLS     R0,R0,#+16
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable39
   \   00000096   0x6008             STR      R0,[R1, #+0]
   1752                
   1753                MCI_SetOutputMode(MCI_OUTPUT_MODE_PUSHPULL);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x.... 0x....      BL       MCI_SetOutputMode
   1754                
   1755                return (MCI_FUNC_OK);    /* response is back and correct. */
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xE00B             B.N      ??MCI_SetCardAddress_9
   1756              }
   1757              
   1758              for ( i = 0; i < 0x20; i++ );
   \                     ??MCI_SetCardAddress_6:
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x9001             STR      R0,[SP, #+4]
   \                     ??MCI_SetCardAddress_10:
   \   000000A6   0x9801             LDR      R0,[SP, #+4]
   \   000000A8   0x2820             CMP      R0,#+32
   \   000000AA   0xD203             BCS.N    ??MCI_SetCardAddress_11
   \   000000AC   0x9801             LDR      R0,[SP, #+4]
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0x9001             STR      R0,[SP, #+4]
   \   000000B2   0xE7F8             B.N      ??MCI_SetCardAddress_10
   1759              
   1760              retryCount--;
   \                     ??MCI_SetCardAddress_11:
   \   000000B4   0x1E64             SUBS     R4,R4,#+1
   \   000000B6   0xE7C7             B.N      ??MCI_SetCardAddress_3
   1761            }
   1762            
   1763            return retval;
   \                     ??MCI_SetCardAddress_4:
   \   000000B8   0x0038             MOVS     R0,R7
   \                     ??MCI_SetCardAddress_9:
   \   000000BA   0xB007             ADD      SP,SP,#+28
   \   000000BC   0xBDF0             POP      {R4-R7,PC}       ;; return
   1764          }
   1765          
   1766          
   1767          /************************************************************************//**
   1768          * @brief        Get the address for the card in the slot
   1769          *
   1770          * @param        None
   1771          *
   1772          * @return       MCI_FUNC_OK if all success
   1773          *
   1774          * @note        This function must be called after MCI_SetCardAddress() executing
   1775          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1776          uint32_t MCI_GetCardAddress(void)
   1777          {
   1778            return CardRCA;
   \                     MCI_GetCardAddress:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   1779          }
   1780          
   1781          
   1782          /************************************************************************//**
   1783          * @brief       Get the Card-Specific Data of in-slot card by sending CMD9
   1784          *                (SEND_CSD) command
   1785          *
   1786          * @param[out]  csdVal a buffer stored the value of CSD obtained from the card
   1787          *
   1788          * @return      MCI_FUNC_OK if all success
   1789          *
   1790          * @note        CMD9 (SEND_CSD) command should be sent only at standby state 
   1791          *                (STBY) after CMD3
   1792          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1793          int32_t MCI_GetCSD(uint32_t* csdVal)
   1794          {
   \                     MCI_GetCSD:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   1795            volatile uint32_t i;
   1796            uint32_t retryCount;
   1797            uint32_t respStatus;
   1798            uint32_t respValue[4];
   1799            uint32_t CmdArgument;
   1800            st_Mci_CmdInfo cmdIf;
   1801            
   1802            if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
   1803                (MCI_CardType == MCI_SDSC_V2_CARD) ||
   1804                  (MCI_CardType == MCI_SDHC_SDXC_CARD))
   \   00000006   0x....             LDR.N    R0,??DataTable27_3
   \   00000008   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD009             BEQ.N    ??MCI_GetCSD_0
   \   00000010   0x....             LDR.N    R0,??DataTable27_3
   \   00000012   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD004             BEQ.N    ??MCI_GetCSD_0
   \   0000001A   0x....             LDR.N    R0,??DataTable27_3
   \   0000001C   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD104             BNE.N    ??MCI_GetCSD_1
   1805            {
   1806              CmdArgument = CardRCA;
   \                     ??MCI_GetCSD_0:
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable39
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0007             MOVS     R7,R0
   \   0000002C   0xE002             B.N      ??MCI_GetCSD_2
   1807            }
   1808            else            /* if MMC or unknown card type, use default RCA addr. */
   1809            {
   1810              CmdArgument = 0x00010000;
   \                     ??MCI_GetCSD_1:
   \   0000002E   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000032   0x0007             MOVS     R7,R0
   1811            }
   1812            
   1813            retryCount = 0x20;
   \                     ??MCI_GetCSD_2:
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0x0005             MOVS     R5,R0
   1814            cmdIf.CmdIndex = CMD9_SEND_CSD;
   \   00000038   0x2009             MOVS     R0,#+9
   \   0000003A   0x9005             STR      R0,[SP, #+20]
   1815            cmdIf.Argument = CmdArgument;
   \   0000003C   0x9706             STR      R7,[SP, #+24]
   1816            cmdIf.ExpectResp = EXPECT_LONG_RESP;
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x9007             STR      R0,[SP, #+28]
   1817            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x9008             STR      R0,[SP, #+32]
   1818            cmdIf.CmdResp = (uint32_t *)&respValue[0];
   \   00000046   0xA801             ADD      R0,SP,#+4
   \   00000048   0x9009             STR      R0,[SP, #+36]
   1819            while ( retryCount > 0 )
   \                     ??MCI_GetCSD_3:
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD024             BEQ.N    ??MCI_GetCSD_4
   1820            {
   1821              /* Check current status */
   1822              if(((MCI_CheckStatus(CARD_STATE_STBY) != MCI_FUNC_OK)))
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0x.... 0x....      BL       MCI_CheckStatus
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??MCI_GetCSD_5
   1823                return MCI_FUNC_ERR_STATE;
   \   00000058   0xF07F 0x0003      MVNS     R0,#+3
   \   0000005C   0xE01E             B.N      ??MCI_GetCSD_6
   1824              
   1825              respStatus = MCI_CmdResp(&cmdIf);
   \                     ??MCI_GetCSD_5:
   \   0000005E   0xA805             ADD      R0,SP,#+20
   \   00000060   0x.... 0x....      BL       MCI_CmdResp
   \   00000064   0x0006             MOVS     R6,R0
   1826              
   1827              if ( !respStatus )
   \   00000066   0x2E00             CMP      R6,#+0
   \   00000068   0xD10B             BNE.N    ??MCI_GetCSD_7
   1828              {
   1829                if(csdVal != NULL)
   \   0000006A   0x2C00             CMP      R4,#+0
   \   0000006C   0xD007             BEQ.N    ??MCI_GetCSD_8
   1830                {
   1831                  csdVal[0] = respValue[0];
   \   0000006E   0x9801             LDR      R0,[SP, #+4]
   \   00000070   0x6020             STR      R0,[R4, #+0]
   1832                  csdVal[1] = respValue[1];
   \   00000072   0x9802             LDR      R0,[SP, #+8]
   \   00000074   0x6060             STR      R0,[R4, #+4]
   1833                  csdVal[2] = respValue[2];
   \   00000076   0x9803             LDR      R0,[SP, #+12]
   \   00000078   0x60A0             STR      R0,[R4, #+8]
   1834                  csdVal[3] = respValue[3];
   \   0000007A   0x9804             LDR      R0,[SP, #+16]
   \   0000007C   0x60E0             STR      R0,[R4, #+12]
   1835                }
   1836                
   1837                return (MCI_FUNC_OK);
   \                     ??MCI_GetCSD_8:
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE00C             B.N      ??MCI_GetCSD_6
   1838              }
   1839              
   1840              for ( i = 0; i < 0x20; i++ );
   \                     ??MCI_GetCSD_7:
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_GetCSD_9:
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0x2820             CMP      R0,#+32
   \   0000008A   0xD203             BCS.N    ??MCI_GetCSD_10
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \   00000090   0x9000             STR      R0,[SP, #+0]
   \   00000092   0xE7F8             B.N      ??MCI_GetCSD_9
   1841              
   1842              retryCount--;
   \                     ??MCI_GetCSD_10:
   \   00000094   0x1E6D             SUBS     R5,R5,#+1
   \   00000096   0xE7D8             B.N      ??MCI_GetCSD_3
   1843            }
   1844            
   1845            return (MCI_FUNC_FAILED);
   \                     ??MCI_GetCSD_4:
   \   00000098   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??MCI_GetCSD_6:
   \   0000009C   0xB00B             ADD      SP,SP,#+44
   \   0000009E   0xBDF0             POP      {R4-R7,PC}       ;; return
   1846          }
   1847          
   1848          
   1849          /************************************************************************//**
   1850          * @brief       Select the card by the specified address. This is done by sending
   1851          *              out the CMD7 with the address argument to needed card
   1852          *
   1853          * @param       None
   1854          *
   1855          * @return      MCI_FUNC_OK if all success
   1856          *
   1857          * @note        CMD7 (SELECT_CARD) command should be sent after CMD9 ((SEND_CSD).
   1858          *                The state will be inter-changed between STBY to TRANS by this 
   1859          *                CMD7 command
   1860          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1861          int32_t MCI_Cmd_SelectCard( void )
   1862          {
   \                     MCI_Cmd_SelectCard:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   1863            volatile uint32_t i;
   1864            uint32_t retryCount;
   1865            uint32_t respStatus;
   1866            uint32_t respValue[4];
   1867            uint32_t CmdArgument;
   1868            st_Mci_CmdInfo cmdIf;
   1869            int32_t retval = MCI_FUNC_FAILED;
   \   00000004   0xF05F 0x37FF      MOVS     R7,#-1
   1870            
   1871            if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
   1872                (MCI_CardType == MCI_SDSC_V2_CARD) ||
   1873                  (MCI_CardType == MCI_SDHC_SDXC_CARD)) 
   \   00000008   0x....             LDR.N    R0,??DataTable27_3
   \   0000000A   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD009             BEQ.N    ??MCI_Cmd_SelectCard_0
   \   00000012   0x....             LDR.N    R0,??DataTable27_3
   \   00000014   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD004             BEQ.N    ??MCI_Cmd_SelectCard_0
   \   0000001C   0x....             LDR.N    R0,??DataTable27_3
   \   0000001E   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000022   0x2803             CMP      R0,#+3
   \   00000024   0xD104             BNE.N    ??MCI_Cmd_SelectCard_1
   1874            {
   1875              CmdArgument = CardRCA;
   \                     ??MCI_Cmd_SelectCard_0:
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable39
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x0006             MOVS     R6,R0
   \   0000002E   0xE002             B.N      ??MCI_Cmd_SelectCard_2
   1876            }
   1877            else            /* if MMC or unknown card type, use default RCA addr. */
   1878            {
   1879              CmdArgument = 0x00010000;
   \                     ??MCI_Cmd_SelectCard_1:
   \   00000030   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000034   0x0006             MOVS     R6,R0
   1880            }
   1881            
   1882            retryCount = 0x20;
   \                     ??MCI_Cmd_SelectCard_2:
   \   00000036   0x2020             MOVS     R0,#+32
   \   00000038   0x0004             MOVS     R4,R0
   1883            cmdIf.CmdIndex = CMD7_SELECT_CARD;
   \   0000003A   0x2007             MOVS     R0,#+7
   \   0000003C   0x9001             STR      R0,[SP, #+4]
   1884            cmdIf.Argument = CmdArgument;
   \   0000003E   0x9602             STR      R6,[SP, #+8]
   1885            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x9003             STR      R0,[SP, #+12]
   1886            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x9004             STR      R0,[SP, #+16]
   1887            cmdIf.CmdResp =  (uint32_t *)&respValue[0];
   \   00000048   0xA806             ADD      R0,SP,#+24
   \   0000004A   0x9005             STR      R0,[SP, #+20]
   1888            while ( retryCount > 0 )
   \                     ??MCI_Cmd_SelectCard_3:
   \   0000004C   0x2C00             CMP      R4,#+0
   \   0000004E   0xD050             BEQ.N    ??MCI_Cmd_SelectCard_4
   1889            {
   1890              /* Check current status */
   1891              if(((MCI_CheckStatus(CARD_STATE_STBY) != MCI_FUNC_OK)) &&
   1892                 (MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK) &&
   1893                   (MCI_CheckStatus(CARD_STATE_DATA) != MCI_FUNC_OK) &&
   1894                     (MCI_CheckStatus(CARD_STATE_PRG) != MCI_FUNC_OK) &&
   1895                       (MCI_CheckStatus(CARD_STATE_DIS) != MCI_FUNC_OK))
   \   00000050   0x2003             MOVS     R0,#+3
   \   00000052   0x.... 0x....      BL       MCI_CheckStatus
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD016             BEQ.N    ??MCI_Cmd_SelectCard_5
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0x.... 0x....      BL       MCI_CheckStatus
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD011             BEQ.N    ??MCI_Cmd_SelectCard_5
   \   00000064   0x2005             MOVS     R0,#+5
   \   00000066   0x.... 0x....      BL       MCI_CheckStatus
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD00C             BEQ.N    ??MCI_Cmd_SelectCard_5
   \   0000006E   0x2007             MOVS     R0,#+7
   \   00000070   0x.... 0x....      BL       MCI_CheckStatus
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD007             BEQ.N    ??MCI_Cmd_SelectCard_5
   \   00000078   0x2008             MOVS     R0,#+8
   \   0000007A   0x.... 0x....      BL       MCI_CheckStatus
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD002             BEQ.N    ??MCI_Cmd_SelectCard_5
   1896                return MCI_FUNC_ERR_STATE;
   \   00000082   0xF07F 0x0003      MVNS     R0,#+3
   \   00000086   0xE035             B.N      ??MCI_Cmd_SelectCard_6
   1897              
   1898              respStatus = MCI_CmdResp(&cmdIf);
   \                     ??MCI_Cmd_SelectCard_5:
   \   00000088   0xA801             ADD      R0,SP,#+4
   \   0000008A   0x.... 0x....      BL       MCI_CmdResp
   \   0000008E   0x0005             MOVS     R5,R0
   1899              
   1900              if(respStatus)
   \   00000090   0x2D00             CMP      R5,#+0
   \   00000092   0xD005             BEQ.N    ??MCI_Cmd_SelectCard_7
   1901              {
   1902                retval = MCI_FUNC_FAILED;
   \   00000094   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000098   0x0007             MOVS     R7,R0
   1903              }
   1904              else if (respValue[0] & CARD_STATUS_ERR_MASK)
   1905              {
   1906                return MCI_FUNC_BAD_PARAMETERS;
   1907              }
   1908              else
   1909              {
   1910                if(((MCI_CheckStatus(CARD_STATE_STBY) != MCI_FUNC_OK)) &&
   1911                   (MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK) &&
   1912                     (MCI_CheckStatus(CARD_STATE_PRG) != MCI_FUNC_OK) &&
   1913                       (MCI_CheckStatus(CARD_STATE_DIS) != MCI_FUNC_OK))
   1914                  return MCI_FUNC_ERR_STATE;
   1915                return MCI_FUNC_OK;
   1916              }
   1917              
   1918              for ( i = 0; i < 0x20; i++ );
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0xE01F             B.N      ??MCI_Cmd_SelectCard_8
   \                     ??MCI_Cmd_SelectCard_7:
   \   000000A0   0x9806             LDR      R0,[SP, #+24]
   \   000000A2   0x....             LDR.N    R1,??DataTable30  ;; 0xfdf88008
   \   000000A4   0x4208             TST      R0,R1
   \   000000A6   0xD002             BEQ.N    ??MCI_Cmd_SelectCard_9
   \   000000A8   0xF07F 0x0001      MVNS     R0,#+1
   \   000000AC   0xE022             B.N      ??MCI_Cmd_SelectCard_6
   \                     ??MCI_Cmd_SelectCard_9:
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0x.... 0x....      BL       MCI_CheckStatus
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD011             BEQ.N    ??MCI_Cmd_SelectCard_10
   \   000000B8   0x2004             MOVS     R0,#+4
   \   000000BA   0x.... 0x....      BL       MCI_CheckStatus
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD00C             BEQ.N    ??MCI_Cmd_SelectCard_10
   \   000000C2   0x2007             MOVS     R0,#+7
   \   000000C4   0x.... 0x....      BL       MCI_CheckStatus
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD007             BEQ.N    ??MCI_Cmd_SelectCard_10
   \   000000CC   0x2008             MOVS     R0,#+8
   \   000000CE   0x.... 0x....      BL       MCI_CheckStatus
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD002             BEQ.N    ??MCI_Cmd_SelectCard_10
   \   000000D6   0xF07F 0x0003      MVNS     R0,#+3
   \   000000DA   0xE00B             B.N      ??MCI_Cmd_SelectCard_6
   \                     ??MCI_Cmd_SelectCard_10:
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xE009             B.N      ??MCI_Cmd_SelectCard_6
   \                     ??MCI_Cmd_SelectCard_8:
   \   000000E0   0x9800             LDR      R0,[SP, #+0]
   \   000000E2   0x2820             CMP      R0,#+32
   \   000000E4   0xD203             BCS.N    ??MCI_Cmd_SelectCard_11
   \   000000E6   0x9800             LDR      R0,[SP, #+0]
   \   000000E8   0x1C40             ADDS     R0,R0,#+1
   \   000000EA   0x9000             STR      R0,[SP, #+0]
   \   000000EC   0xE7F8             B.N      ??MCI_Cmd_SelectCard_8
   1919              
   1920              retryCount--;
   \                     ??MCI_Cmd_SelectCard_11:
   \   000000EE   0x1E64             SUBS     R4,R4,#+1
   \   000000F0   0xE7AC             B.N      ??MCI_Cmd_SelectCard_3
   1921            }
   1922            
   1923            return retval;
   \                     ??MCI_Cmd_SelectCard_4:
   \   000000F2   0x0038             MOVS     R0,R7
   \                     ??MCI_Cmd_SelectCard_6:
   \   000000F4   0xB00B             ADD      SP,SP,#+44
   \   000000F6   0xBDF0             POP      {R4-R7,PC}       ;; return
   1924          }
   1925          
   1926          
   1927          /************************************************************************//**
   1928          * @brief         Get the status of the card. The return is from the card.
   1929          *                By sending CMD13 (SEND_STATUS), the status of the card
   1930          *                will be responded from card addressed
   1931          *
   1932          * @param[out]    cardStatus the status returned from the card
   1933          *
   1934          * @return        MCI_FUNC_OK if all success
   1935          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1936          int32_t MCI_GetCardStatus(int32_t* cardStatus)
   1937          {
   \                     MCI_GetCardStatus:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0004             MOVS     R4,R0
   1938            volatile uint32_t i;
   1939            uint32_t retryCount;
   1940            uint32_t respStatus;
   1941            uint32_t respValue[4];
   1942            uint32_t CmdArgument;
   1943            st_Mci_CmdInfo cmdIf;
   1944            int32_t retval = MCI_FUNC_FAILED;
   \   00000008   0xF05F 0x38FF      MOVS     R8,#-1
   1945            
   1946            if(cardStatus == NULL)
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD101             BNE.N    ??MCI_GetCardStatus_0
   1947              return MCI_FUNC_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE03F             B.N      ??MCI_GetCardStatus_1
   1948            
   1949            if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
   1950                (MCI_CardType == MCI_SDSC_V2_CARD) ||
   1951                  (MCI_CardType == MCI_SDHC_SDXC_CARD)) 
   \                     ??MCI_GetCardStatus_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable39_2
   \   00000018   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD00B             BEQ.N    ??MCI_GetCardStatus_2
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable39_2
   \   00000024   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD005             BEQ.N    ??MCI_GetCardStatus_2
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable39_2
   \   00000030   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000034   0x2803             CMP      R0,#+3
   \   00000036   0xD104             BNE.N    ??MCI_GetCardStatus_3
   1952            {
   1953              CmdArgument = CardRCA;
   \                     ??MCI_GetCardStatus_2:
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable39
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x0007             MOVS     R7,R0
   \   00000040   0xE002             B.N      ??MCI_GetCardStatus_4
   1954            }
   1955            else            /* if MMC or unknown card type, use default RCA addr. */
   1956            {
   1957              CmdArgument = 0x00010000;
   \                     ??MCI_GetCardStatus_3:
   \   00000042   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000046   0x0007             MOVS     R7,R0
   1958            }
   1959            
   1960            retryCount = 0x20;
   \                     ??MCI_GetCardStatus_4:
   \   00000048   0x2020             MOVS     R0,#+32
   \   0000004A   0x0005             MOVS     R5,R0
   1961            cmdIf.CmdIndex = CMD13_SEND_STATUS;
   \   0000004C   0x200D             MOVS     R0,#+13
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   1962            cmdIf.Argument = CmdArgument;
   \   00000050   0x9702             STR      R7,[SP, #+8]
   1963            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x9003             STR      R0,[SP, #+12]
   1964            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x9004             STR      R0,[SP, #+16]
   1965            cmdIf.CmdResp =  (uint32_t *)&respValue[0];
   \   0000005A   0xA806             ADD      R0,SP,#+24
   \   0000005C   0x9005             STR      R0,[SP, #+20]
   1966            while ( retryCount > 0 )
   \                     ??MCI_GetCardStatus_5:
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD017             BEQ.N    ??MCI_GetCardStatus_6
   1967            {
   1968              respStatus = MCI_CmdResp(&cmdIf);
   \   00000062   0xA801             ADD      R0,SP,#+4
   \   00000064   0x.... 0x....      BL       MCI_CmdResp
   \   00000068   0x0006             MOVS     R6,R0
   1969              
   1970              if(respStatus)  /* only retry if sending command failed */
   \   0000006A   0x2E00             CMP      R6,#+0
   \   0000006C   0xD006             BEQ.N    ??MCI_GetCardStatus_7
   1971              {
   1972                retval = MCI_FUNC_FAILED;
   \   0000006E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000072   0x4680             MOV      R8,R0
   1973              }
   1974              else
   1975              {
   1976                *cardStatus = respValue[0];
   1977                
   1978                return MCI_FUNC_OK;
   1979              }
   1980              
   1981              retryCount--;
   \   00000074   0x1E6D             SUBS     R5,R5,#+1
   1982              for ( i = 0; i < 0x10; i++ );
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x9000             STR      R0,[SP, #+0]
   \   0000007A   0xE003             B.N      ??MCI_GetCardStatus_8
   \                     ??MCI_GetCardStatus_7:
   \   0000007C   0x9806             LDR      R0,[SP, #+24]
   \   0000007E   0x6020             STR      R0,[R4, #+0]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE007             B.N      ??MCI_GetCardStatus_1
   \                     ??MCI_GetCardStatus_8:
   \   00000084   0x9800             LDR      R0,[SP, #+0]
   \   00000086   0x2810             CMP      R0,#+16
   \   00000088   0xD2E9             BCS.N    ??MCI_GetCardStatus_5
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0xE7F8             B.N      ??MCI_GetCardStatus_8
   1983            }
   1984            
   1985            return retval;
   \                     ??MCI_GetCardStatus_6:
   \   00000092   0x4640             MOV      R0,R8
   \                     ??MCI_GetCardStatus_1:
   \   00000094   0xB00A             ADD      SP,SP,#+40
   \   00000096   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1986          }
   1987          
   1988          /************************************************************************//**
   1989          * @brief        Set the length for the blocks in the next action on data 
   1990          *                manipulation (as read, write, erase). This function is to
   1991          *                send CMD16 (SET_BLOCK_LEN) to cards.
   1992          *
   1993          * @param[in]    blockLength the value for the length of block will be handled
   1994          *
   1995          * @return         MCI_FUNC_OK if all success
   1996          *
   1997          * @note         CMD16 command should be sent after the card is selected by CMD7 
   1998          *                (SELECT_CARD).
   1999          *  In the case of SDHC and SDXC Cards, block length set by CMD16 command doen't 
   2000          *  affect memory read and write commands. Always 512 Bytes fixed block length is 
   2001          *  used. This command is effective for LOCK_UNLOCK command..
   2002          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2003          int32_t MCI_SetBlockLen(uint32_t blockLength)
   2004          {
   \                     MCI_SetBlockLen:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   2005            volatile uint32_t i;
   2006            uint32_t retryCount;
   2007            uint32_t respStatus;
   2008            uint32_t respValue[4];
   2009            st_Mci_CmdInfo cmdIf;
   2010            int32_t retval = MCI_FUNC_FAILED;
   \   00000006   0xF05F 0x37FF      MOVS     R7,#-1
   2011            
   2012            retryCount = 0x20;
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x0005             MOVS     R5,R0
   2013            cmdIf.CmdIndex = CMD16_SET_BLOCK_LEN;
   \   0000000E   0x2010             MOVS     R0,#+16
   \   00000010   0x9001             STR      R0,[SP, #+4]
   2014            cmdIf.Argument = blockLength;
   \   00000012   0x9402             STR      R4,[SP, #+8]
   2015            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x9003             STR      R0,[SP, #+12]
   2016            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x9004             STR      R0,[SP, #+16]
   2017            cmdIf.CmdResp =  (uint32_t *)&respValue[0];
   \   0000001C   0xA806             ADD      R0,SP,#+24
   \   0000001E   0x9005             STR      R0,[SP, #+20]
   2018            while ( retryCount > 0 )
   \                     ??MCI_SetBlockLen_0:
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD027             BEQ.N    ??MCI_SetBlockLen_1
   2019            {
   2020              /* Check current status */
   2021              if((MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK) )
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x.... 0x....      BL       MCI_CheckStatus
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD002             BEQ.N    ??MCI_SetBlockLen_2
   2022                return MCI_FUNC_ERR_STATE;
   \   0000002E   0xF07F 0x0003      MVNS     R0,#+3
   \   00000032   0xE020             B.N      ??MCI_SetBlockLen_3
   2023              
   2024              respStatus = MCI_CmdResp(&cmdIf);
   \                     ??MCI_SetBlockLen_2:
   \   00000034   0xA801             ADD      R0,SP,#+4
   \   00000036   0x.... 0x....      BL       MCI_CmdResp
   \   0000003A   0x0006             MOVS     R6,R0
   2025              
   2026              if(respStatus)
   \   0000003C   0x2E00             CMP      R6,#+0
   \   0000003E   0xD005             BEQ.N    ??MCI_SetBlockLen_4
   2027              {
   2028                retval = MCI_FUNC_FAILED;
   \   00000040   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000044   0x0007             MOVS     R7,R0
   2029              }
   2030              else if (respValue[0] & CARD_STATUS_ERR_MASK)
   2031              {
   2032                return MCI_FUNC_BAD_PARAMETERS;
   2033              }
   2034              else
   2035              {
   2036                return MCI_CheckStatus(CARD_STATE_TRAN);
   2037              }
   2038              
   2039              
   2040              for ( i = 0; i < 0x20; i++ );
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0xE00A             B.N      ??MCI_SetBlockLen_5
   \                     ??MCI_SetBlockLen_4:
   \   0000004C   0x9806             LDR      R0,[SP, #+24]
   \   0000004E   0x....             LDR.N    R1,??DataTable30  ;; 0xfdf88008
   \   00000050   0x4208             TST      R0,R1
   \   00000052   0xD002             BEQ.N    ??MCI_SetBlockLen_6
   \   00000054   0xF07F 0x0001      MVNS     R0,#+1
   \   00000058   0xE00D             B.N      ??MCI_SetBlockLen_3
   \                     ??MCI_SetBlockLen_6:
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0x.... 0x....      BL       MCI_CheckStatus
   \   00000060   0xE009             B.N      ??MCI_SetBlockLen_3
   \                     ??MCI_SetBlockLen_5:
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x2820             CMP      R0,#+32
   \   00000066   0xD203             BCS.N    ??MCI_SetBlockLen_7
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   \   0000006E   0xE7F8             B.N      ??MCI_SetBlockLen_5
   2041              
   2042              retryCount--;
   \                     ??MCI_SetBlockLen_7:
   \   00000070   0x1E6D             SUBS     R5,R5,#+1
   \   00000072   0xE7D5             B.N      ??MCI_SetBlockLen_0
   2043            }
   2044            
   2045            return retval;
   \                     ??MCI_SetBlockLen_1:
   \   00000074   0x0038             MOVS     R0,R7
   \                     ??MCI_SetBlockLen_3:
   \   00000076   0xB00B             ADD      SP,SP,#+44
   \   00000078   0xBDF0             POP      {R4-R7,PC}       ;; return
   2046          }
   2047          /************************************************************************//**
   2048          * @brief        Set the number of blocks to be transfered befor block read OR
   2049          *               block write 
   2050          *
   2051          * @param[in]    block_cnt the value for the nu of block will be handled
   2052          *
   2053          * @return         MCI_FUNC_OK if all success
   2054          *
   2055          * @note         CMD23 command should be sent immediately before multiple block
   2056          *               read OR block write 
   2057          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2058          int32_t MCI_SetBlockCount( uint32_t block_cnt)
   2059          {
   \                     MCI_SetBlockCount:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   2060            volatile uint32_t i;
   2061            uint32_t retryCount;
   2062            uint32_t respStatus;
   2063            uint32_t respValue[4];
   2064            st_Mci_CmdInfo cmdIf;
   2065            int32_t retval = MCI_FUNC_FAILED;
   \   00000006   0xF05F 0x37FF      MOVS     R7,#-1
   2066            
   2067            retryCount = 0x20;
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x0005             MOVS     R5,R0
   2068            cmdIf.CmdIndex = CMD23_SET_BLOCK_COUNT;
   \   0000000E   0x2017             MOVS     R0,#+23
   \   00000010   0x9001             STR      R0,[SP, #+4]
   2069            cmdIf.Argument = block_cnt;
   \   00000012   0x9402             STR      R4,[SP, #+8]
   2070            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x9003             STR      R0,[SP, #+12]
   2071            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x9004             STR      R0,[SP, #+16]
   2072            cmdIf.CmdResp =  (uint32_t *)&respValue[0];
   \   0000001C   0xA806             ADD      R0,SP,#+24
   \   0000001E   0x9005             STR      R0,[SP, #+20]
   2073            while ( retryCount > 0 )
   \                     ??MCI_SetBlockCount_0:
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD025             BEQ.N    ??MCI_SetBlockCount_1
   2074            {
   2075              /* Check current status */
   2076              if((MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK) )
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x.... 0x....      BL       MCI_CheckStatus
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD002             BEQ.N    ??MCI_SetBlockCount_2
   2077                return MCI_FUNC_ERR_STATE;
   \   0000002E   0xF07F 0x0003      MVNS     R0,#+3
   \   00000032   0xE01E             B.N      ??MCI_SetBlockCount_3
   2078              
   2079              respStatus = MCI_CmdResp(&cmdIf);
   \                     ??MCI_SetBlockCount_2:
   \   00000034   0xA801             ADD      R0,SP,#+4
   \   00000036   0x.... 0x....      BL       MCI_CmdResp
   \   0000003A   0x0006             MOVS     R6,R0
   2080              
   2081              if(respStatus)
   \   0000003C   0x2E00             CMP      R6,#+0
   \   0000003E   0xD005             BEQ.N    ??MCI_SetBlockCount_4
   2082              {
   2083                retval = MCI_FUNC_FAILED;
   \   00000040   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000044   0x0007             MOVS     R7,R0
   2084              }
   2085              else if (respValue[0] & CARD_STATUS_ERR_MASK)
   2086              {
   2087                return MCI_FUNC_BAD_PARAMETERS;
   2088              }
   2089              else
   2090              {
   2091                return MCI_FUNC_OK;
   2092              }
   2093              
   2094              
   2095              for ( i = 0; i < 0x20; i++ );
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0xE008             B.N      ??MCI_SetBlockCount_5
   \                     ??MCI_SetBlockCount_4:
   \   0000004C   0x9806             LDR      R0,[SP, #+24]
   \   0000004E   0x....             LDR.N    R1,??DataTable30  ;; 0xfdf88008
   \   00000050   0x4208             TST      R0,R1
   \   00000052   0xD002             BEQ.N    ??MCI_SetBlockCount_6
   \   00000054   0xF07F 0x0001      MVNS     R0,#+1
   \   00000058   0xE00B             B.N      ??MCI_SetBlockCount_3
   \                     ??MCI_SetBlockCount_6:
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xE009             B.N      ??MCI_SetBlockCount_3
   \                     ??MCI_SetBlockCount_5:
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   \   00000060   0x2820             CMP      R0,#+32
   \   00000062   0xD203             BCS.N    ??MCI_SetBlockCount_7
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0xE7F8             B.N      ??MCI_SetBlockCount_5
   2096              
   2097              retryCount--;
   \                     ??MCI_SetBlockCount_7:
   \   0000006C   0x1E6D             SUBS     R5,R5,#+1
   \   0000006E   0xE7D7             B.N      ??MCI_SetBlockCount_0
   2098            }
   2099            
   2100            return retval;
   \                     ??MCI_SetBlockCount_1:
   \   00000070   0x0038             MOVS     R0,R7
   \                     ??MCI_SetBlockCount_3:
   \   00000072   0xB00B             ADD      SP,SP,#+44
   \   00000074   0xBDF0             POP      {R4-R7,PC}       ;; return
   2101          }
   2102          
   2103          
   2104          /************************************************************************//**
   2105          * @brief         Set bus-width (1 bit or 4 bit) to work with the card by command
   2106          *                CMD6 (SET_ACMD_BUS_WIDTH).
   2107          *
   2108          * @param[in]    buswidth The value represented for bus-width
   2109          *                - 0b00: 1-bit bus-width
   2110          *                - 0b10: 4-bit bus-width
   2111          *
   2112          * @return         MCI_FUNC_OK if all success
   2113          *
   2114          * @note        
   2115          *                - If SD card is currently in used, it's possible to enable 4-bit
   2116          *                bus-width instead of 1-bit to speed up.
   2117          *                - This command can only be transferred during TRANS state.
   2118          *                - Since, it's a ACMD, CMD55 (APP_CMD) needs to be sent out first
   2119          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2120          int32_t MCI_Acmd_SendBusWidth( uint32_t buswidth )
   2121          {
   \                     MCI_Acmd_SendBusWidth:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   2122            volatile uint32_t i;
   2123            uint32_t retryCount;
   2124            uint32_t respStatus;
   2125            uint32_t respValue[4];
   2126            st_Mci_CmdInfo cmdIf;
   2127            int32_t retval = MCI_FUNC_FAILED;
   \   00000006   0xF05F 0x37FF      MOVS     R7,#-1
   2128            
   2129            retryCount = 0x20;            /* reset retry counter */
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x0005             MOVS     R5,R0
   2130            cmdIf.CmdIndex = ACMD6_SET_BUS_WIDTH;
   \   0000000E   0x2006             MOVS     R0,#+6
   \   00000010   0x9001             STR      R0,[SP, #+4]
   2131            cmdIf.Argument = buswidth;
   \   00000012   0x9402             STR      R4,[SP, #+8]
   2132            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x9003             STR      R0,[SP, #+12]
   2133            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x9004             STR      R0,[SP, #+16]
   2134            cmdIf.CmdResp =  (uint32_t *)&respValue[0];
   \   0000001C   0xA806             ADD      R0,SP,#+24
   \   0000001E   0x9005             STR      R0,[SP, #+20]
   2135            while ( retryCount > 0 )
   \                     ??MCI_Acmd_SendBusWidth_0:
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD02C             BEQ.N    ??MCI_Acmd_SendBusWidth_1
   2136            {
   2137              /* The card must be in tran state in order to change the bus width */
   2138              retval = MCI_CheckStatus(CARD_STATE_TRAN);
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x.... 0x....      BL       MCI_CheckStatus
   \   0000002A   0x0007             MOVS     R7,R0
   2139              if(retval!= MCI_FUNC_OK)
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD001             BEQ.N    ??MCI_Acmd_SendBusWidth_2
   2140                return retval;
   \   00000030   0x0038             MOVS     R0,R7
   \   00000032   0xE025             B.N      ??MCI_Acmd_SendBusWidth_3
   2141              
   2142              if (MCI_Cmd_SendACMD() == MCI_FUNC_OK)
   \                     ??MCI_Acmd_SendBusWidth_2:
   \   00000034   0x.... 0x....      BL       MCI_Cmd_SendACMD
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD115             BNE.N    ??MCI_Acmd_SendBusWidth_4
   2143              {
   2144                respStatus = MCI_CmdResp(&cmdIf);
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0x.... 0x....      BL       MCI_CmdResp
   \   00000042   0x0006             MOVS     R6,R0
   2145                
   2146                if(respStatus)
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD003             BEQ.N    ??MCI_Acmd_SendBusWidth_5
   2147                {
   2148                  retval = MCI_FUNC_FAILED;
   \   00000048   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004C   0x0007             MOVS     R7,R0
   \   0000004E   0xE00B             B.N      ??MCI_Acmd_SendBusWidth_4
   2149                }
   2150                else if (respValue[0] & CARD_STATUS_ERR_MASK)
   \                     ??MCI_Acmd_SendBusWidth_5:
   \   00000050   0x9806             LDR      R0,[SP, #+24]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable39_3  ;; 0xfdf88008
   \   00000056   0x4208             TST      R0,R1
   \   00000058   0xD002             BEQ.N    ??MCI_Acmd_SendBusWidth_6
   2151                {
   2152                  return MCI_FUNC_BAD_PARAMETERS;
   \   0000005A   0xF07F 0x0001      MVNS     R0,#+1
   \   0000005E   0xE00F             B.N      ??MCI_Acmd_SendBusWidth_3
   2153                }
   2154                else
   2155                {
   2156                  return MCI_CheckStatus(CARD_STATE_TRAN);
   \                     ??MCI_Acmd_SendBusWidth_6:
   \   00000060   0x2004             MOVS     R0,#+4
   \   00000062   0x.... 0x....      BL       MCI_CheckStatus
   \   00000066   0xE00B             B.N      ??MCI_Acmd_SendBusWidth_3
   2157                }
   2158              }
   2159              
   2160              
   2161              for ( i = 0; i < 0x20; i++ );
   \                     ??MCI_Acmd_SendBusWidth_4:
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_Acmd_SendBusWidth_7:
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0x2820             CMP      R0,#+32
   \   00000070   0xD203             BCS.N    ??MCI_Acmd_SendBusWidth_8
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x1C40             ADDS     R0,R0,#+1
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0xE7F8             B.N      ??MCI_Acmd_SendBusWidth_7
   2162              
   2163              retryCount--;
   \                     ??MCI_Acmd_SendBusWidth_8:
   \   0000007A   0x1E6D             SUBS     R5,R5,#+1
   \   0000007C   0xE7D0             B.N      ??MCI_Acmd_SendBusWidth_0
   2164            }
   2165            
   2166            return retval;
   \                     ??MCI_Acmd_SendBusWidth_1:
   \   0000007E   0x0038             MOVS     R0,R7
   \                     ??MCI_Acmd_SendBusWidth_3:
   \   00000080   0xB00B             ADD      SP,SP,#+44
   \   00000082   0xBDF0             POP      {R4-R7,PC}       ;; return
   2167          }
   2168          
   2169          
   2170          /************************************************************************//**
   2171          * @brief        Get the state of  data transfer to see if it is ended or not
   2172          *
   2173          * @param        None
   2174          *
   2175          * @return       Transfer state (stored by Mci_Data_Xfer_End variable)
   2176          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2177          uint32_t MCI_GetDataXferEndState(void)
   2178          {
   2179            return Mci_Data_Xfer_End;
   \                     MCI_GetDataXferEndState:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39_4
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   2180          }
   2181          /************************************************************************//**
   2182          * @brief        Get the error state of  the lastest data transfer
   2183          *
   2184          * @param        None
   2185          *
   2186          * @return       Error state (stored by Mci_Data_Xfer_ERR variable)
   2187          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2188          uint32_t MCI_GetXferErrState(void)
   2189          {
   2190            return Mci_Data_Xfer_ERR;
   \                     MCI_GetXferErrState:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39_5
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   2191          }
   2192          
   2193          /************************************************************************//**
   2194          * @brief        Stop the current transmission on the bus by sending command CMD12
   2195          *                (STOP_TRANSMISSION). In this case, the card may be in a unknown
   2196          *                state. So that it need a warm reset for normal operation.
   2197          *
   2198          * @param[in]    None
   2199          *
   2200          * @return       MCI_FUNC_OK if all success
   2201          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2202          int32_t MCI_Cmd_StopTransmission( void )
   2203          {
   \                     MCI_Cmd_StopTransmission:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   2204            volatile uint32_t i;
   2205            uint32_t retryCount;
   2206            uint32_t respStatus;
   2207            uint32_t respValue[4];
   2208            st_Mci_CmdInfo cmdIf;
   2209            int32_t retval = MCI_FUNC_FAILED;
   \   00000004   0xF05F 0x36FF      MOVS     R6,#-1
   2210            
   2211            /* do nothing when the card is in tran state */
   2212            if(MCI_CheckStatus(CARD_STATE_TRAN) == MCI_FUNC_OK) 
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x.... 0x....      BL       MCI_CheckStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??MCI_Cmd_StopTransmission_0
   2213            {
   2214              return MCI_FUNC_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE047             B.N      ??MCI_Cmd_StopTransmission_1
   2215            }
   2216            
   2217            retryCount = 0x20;
   \                     ??MCI_Cmd_StopTransmission_0:
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0x0004             MOVS     R4,R0
   2218            cmdIf.CmdIndex = CMD12_STOP_TRANSMISSION;
   \   0000001A   0x200C             MOVS     R0,#+12
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   2219            cmdIf.Argument = 0x00000000;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x9002             STR      R0,[SP, #+8]
   2220            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x9003             STR      R0,[SP, #+12]
   2221            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x9004             STR      R0,[SP, #+16]
   2222            cmdIf.CmdResp =  (uint32_t *)&respValue[0];
   \   0000002A   0xA806             ADD      R0,SP,#+24
   \   0000002C   0x9005             STR      R0,[SP, #+20]
   2223            while ( retryCount > 0 )
   \                     ??MCI_Cmd_StopTransmission_2:
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD038             BEQ.N    ??MCI_Cmd_StopTransmission_3
   2224            {
   2225              /* Check current status */
   2226              if((MCI_CheckStatus(CARD_STATE_DATA) != MCI_FUNC_OK) &&
   2227                 (MCI_CheckStatus(CARD_STATE_RCV) != MCI_FUNC_OK))
   \   00000032   0x2005             MOVS     R0,#+5
   \   00000034   0x.... 0x....      BL       MCI_CheckStatus
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD007             BEQ.N    ??MCI_Cmd_StopTransmission_4
   \   0000003C   0x2006             MOVS     R0,#+6
   \   0000003E   0x.... 0x....      BL       MCI_CheckStatus
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??MCI_Cmd_StopTransmission_4
   2228                return MCI_FUNC_ERR_STATE;
   \   00000046   0xF07F 0x0003      MVNS     R0,#+3
   \   0000004A   0xE02C             B.N      ??MCI_Cmd_StopTransmission_1
   2229              
   2230              respStatus = MCI_CmdResp(&cmdIf);
   \                     ??MCI_Cmd_StopTransmission_4:
   \   0000004C   0xA801             ADD      R0,SP,#+4
   \   0000004E   0x.... 0x....      BL       MCI_CmdResp
   \   00000052   0x0005             MOVS     R5,R0
   2231              
   2232              if(respStatus)
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD005             BEQ.N    ??MCI_Cmd_StopTransmission_5
   2233              {
   2234                retval = MCI_FUNC_FAILED;
   \   00000058   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000005C   0x0006             MOVS     R6,R0
   2235              }
   2236              else if (respValue[0] & CARD_STATUS_ERR_MASK)
   2237              {
   2238                return MCI_FUNC_BAD_PARAMETERS;
   2239              }
   2240              else
   2241              {
   2242                if((MCI_CheckStatus(CARD_STATE_PRG) != MCI_FUNC_OK) &&
   2243                   (MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK))
   2244                  return MCI_FUNC_ERR_STATE;
   2245                return MCI_FUNC_OK;
   2246              }
   2247              
   2248              for ( i = 0; i < 0x20; i++ );
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x9000             STR      R0,[SP, #+0]
   \   00000062   0xE016             B.N      ??MCI_Cmd_StopTransmission_6
   \                     ??MCI_Cmd_StopTransmission_5:
   \   00000064   0x9806             LDR      R0,[SP, #+24]
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable39_3  ;; 0xfdf88008
   \   0000006A   0x4208             TST      R0,R1
   \   0000006C   0xD002             BEQ.N    ??MCI_Cmd_StopTransmission_7
   \   0000006E   0xF07F 0x0001      MVNS     R0,#+1
   \   00000072   0xE018             B.N      ??MCI_Cmd_StopTransmission_1
   \                     ??MCI_Cmd_StopTransmission_7:
   \   00000074   0x2007             MOVS     R0,#+7
   \   00000076   0x.... 0x....      BL       MCI_CheckStatus
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD007             BEQ.N    ??MCI_Cmd_StopTransmission_8
   \   0000007E   0x2004             MOVS     R0,#+4
   \   00000080   0x.... 0x....      BL       MCI_CheckStatus
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD002             BEQ.N    ??MCI_Cmd_StopTransmission_8
   \   00000088   0xF07F 0x0003      MVNS     R0,#+3
   \   0000008C   0xE00B             B.N      ??MCI_Cmd_StopTransmission_1
   \                     ??MCI_Cmd_StopTransmission_8:
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE009             B.N      ??MCI_Cmd_StopTransmission_1
   \                     ??MCI_Cmd_StopTransmission_6:
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x2820             CMP      R0,#+32
   \   00000096   0xD203             BCS.N    ??MCI_Cmd_StopTransmission_9
   \   00000098   0x9800             LDR      R0,[SP, #+0]
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0xE7F8             B.N      ??MCI_Cmd_StopTransmission_6
   2249              
   2250              retryCount--;
   \                     ??MCI_Cmd_StopTransmission_9:
   \   000000A0   0x1E64             SUBS     R4,R4,#+1
   \   000000A2   0xE7C4             B.N      ??MCI_Cmd_StopTransmission_2
   2251            }
   2252            
   2253            return retval;
   \                     ??MCI_Cmd_StopTransmission_3:
   \   000000A4   0x0030             MOVS     R0,R6
   \                     ??MCI_Cmd_StopTransmission_1:
   \   000000A6   0xB00A             ADD      SP,SP,#+40
   \   000000A8   0xBD70             POP      {R4-R6,PC}       ;; return
   2254          }
   2255          
   2256          
   2257          /************************************************************************//**
   2258          * @brief        Write blocks to card by sending command CMD24 (WRITE_BLOCK) or
   2259          *                command CMD25 (WRITE_MULTIPLE_BLOCK) followed by the blocks of
   2260          *                data to be written.
   2261          *
   2262          * @param[in]    blockNum The block number to start writting
   2263          *
   2264          * @param[in]    numOfBlock Determine how many blocks will be written (from the
   2265          *                starting block)
   2266          *
   2267          * @return       MCI_FUNC_OK if all success
   2268          *
   2269          * @note        These commands should be sent in TRANS state.
   2270          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2271          int32_t MCI_Cmd_WriteBlock(uint32_t blockNum, uint32_t numOfBlock)
   2272          {
   \                     MCI_Cmd_WriteBlock:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   2273            volatile uint32_t i;
   2274            uint32_t retryCount;
   2275            uint32_t respStatus;
   2276            uint32_t respValue[4];
   2277            st_Mci_CmdInfo cmdIf;
   2278            uint32_t commandID;
   2279            
   2280            int32_t retval = MCI_FUNC_FAILED;
   \   0000000A   0xF05F 0x39FF      MOVS     R9,#-1
   2281            
   2282            if( numOfBlock == 0)
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD102             BNE.N    ??MCI_Cmd_WriteBlock_0
   2283            {
   2284              return MCI_FUNC_FAILED;
   \   00000012   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000016   0xE063             B.N      ??MCI_Cmd_WriteBlock_1
   2285            }
   2286            
   2287            if (numOfBlock > 1)
   \                     ??MCI_Cmd_WriteBlock_0:
   \   00000018   0x2D02             CMP      R5,#+2
   \   0000001A   0xD302             BCC.N    ??MCI_Cmd_WriteBlock_2
   2288            {
   2289              commandID = CMD25_WRITE_MULTIPLE_BLOCK;
   \   0000001C   0x2019             MOVS     R0,#+25
   \   0000001E   0x4680             MOV      R8,R0
   \   00000020   0xE001             B.N      ??MCI_Cmd_WriteBlock_3
   2290            }
   2291            else
   2292            {
   2293              commandID = CMD24_WRITE_BLOCK;
   \                     ??MCI_Cmd_WriteBlock_2:
   \   00000022   0x2018             MOVS     R0,#+24
   \   00000024   0x4680             MOV      R8,R0
   2294            }
   2295            
   2296            retryCount = 0x20;
   \                     ??MCI_Cmd_WriteBlock_3:
   \   00000026   0x2020             MOVS     R0,#+32
   \   00000028   0x0006             MOVS     R6,R0
   2297            cmdIf.CmdIndex = commandID;
   \   0000002A   0xF8CD 0x8004      STR      R8,[SP, #+4]
   2298            if ( (MCI_CardType == MCI_SDHC_SDXC_CARD) ||
   2299                (MCI_CardType == MCI_MMC_CARD)
   2300                  )
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable39_2
   \   00000032   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000036   0x2803             CMP      R0,#+3
   \   00000038   0xD005             BEQ.N    ??MCI_Cmd_WriteBlock_4
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable39_2
   \   0000003E   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD101             BNE.N    ??MCI_Cmd_WriteBlock_5
   2301            {
   2302              cmdIf.Argument = blockNum;                      /* Block Address */
   \                     ??MCI_Cmd_WriteBlock_4:
   \   00000046   0x9402             STR      R4,[SP, #+8]
   \   00000048   0xE004             B.N      ??MCI_Cmd_WriteBlock_6
   2303            }
   2304            else            
   2305            {
   2306              cmdIf.Argument = blockNum * BLOCK_LENGTH;       /* Byte Address */
   \                     ??MCI_Cmd_WriteBlock_5:
   \   0000004A   0xF44F 0x7000      MOV      R0,#+512
   \   0000004E   0xFB00 0xF004      MUL      R0,R0,R4
   \   00000052   0x9002             STR      R0,[SP, #+8]
   2307            }     
   2308            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \                     ??MCI_Cmd_WriteBlock_6:
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x9003             STR      R0,[SP, #+12]
   2309            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x9004             STR      R0,[SP, #+16]
   2310            cmdIf.CmdResp =  (uint32_t *)&respValue[0];
   \   0000005C   0xA806             ADD      R0,SP,#+24
   \   0000005E   0x9005             STR      R0,[SP, #+20]
   2311            
   2312            while ( retryCount > 0 )
   \                     ??MCI_Cmd_WriteBlock_7:
   \   00000060   0x2E00             CMP      R6,#+0
   \   00000062   0xD03C             BEQ.N    ??MCI_Cmd_WriteBlock_8
   2313            {
   2314              /* Check current status */
   2315              if((MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK))
   \   00000064   0x2004             MOVS     R0,#+4
   \   00000066   0x.... 0x....      BL       MCI_CheckStatus
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD002             BEQ.N    ??MCI_Cmd_WriteBlock_9
   2316                return MCI_FUNC_ERR_STATE;
   \   0000006E   0xF07F 0x0003      MVNS     R0,#+3
   \   00000072   0xE035             B.N      ??MCI_Cmd_WriteBlock_1
   2317              
   2318              if (numOfBlock > 1)
   \                     ??MCI_Cmd_WriteBlock_9:
   \   00000074   0x2D02             CMP      R5,#+2
   \   00000076   0xD307             BCC.N    ??MCI_Cmd_WriteBlock_10
   2319              {
   2320                if( MCI_SetBlockCount( numOfBlock & 0xFFFF) != MCI_FUNC_OK )
   \   00000078   0xB2A8             UXTH     R0,R5            ;; ZeroExt  R0,R5,#+16,#+16
   \   0000007A   0x.... 0x....      BL       MCI_SetBlockCount
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD002             BEQ.N    ??MCI_Cmd_WriteBlock_10
   2321                {
   2322                  return ( MCI_FUNC_FAILED );
   \   00000082   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000086   0xE02B             B.N      ??MCI_Cmd_WriteBlock_1
   2323                }
   2324              }
   2325              
   2326              respStatus = MCI_CmdResp(&cmdIf);
   \                     ??MCI_Cmd_WriteBlock_10:
   \   00000088   0xA801             ADD      R0,SP,#+4
   \   0000008A   0x.... 0x....      BL       MCI_CmdResp
   \   0000008E   0x0007             MOVS     R7,R0
   2327              
   2328              if(respStatus)
   \   00000090   0x2F00             CMP      R7,#+0
   \   00000092   0xD005             BEQ.N    ??MCI_Cmd_WriteBlock_11
   2329              {
   2330                retval = MCI_FUNC_FAILED;
   \   00000094   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000098   0x4681             MOV      R9,R0
   2331              }
   2332              else if (respValue[0] & CARD_STATUS_ERR_MASK)
   2333              {
   2334                return MCI_FUNC_BAD_PARAMETERS;
   2335              }
   2336              else 
   2337              {
   2338                if((MCI_CheckStatus(CARD_STATE_RCV) != MCI_FUNC_OK) &&
   2339                   (MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK))
   2340                  return MCI_FUNC_ERR_STATE;
   2341                return MCI_FUNC_OK;
   2342              }
   2343              
   2344              
   2345              for ( i = 0; i < 0x20; i++ );
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0xE015             B.N      ??MCI_Cmd_WriteBlock_12
   \                     ??MCI_Cmd_WriteBlock_11:
   \   000000A0   0x9806             LDR      R0,[SP, #+24]
   \   000000A2   0x....             LDR.N    R1,??DataTable39_3  ;; 0xfdf88008
   \   000000A4   0x4208             TST      R0,R1
   \   000000A6   0xD002             BEQ.N    ??MCI_Cmd_WriteBlock_13
   \   000000A8   0xF07F 0x0001      MVNS     R0,#+1
   \   000000AC   0xE018             B.N      ??MCI_Cmd_WriteBlock_1
   \                     ??MCI_Cmd_WriteBlock_13:
   \   000000AE   0x2006             MOVS     R0,#+6
   \   000000B0   0x.... 0x....      BL       MCI_CheckStatus
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD007             BEQ.N    ??MCI_Cmd_WriteBlock_14
   \   000000B8   0x2004             MOVS     R0,#+4
   \   000000BA   0x.... 0x....      BL       MCI_CheckStatus
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD002             BEQ.N    ??MCI_Cmd_WriteBlock_14
   \   000000C2   0xF07F 0x0003      MVNS     R0,#+3
   \   000000C6   0xE00B             B.N      ??MCI_Cmd_WriteBlock_1
   \                     ??MCI_Cmd_WriteBlock_14:
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xE009             B.N      ??MCI_Cmd_WriteBlock_1
   \                     ??MCI_Cmd_WriteBlock_12:
   \   000000CC   0x9800             LDR      R0,[SP, #+0]
   \   000000CE   0x2820             CMP      R0,#+32
   \   000000D0   0xD203             BCS.N    ??MCI_Cmd_WriteBlock_15
   \   000000D2   0x9800             LDR      R0,[SP, #+0]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0xE7F8             B.N      ??MCI_Cmd_WriteBlock_12
   2346              
   2347              retryCount--;
   \                     ??MCI_Cmd_WriteBlock_15:
   \   000000DA   0x1E76             SUBS     R6,R6,#+1
   \   000000DC   0xE7C0             B.N      ??MCI_Cmd_WriteBlock_7
   2348              
   2349            }
   2350            
   2351            return retval;                /* Fatal error */
   \                     ??MCI_Cmd_WriteBlock_8:
   \   000000DE   0x4648             MOV      R0,R9
   \                     ??MCI_Cmd_WriteBlock_1:
   \   000000E0   0xB00B             ADD      SP,SP,#+44
   \   000000E2   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2352          }
   2353          
   2354          
   2355          
   2356          
   2357          /************************************************************************//**
   2358          * @brief        Read blocks to card by sending CMD17 (READ_SINGLE_BLOCK) or
   2359          *                CMD18 (READ_MULTIPLE_BLOCK) commands followed by the blocks of
   2360          *                data to be read.
   2361          *
   2362          * @param[in]    blockNum The block number to start reading
   2363          *
   2364          * @param[in]    numOfBlock Determine how many blocks will be read (from the
   2365          *                starting block)
   2366          *
   2367          * @return       MCI_FUNC_OK if all success
   2368          *
   2369          * @note        These commands should be sent in TRANS state.
   2370          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2371          int32_t MCI_Cmd_ReadBlock(uint32_t blockNum, uint32_t numOfBlock)
   2372          {
   \                     MCI_Cmd_ReadBlock:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   2373            volatile uint32_t i;
   2374            uint32_t retryCount;
   2375            uint32_t respStatus;
   2376            uint32_t respValue[4];
   2377            uint32_t commandID;
   2378            st_Mci_CmdInfo cmdIf;
   2379            int32_t retval = MCI_FUNC_FAILED;
   \   0000000A   0xF05F 0x39FF      MOVS     R9,#-1
   2380            
   2381            // To Do: Read Multi-Block
   2382            if (numOfBlock > 1)
   \   0000000E   0x2D02             CMP      R5,#+2
   \   00000010   0xD302             BCC.N    ??MCI_Cmd_ReadBlock_0
   2383              commandID = CMD18_READ_MULTIPLE_BLOCK;
   \   00000012   0x2012             MOVS     R0,#+18
   \   00000014   0x4680             MOV      R8,R0
   \   00000016   0xE001             B.N      ??MCI_Cmd_ReadBlock_1
   2384            else
   2385              commandID = CMD17_READ_SINGLE_BLOCK;
   \                     ??MCI_Cmd_ReadBlock_0:
   \   00000018   0x2011             MOVS     R0,#+17
   \   0000001A   0x4680             MOV      R8,R0
   2386            
   2387            retryCount = 0x20;
   \                     ??MCI_Cmd_ReadBlock_1:
   \   0000001C   0x2020             MOVS     R0,#+32
   \   0000001E   0x0006             MOVS     R6,R0
   2388            cmdIf.CmdIndex = commandID;
   \   00000020   0xF8CD 0x8004      STR      R8,[SP, #+4]
   2389            if ( (MCI_CardType == MCI_SDHC_SDXC_CARD) ||
   2390                (MCI_CardType == MCI_MMC_CARD)
   2391                  )
   \   00000024   0x....             LDR.N    R0,??DataTable39_2
   \   00000026   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD004             BEQ.N    ??MCI_Cmd_ReadBlock_2
   \   0000002E   0x....             LDR.N    R0,??DataTable39_2
   \   00000030   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??MCI_Cmd_ReadBlock_3
   2392            {
   2393              cmdIf.Argument = blockNum;                      /* Block Address */
   \                     ??MCI_Cmd_ReadBlock_2:
   \   00000038   0x9402             STR      R4,[SP, #+8]
   \   0000003A   0xE004             B.N      ??MCI_Cmd_ReadBlock_4
   2394            }
   2395            else            
   2396            {
   2397              cmdIf.Argument = blockNum * BLOCK_LENGTH;       /* Byte Address */
   \                     ??MCI_Cmd_ReadBlock_3:
   \   0000003C   0xF44F 0x7000      MOV      R0,#+512
   \   00000040   0xFB00 0xF004      MUL      R0,R0,R4
   \   00000044   0x9002             STR      R0,[SP, #+8]
   2398            }    
   2399            cmdIf.ExpectResp = EXPECT_SHORT_RESP;
   \                     ??MCI_Cmd_ReadBlock_4:
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x9003             STR      R0,[SP, #+12]
   2400            cmdIf.AllowTimeout = ALLOW_CMD_TIMER;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x9004             STR      R0,[SP, #+16]
   2401            cmdIf.CmdResp =  (uint32_t *)&respValue[0];
   \   0000004E   0xA806             ADD      R0,SP,#+24
   \   00000050   0x9005             STR      R0,[SP, #+20]
   2402            while ( retryCount > 0 )
   \                     ??MCI_Cmd_ReadBlock_5:
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD03C             BEQ.N    ??MCI_Cmd_ReadBlock_6
   2403            {
   2404              /* Check current status */
   2405              if((MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK))
   \   00000056   0x2004             MOVS     R0,#+4
   \   00000058   0x.... 0x....      BL       MCI_CheckStatus
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??MCI_Cmd_ReadBlock_7
   2406                return MCI_FUNC_ERR_STATE;
   \   00000060   0xF07F 0x0003      MVNS     R0,#+3
   \   00000064   0xE035             B.N      ??MCI_Cmd_ReadBlock_8
   2407              
   2408              if (numOfBlock > 1)
   \                     ??MCI_Cmd_ReadBlock_7:
   \   00000066   0x2D02             CMP      R5,#+2
   \   00000068   0xD307             BCC.N    ??MCI_Cmd_ReadBlock_9
   2409              {
   2410                if( MCI_SetBlockCount( numOfBlock & 0xFFFF ) != MCI_FUNC_OK )
   \   0000006A   0xB2A8             UXTH     R0,R5            ;; ZeroExt  R0,R5,#+16,#+16
   \   0000006C   0x.... 0x....      BL       MCI_SetBlockCount
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD002             BEQ.N    ??MCI_Cmd_ReadBlock_9
   2411                {
   2412                  return ( MCI_FUNC_FAILED );
   \   00000074   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000078   0xE02B             B.N      ??MCI_Cmd_ReadBlock_8
   2413                }
   2414              }
   2415              
   2416              respStatus = MCI_CmdResp(&cmdIf);
   \                     ??MCI_Cmd_ReadBlock_9:
   \   0000007A   0xA801             ADD      R0,SP,#+4
   \   0000007C   0x.... 0x....      BL       MCI_CmdResp
   \   00000080   0x0007             MOVS     R7,R0
   2417              
   2418              if(respStatus)
   \   00000082   0x2F00             CMP      R7,#+0
   \   00000084   0xD005             BEQ.N    ??MCI_Cmd_ReadBlock_10
   2419              {
   2420                retval = MCI_FUNC_FAILED;
   \   00000086   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000008A   0x4681             MOV      R9,R0
   2421              }
   2422              else if (respValue[0] & CARD_STATUS_ERR_MASK)
   2423              {
   2424                return MCI_FUNC_BAD_PARAMETERS;
   2425              }
   2426              else
   2427              {
   2428                if((MCI_CheckStatus(CARD_STATE_DATA) != MCI_FUNC_OK) &&
   2429                   (MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK))
   2430                  return MCI_FUNC_ERR_STATE;
   2431                return MCI_FUNC_OK;
   2432              }
   2433              
   2434              for ( i = 0; i < 0x20; i++ );
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0xE015             B.N      ??MCI_Cmd_ReadBlock_11
   \                     ??MCI_Cmd_ReadBlock_10:
   \   00000092   0x9806             LDR      R0,[SP, #+24]
   \   00000094   0x....             LDR.N    R1,??DataTable39_3  ;; 0xfdf88008
   \   00000096   0x4208             TST      R0,R1
   \   00000098   0xD002             BEQ.N    ??MCI_Cmd_ReadBlock_12
   \   0000009A   0xF07F 0x0001      MVNS     R0,#+1
   \   0000009E   0xE018             B.N      ??MCI_Cmd_ReadBlock_8
   \                     ??MCI_Cmd_ReadBlock_12:
   \   000000A0   0x2005             MOVS     R0,#+5
   \   000000A2   0x.... 0x....      BL       MCI_CheckStatus
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD007             BEQ.N    ??MCI_Cmd_ReadBlock_13
   \   000000AA   0x2004             MOVS     R0,#+4
   \   000000AC   0x.... 0x....      BL       MCI_CheckStatus
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD002             BEQ.N    ??MCI_Cmd_ReadBlock_13
   \   000000B4   0xF07F 0x0003      MVNS     R0,#+3
   \   000000B8   0xE00B             B.N      ??MCI_Cmd_ReadBlock_8
   \                     ??MCI_Cmd_ReadBlock_13:
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE009             B.N      ??MCI_Cmd_ReadBlock_8
   \                     ??MCI_Cmd_ReadBlock_11:
   \   000000BE   0x9800             LDR      R0,[SP, #+0]
   \   000000C0   0x2820             CMP      R0,#+32
   \   000000C2   0xD203             BCS.N    ??MCI_Cmd_ReadBlock_14
   \   000000C4   0x9800             LDR      R0,[SP, #+0]
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \   000000C8   0x9000             STR      R0,[SP, #+0]
   \   000000CA   0xE7F8             B.N      ??MCI_Cmd_ReadBlock_11
   2435              
   2436              retryCount--;
   \                     ??MCI_Cmd_ReadBlock_14:
   \   000000CC   0x1E76             SUBS     R6,R6,#+1
   \   000000CE   0xE7C0             B.N      ??MCI_Cmd_ReadBlock_5
   2437              
   2438            }
   2439            
   2440            return retval;
   \                     ??MCI_Cmd_ReadBlock_6:
   \   000000D0   0x4648             MOV      R0,R9
   \                     ??MCI_Cmd_ReadBlock_8:
   \   000000D2   0xB00B             ADD      SP,SP,#+44
   \   000000D4   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2441          }
   2442          
   2443          
   2444          /************************************************************************//**
   2445          * @brief         Write data at a specific address to starting block with number
   2446          *                of blocks will be written from first block
   2447          * @details        
   2448          *                - At preparation
   2449          *                    - Set MCI data control register, data length and data timeout
   2450          *                    - Send CMD24 (WRITE_BLOCK) or CMD25 (WRITE_MULTIPLE_BLOCK)
   2451          *                    commands to card
   2452          *                    - Enable interupt for MCI component
   2453          *                - At completion
   2454          *                    - TX_ACTIVE interrupt is occured
   2455          *                    - Write data to FIFO register continuously until the data block
   2456          *                    length is reached
   2457          *
   2458          * @param[in]    *memblock The pointer to location stored required data to be
   2459          *                written to card
   2460          *
   2461          * @param[in]    blockNum The block number to start writting
   2462          *
   2463          * @param[in]    numOfBlock Determine how many blocks will be written (from the
   2464          *                starting block)
   2465          *
   2466          * @return         MCI_FUNC_OK if all success
   2467          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2468          int32_t MCI_WriteBlock( uint8_t* memblock, uint32_t blockNum, uint32_t numOfBlock)
   2469          {
   \                     MCI_WriteBlock:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2470            volatile uint32_t i;
   2471            uint32_t DataCtrl = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   2472            
   2473            if(BLOCK_LENGTH*numOfBlock > DATA_RW_MAX_LEN)
   \   0000000A   0xF44F 0x7000      MOV      R0,#+512
   \   0000000E   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000012   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000016   0xD302             BCC.N    ??MCI_WriteBlock_0
   2474              return MCI_FUNC_BAD_PARAMETERS;
   \   00000018   0xF07F 0x0001      MVNS     R0,#+1
   \   0000001C   0xE04E             B.N      ??MCI_WriteBlock_1
   2475            
   2476            dataSrcBlock = memblock;
   \                     ??MCI_WriteBlock_0:
   \   0000001E   0x....             LDR.N    R0,??DataTable39_6
   \   00000020   0x6004             STR      R4,[R0, #+0]
   2477            
   2478            LPC_MCI->CLEAR = 0x7FF;
   \   00000022   0x....             LDR.N    R0,??DataTable39_7  ;; 0x400c0038
   \   00000024   0xF240 0x71FF      MOVW     R1,#+2047
   \   00000028   0x6001             STR      R1,[R0, #+0]
   2479            
   2480            LPC_MCI->DATACTRL = 0;
   \   0000002A   0x....             LDR.N    R0,??DataTable39_8  ;; 0x400c002c
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   2481            
   2482            for ( i = 0; i < 0x10; i++ );
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_WriteBlock_2:
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x2810             CMP      R0,#+16
   \   00000038   0xD203             BCS.N    ??MCI_WriteBlock_3
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0xE7F8             B.N      ??MCI_WriteBlock_2
   2483            
   2484            /* Wait the SD Card enters to TRANS state. */
   2485            if (MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK)
   \                     ??MCI_WriteBlock_3:
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0x.... 0x....      BL       MCI_CheckStatus
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD002             BEQ.N    ??MCI_WriteBlock_4
   2486              return MCI_FUNC_ERR_STATE;
   \   0000004C   0xF07F 0x0003      MVNS     R0,#+3
   \   00000050   0xE034             B.N      ??MCI_WriteBlock_1
   2487            
   2488            LPC_MCI->DATATMR = DATA_TIMER_VALUE_W;
   \                     ??MCI_WriteBlock_4:
   \   00000052   0x....             LDR.N    R0,??DataTable39_9  ;; 0x400c0024
   \   00000054   0x....             LDR.N    R1,??DataTable39_10  ;; 0xe4e1c0
   \   00000056   0x6001             STR      R1,[R0, #+0]
   2489            
   2490            LPC_MCI->DATALEN = BLOCK_LENGTH*numOfBlock;
   \   00000058   0xF44F 0x7000      MOV      R0,#+512
   \   0000005C   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000060   0x....             LDR.N    R1,??DataTable39_11  ;; 0x400c0028
   \   00000062   0x6008             STR      R0,[R1, #+0]
   2491            
   2492            Mci_Data_Xfer_End = 1;
   \   00000064   0x....             LDR.N    R0,??DataTable39_4
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x6001             STR      R1,[R0, #+0]
   2493            Mci_Data_Xfer_ERR = 0;
   \   0000006A   0x....             LDR.N    R0,??DataTable39_5
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   2494            fifo_plane = 0;
   \   00000070   0x....             LDR.N    R0,??DataTable39_12
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x7001             STRB     R1,[R0, #+0]
   2495            
   2496            txBlockCnt = 0;
   \   00000076   0x....             LDR.N    R0,??DataTable39_13
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x6001             STR      R1,[R0, #+0]
   2497            
   2498            MCI_TXEnable();
   \   0000007C   0x.... 0x....      BL       MCI_TXEnable
   2499            
   2500            
   2501            if (MCI_Cmd_WriteBlock(blockNum, numOfBlock) != MCI_FUNC_OK)
   \   00000080   0x0031             MOVS     R1,R6
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0x.... 0x....      BL       MCI_Cmd_WriteBlock
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD002             BEQ.N    ??MCI_WriteBlock_5
   2502            {
   2503              return ( MCI_FUNC_FAILED );
   \   0000008C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000090   0xE014             B.N      ??MCI_WriteBlock_1
   2504            }
   2505            
   2506            //for(blockCnt = 0; blockCnt < numOfBlock; blockCnt++)
   2507            {
   2508          #if MCI_DMA_ENABLED
   2509              MCI_SettingDma((uint8_t*) dataSrcBlock, MCI_DMA_WRITE_CHANNEL, GPDMA_TRANSFERTYPE_M2P_DEST_CTRL,numOfBlock);
   \                     ??MCI_WriteBlock_5:
   \   00000092   0x0033             MOVS     R3,R6
   \   00000094   0x2205             MOVS     R2,#+5
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0x....             LDR.N    R0,??DataTable39_6
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x.... 0x....      BL       MCI_SettingDma
   2510              
   2511              /* Write, block transfer, DMA, and data length */
   2512              DataCtrl |= MCI_DATACTRL_ENABLE | MCI_DATACTRL_DIR_TO_CARD 
   2513                | MCI_DATACTRL_DMA_ENABLE | MCI_DTATCTRL_BLOCKSIZE(DATA_BLOCK_LEN);
   \   000000A0   0xF057 0x0799      ORRS     R7,R7,#0x99
   2514          #else
   2515              /* Write, block transfer, and data length */
   2516              DataCtrl |= MCI_DATACTRL_ENABLE  | MCI_DATACTRL_DIR_TO_CARD  | MCI_DTATCTRL_BLOCKSIZE(DATA_BLOCK_LEN);
   2517          #endif
   2518            }
   2519            
   2520            LPC_MCI->DATACTRL = DataCtrl;
   \   000000A4   0x....             LDR.N    R0,??DataTable39_8  ;; 0x400c002c
   \   000000A6   0x6007             STR      R7,[R0, #+0]
   2521            
   2522            for ( i = 0; i < 0x10; i++ );
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_WriteBlock_6:
   \   000000AC   0x9800             LDR      R0,[SP, #+0]
   \   000000AE   0x2810             CMP      R0,#+16
   \   000000B0   0xD203             BCS.N    ??MCI_WriteBlock_7
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0x1C40             ADDS     R0,R0,#+1
   \   000000B6   0x9000             STR      R0,[SP, #+0]
   \   000000B8   0xE7F8             B.N      ??MCI_WriteBlock_6
   2523            
   2524            return MCI_FUNC_OK;
   \                     ??MCI_WriteBlock_7:
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??MCI_WriteBlock_1:
   \   000000BC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2525          }
   2526          
   2527          
   2528          
   2529          
   2530          /************************************************************************//**
   2531          * @brief         Read data at a specific address to starting block with number
   2532          *                of blocks will be read from first block
   2533          *
   2534          * @details        
   2535          *                - At preparation
   2536          *                    - Set MCI data control register, data length and data timeout
   2537          *                    - Send CMD17 (READ_SINGLE_BLOCK) or CMD18 (READ_MULTIPLE_BLOCK)
   2538          *                    commands to card
   2539          *                    - Enable interupt for MCI component
   2540          *                - At completion
   2541          *                    - RX_ACTIVE interrupt is occured
   2542          *                    - Read data from FIFO register continuously until the data block
   2543          *                    length is reached to retrieve needed data
   2544          *
   2545          * @param[in]    *destBlock The pointer to location will captured data read
   2546          *                from card
   2547          *
   2548          * @param[in]    blockNum The block number to start reading
   2549          *
   2550          * @param[in]    numOfBlock Determine how many blocks will be read (from the
   2551          *                starting block)
   2552          *
   2553          * @return         MCI_FUNC_OK if all success
   2554          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2555          int32_t MCI_ReadBlock( uint8_t* destBlock, uint32_t blockNum, uint32_t numOfBlock)
   2556          {
   \                     MCI_ReadBlock:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2557            volatile uint32_t i;
   2558            uint32_t DataCtrl = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   2559            
   2560            if(BLOCK_LENGTH*numOfBlock > DATA_RW_MAX_LEN)
   \   0000000A   0xF44F 0x7000      MOV      R0,#+512
   \   0000000E   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000012   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000016   0xD302             BCC.N    ??MCI_ReadBlock_0
   2561              return MCI_FUNC_BAD_PARAMETERS;
   \   00000018   0xF07F 0x0001      MVNS     R0,#+1
   \   0000001C   0xE04E             B.N      ??MCI_ReadBlock_1
   2562            
   2563            dataDestBlock = destBlock;
   \                     ??MCI_ReadBlock_0:
   \   0000001E   0x....             LDR.N    R0,??DataTable39_14
   \   00000020   0x6004             STR      R4,[R0, #+0]
   2564            
   2565            LPC_MCI->CLEAR = 0x7FF;
   \   00000022   0x....             LDR.N    R0,??DataTable39_7  ;; 0x400c0038
   \   00000024   0xF240 0x71FF      MOVW     R1,#+2047
   \   00000028   0x6001             STR      R1,[R0, #+0]
   2566            
   2567            LPC_MCI->DATACTRL = 0;
   \   0000002A   0x....             LDR.N    R0,??DataTable39_8  ;; 0x400c002c
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   2568            
   2569            for ( i = 0; i < 0x10; i++ );
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_ReadBlock_2:
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x2810             CMP      R0,#+16
   \   00000038   0xD203             BCS.N    ??MCI_ReadBlock_3
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0xE7F8             B.N      ??MCI_ReadBlock_2
   2570            
   2571            /* Wait the SD Card enters to TRANS state. */
   2572            if (MCI_CheckStatus(CARD_STATE_TRAN) != MCI_FUNC_OK)
   \                     ??MCI_ReadBlock_3:
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0x.... 0x....      BL       MCI_CheckStatus
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD002             BEQ.N    ??MCI_ReadBlock_4
   2573              return MCI_FUNC_ERR_STATE;
   \   0000004C   0xF07F 0x0003      MVNS     R0,#+3
   \   00000050   0xE034             B.N      ??MCI_ReadBlock_1
   2574            
   2575            MCI_RXEnable();
   \                     ??MCI_ReadBlock_4:
   \   00000052   0x.... 0x....      BL       MCI_RXEnable
   2576            
   2577            LPC_MCI->DATATMR = DATA_TIMER_VALUE_R;
   \   00000056   0x....             LDR.N    R0,??DataTable39_9  ;; 0x400c0024
   \   00000058   0x....             LDR.N    R1,??DataTable39_15  ;; 0x393870
   \   0000005A   0x6001             STR      R1,[R0, #+0]
   2578            
   2579            LPC_MCI->DATALEN = BLOCK_LENGTH*numOfBlock;
   \   0000005C   0xF44F 0x7000      MOV      R0,#+512
   \   00000060   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000064   0x....             LDR.N    R1,??DataTable39_11  ;; 0x400c0028
   \   00000066   0x6008             STR      R0,[R1, #+0]
   2580            
   2581            Mci_Data_Xfer_End = 1;
   \   00000068   0x....             LDR.N    R0,??DataTable39_4
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x6001             STR      R1,[R0, #+0]
   2582            Mci_Data_Xfer_ERR = 0;
   \   0000006E   0x....             LDR.N    R0,??DataTable39_5
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x6001             STR      R1,[R0, #+0]
   2583            rxBlockCnt = 0;
   \   00000074   0x....             LDR.N    R0,??DataTable39_16
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x6001             STR      R1,[R0, #+0]
   2584            fifo_plane = 0;
   \   0000007A   0x....             LDR.N    R0,??DataTable39_12
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x7001             STRB     R1,[R0, #+0]
   2585            
   2586            
   2587            if ( MCI_Cmd_ReadBlock(blockNum, numOfBlock) != MCI_FUNC_OK )
   \   00000080   0x0031             MOVS     R1,R6
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0x.... 0x....      BL       MCI_Cmd_ReadBlock
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD002             BEQ.N    ??MCI_ReadBlock_5
   2588            {
   2589              return MCI_FUNC_FAILED;
   \   0000008C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000090   0xE014             B.N      ??MCI_ReadBlock_1
   2590            }
   2591            
   2592            // Start data engine on READ before command to avoid overflow of the FIFO.
   2593            {        
   2594          #if MCI_DMA_ENABLED
   2595              MCI_SettingDma((uint8_t*) dataDestBlock, MCI_DMA_READ_CHANNEL, GPDMA_TRANSFERTYPE_P2M_SRC_CTRL,numOfBlock);
   \                     ??MCI_ReadBlock_5:
   \   00000092   0x0033             MOVS     R3,R6
   \   00000094   0x2206             MOVS     R2,#+6
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0x....             LDR.N    R0,??DataTable39_14
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x.... 0x....      BL       MCI_SettingDma
   2596              
   2597              /* Write, block transfer, DMA, and data length */
   2598              DataCtrl |= MCI_DATACTRL_ENABLE | MCI_DATACTRL_DIR_FROM_CARD
   2599                | MCI_DATACTRL_DMA_ENABLE | MCI_DTATCTRL_BLOCKSIZE(DATA_BLOCK_LEN);
   \   000000A0   0xF057 0x079B      ORRS     R7,R7,#0x9B
   2600          #else
   2601              //Retrieving the result after reading the card is done by the FIFO handling for interrupt
   2602              
   2603              /* Read, enable, block transfer, and data length */
   2604              DataCtrl |= MCI_DATACTRL_ENABLE | MCI_DATACTRL_DIR_FROM_CARD | MCI_DTATCTRL_BLOCKSIZE(DATA_BLOCK_LEN);
   2605              
   2606          #endif
   2607            }
   2608            
   2609            LPC_MCI->DATACTRL = DataCtrl;
   \   000000A4   0x....             LDR.N    R0,??DataTable39_8  ;; 0x400c002c
   \   000000A6   0x6007             STR      R7,[R0, #+0]
   2610            
   2611            for ( i = 0; i < 0x10; i++ );
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_ReadBlock_6:
   \   000000AC   0x9800             LDR      R0,[SP, #+0]
   \   000000AE   0x2810             CMP      R0,#+16
   \   000000B0   0xD203             BCS.N    ??MCI_ReadBlock_7
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0x1C40             ADDS     R0,R0,#+1
   \   000000B6   0x9000             STR      R0,[SP, #+0]
   \   000000B8   0xE7F8             B.N      ??MCI_ReadBlock_6
   2612            
   2613            return MCI_FUNC_OK;
   \                     ??MCI_ReadBlock_7:
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??MCI_ReadBlock_1:
   \   000000BC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2614          }
   2615          
   2616          
   2617          /************************************************************************//**
   2618          * @brief        Turn off the MCI power by disabling the Power Register for MCI
   2619          *
   2620          * @param        None
   2621          *
   2622          * @return       None
   2623          ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2624          void MCI_PowerOff(void) 
   2625          {
   \                     MCI_PowerOff:
   \   00000000   0xB081             SUB      SP,SP,#+4
   2626            volatile uint32_t i;
   2627            
   2628            LPC_MCI->POWER = 0;
   \   00000002   0x....             LDR.N    R0,??DataTable39_17  ;; 0x400c0000
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #+0]
   2629            
   2630            for (i = 0; i < 0x100; i++);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \                     ??MCI_PowerOff_0:
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0x28FF             CMP      R0,#+255
   \   00000010   0xD803             BHI.N    ??MCI_PowerOff_1
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0xE7F8             B.N      ??MCI_PowerOff_0
   2631            
   2632            return;
   \                     ??MCI_PowerOff_1:
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0x4770             BX       LR               ;; return
   2633          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     dmaWrCh_TermianalCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     dmaWrCh_ErrorCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x........         DC32     dmaRdCh_TermianalCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x400C0080         DC32     0x400c0080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x........         DC32     dmaRdCh_ErrorCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x........         DC32     fifo_plane

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0xFFFFF8E5         DC32     0xfffff8e5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0xFFFFF8D5         DC32     0xfffff8d5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x400C003C         DC32     0x400c003c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x400C0034         DC32     0x400c0034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x400C0038         DC32     0x400c0038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     Mci_Data_Xfer_End

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x........         DC32     Mci_Data_Xfer_ERR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x400C0004         DC32     0x400c0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x03B70000         DC32     0x3b70000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x03B70100         DC32     0x3b70100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x........         DC32     MCI_CardType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x000FC400         DC32     0xfc400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x4002C088         DC32     0x4002c088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0x4002C08C         DC32     0x4002c08c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \   00000000   0x4002C094         DC32     0x4002c094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \   00000000   0x4002C098         DC32     0x4002c098

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0xFDF88008         DC32     0xfdf88008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x4002C09C         DC32     0x4002c09c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0x4002C0AC         DC32     0x4002c0ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   0x4002C0B0         DC32     0x4002c0b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_4:
   \   00000000   0x20098020         DC32     0x20098020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_5:
   \   00000000   0x2009803C         DC32     0x2009803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_6:
   \   00000000   0x20098038         DC32     0x20098038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x400FC0C4         DC32     0x400fc0c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   0x400C0000         DC32     0x400c0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_1:
   \   00000000   0x400FC1A0         DC32     0x400fc1a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x400C0024         DC32     0x400c0024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x400C000C         DC32     0x400c000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x400C002C         DC32     0x400c002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_3:
   \   00000000   0x00061A80         DC32     0x61a80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x400C0008         DC32     0x400c0008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x400C0010         DC32     0x400c0010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_1:
   \   00000000   0x400C0014         DC32     0x400c0014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_2:
   \   00000000   0x400C0018         DC32     0x400c0018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0x400C001C         DC32     0x400c001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \   00000000   0x400C0020         DC32     0x400c0020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0xC0FF8080         DC32     0xc0ff8080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39:
   \   00000000   0x........         DC32     CardRCA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_1:
   \   00000000   0x........         DC32     CCS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_2:
   \   00000000   0x........         DC32     MCI_CardType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_3:
   \   00000000   0xFDF88008         DC32     0xfdf88008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_4:
   \   00000000   0x........         DC32     Mci_Data_Xfer_End

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_5:
   \   00000000   0x........         DC32     Mci_Data_Xfer_ERR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_6:
   \   00000000   0x........         DC32     dataSrcBlock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_7:
   \   00000000   0x400C0038         DC32     0x400c0038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_8:
   \   00000000   0x400C002C         DC32     0x400c002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_9:
   \   00000000   0x400C0024         DC32     0x400c0024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_10:
   \   00000000   0x00E4E1C0         DC32     0xe4e1c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_11:
   \   00000000   0x400C0028         DC32     0x400c0028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_12:
   \   00000000   0x........         DC32     fifo_plane

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_13:
   \   00000000   0x........         DC32     txBlockCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_14:
   \   00000000   0x........         DC32     dataDestBlock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_15:
   \   00000000   0x00393870         DC32     0x393870

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_16:
   \   00000000   0x........         DC32     rxBlockCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_17:
   \   00000000   0x400C0000         DC32     0x400c0000
   2634          
   2635          
   2636          /**
   2637          * @}
   2638          */
   2639          
   2640          #endif /*_MCI*/
   2641          
   2642          /*****************************************************************************
   2643          **                            End Of File
   2644          ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   MCI_Acmd_SendBusWidth
        64   -> MCI_CheckStatus
        64   -> MCI_CmdResp
        64   -> MCI_Cmd_SendACMD
      64   MCI_Acmd_SendOpCond
        64   -> MCI_CmdResp
        64   -> MCI_Cmd_SendACMD
        64   -> MCI_SetOutputMode
      16   MCI_CardInit
        16   -> MCI_Acmd_SendOpCond
        16   -> MCI_CardReset
        16   -> MCI_Cmd_SendIfCond
        16   -> MCI_Cmd_SendOpCond
        16   -> MCI_SetOutputMode
      24   MCI_CardReset
        24   -> MCI_SendCmd
      24   MCI_CheckStatus
        24   -> MCI_GetCardStatus
       0   MCI_CmdProcess
      24   MCI_CmdResp
        24   -> MCI_GetCmdResp
        24   -> MCI_SendCmd
      72   MCI_Cmd_ReadBlock
        72   -> MCI_CheckStatus
        72   -> MCI_CmdResp
        72   -> MCI_SetBlockCount
      64   MCI_Cmd_SelectCard
        64   -> MCI_CheckStatus
        64   -> MCI_CmdResp
      64   MCI_Cmd_SendACMD
        64   -> MCI_CmdResp
      72   MCI_Cmd_SendIfCond
        72   -> MCI_CmdResp
      56   MCI_Cmd_SendOpCond
        56   -> MCI_CmdResp
      56   MCI_Cmd_StopTransmission
        56   -> MCI_CheckStatus
        56   -> MCI_CmdResp
      72   MCI_Cmd_WriteBlock
        72   -> MCI_CheckStatus
        72   -> MCI_CmdResp
        72   -> MCI_SetBlockCount
       8   MCI_DATA_END_InterruptService
         8   -> MCI_RXDisable
         8   -> MCI_TXDisable
       8   MCI_DMA_IRQHandler
         8   -> GPDMA_ClearIntPending
         8   -> GPDMA_IntGetStatus
       0   MCI_DataErrorProcess
       0   MCI_FIFOInterruptService
      56   MCI_GetCID
        56   -> MCI_CmdResp
      64   MCI_GetCSD
        64   -> MCI_CheckStatus
        64   -> MCI_CmdResp
       0   MCI_GetCardAddress
      64   MCI_GetCardStatus
        64   -> MCI_CmdResp
       0   MCI_GetCardType
      16   MCI_GetCmdResp
       0   MCI_GetDataXferEndState
       0   MCI_GetXferErrState
       8   MCI_IRQHandler
         8   -> MCI_CmdProcess
         8   -> MCI_DATA_END_InterruptService
         8   -> MCI_DataErrorProcess
         8   -> MCI_FIFOInterruptService
      16   MCI_Init
        16   -> MCI_CardInit
        16   -> MCI_Set_MCIClock
        16   -> NVIC_EnableIRQ
        16   -> PINSEL_ConfigPin
       4   MCI_PowerOff
       0   MCI_RXDisable
       0   MCI_RXEnable
      24   MCI_ReadBlock
        24   -> MCI_CheckStatus
        24   -> MCI_Cmd_ReadBlock
        24   -> MCI_RXEnable
        24   -> MCI_SettingDma
       8   MCI_ReadFifo
      20   MCI_SendCmd
      64   MCI_SetBlockCount
        64   -> MCI_CheckStatus
        64   -> MCI_CmdResp
      64   MCI_SetBlockLen
        64   -> MCI_CheckStatus
        64   -> MCI_CmdResp
      72   MCI_SetBusWidth
        72   -> MCI_Acmd_SendBusWidth
        72   -> MCI_CheckStatus
        72   -> MCI_CmdResp
      48   MCI_SetCardAddress
        48   -> MCI_CmdResp
        48   -> MCI_SetOutputMode
       0   MCI_SetOutputMode
      24   MCI_Set_MCIClock
        24   -> CLKPWR_GetCLK
      56   MCI_SettingDma
        56   -> GPDMA_ChannelCmd
        56   -> GPDMA_Setup
        56   -> NVIC_EnableIRQ
       0   MCI_TXDisable
       0   MCI_TXEnable
      24   MCI_WriteBlock
        24   -> MCI_CheckStatus
        24   -> MCI_Cmd_WriteBlock
        24   -> MCI_SettingDma
        24   -> MCI_TXEnable
       8   MCI_WriteFifo
       4   NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable28
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable32
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       4  ??DataTable35
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_2
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable38
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable39_10
       4  ??DataTable39_11
       4  ??DataTable39_12
       4  ??DataTable39_13
       4  ??DataTable39_14
       4  ??DataTable39_15
       4  ??DataTable39_16
       4  ??DataTable39_17
       4  ??DataTable39_2
       4  ??DataTable39_3
       4  ??DataTable39_4
       4  ??DataTable39_5
       4  ??DataTable39_6
       4  ??DataTable39_7
       4  ??DataTable39_8
       4  ??DataTable39_9
       1  CCS
       4  CardRCA
     132  MCI_Acmd_SendBusWidth
     154  MCI_Acmd_SendOpCond
     200  MCI_CardInit
      36  MCI_CardReset
       1  MCI_CardType
      90  MCI_CheckStatus
      72  MCI_CmdProcess
      56  MCI_CmdResp
     216  MCI_Cmd_ReadBlock
     248  MCI_Cmd_SelectCard
     150  MCI_Cmd_SendACMD
     150  MCI_Cmd_SendIfCond
     108  MCI_Cmd_SendOpCond
     170  MCI_Cmd_StopTransmission
     230  MCI_Cmd_WriteBlock
      68  MCI_DATA_END_InterruptService
     166  MCI_DMA_IRQHandler
      86  MCI_DataErrorProcess
       2  MCI_FIFOInterruptService
     162  MCI_GetCID
     160  MCI_GetCSD
       8  MCI_GetCardAddress
     154  MCI_GetCardStatus
      10  MCI_GetCardType
     262  MCI_GetCmdResp
       8  MCI_GetDataXferEndState
       8  MCI_GetXferErrState
      66  MCI_IRQHandler
     616  MCI_Init
      30  MCI_PowerOff
      20  MCI_RXDisable
      20  MCI_RXEnable
     190  MCI_ReadBlock
      88  MCI_ReadFifo
     186  MCI_SendCmd
     118  MCI_SetBlockCount
     122  MCI_SetBlockLen
     272  MCI_SetBusWidth
     190  MCI_SetCardAddress
      54  MCI_SetOutputMode
      78  MCI_Set_MCIClock
     110  MCI_SettingDma
      20  MCI_TXDisable
      20  MCI_TXEnable
     190  MCI_WriteBlock
      88  MCI_WriteFifo
       4  Mci_Data_Xfer_ERR
       4  Mci_Data_Xfer_End
      26  NVIC_EnableIRQ
       4  dataDestBlock
       4  dataSrcBlock
       4  dmaRdCh_ErrorCnt
       4  dmaRdCh_TermianalCnt
       4  dmaWrCh_ErrorCnt
       4  dmaWrCh_TermianalCnt
       1  fifo_plane
       4  rxBlockCnt
       4  txBlockCnt

 
    39 bytes in section .bss
     8 bytes in section .data
 5 858 bytes in section .text
 
 5 858 bytes of CODE memory
    47 bytes of DATA memory

Errors: none
Warnings: none
