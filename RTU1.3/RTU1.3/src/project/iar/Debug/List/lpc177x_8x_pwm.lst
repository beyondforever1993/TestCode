###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:24 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source2\lpc177x_8x_pwm.c                            #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source2\lpc177x_8x_pwm.c -lCN                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\ -o D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë #
#                    \RTU_1.2\project\iar\Debug\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\lpc177x_8x_pwm.lst                         #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\lpc177x_8x_pwm.o                            #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Drivers\source2\lpc177x_8x_pwm.c
      1          /**********************************************************************
      2          * $Id$		lpc177x_8x_pwm.c			2011-06-02
      3          *//**
      4          * @file		lpc177x_8x_pwm.c
      5          * @brief	Contains all functions support for PWM firmware library
      6          *			on LPC177x_8x
      7          * @version	1.0
      8          * @date		02. June. 2011
      9          * @author	NXP MCU SW Application Team
     10          * 
     11          * Copyright(C) 2011, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          **********************************************************************/
     26          
     27          /* Peripheral group ----------------------------------------------------------- */
     28          /** @addtogroup PWM
     29           * @{
     30           */
     31          
     32          /* Includes ------------------------------------------------------------------- */
     33          #include "lpc177x_8x_pwm.h"
     34          #include "lpc177x_8x_clkpwr.h"
     35          
     36          /* Public Functions ----------------------------------------------------------- */
     37          /** @addtogroup PWM_Public_Functions
     38           * @{
     39           */
     40          
     41          static LPC_PWM_TypeDef* PWM_GetPointer (uint8_t pwmId);
     42          
     43          /*********************************************************************//**
     44           * @brief 		Setting CAN baud rate (bps)
     45           * @param[in] 	canId point to LPC_CAN_TypeDef object, should be:
     46           * 				- LPC_CAN1: CAN1 peripheral
     47           * 				- LPC_CAN2: CAN2 peripheral
     48           * @return 		The pointer to CAN peripheral that's expected to use
     49           ***********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     50          static LPC_PWM_TypeDef* PWM_GetPointer (uint8_t pwmId)
     51          {
   \                     PWM_GetPointer:
   \   00000000   0x0001             MOVS     R1,R0
     52          	LPC_PWM_TypeDef* pPwm;
     53          
     54          	switch (pwmId)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??PWM_GetPointer_0
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD003             BEQ.N    ??PWM_GetPointer_1
   \   0000000C   0xE005             B.N      ??PWM_GetPointer_2
     55          	{
     56          		case PWM_0:
     57          			pPwm = LPC_PWM0;
   \                     ??PWM_GetPointer_0:
   \   0000000E   0x....             LDR.N    R2,??DataTable1  ;; 0x40014000
   \   00000010   0x0010             MOVS     R0,R2
     58          			break;
   \   00000012   0xE004             B.N      ??PWM_GetPointer_3
     59          
     60          		case PWM_1:
     61          			pPwm = LPC_PWM1;
   \                     ??PWM_GetPointer_1:
   \   00000014   0x....             LDR.N    R2,??DataTable1_1  ;; 0x40018000
   \   00000016   0x0010             MOVS     R0,R2
     62          			break;
   \   00000018   0xE001             B.N      ??PWM_GetPointer_3
     63          
     64          		default:
     65          			pPwm = NULL;
   \                     ??PWM_GetPointer_2:
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x0010             MOVS     R0,R2
     66          			break;
     67          	}
     68          
     69          	return pPwm;
   \                     ??PWM_GetPointer_3:
   \   0000001E   0x4770             BX       LR               ;; return
     70          }
     71          
     72          
     73          /*********************************************************************//**
     74           * @brief 		Check whether specified interrupt flag in PWM is set or not
     75           * @param[in]	 pwmId			 The Id of the expected PWM component
     76           *
     77           * @param[in]	IntFlag: PWM interrupt flag, should be:
     78           * 				- PWM_INTSTAT_MR0: Interrupt flag for PWM match channel 0
     79           * 				- PWM_INTSTAT_MR1: Interrupt flag for PWM match channel 1
     80           * 				- PWM_INTSTAT_MR2: Interrupt flag for PWM match channel 2
     81           * 				- PWM_INTSTAT_MR3: Interrupt flag for PWM match channel 3
     82           * 				- PWM_INTSTAT_MR4: Interrupt flag for PWM match channel 4
     83           * 				- PWM_INTSTAT_MR5: Interrupt flag for PWM match channel 5
     84           * 				- PWM_INTSTAT_MR6: Interrupt flag for PWM match channel 6
     85           * 				- PWM_INTSTAT_CAP0: Interrupt flag for capture input 0
     86           * 				- PWM_INTSTAT_CAP1: Interrupt flag for capture input 1
     87           * @return 		New State of PWM interrupt flag (SET or RESET)
     88           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     89          IntStatus PWM_GetIntStatus(uint8_t pwmId, uint32_t IntFlag)
     90          {
   \                     PWM_GetIntStatus:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     91          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       PWM_GetPointer
     92          
     93          	return ((pPwm->IR & IntFlag) ? SET : RESET);
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x4228             TST      R0,R5
   \   00000012   0xD001             BEQ.N    ??PWM_GetIntStatus_0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B.N      ??PWM_GetIntStatus_1
   \                     ??PWM_GetIntStatus_0:
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??PWM_GetIntStatus_1:
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     94          }
     95          
     96          
     97          
     98          /*********************************************************************//**
     99           * @brief 		Clear specified PWM Interrupt pending
    100           * @param[in]	 pwmId			 The Id of the expected PWM component
    101           *
    102           * @param[in]	IntFlag: PWM interrupt flag, should be:
    103           * 				- PWM_INTSTAT_MR0: Interrupt flag for PWM match channel 0
    104           * 				- PWM_INTSTAT_MR1: Interrupt flag for PWM match channel 1
    105           * 				- PWM_INTSTAT_MR2: Interrupt flag for PWM match channel 2
    106           * 				- PWM_INTSTAT_MR3: Interrupt flag for PWM match channel 3
    107           * 				- PWM_INTSTAT_MR4: Interrupt flag for PWM match channel 4
    108           * 				- PWM_INTSTAT_MR5: Interrupt flag for PWM match channel 5
    109           * 				- PWM_INTSTAT_MR6: Interrupt flag for PWM match channel 6
    110           * 				- PWM_INTSTAT_CAP0: Interrupt flag for capture input 0
    111           * 				- PWM_INTSTAT_CAP1: Interrupt flag for capture input 1
    112           * @return 		None
    113           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    114          void PWM_ClearIntPending(uint8_t pwmId, uint32_t IntFlag)
    115          {
   \                     PWM_ClearIntPending:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    116          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       PWM_GetPointer
    117          
    118          	pPwm->IR = IntFlag;
   \   0000000E   0x6005             STR      R5,[R0, #+0]
    119          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    120          
    121          
    122          
    123          /*****************************************************************************//**
    124          * @brief		Fills each PWM_InitStruct member with its default value:
    125          * 				- If PWMCounterMode = PWM_MODE_TIMER:
    126          * 					+ PrescaleOption = PWM_TIMER_PRESCALE_USVAL
    127          * 					+ PrescaleValue = 1
    128          * 				- If PWMCounterMode = PWM_MODE_COUNTER:
    129          * 					+ CountInputSelect = PWM_COUNTER_PCAP1_0
    130          * 					+ CounterOption = PWM_COUNTER_RISING
    131          * @param[in]	PWMTimerCounterMode Timer or Counter mode, should be:
    132          * 				- PWM_MODE_TIMER: Counter of PWM peripheral is in Timer mode
    133          * 				- PWM_MODE_COUNTER: Counter of PWM peripheral is in Counter mode
    134          * @param[in]	PWM_InitStruct Pointer to structure (PWM_TIMERCFG_Type or
    135          * 				 PWM_COUNTERCFG_Type) which will be initialized.
    136          * @return		None
    137          * Note: PWM_InitStruct pointer will be assigned to corresponding structure
    138          * 		(PWM_TIMERCFG_Type or PWM_COUNTERCFG_Type) due to PWMTimerCounterMode.
    139          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    140          void PWM_ConfigStructInit(uint8_t PWMTimerCounterMode, void *PWM_InitStruct)
    141          {
   \                     PWM_ConfigStructInit:
   \   00000000   0xB410             PUSH     {R4}
    142          	PWM_TIMERCFG_Type *pTimeCfg;
    143          	PWM_COUNTERCFG_Type *pCounterCfg;
    144          
    145          	pTimeCfg = (PWM_TIMERCFG_Type *) PWM_InitStruct;
   \   00000002   0x000A             MOVS     R2,R1
    146          	pCounterCfg = (PWM_COUNTERCFG_Type *) PWM_InitStruct;
   \   00000004   0x000B             MOVS     R3,R1
    147          
    148          	if (PWMTimerCounterMode == PWM_MODE_TIMER )
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD104             BNE.N    ??PWM_ConfigStructInit_0
    149          	{
    150          		pTimeCfg->PrescaleOption = PWM_TIMER_PRESCALE_USVAL;
   \   0000000C   0x2401             MOVS     R4,#+1
   \   0000000E   0x7014             STRB     R4,[R2, #+0]
    151          		pTimeCfg->PrescaleValue = 1;
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0x6054             STR      R4,[R2, #+4]
   \   00000014   0xE006             B.N      ??PWM_ConfigStructInit_1
    152          	}
    153          	else if (PWMTimerCounterMode == PWM_MODE_COUNTER)
   \                     ??PWM_ConfigStructInit_0:
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD103             BNE.N    ??PWM_ConfigStructInit_1
    154          	{
    155          		pCounterCfg->CountInputSelect = PWM_COUNTER_PCAP1_0;
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0x705C             STRB     R4,[R3, #+1]
    156          		pCounterCfg->CounterOption = PWM_COUNTER_RISING;
   \   00000020   0x2401             MOVS     R4,#+1
   \   00000022   0x701C             STRB     R4,[R3, #+0]
    157          	}
    158          }
   \                     ??PWM_ConfigStructInit_1:
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return
    159          
    160          
    161          /*********************************************************************//**
    162           * @brief 		Initializes the pPwm peripheral corresponding to the specified
    163           *               parameters in the PWM_ConfigStruct.
    164           * @param[in]	 pwmId			 The Id of the expected PWM component
    165           *
    166           *
    167           * @param[in]	PWMTimerCounterMode Timer or Counter mode, should be:
    168           * 				- PWM_MODE_TIMER: Counter of PWM peripheral is in Timer mode
    169           * 				- PWM_MODE_COUNTER: Counter of PWM peripheral is in Counter mode
    170           * @param[in]	PWM_ConfigStruct Pointer to structure (PWM_TIMERCFG_Type or
    171           * 				 PWM_COUNTERCFG_Type) which will be initialized.
    172           * @return 		None
    173           * Note: PWM_ConfigStruct pointer will be assigned to corresponding structure
    174           * 		(PWM_TIMERCFG_Type or PWM_COUNTERCFG_Type) due to PWMTimerCounterMode.
    175           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    176          void PWM_Init(uint8_t pwmId, uint32_t PWMTimerCounterMode, void *PWM_ConfigStruct)
    177          {
   \                     PWM_Init:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x468A             MOV      R10,R1
   \   00000008   0x4691             MOV      R9,R2
    178          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   0000000A   0x0030             MOVS     R0,R6
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       PWM_GetPointer
   \   00000012   0x0007             MOVS     R7,R0
    179          
    180          	PWM_TIMERCFG_Type *pTimeCfg;
    181          	PWM_COUNTERCFG_Type *pCounterCfg;
    182          	uint64_t clkdlycnt;
    183          
    184          	pTimeCfg = (PWM_TIMERCFG_Type *)PWM_ConfigStruct;
   \   00000014   0x46C8             MOV      R8,R9
    185          	pCounterCfg = (PWM_COUNTERCFG_Type *)PWM_ConfigStruct;
   \   00000016   0x46CB             MOV      R11,R9
    186          
    187          	if(pwmId == PWM_0)
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD104             BNE.N    ??PWM_Init_0
    188          	{
    189          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM0, ENABLE);
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x2020             MOVS     R0,#+32
   \   00000022   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000026   0xE008             B.N      ??PWM_Init_1
    190          	}
    191          	else if(pwmId == PWM_1)
   \                     ??PWM_Init_0:
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x2E01             CMP      R6,#+1
   \   0000002C   0xD104             BNE.N    ??PWM_Init_2
    192          	{
    193          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM1, ENABLE);
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x2040             MOVS     R0,#+64
   \   00000032   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000036   0xE000             B.N      ??PWM_Init_1
    194          	}
    195          	else
    196          	{
    197          		//Trap the error
    198          		while(1);
   \                     ??PWM_Init_2:
   \   00000038   0xE7FE             B.N      ??PWM_Init_2
    199          		return;
    200          	}
    201          
    202          	// Get peripheral clock of PWM1
    203          	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
   \                     ??PWM_Init_1:
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       CLKPWR_GetCLK
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x0004             MOVS     R4,R0
   \   00000044   0x000D             MOVS     R5,R1
    204          
    205          	// Clear all interrupts pending
    206          	pPwm->IR = 0xFF & PWM_IR_BITMASK;
   \   00000046   0x203F             MOVS     R0,#+63
   \   00000048   0x6038             STR      R0,[R7, #+0]
    207          	pPwm->TCR = 0x00;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6078             STR      R0,[R7, #+4]
    208          	pPwm->CTCR = 0x00;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x6738             STR      R0,[R7, #+112]
    209          	pPwm->MCR = 0x00;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6178             STR      R0,[R7, #+20]
    210          	pPwm->CCR = 0x00;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x62B8             STR      R0,[R7, #+40]
    211          	pPwm->PCR = 0x00;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x64F8             STR      R0,[R7, #+76]
    212          	pPwm->LER = 0x00;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x6538             STR      R0,[R7, #+80]
    213          
    214          	if (PWMTimerCounterMode == PWM_MODE_TIMER)
   \   00000062   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000066   0xD11A             BNE.N    ??PWM_Init_3
    215          	{
    216          		/* Absolute prescale value */
    217          		if (pTimeCfg->PrescaleOption == PWM_TIMER_PRESCALE_TICKVAL)
   \   00000068   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD104             BNE.N    ??PWM_Init_4
    218          		{
    219          			pPwm->PR   = pTimeCfg->PrescaleValue - 1;
   \   00000070   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x60F8             STR      R0,[R7, #+12]
   \   00000078   0xE021             B.N      ??PWM_Init_5
    220          		}
    221          		/* uSecond prescale value */
    222          		else
    223          		{
    224          			clkdlycnt = (clkdlycnt * pTimeCfg->PrescaleValue) / 1000000;
   \                     ??PWM_Init_4:
   \   0000007A   0xF8D8 0x2004      LDR      R2,[R8, #+4]
   \   0000007E   0x2300             MOVS     R3,#+0
   \   00000080   0xFBA2 0x0104      UMULL    R0,R1,R2,R4
   \   00000084   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000088   0xFB03 0x1104      MLA      R1,R3,R4,R1
   \   0000008C   0x....             LDR.N    R2,??DataTable1_2  ;; 0xf4240
   \   0000008E   0x2300             MOVS     R3,#+0
   \   00000090   0x.... 0x....      BL       __aeabi_uldivmod
   \   00000094   0x0004             MOVS     R4,R0
   \   00000096   0x000D             MOVS     R5,R1
    225          			pPwm->PR = ((uint32_t) clkdlycnt) - 1;
   \   00000098   0x1E60             SUBS     R0,R4,#+1
   \   0000009A   0x60F8             STR      R0,[R7, #+12]
   \   0000009C   0xE00F             B.N      ??PWM_Init_5
    226          		}
    227          
    228          	}
    229          	else if (PWMTimerCounterMode == PWM_MODE_COUNTER)
   \                     ??PWM_Init_3:
   \   0000009E   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000A2   0xD10C             BNE.N    ??PWM_Init_5
    230          	{
    231          
    232          		pPwm->CTCR |= (PWM_CTCR_MODE((uint32_t)pCounterCfg->CounterOption)) \
    233          						| (PWM_CTCR_SELECT_INPUT((uint32_t)pCounterCfg->CountInputSelect));
   \   000000A4   0x6F38             LDR      R0,[R7, #+112]
   \   000000A6   0xF89B 0x1000      LDRB     R1,[R11, #+0]
   \   000000AA   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   000000AE   0xF89B 0x2001      LDRB     R2,[R11, #+1]
   \   000000B2   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   000000B6   0xEA51 0x0182      ORRS     R1,R1,R2, LSL #+2
   \   000000BA   0x4308             ORRS     R0,R1,R0
   \   000000BC   0x6738             STR      R0,[R7, #+112]
    234          	}
    235          }
   \                     ??PWM_Init_5:
   \   000000BE   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    236          
    237          /*********************************************************************//**
    238           * @brief		De-initializes the PWM peripheral registers to their
    239          *                  default reset values.
    240           * @param[in]	 pwmId			 The Id of the expected PWM component
    241           *
    242           * @return 		None
    243           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    244          void PWM_DeInit (uint8_t pwmId)
    245          {
   \                     PWM_DeInit:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    246          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       PWM_GetPointer
   \   0000000C   0x0005             MOVS     R5,R0
    247          
    248          	// Disable PWM control (timer, counter and PWM)
    249          	pPwm->TCR = 0x00;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x6068             STR      R0,[R5, #+4]
    250          
    251          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM1, DISABLE);
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x2040             MOVS     R0,#+64
   \   00000016   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    252          }
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    253          
    254          
    255          /*********************************************************************//**
    256           * @brief	 	Enable/Disable PWM peripheral
    257           * @param[in]	 pwmId			 The Id of the expected PWM component
    258           *
    259           * @param[in]	NewState	New State of this function, should be:
    260           * 							- ENABLE: Enable PWM peripheral
    261           * 							- DISABLE: Disable PWM peripheral
    262           * @return 		None
    263           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    264          void PWM_Cmd(uint8_t pwmId, FunctionalState NewState)
    265          {
   \                     PWM_Cmd:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    266          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       PWM_GetPointer
    267          
    268          	if (NewState == ENABLE)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xD104             BNE.N    ??PWM_Cmd_0
    269          	{
    270          		pPwm->TCR	|=  PWM_TCR_PWM_ENABLE;
   \   00000014   0x6841             LDR      R1,[R0, #+4]
   \   00000016   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   0000001A   0x6041             STR      R1,[R0, #+4]
   \   0000001C   0xE003             B.N      ??PWM_Cmd_1
    271          	}
    272          	else
    273          	{
    274          		pPwm->TCR &= (~PWM_TCR_PWM_ENABLE) & PWM_TCR_BITMASK;
   \                     ??PWM_Cmd_0:
   \   0000001E   0x6841             LDR      R1,[R0, #+4]
   \   00000020   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   00000024   0x6041             STR      R1,[R0, #+4]
    275          	}
    276          }
   \                     ??PWM_Cmd_1:
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    277          
    278          
    279          /*********************************************************************//**
    280           * @brief 		Enable/Disable Counter in PWM peripheral
    281           * @param[in]	 pwmId			 The Id of the expected PWM component
    282           *
    283           * @param[in]	NewState New State of this function, should be:
    284           * 							- ENABLE: Enable Counter in PWM peripheral
    285           * 							- DISABLE: Disable Counter in PWM peripheral
    286           * @return 		None
    287           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    288          void PWM_CounterCmd(uint8_t pwmId, FunctionalState NewState)
    289          {
   \                     PWM_CounterCmd:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    290          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       PWM_GetPointer
    291          
    292          	if (NewState == ENABLE)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xD104             BNE.N    ??PWM_CounterCmd_0
    293          	{
    294          		pPwm->TCR	|=  PWM_TCR_COUNTER_ENABLE;
   \   00000014   0x6841             LDR      R1,[R0, #+4]
   \   00000016   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000001A   0x6041             STR      R1,[R0, #+4]
   \   0000001C   0xE003             B.N      ??PWM_CounterCmd_1
    295          	}
    296          	else
    297          	{
    298          		pPwm->TCR &= (~PWM_TCR_COUNTER_ENABLE) & PWM_TCR_BITMASK;
   \                     ??PWM_CounterCmd_0:
   \   0000001E   0x6841             LDR      R1,[R0, #+4]
   \   00000020   0xF011 0x010A      ANDS     R1,R1,#0xA
   \   00000024   0x6041             STR      R1,[R0, #+4]
    299          	}
    300          }
   \                     ??PWM_CounterCmd_1:
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    301          
    302          
    303          /*********************************************************************//**
    304           * @brief 		Reset Counter in PWM peripheral
    305           * @param[in]	 pwmId			 The Id of the expected PWM component
    306           *
    307           * @return 		None
    308           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    309          void PWM_ResetCounter(uint8_t pwmId)
    310          {
   \                     PWM_ResetCounter:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    311          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       PWM_GetPointer
    312          
    313          	pPwm->TCR |= PWM_TCR_COUNTER_RESET;
   \   0000000C   0x6841             LDR      R1,[R0, #+4]
   \   0000000E   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000012   0x6041             STR      R1,[R0, #+4]
    314          
    315          	pPwm->TCR &= (~PWM_TCR_COUNTER_RESET) & PWM_TCR_BITMASK;
   \   00000014   0x6841             LDR      R1,[R0, #+4]
   \   00000016   0xF011 0x0109      ANDS     R1,R1,#0x9
   \   0000001A   0x6041             STR      R1,[R0, #+4]
    316          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    317          
    318          
    319          /*********************************************************************//**
    320           * @brief 		Configures match for PWM peripheral
    321           * @param[in]	 pwmId			 The Id of the expected PWM component
    322           *
    323           * @param[in]   PWM_MatchConfigStruct	Pointer to a PWM_MATCHCFG_Type structure
    324          *                    that contains the configuration information for the
    325          *                    specified PWM match function.
    326           * @return 		None
    327           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    328          void PWM_ConfigMatch(uint8_t pwmId, PWM_MATCHCFG_Type *PWM_MatchConfigStruct)
    329          {
   \                     PWM_ConfigMatch:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    330          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       PWM_GetPointer
    331          
    332          	//interrupt on MRn
    333          	if (PWM_MatchConfigStruct->IntOnMatch == ENABLE)
   \   0000000E   0x7869             LDRB     R1,[R5, #+1]
   \   00000010   0x2901             CMP      R1,#+1
   \   00000012   0xD10D             BNE.N    ??PWM_ConfigMatch_0
    334          	{
    335          		pPwm->MCR |= PWM_MCR_INT_ON_MATCH(PWM_MatchConfigStruct->MatchChannel);
   \   00000014   0x6941             LDR      R1,[R0, #+20]
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x782B             LDRB     R3,[R5, #+0]
   \   0000001A   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   0000001E   0x782E             LDRB     R6,[R5, #+0]
   \   00000020   0xF016 0x0607      ANDS     R6,R6,#0x7
   \   00000024   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   00000028   0x409A             LSLS     R2,R2,R3
   \   0000002A   0x4311             ORRS     R1,R2,R1
   \   0000002C   0x6141             STR      R1,[R0, #+20]
   \   0000002E   0xE00F             B.N      ??PWM_ConfigMatch_1
    336          	}
    337          	else
    338          	{
    339          		pPwm->MCR &= (~ PWM_MCR_INT_ON_MATCH(PWM_MatchConfigStruct->MatchChannel)) \
    340          																		& PWM_MCR_BITMASK;
   \                     ??PWM_ConfigMatch_0:
   \   00000030   0x6941             LDR      R1,[R0, #+20]
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x782B             LDRB     R3,[R5, #+0]
   \   00000036   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   0000003A   0x782E             LDRB     R6,[R5, #+0]
   \   0000003C   0xF016 0x0607      ANDS     R6,R6,#0x7
   \   00000040   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   00000044   0x409A             LSLS     R2,R2,R3
   \   00000046   0x43D2             MVNS     R2,R2
   \   00000048   0x02D2             LSLS     R2,R2,#+11       ;; ZeroExtS R2,R2,#+11,#+11
   \   0000004A   0x0AD2             LSRS     R2,R2,#+11
   \   0000004C   0x4011             ANDS     R1,R2,R1
   \   0000004E   0x6141             STR      R1,[R0, #+20]
    341          	}
    342          
    343          	//reset on MRn
    344          	if (PWM_MatchConfigStruct->ResetOnMatch == ENABLE)
   \                     ??PWM_ConfigMatch_1:
   \   00000050   0x78E9             LDRB     R1,[R5, #+3]
   \   00000052   0x2901             CMP      R1,#+1
   \   00000054   0xD10E             BNE.N    ??PWM_ConfigMatch_2
    345          	{
    346          		pPwm->MCR |= PWM_MCR_RESET_ON_MATCH(PWM_MatchConfigStruct->MatchChannel);
   \   00000056   0x6941             LDR      R1,[R0, #+20]
   \   00000058   0x2201             MOVS     R2,#+1
   \   0000005A   0x782B             LDRB     R3,[R5, #+0]
   \   0000005C   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   00000060   0x782E             LDRB     R6,[R5, #+0]
   \   00000062   0xF016 0x0607      ANDS     R6,R6,#0x7
   \   00000066   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   0000006A   0x1C5B             ADDS     R3,R3,#+1
   \   0000006C   0x409A             LSLS     R2,R2,R3
   \   0000006E   0x4311             ORRS     R1,R2,R1
   \   00000070   0x6141             STR      R1,[R0, #+20]
   \   00000072   0xE010             B.N      ??PWM_ConfigMatch_3
    347          	}
    348          	else
    349          	{
    350          		pPwm->MCR &= (~ PWM_MCR_RESET_ON_MATCH(PWM_MatchConfigStruct->MatchChannel)) \
    351          																		& PWM_MCR_BITMASK;
   \                     ??PWM_ConfigMatch_2:
   \   00000074   0x6941             LDR      R1,[R0, #+20]
   \   00000076   0x2201             MOVS     R2,#+1
   \   00000078   0x782B             LDRB     R3,[R5, #+0]
   \   0000007A   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   0000007E   0x782E             LDRB     R6,[R5, #+0]
   \   00000080   0xF016 0x0607      ANDS     R6,R6,#0x7
   \   00000084   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   00000088   0x1C5B             ADDS     R3,R3,#+1
   \   0000008A   0x409A             LSLS     R2,R2,R3
   \   0000008C   0x43D2             MVNS     R2,R2
   \   0000008E   0x02D2             LSLS     R2,R2,#+11       ;; ZeroExtS R2,R2,#+11,#+11
   \   00000090   0x0AD2             LSRS     R2,R2,#+11
   \   00000092   0x4011             ANDS     R1,R2,R1
   \   00000094   0x6141             STR      R1,[R0, #+20]
    352          	}
    353          
    354          	//stop on MRn
    355          	if (PWM_MatchConfigStruct->StopOnMatch == ENABLE)
   \                     ??PWM_ConfigMatch_3:
   \   00000096   0x78A9             LDRB     R1,[R5, #+2]
   \   00000098   0x2901             CMP      R1,#+1
   \   0000009A   0xD10E             BNE.N    ??PWM_ConfigMatch_4
    356          	{
    357          		pPwm->MCR |= PWM_MCR_STOP_ON_MATCH(PWM_MatchConfigStruct->MatchChannel);
   \   0000009C   0x6941             LDR      R1,[R0, #+20]
   \   0000009E   0x2201             MOVS     R2,#+1
   \   000000A0   0x782B             LDRB     R3,[R5, #+0]
   \   000000A2   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   000000A6   0x782E             LDRB     R6,[R5, #+0]
   \   000000A8   0xF016 0x0607      ANDS     R6,R6,#0x7
   \   000000AC   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   000000B0   0x1C9B             ADDS     R3,R3,#+2
   \   000000B2   0x409A             LSLS     R2,R2,R3
   \   000000B4   0x4311             ORRS     R1,R2,R1
   \   000000B6   0x6141             STR      R1,[R0, #+20]
   \   000000B8   0xE010             B.N      ??PWM_ConfigMatch_5
    358          	}
    359          	else
    360          	{
    361          		pPwm->MCR &= (~ PWM_MCR_STOP_ON_MATCH(PWM_MatchConfigStruct->MatchChannel)) \
    362          																		& PWM_MCR_BITMASK;
   \                     ??PWM_ConfigMatch_4:
   \   000000BA   0x6941             LDR      R1,[R0, #+20]
   \   000000BC   0x2201             MOVS     R2,#+1
   \   000000BE   0x782B             LDRB     R3,[R5, #+0]
   \   000000C0   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   000000C4   0x782E             LDRB     R6,[R5, #+0]
   \   000000C6   0xF016 0x0607      ANDS     R6,R6,#0x7
   \   000000CA   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   000000CE   0x1C9B             ADDS     R3,R3,#+2
   \   000000D0   0x409A             LSLS     R2,R2,R3
   \   000000D2   0x43D2             MVNS     R2,R2
   \   000000D4   0x02D2             LSLS     R2,R2,#+11       ;; ZeroExtS R2,R2,#+11,#+11
   \   000000D6   0x0AD2             LSRS     R2,R2,#+11
   \   000000D8   0x4011             ANDS     R1,R2,R1
   \   000000DA   0x6141             STR      R1,[R0, #+20]
    363          	}
    364          }
   \                     ??PWM_ConfigMatch_5:
   \   000000DC   0xBD70             POP      {R4-R6,PC}       ;; return
    365          
    366          
    367          /*********************************************************************//**
    368           * @brief 		Configures capture input for PWM peripheral
    369           * @param[in]	 pwmId			 The Id of the expected PWM component
    370           *
    371           * @param[in]   PWM_CaptureConfigStruct	Pointer to a PWM_CAPTURECFG_Type structure
    372           *                    that contains the configuration information for the
    373           *                    specified PWM capture input function.
    374           * @return 		None
    375           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    376          void PWM_ConfigCapture(uint8_t pwmId, PWM_CAPTURECFG_Type *PWM_CaptureConfigStruct)
    377          {
   \                     PWM_ConfigCapture:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    378          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       PWM_GetPointer
    379          
    380          	if (PWM_CaptureConfigStruct->RisingEdge == ENABLE)
   \   0000000E   0x7869             LDRB     R1,[R5, #+1]
   \   00000010   0x2901             CMP      R1,#+1
   \   00000012   0xD10D             BNE.N    ??PWM_ConfigCapture_0
    381          	{
    382          		pPwm->CCR |= PWM_CCR_CAP_RISING(PWM_CaptureConfigStruct->CaptureChannel);
   \   00000014   0x6A81             LDR      R1,[R0, #+40]
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x782B             LDRB     R3,[R5, #+0]
   \   0000001A   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   0000001E   0x782E             LDRB     R6,[R5, #+0]
   \   00000020   0xF016 0x0601      ANDS     R6,R6,#0x1
   \   00000024   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   00000028   0x409A             LSLS     R2,R2,R3
   \   0000002A   0x4311             ORRS     R1,R2,R1
   \   0000002C   0x6281             STR      R1,[R0, #+40]
   \   0000002E   0xE00F             B.N      ??PWM_ConfigCapture_1
    383          	}
    384          	else
    385          	{
    386          		pPwm->CCR &= (~ PWM_CCR_CAP_RISING(PWM_CaptureConfigStruct->CaptureChannel)) \
    387          																		& PWM_CCR_BITMASK;
   \                     ??PWM_ConfigCapture_0:
   \   00000030   0x6A81             LDR      R1,[R0, #+40]
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x782B             LDRB     R3,[R5, #+0]
   \   00000036   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   0000003A   0x782E             LDRB     R6,[R5, #+0]
   \   0000003C   0xF016 0x0601      ANDS     R6,R6,#0x1
   \   00000040   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   00000044   0x409A             LSLS     R2,R2,R3
   \   00000046   0x43D2             MVNS     R2,R2
   \   00000048   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   0000004C   0x4011             ANDS     R1,R2,R1
   \   0000004E   0x6281             STR      R1,[R0, #+40]
    388          	}
    389          
    390          	if (PWM_CaptureConfigStruct->FallingEdge == ENABLE)
   \                     ??PWM_ConfigCapture_1:
   \   00000050   0x78A9             LDRB     R1,[R5, #+2]
   \   00000052   0x2901             CMP      R1,#+1
   \   00000054   0xD10E             BNE.N    ??PWM_ConfigCapture_2
    391          	{
    392          		pPwm->CCR |= PWM_CCR_CAP_FALLING(PWM_CaptureConfigStruct->CaptureChannel);
   \   00000056   0x6A81             LDR      R1,[R0, #+40]
   \   00000058   0x2201             MOVS     R2,#+1
   \   0000005A   0x782B             LDRB     R3,[R5, #+0]
   \   0000005C   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   00000060   0x782E             LDRB     R6,[R5, #+0]
   \   00000062   0xF016 0x0601      ANDS     R6,R6,#0x1
   \   00000066   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   0000006A   0x1C5B             ADDS     R3,R3,#+1
   \   0000006C   0x409A             LSLS     R2,R2,R3
   \   0000006E   0x4311             ORRS     R1,R2,R1
   \   00000070   0x6281             STR      R1,[R0, #+40]
   \   00000072   0xE010             B.N      ??PWM_ConfigCapture_3
    393          	}
    394          	else
    395          	{
    396          		pPwm->CCR &= (~ PWM_CCR_CAP_FALLING(PWM_CaptureConfigStruct->CaptureChannel)) \
    397          																		& PWM_CCR_BITMASK;
   \                     ??PWM_ConfigCapture_2:
   \   00000074   0x6A81             LDR      R1,[R0, #+40]
   \   00000076   0x2201             MOVS     R2,#+1
   \   00000078   0x782B             LDRB     R3,[R5, #+0]
   \   0000007A   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   0000007E   0x782E             LDRB     R6,[R5, #+0]
   \   00000080   0xF016 0x0601      ANDS     R6,R6,#0x1
   \   00000084   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   00000088   0x1C5B             ADDS     R3,R3,#+1
   \   0000008A   0x409A             LSLS     R2,R2,R3
   \   0000008C   0x43D2             MVNS     R2,R2
   \   0000008E   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   00000092   0x4011             ANDS     R1,R2,R1
   \   00000094   0x6281             STR      R1,[R0, #+40]
    398          	}
    399          
    400          	if (PWM_CaptureConfigStruct->IntOnCaption == ENABLE)
   \                     ??PWM_ConfigCapture_3:
   \   00000096   0x78E9             LDRB     R1,[R5, #+3]
   \   00000098   0x2901             CMP      R1,#+1
   \   0000009A   0xD10E             BNE.N    ??PWM_ConfigCapture_4
    401          	{
    402          		pPwm->CCR |= PWM_CCR_INT_ON_CAP(PWM_CaptureConfigStruct->CaptureChannel);
   \   0000009C   0x6A81             LDR      R1,[R0, #+40]
   \   0000009E   0x2201             MOVS     R2,#+1
   \   000000A0   0x782B             LDRB     R3,[R5, #+0]
   \   000000A2   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   000000A6   0x782E             LDRB     R6,[R5, #+0]
   \   000000A8   0xF016 0x0601      ANDS     R6,R6,#0x1
   \   000000AC   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   000000B0   0x1C9B             ADDS     R3,R3,#+2
   \   000000B2   0x409A             LSLS     R2,R2,R3
   \   000000B4   0x4311             ORRS     R1,R2,R1
   \   000000B6   0x6281             STR      R1,[R0, #+40]
   \   000000B8   0xE010             B.N      ??PWM_ConfigCapture_5
    403          	}
    404          	else
    405          	{
    406          		pPwm->CCR &= (~ PWM_CCR_INT_ON_CAP(PWM_CaptureConfigStruct->CaptureChannel)) \
    407          																		& PWM_CCR_BITMASK;
   \                     ??PWM_ConfigCapture_4:
   \   000000BA   0x6A81             LDR      R1,[R0, #+40]
   \   000000BC   0x2201             MOVS     R2,#+1
   \   000000BE   0x782B             LDRB     R3,[R5, #+0]
   \   000000C0   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   000000C4   0x782E             LDRB     R6,[R5, #+0]
   \   000000C6   0xF016 0x0601      ANDS     R6,R6,#0x1
   \   000000CA   0xEB16 0x0343      ADDS     R3,R6,R3, LSL #+1
   \   000000CE   0x1C9B             ADDS     R3,R3,#+2
   \   000000D0   0x409A             LSLS     R2,R2,R3
   \   000000D2   0x43D2             MVNS     R2,R2
   \   000000D4   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   000000D8   0x4011             ANDS     R1,R2,R1
   \   000000DA   0x6281             STR      R1,[R0, #+40]
    408          	}
    409          }
   \                     ??PWM_ConfigCapture_5:
   \   000000DC   0xBD70             POP      {R4-R6,PC}       ;; return
    410          
    411          
    412          /*********************************************************************//**
    413           * @brief 		Read value of capture register PWM peripheral
    414           * @param[in]	 pwmId			 The Id of the expected PWM component
    415           *
    416           * @param[in]	CaptureChannel: capture channel number, should be in
    417           * 				range 0 to 1
    418           * @return 		Value of capture register
    419           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    420          uint32_t PWM_GetCaptureValue(uint8_t pwmId, uint8_t CaptureChannel)
    421          {
   \                     PWM_GetCaptureValue:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    422          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       PWM_GetPointer
   \   0000000E   0x0001             MOVS     R1,R0
    423          
    424          	switch (CaptureChannel)
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD002             BEQ.N    ??PWM_GetCaptureValue_0
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD002             BEQ.N    ??PWM_GetCaptureValue_1
   \   0000001A   0xE003             B.N      ??PWM_GetCaptureValue_2
    425          	{
    426          		case 0:
    427          			return pPwm->CR0;
   \                     ??PWM_GetCaptureValue_0:
   \   0000001C   0x6AC8             LDR      R0,[R1, #+44]
   \   0000001E   0xE002             B.N      ??PWM_GetCaptureValue_3
    428          
    429          		case 1:
    430          			return pPwm->CR1;
   \                     ??PWM_GetCaptureValue_1:
   \   00000020   0x6B08             LDR      R0,[R1, #+48]
   \   00000022   0xE000             B.N      ??PWM_GetCaptureValue_3
    431          
    432          		default:
    433          			return (0);
   \                     ??PWM_GetCaptureValue_2:
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??PWM_GetCaptureValue_3:
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    434          	}
    435          }
    436          
    437          
    438          /********************************************************************//**
    439           * @brief 		Update value for each PWM channel with update type option
    440           * @param[in]	 pwmId			 The Id of the expected PWM component
    441           *
    442           * @param[in]	MatchChannel Match channel
    443           * @param[in]	MatchValue Match value
    444           * @param[in]	UpdateType Type of Update, should be:
    445           * 				- PWM_MATCH_UPDATE_NOW: The update value will be updated for
    446           * 					this channel immediately
    447           * 				- PWM_MATCH_UPDATE_NEXT_RST: The update value will be updated for
    448           * 					this channel on next reset by a PWM Match event.
    449           * @return		None
    450           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    451          void PWM_MatchUpdate(uint8_t pwmId, uint8_t MatchChannel,
    452          										uint32_t MatchValue, uint8_t UpdateType)
    453          {
   \                     PWM_MatchUpdate:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    454          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       PWM_GetPointer
    455          
    456          	switch (MatchChannel)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD009             BEQ.N    ??PWM_MatchUpdate_0
   \   00000018   0x2D02             CMP      R5,#+2
   \   0000001A   0xD00B             BEQ.N    ??PWM_MatchUpdate_1
   \   0000001C   0xD308             BCC.N    ??PWM_MatchUpdate_2
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xD00C             BEQ.N    ??PWM_MatchUpdate_3
   \   00000022   0xD309             BCC.N    ??PWM_MatchUpdate_4
   \   00000024   0x2D06             CMP      R5,#+6
   \   00000026   0xD00D             BEQ.N    ??PWM_MatchUpdate_5
   \   00000028   0xD30A             BCC.N    ??PWM_MatchUpdate_6
   \   0000002A   0xE00C             B.N      ??PWM_MatchUpdate_7
    457          	{
    458          		case 0:
    459          			pPwm->MR0 = MatchValue;
   \                     ??PWM_MatchUpdate_0:
   \   0000002C   0x6186             STR      R6,[R0, #+24]
    460          			break;
   \   0000002E   0xE00A             B.N      ??PWM_MatchUpdate_7
    461          
    462          		case 1:
    463          			pPwm->MR1 = MatchValue;
   \                     ??PWM_MatchUpdate_2:
   \   00000030   0x61C6             STR      R6,[R0, #+28]
    464          			break;
   \   00000032   0xE008             B.N      ??PWM_MatchUpdate_7
    465          
    466          		case 2:
    467          			pPwm->MR2 = MatchValue;
   \                     ??PWM_MatchUpdate_1:
   \   00000034   0x6206             STR      R6,[R0, #+32]
    468          			break;
   \   00000036   0xE006             B.N      ??PWM_MatchUpdate_7
    469          
    470          		case 3:
    471          			pPwm->MR3 = MatchValue;
   \                     ??PWM_MatchUpdate_4:
   \   00000038   0x6246             STR      R6,[R0, #+36]
    472          			break;
   \   0000003A   0xE004             B.N      ??PWM_MatchUpdate_7
    473          
    474          		case 4:
    475          			pPwm->MR4 = MatchValue;
   \                     ??PWM_MatchUpdate_3:
   \   0000003C   0x6406             STR      R6,[R0, #+64]
    476          			break;
   \   0000003E   0xE002             B.N      ??PWM_MatchUpdate_7
    477          
    478          		case 5:
    479          			pPwm->MR5 = MatchValue;
   \                     ??PWM_MatchUpdate_6:
   \   00000040   0x6446             STR      R6,[R0, #+68]
    480          			break;
   \   00000042   0xE000             B.N      ??PWM_MatchUpdate_7
    481          
    482          		case 6:
    483          			pPwm->MR6 = MatchValue;
   \                     ??PWM_MatchUpdate_5:
   \   00000044   0x6486             STR      R6,[R0, #+72]
    484          			break;
    485          	}
    486          
    487          	// Write Latch register
    488          	pPwm->LER |= PWM_LER_EN_MATCHn_LATCH(MatchChannel);
   \                     ??PWM_MatchUpdate_7:
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D07             CMP      R5,#+7
   \   0000004A   0xDA02             BGE.N    ??PWM_MatchUpdate_8
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x40A9             LSLS     R1,R1,R5
   \   00000050   0xE000             B.N      ??PWM_MatchUpdate_9
   \                     ??PWM_MatchUpdate_8:
   \   00000052   0x2100             MOVS     R1,#+0
   \                     ??PWM_MatchUpdate_9:
   \   00000054   0x6D02             LDR      R2,[R0, #+80]
   \   00000056   0x4311             ORRS     R1,R1,R2
   \   00000058   0x6501             STR      R1,[R0, #+80]
    489          
    490          	// In case of update now
    491          	if (UpdateType == PWM_MATCH_UPDATE_NOW)
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0x2F00             CMP      R7,#+0
   \   0000005E   0xD107             BNE.N    ??PWM_MatchUpdate_10
    492          	{
    493          		pPwm->TCR |= PWM_TCR_COUNTER_RESET;
   \   00000060   0x6841             LDR      R1,[R0, #+4]
   \   00000062   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000066   0x6041             STR      R1,[R0, #+4]
    494          		pPwm->TCR &= (~PWM_TCR_COUNTER_RESET) & PWM_TCR_BITMASK;
   \   00000068   0x6841             LDR      R1,[R0, #+4]
   \   0000006A   0xF011 0x0109      ANDS     R1,R1,#0x9
   \   0000006E   0x6041             STR      R1,[R0, #+4]
    495          	}
    496          }
   \                     ??PWM_MatchUpdate_10:
   \   00000070   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    497          
    498          
    499          /********************************************************************//**
    500           * @brief 		Configure Edge mode for each PWM channel
    501           * @param[in]	 pwmId			 The Id of the expected PWM component
    502           *
    503           * @param[in]	PWMChannel PWM channel, should be in range from 2 to 6
    504           * @param[in]	ModeOption PWM mode option, should be:
    505           * 				- PWM_CHANNEL_SINGLE_EDGE: Single Edge mode
    506           * 				- PWM_CHANNEL_DUAL_EDGE: Dual Edge mode
    507           * @return 		None
    508           * Note: PWM Channel 1 can not be selected for mode option
    509           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    510          void PWM_ChannelConfig(uint8_t pwmId, uint8_t PWMChannel, uint8_t ModeOption)
    511          {
   \                     PWM_ChannelConfig:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    512          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       PWM_GetPointer
    513          
    514          	// Single edge mode
    515          	if (ModeOption == PWM_CHANNEL_SINGLE_EDGE)
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD110             BNE.N    ??PWM_ChannelConfig_0
    516          	{
    517          		pPwm->PCR &= (~ PWM_PCR_PWMSELn(PWMChannel)) & PWM_PCR_BITMASK;
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0xF015 0x0107      ANDS     R1,R5,#0x7
   \   0000001C   0x2902             CMP      R1,#+2
   \   0000001E   0xDA01             BGE.N    ??PWM_ChannelConfig_1
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0xE001             B.N      ??PWM_ChannelConfig_2
   \                     ??PWM_ChannelConfig_1:
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x40A9             LSLS     R1,R1,R5
   \                     ??PWM_ChannelConfig_2:
   \   00000028   0x6CC2             LDR      R2,[R0, #+76]
   \   0000002A   0xF647 0x637C      MOVW     R3,#+32380
   \   0000002E   0xEA33 0x0101      BICS     R1,R3,R1
   \   00000032   0x4011             ANDS     R1,R1,R2
   \   00000034   0x64C1             STR      R1,[R0, #+76]
   \   00000036   0xE00B             B.N      ??PWM_ChannelConfig_3
    518          	}
    519          	// Double edge mode
    520          	else if (PWM_CHANNEL_DUAL_EDGE)
    521          	{
    522          		pPwm->PCR |= PWM_PCR_PWMSELn(PWMChannel);
   \                     ??PWM_ChannelConfig_0:
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0xF015 0x0107      ANDS     R1,R5,#0x7
   \   0000003E   0x2902             CMP      R1,#+2
   \   00000040   0xDA01             BGE.N    ??PWM_ChannelConfig_4
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xE001             B.N      ??PWM_ChannelConfig_5
   \                     ??PWM_ChannelConfig_4:
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x40A9             LSLS     R1,R1,R5
   \                     ??PWM_ChannelConfig_5:
   \   0000004A   0x6CC2             LDR      R2,[R0, #+76]
   \   0000004C   0x4311             ORRS     R1,R1,R2
   \   0000004E   0x64C1             STR      R1,[R0, #+76]
    523          	}
    524          }
   \                     ??PWM_ChannelConfig_3:
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    525          
    526          
    527          
    528          /********************************************************************//**
    529           * @brief 		Enable/Disable PWM channel output
    530           * @param[in]	 pwmId			 The Id of the expected PWM component
    531           *
    532           * @param[in]	PWMChannel PWM channel, should be in range from 1 to 6
    533           * @param[in]	NewState New State of this function, should be:
    534           * 				- ENABLE: Enable this PWM channel output
    535           * 				- DISABLE: Disable this PWM channel output
    536           * @return		None
    537           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    538          void PWM_ChannelCmd(uint8_t pwmId, uint8_t PWMChannel, FunctionalState NewState)
    539          {
   \                     PWM_ChannelCmd:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    540          	LPC_PWM_TypeDef* pPwm = PWM_GetPointer(pwmId);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       PWM_GetPointer
    541          
    542          	if (NewState == ENABLE)
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E01             CMP      R6,#+1
   \   00000014   0xD10E             BNE.N    ??PWM_ChannelCmd_0
    543          	{
    544          		pPwm->PCR |= PWM_PCR_PWMENAn(PWMChannel);
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0xF015 0x0107      ANDS     R1,R5,#0x7
   \   0000001C   0x2901             CMP      R1,#+1
   \   0000001E   0xDA01             BGE.N    ??PWM_ChannelCmd_1
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0xE003             B.N      ??PWM_ChannelCmd_2
   \                     ??PWM_ChannelCmd_1:
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF115 0x0208      ADDS     R2,R5,#+8
   \   0000002A   0x4091             LSLS     R1,R1,R2
   \                     ??PWM_ChannelCmd_2:
   \   0000002C   0x6CC2             LDR      R2,[R0, #+76]
   \   0000002E   0x4311             ORRS     R1,R1,R2
   \   00000030   0x64C1             STR      R1,[R0, #+76]
   \   00000032   0xE011             B.N      ??PWM_ChannelCmd_3
    545          	}
    546          	else
    547          	{
    548          		pPwm->PCR &= (~ PWM_PCR_PWMENAn(PWMChannel)) & PWM_PCR_BITMASK;
   \                     ??PWM_ChannelCmd_0:
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0xF015 0x0107      ANDS     R1,R5,#0x7
   \   0000003A   0x2901             CMP      R1,#+1
   \   0000003C   0xDA01             BGE.N    ??PWM_ChannelCmd_4
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xE003             B.N      ??PWM_ChannelCmd_5
   \                     ??PWM_ChannelCmd_4:
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0xF115 0x0208      ADDS     R2,R5,#+8
   \   00000048   0x4091             LSLS     R1,R1,R2
   \                     ??PWM_ChannelCmd_5:
   \   0000004A   0x6CC2             LDR      R2,[R0, #+76]
   \   0000004C   0xF647 0x637C      MOVW     R3,#+32380
   \   00000050   0xEA33 0x0101      BICS     R1,R3,R1
   \   00000054   0x4011             ANDS     R1,R1,R2
   \   00000056   0x64C1             STR      R1,[R0, #+76]
    549          	}
    550          }
   \                     ??PWM_ChannelCmd_3:
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40018000         DC32     0x40018000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x000F4240         DC32     0xf4240
    551          
    552          /**
    553           * @}
    554           */
    555          
    556          /**
    557           * @}
    558           */
    559          
    560          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   PWM_ChannelCmd
        16   -> PWM_GetPointer
      16   PWM_ChannelConfig
        16   -> PWM_GetPointer
      16   PWM_ClearIntPending
        16   -> PWM_GetPointer
      16   PWM_Cmd
        16   -> PWM_GetPointer
      16   PWM_ConfigCapture
        16   -> PWM_GetPointer
      16   PWM_ConfigMatch
        16   -> PWM_GetPointer
       4   PWM_ConfigStructInit
      16   PWM_CounterCmd
        16   -> PWM_GetPointer
      16   PWM_DeInit
        16   -> CLKPWR_ConfigPPWR
        16   -> PWM_GetPointer
      16   PWM_GetCaptureValue
        16   -> PWM_GetPointer
      16   PWM_GetIntStatus
        16   -> PWM_GetPointer
       0   PWM_GetPointer
      40   PWM_Init
        40   -> CLKPWR_ConfigPPWR
        40   -> CLKPWR_GetCLK
        40   -> PWM_GetPointer
        40   -> __aeabi_uldivmod
      24   PWM_MatchUpdate
        24   -> PWM_GetPointer
       8   PWM_ResetCounter
         8   -> PWM_GetPointer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      90  PWM_ChannelCmd
      82  PWM_ChannelConfig
      18  PWM_ClearIntPending
      40  PWM_Cmd
     222  PWM_ConfigCapture
     222  PWM_ConfigMatch
      40  PWM_ConfigStructInit
      40  PWM_CounterCmd
      28  PWM_DeInit
      40  PWM_GetCaptureValue
      30  PWM_GetIntStatus
      32  PWM_GetPointer
     194  PWM_Init
     114  PWM_MatchUpdate
      30  PWM_ResetCounter

 
 1 234 bytes in section .text
 
 1 234 bytes of CODE memory

Errors: none
Warnings: 1
