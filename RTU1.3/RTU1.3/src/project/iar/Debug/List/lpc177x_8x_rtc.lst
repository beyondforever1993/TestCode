###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:42 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_rtc.c                             #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_rtc.c -lCN                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\ -o D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë #
#                    \RTU_1.2\project\iar\Debug\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\lpc177x_8x_rtc.lst                         #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\lpc177x_8x_rtc.o                            #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Drivers\source\lpc177x_8x_rtc.c
      1          /**********************************************************************
      2          * $Id$		lpc177x_8x_rtc.c			2011-06-02
      3          *//**
      4          * @file		lpc177x_8x_rtc.c
      5          * @brief	Contains all functions support for RTC firmware library
      6          *			on LPC177x_8x
      7          * @version	1.0
      8          * @date		02. June. 2011
      9          * @author	NXP MCU SW Application Team
     10          * 
     11          * Copyright(C) 2011, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          **********************************************************************/
     26          
     27          /* Peripheral group ----------------------------------------------------------- */
     28          /** @addtogroup RTC
     29           * @{
     30           */
     31          
     32          /* Includes ------------------------------------------------------------------- */
     33          #include "lpc177x_8x_rtc.h"
     34          #include "lpc177x_8x_clkpwr.h"
     35          
     36          /* Public Functions ----------------------------------------------------------- */
     37          /** @addtogroup RTC_Public_Functions
     38           * @{
     39           */
     40          
     41          /********************************************************************//**
     42           * @brief		Initializes the RTC peripheral.
     43           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
     44           * @return 		None
     45           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     46          void RTC_Init (LPC_RTC_TypeDef *RTCx)
     47          {
   \                     RTC_Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     48          	/* Set up clock and power for RTC module */
     49          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRTC, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF44F 0x7000      MOV      R0,#+512
   \   0000000A   0x.... 0x....      BL       CLKPWR_ConfigPPWR
     50          
     51          	// Clear all register to be default
     52          	RTCx->ILR = 0x00;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7020             STRB     R0,[R4, #+0]
     53          	RTCx->CCR = 0x00;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7220             STRB     R0,[R4, #+8]
     54          	RTCx->CIIR = 0x00;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7320             STRB     R0,[R4, #+12]
     55          	RTCx->AMR = 0xFF;
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0x7420             STRB     R0,[R4, #+16]
     56          	RTCx->CALIBRATION = 0x00;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6420             STR      R0,[R4, #+64]
     57          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
     58          
     59          
     60          /*********************************************************************//**
     61           * @brief		De-initializes the RTC peripheral registers to their
     62          *                  default reset values.
     63           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
     64           * @return 		None
     65           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     66          void RTC_DeInit(LPC_RTC_TypeDef *RTCx)
     67          {
   \                     RTC_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     68          	RTCx->CCR = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7220             STRB     R0,[R4, #+8]
     69          	// Disable power and clock for RTC module
     70          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRTC, DISABLE);
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF44F 0x7000      MOV      R0,#+512
   \   0000000E   0x.... 0x....      BL       CLKPWR_ConfigPPWR
     71          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     72          
     73          /*********************************************************************//**
     74           * @brief 		Reset clock tick counter in RTC peripheral
     75           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
     76           * @return 		None
     77           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     78          void RTC_ResetClockTickCounter(LPC_RTC_TypeDef *RTCx)
     79          {
     80          	RTCx->CCR |= RTC_CCR_CTCRST;
   \                     RTC_ResetClockTickCounter:
   \   00000000   0x7A01             LDRB     R1,[R0, #+8]
   \   00000002   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000006   0x7201             STRB     R1,[R0, #+8]
     81          	RTCx->CCR &= (~RTC_CCR_CTCRST) & RTC_CCR_BITMASK;
   \   00000008   0x7A01             LDRB     R1,[R0, #+8]
   \   0000000A   0xF011 0x0111      ANDS     R1,R1,#0x11
   \   0000000E   0x7201             STRB     R1,[R0, #+8]
     82          }
   \   00000010   0x4770             BX       LR               ;; return
     83          
     84          /*********************************************************************//**
     85           * @brief 		Start/Stop RTC peripheral
     86           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
     87           * @param[in]	NewState New State of this function, should be:
     88           * 				- ENABLE: The time counters are enabled
     89           * 				- DISABLE: The time counters are disabled
     90           * @return 		None
     91           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     92          void RTC_Cmd (LPC_RTC_TypeDef *RTCx, FunctionalState NewState)
     93          {
     94          	if (NewState == ENABLE)
   \                     RTC_Cmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD104             BNE.N    ??RTC_Cmd_0
     95          	{
     96          		RTCx->CCR |= RTC_CCR_CLKEN;
   \   00000006   0x7A02             LDRB     R2,[R0, #+8]
   \   00000008   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000000C   0x7202             STRB     R2,[R0, #+8]
   \   0000000E   0xE003             B.N      ??RTC_Cmd_1
     97          	}
     98          	else
     99          	{
    100          		RTCx->CCR &= (~RTC_CCR_CLKEN) & RTC_CCR_BITMASK;
   \                     ??RTC_Cmd_0:
   \   00000010   0x7A02             LDRB     R2,[R0, #+8]
   \   00000012   0xF012 0x0212      ANDS     R2,R2,#0x12
   \   00000016   0x7202             STRB     R2,[R0, #+8]
    101          	}
    102          }
   \                     ??RTC_Cmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    103          
    104          
    105          /*********************************************************************//**
    106           * @brief 		Enable/Disable Counter increment interrupt for each time type
    107           * 				in RTC peripheral
    108           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    109           * @param[in]	CntIncrIntType: Counter Increment Interrupt type,
    110           * 				an increment of this type value below will generates
    111           * 				an interrupt, should be:
    112           * 				- RTC_TIMETYPE_SECOND
    113           * 				- RTC_TIMETYPE_MINUTE
    114           * 				- RTC_TIMETYPE_HOUR
    115           * 				- RTC_TIMETYPE_DAYOFWEEK
    116           * 				- RTC_TIMETYPE_DAYOFMONTH
    117           * 				- RTC_TIMETYPE_DAYOFYEAR
    118           * 				- RTC_TIMETYPE_MONTH
    119           * 				- RTC_TIMETYPE_YEAR
    120           * @param[in]	NewState New State of this function, should be:
    121           * 				- ENABLE: Counter Increment interrupt for this
    122           * 					time type are enabled
    123           * 				- DISABLE: Counter Increment interrupt for this
    124           * 					time type are disabled
    125           * @return 		None
    126           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    127          void RTC_CntIncrIntConfig (LPC_RTC_TypeDef *RTCx, uint32_t CntIncrIntType, \
    128          								FunctionalState NewState)
    129          {
    130          	if (NewState ==  ENABLE)
   \                     RTC_CntIncrIntConfig:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A01             CMP      R2,#+1
   \   00000004   0xD135             BNE.N    ??RTC_CntIncrIntConfig_0
    131          	{
    132          		switch (CntIncrIntType)
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD00B             BEQ.N    ??RTC_CntIncrIntConfig_1
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD013             BEQ.N    ??RTC_CntIncrIntConfig_2
   \   0000000E   0xD30D             BCC.N    ??RTC_CntIncrIntConfig_3
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD01A             BEQ.N    ??RTC_CntIncrIntConfig_4
   \   00000014   0xD314             BCC.N    ??RTC_CntIncrIntConfig_5
   \   00000016   0x2906             CMP      R1,#+6
   \   00000018   0xD021             BEQ.N    ??RTC_CntIncrIntConfig_6
   \   0000001A   0xD31B             BCC.N    ??RTC_CntIncrIntConfig_7
   \   0000001C   0x2907             CMP      R1,#+7
   \   0000001E   0xD023             BEQ.N    ??RTC_CntIncrIntConfig_8
   \   00000020   0xE05C             B.N      ??RTC_CntIncrIntConfig_9
    133          		{
    134          		case RTC_TIMETYPE_SECOND:
    135          			RTCx->CIIR |= RTC_CIIR_IMSEC;
   \                     ??RTC_CntIncrIntConfig_1:
   \   00000022   0x7B03             LDRB     R3,[R0, #+12]
   \   00000024   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   00000028   0x7303             STRB     R3,[R0, #+12]
    136          			break;
   \   0000002A   0xE057             B.N      ??RTC_CntIncrIntConfig_9
    137          		case RTC_TIMETYPE_MINUTE:
    138          			RTCx->CIIR |= RTC_CIIR_IMMIN;
   \                     ??RTC_CntIncrIntConfig_3:
   \   0000002C   0x7B03             LDRB     R3,[R0, #+12]
   \   0000002E   0xF053 0x0302      ORRS     R3,R3,#0x2
   \   00000032   0x7303             STRB     R3,[R0, #+12]
    139          			break;
   \   00000034   0xE052             B.N      ??RTC_CntIncrIntConfig_9
    140          		case RTC_TIMETYPE_HOUR:
    141          			RTCx->CIIR |= RTC_CIIR_IMHOUR;
   \                     ??RTC_CntIncrIntConfig_2:
   \   00000036   0x7B03             LDRB     R3,[R0, #+12]
   \   00000038   0xF053 0x0304      ORRS     R3,R3,#0x4
   \   0000003C   0x7303             STRB     R3,[R0, #+12]
    142          			break;
   \   0000003E   0xE04D             B.N      ??RTC_CntIncrIntConfig_9
    143          		case RTC_TIMETYPE_DAYOFWEEK:
    144          			RTCx->CIIR |= RTC_CIIR_IMDOW;
   \                     ??RTC_CntIncrIntConfig_5:
   \   00000040   0x7B03             LDRB     R3,[R0, #+12]
   \   00000042   0xF053 0x0310      ORRS     R3,R3,#0x10
   \   00000046   0x7303             STRB     R3,[R0, #+12]
    145          			break;
   \   00000048   0xE048             B.N      ??RTC_CntIncrIntConfig_9
    146          		case RTC_TIMETYPE_DAYOFMONTH:
    147          			RTCx->CIIR |= RTC_CIIR_IMDOM;
   \                     ??RTC_CntIncrIntConfig_4:
   \   0000004A   0x7B03             LDRB     R3,[R0, #+12]
   \   0000004C   0xF053 0x0308      ORRS     R3,R3,#0x8
   \   00000050   0x7303             STRB     R3,[R0, #+12]
    148          			break;
   \   00000052   0xE043             B.N      ??RTC_CntIncrIntConfig_9
    149          		case RTC_TIMETYPE_DAYOFYEAR:
    150          			RTCx->CIIR |= RTC_CIIR_IMDOY;
   \                     ??RTC_CntIncrIntConfig_7:
   \   00000054   0x7B03             LDRB     R3,[R0, #+12]
   \   00000056   0xF053 0x0320      ORRS     R3,R3,#0x20
   \   0000005A   0x7303             STRB     R3,[R0, #+12]
    151          			break;
   \   0000005C   0xE03E             B.N      ??RTC_CntIncrIntConfig_9
    152          		case RTC_TIMETYPE_MONTH:
    153          			RTCx->CIIR |= RTC_CIIR_IMMON;
   \                     ??RTC_CntIncrIntConfig_6:
   \   0000005E   0x7B03             LDRB     R3,[R0, #+12]
   \   00000060   0xF053 0x0340      ORRS     R3,R3,#0x40
   \   00000064   0x7303             STRB     R3,[R0, #+12]
    154          			break;
   \   00000066   0xE039             B.N      ??RTC_CntIncrIntConfig_9
    155          		case RTC_TIMETYPE_YEAR:
    156          			RTCx->CIIR |= RTC_CIIR_IMYEAR;
   \                     ??RTC_CntIncrIntConfig_8:
   \   00000068   0x7B03             LDRB     R3,[R0, #+12]
   \   0000006A   0xF053 0x0380      ORRS     R3,R3,#0x80
   \   0000006E   0x7303             STRB     R3,[R0, #+12]
    157          			break;
   \   00000070   0xE034             B.N      ??RTC_CntIncrIntConfig_9
    158          		}
    159          	}
    160          	else
    161          	{
    162          		switch (CntIncrIntType)
   \                     ??RTC_CntIncrIntConfig_0:
   \   00000072   0x2900             CMP      R1,#+0
   \   00000074   0xD00B             BEQ.N    ??RTC_CntIncrIntConfig_10
   \   00000076   0x2902             CMP      R1,#+2
   \   00000078   0xD013             BEQ.N    ??RTC_CntIncrIntConfig_11
   \   0000007A   0xD30D             BCC.N    ??RTC_CntIncrIntConfig_12
   \   0000007C   0x2904             CMP      R1,#+4
   \   0000007E   0xD01A             BEQ.N    ??RTC_CntIncrIntConfig_13
   \   00000080   0xD314             BCC.N    ??RTC_CntIncrIntConfig_14
   \   00000082   0x2906             CMP      R1,#+6
   \   00000084   0xD021             BEQ.N    ??RTC_CntIncrIntConfig_15
   \   00000086   0xD31B             BCC.N    ??RTC_CntIncrIntConfig_16
   \   00000088   0x2907             CMP      R1,#+7
   \   0000008A   0xD023             BEQ.N    ??RTC_CntIncrIntConfig_17
   \   0000008C   0xE026             B.N      ??RTC_CntIncrIntConfig_9
    163          		{
    164          		case RTC_TIMETYPE_SECOND:
    165          			RTCx->CIIR &= (~RTC_CIIR_IMSEC) & RTC_CIIR_BITMASK;
   \                     ??RTC_CntIncrIntConfig_10:
   \   0000008E   0x7B03             LDRB     R3,[R0, #+12]
   \   00000090   0xF013 0x03FE      ANDS     R3,R3,#0xFE
   \   00000094   0x7303             STRB     R3,[R0, #+12]
    166          			break;
   \   00000096   0xE021             B.N      ??RTC_CntIncrIntConfig_9
    167          		case RTC_TIMETYPE_MINUTE:
    168          			RTCx->CIIR &= (~RTC_CIIR_IMMIN) & RTC_CIIR_BITMASK;
   \                     ??RTC_CntIncrIntConfig_12:
   \   00000098   0x7B03             LDRB     R3,[R0, #+12]
   \   0000009A   0xF013 0x03FD      ANDS     R3,R3,#0xFD
   \   0000009E   0x7303             STRB     R3,[R0, #+12]
    169          			break;
   \   000000A0   0xE01C             B.N      ??RTC_CntIncrIntConfig_9
    170          		case RTC_TIMETYPE_HOUR:
    171          			RTCx->CIIR &= (~RTC_CIIR_IMHOUR) & RTC_CIIR_BITMASK;
   \                     ??RTC_CntIncrIntConfig_11:
   \   000000A2   0x7B03             LDRB     R3,[R0, #+12]
   \   000000A4   0xF013 0x03FB      ANDS     R3,R3,#0xFB
   \   000000A8   0x7303             STRB     R3,[R0, #+12]
    172          			break;
   \   000000AA   0xE017             B.N      ??RTC_CntIncrIntConfig_9
    173          		case RTC_TIMETYPE_DAYOFWEEK:
    174          			RTCx->CIIR &= (~RTC_CIIR_IMDOW) & RTC_CIIR_BITMASK;
   \                     ??RTC_CntIncrIntConfig_14:
   \   000000AC   0x7B03             LDRB     R3,[R0, #+12]
   \   000000AE   0xF013 0x03EF      ANDS     R3,R3,#0xEF
   \   000000B2   0x7303             STRB     R3,[R0, #+12]
    175          			break;
   \   000000B4   0xE012             B.N      ??RTC_CntIncrIntConfig_9
    176          		case RTC_TIMETYPE_DAYOFMONTH:
    177          			RTCx->CIIR &= (~RTC_CIIR_IMDOM) & RTC_CIIR_BITMASK;
   \                     ??RTC_CntIncrIntConfig_13:
   \   000000B6   0x7B03             LDRB     R3,[R0, #+12]
   \   000000B8   0xF013 0x03F7      ANDS     R3,R3,#0xF7
   \   000000BC   0x7303             STRB     R3,[R0, #+12]
    178          			break;
   \   000000BE   0xE00D             B.N      ??RTC_CntIncrIntConfig_9
    179          		case RTC_TIMETYPE_DAYOFYEAR:
    180          			RTCx->CIIR &= (~RTC_CIIR_IMDOY) & RTC_CIIR_BITMASK;
   \                     ??RTC_CntIncrIntConfig_16:
   \   000000C0   0x7B03             LDRB     R3,[R0, #+12]
   \   000000C2   0xF013 0x03DF      ANDS     R3,R3,#0xDF
   \   000000C6   0x7303             STRB     R3,[R0, #+12]
    181          			break;
   \   000000C8   0xE008             B.N      ??RTC_CntIncrIntConfig_9
    182          		case RTC_TIMETYPE_MONTH:
    183          			RTCx->CIIR &= (~RTC_CIIR_IMMON) & RTC_CIIR_BITMASK;
   \                     ??RTC_CntIncrIntConfig_15:
   \   000000CA   0x7B03             LDRB     R3,[R0, #+12]
   \   000000CC   0xF013 0x03BF      ANDS     R3,R3,#0xBF
   \   000000D0   0x7303             STRB     R3,[R0, #+12]
    184          			break;
   \   000000D2   0xE003             B.N      ??RTC_CntIncrIntConfig_9
    185          		case RTC_TIMETYPE_YEAR:
    186          			RTCx->CIIR &= (~RTC_CIIR_IMYEAR) & RTC_CIIR_BITMASK;
   \                     ??RTC_CntIncrIntConfig_17:
   \   000000D4   0x7B03             LDRB     R3,[R0, #+12]
   \   000000D6   0xF013 0x037F      ANDS     R3,R3,#0x7F
   \   000000DA   0x7303             STRB     R3,[R0, #+12]
    187          			break;
    188          		}
    189          	}
    190          }
   \                     ??RTC_CntIncrIntConfig_9:
   \   000000DC   0x4770             BX       LR               ;; return
    191          
    192          
    193          /*********************************************************************//**
    194           * @brief 		Enable/Disable Alarm interrupt for each time type
    195           * 				in RTC peripheral
    196           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    197           * @param[in]	AlarmTimeType: Alarm Time Interrupt type,
    198           * 				an matching of this type value below with current time
    199           * 				in RTC will generates an interrupt, should be:
    200           * 				- RTC_TIMETYPE_SECOND
    201           * 				- RTC_TIMETYPE_MINUTE
    202           * 				- RTC_TIMETYPE_HOUR
    203           * 				- RTC_TIMETYPE_DAYOFWEEK
    204           * 				- RTC_TIMETYPE_DAYOFMONTH
    205           * 				- RTC_TIMETYPE_DAYOFYEAR
    206           * 				- RTC_TIMETYPE_MONTH
    207           * 				- RTC_TIMETYPE_YEAR
    208           * @param[in]	NewState New State of this function, should be:
    209           * 				- ENABLE: Alarm interrupt for this
    210           * 					time type are enabled
    211           * 				- DISABLE: Alarm interrupt for this
    212           * 					time type are disabled
    213           * @return 		None
    214           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    215          void RTC_AlarmIntConfig (LPC_RTC_TypeDef *RTCx, uint32_t AlarmTimeType, \
    216          								FunctionalState NewState)
    217          {
    218          	if (NewState == ENABLE)
   \                     RTC_AlarmIntConfig:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A01             CMP      R2,#+1
   \   00000004   0xD135             BNE.N    ??RTC_AlarmIntConfig_0
    219          	{
    220          		switch (AlarmTimeType)
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD00B             BEQ.N    ??RTC_AlarmIntConfig_1
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD013             BEQ.N    ??RTC_AlarmIntConfig_2
   \   0000000E   0xD30D             BCC.N    ??RTC_AlarmIntConfig_3
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD01A             BEQ.N    ??RTC_AlarmIntConfig_4
   \   00000014   0xD314             BCC.N    ??RTC_AlarmIntConfig_5
   \   00000016   0x2906             CMP      R1,#+6
   \   00000018   0xD021             BEQ.N    ??RTC_AlarmIntConfig_6
   \   0000001A   0xD31B             BCC.N    ??RTC_AlarmIntConfig_7
   \   0000001C   0x2907             CMP      R1,#+7
   \   0000001E   0xD023             BEQ.N    ??RTC_AlarmIntConfig_8
   \   00000020   0xE05C             B.N      ??RTC_AlarmIntConfig_9
    221          		{
    222          		case RTC_TIMETYPE_SECOND:
    223          			RTCx->AMR &= (~RTC_AMR_AMRSEC) & RTC_AMR_BITMASK;
   \                     ??RTC_AlarmIntConfig_1:
   \   00000022   0x7C03             LDRB     R3,[R0, #+16]
   \   00000024   0xF013 0x03FE      ANDS     R3,R3,#0xFE
   \   00000028   0x7403             STRB     R3,[R0, #+16]
    224          			break;
   \   0000002A   0xE057             B.N      ??RTC_AlarmIntConfig_9
    225          		case RTC_TIMETYPE_MINUTE:
    226          			RTCx->AMR &= (~RTC_AMR_AMRMIN) & RTC_AMR_BITMASK;
   \                     ??RTC_AlarmIntConfig_3:
   \   0000002C   0x7C03             LDRB     R3,[R0, #+16]
   \   0000002E   0xF013 0x03FD      ANDS     R3,R3,#0xFD
   \   00000032   0x7403             STRB     R3,[R0, #+16]
    227          			break;
   \   00000034   0xE052             B.N      ??RTC_AlarmIntConfig_9
    228          		case RTC_TIMETYPE_HOUR:
    229          			RTCx->AMR &= (~RTC_AMR_AMRHOUR) & RTC_AMR_BITMASK;
   \                     ??RTC_AlarmIntConfig_2:
   \   00000036   0x7C03             LDRB     R3,[R0, #+16]
   \   00000038   0xF013 0x03FB      ANDS     R3,R3,#0xFB
   \   0000003C   0x7403             STRB     R3,[R0, #+16]
    230          			break;
   \   0000003E   0xE04D             B.N      ??RTC_AlarmIntConfig_9
    231          		case RTC_TIMETYPE_DAYOFWEEK:
    232          			RTCx->AMR &= (~RTC_AMR_AMRDOW) & RTC_AMR_BITMASK;
   \                     ??RTC_AlarmIntConfig_5:
   \   00000040   0x7C03             LDRB     R3,[R0, #+16]
   \   00000042   0xF013 0x03EF      ANDS     R3,R3,#0xEF
   \   00000046   0x7403             STRB     R3,[R0, #+16]
    233          			break;
   \   00000048   0xE048             B.N      ??RTC_AlarmIntConfig_9
    234          		case RTC_TIMETYPE_DAYOFMONTH:
    235          			RTCx->AMR &= (~RTC_AMR_AMRDOM) & RTC_AMR_BITMASK;
   \                     ??RTC_AlarmIntConfig_4:
   \   0000004A   0x7C03             LDRB     R3,[R0, #+16]
   \   0000004C   0xF013 0x03F7      ANDS     R3,R3,#0xF7
   \   00000050   0x7403             STRB     R3,[R0, #+16]
    236          			break;
   \   00000052   0xE043             B.N      ??RTC_AlarmIntConfig_9
    237          		case RTC_TIMETYPE_DAYOFYEAR:
    238          			RTCx->AMR &= (~RTC_AMR_AMRDOY) & RTC_AMR_BITMASK;
   \                     ??RTC_AlarmIntConfig_7:
   \   00000054   0x7C03             LDRB     R3,[R0, #+16]
   \   00000056   0xF013 0x03DF      ANDS     R3,R3,#0xDF
   \   0000005A   0x7403             STRB     R3,[R0, #+16]
    239          			break;
   \   0000005C   0xE03E             B.N      ??RTC_AlarmIntConfig_9
    240          		case RTC_TIMETYPE_MONTH:
    241          			RTCx->AMR &= (~RTC_AMR_AMRMON) & RTC_AMR_BITMASK;
   \                     ??RTC_AlarmIntConfig_6:
   \   0000005E   0x7C03             LDRB     R3,[R0, #+16]
   \   00000060   0xF013 0x03BF      ANDS     R3,R3,#0xBF
   \   00000064   0x7403             STRB     R3,[R0, #+16]
    242          			break;
   \   00000066   0xE039             B.N      ??RTC_AlarmIntConfig_9
    243          		case RTC_TIMETYPE_YEAR:
    244          			RTCx->AMR &= (~RTC_AMR_AMRYEAR) & RTC_AMR_BITMASK;
   \                     ??RTC_AlarmIntConfig_8:
   \   00000068   0x7C03             LDRB     R3,[R0, #+16]
   \   0000006A   0xF013 0x037F      ANDS     R3,R3,#0x7F
   \   0000006E   0x7403             STRB     R3,[R0, #+16]
    245          			break;
   \   00000070   0xE034             B.N      ??RTC_AlarmIntConfig_9
    246          		}
    247          	}
    248          	else
    249          	{
    250          		switch (AlarmTimeType)
   \                     ??RTC_AlarmIntConfig_0:
   \   00000072   0x2900             CMP      R1,#+0
   \   00000074   0xD00B             BEQ.N    ??RTC_AlarmIntConfig_10
   \   00000076   0x2902             CMP      R1,#+2
   \   00000078   0xD013             BEQ.N    ??RTC_AlarmIntConfig_11
   \   0000007A   0xD30D             BCC.N    ??RTC_AlarmIntConfig_12
   \   0000007C   0x2904             CMP      R1,#+4
   \   0000007E   0xD01A             BEQ.N    ??RTC_AlarmIntConfig_13
   \   00000080   0xD314             BCC.N    ??RTC_AlarmIntConfig_14
   \   00000082   0x2906             CMP      R1,#+6
   \   00000084   0xD021             BEQ.N    ??RTC_AlarmIntConfig_15
   \   00000086   0xD31B             BCC.N    ??RTC_AlarmIntConfig_16
   \   00000088   0x2907             CMP      R1,#+7
   \   0000008A   0xD023             BEQ.N    ??RTC_AlarmIntConfig_17
   \   0000008C   0xE026             B.N      ??RTC_AlarmIntConfig_9
    251          		{
    252          		case RTC_TIMETYPE_SECOND:
    253          			RTCx->AMR |= (RTC_AMR_AMRSEC);
   \                     ??RTC_AlarmIntConfig_10:
   \   0000008E   0x7C03             LDRB     R3,[R0, #+16]
   \   00000090   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   00000094   0x7403             STRB     R3,[R0, #+16]
    254          			break;
   \   00000096   0xE021             B.N      ??RTC_AlarmIntConfig_9
    255          		case RTC_TIMETYPE_MINUTE:
    256          			RTCx->AMR |= (RTC_AMR_AMRMIN);
   \                     ??RTC_AlarmIntConfig_12:
   \   00000098   0x7C03             LDRB     R3,[R0, #+16]
   \   0000009A   0xF053 0x0302      ORRS     R3,R3,#0x2
   \   0000009E   0x7403             STRB     R3,[R0, #+16]
    257          			break;
   \   000000A0   0xE01C             B.N      ??RTC_AlarmIntConfig_9
    258          		case RTC_TIMETYPE_HOUR:
    259          			RTCx->AMR |= (RTC_AMR_AMRHOUR);
   \                     ??RTC_AlarmIntConfig_11:
   \   000000A2   0x7C03             LDRB     R3,[R0, #+16]
   \   000000A4   0xF053 0x0304      ORRS     R3,R3,#0x4
   \   000000A8   0x7403             STRB     R3,[R0, #+16]
    260          			break;
   \   000000AA   0xE017             B.N      ??RTC_AlarmIntConfig_9
    261          		case RTC_TIMETYPE_DAYOFWEEK:
    262          			RTCx->AMR |= (RTC_AMR_AMRDOW);
   \                     ??RTC_AlarmIntConfig_14:
   \   000000AC   0x7C03             LDRB     R3,[R0, #+16]
   \   000000AE   0xF053 0x0310      ORRS     R3,R3,#0x10
   \   000000B2   0x7403             STRB     R3,[R0, #+16]
    263          			break;
   \   000000B4   0xE012             B.N      ??RTC_AlarmIntConfig_9
    264          		case RTC_TIMETYPE_DAYOFMONTH:
    265          			RTCx->AMR |= (RTC_AMR_AMRDOM);
   \                     ??RTC_AlarmIntConfig_13:
   \   000000B6   0x7C03             LDRB     R3,[R0, #+16]
   \   000000B8   0xF053 0x0308      ORRS     R3,R3,#0x8
   \   000000BC   0x7403             STRB     R3,[R0, #+16]
    266          			break;
   \   000000BE   0xE00D             B.N      ??RTC_AlarmIntConfig_9
    267          		case RTC_TIMETYPE_DAYOFYEAR:
    268          			RTCx->AMR |= (RTC_AMR_AMRDOY);
   \                     ??RTC_AlarmIntConfig_16:
   \   000000C0   0x7C03             LDRB     R3,[R0, #+16]
   \   000000C2   0xF053 0x0320      ORRS     R3,R3,#0x20
   \   000000C6   0x7403             STRB     R3,[R0, #+16]
    269          			break;
   \   000000C8   0xE008             B.N      ??RTC_AlarmIntConfig_9
    270          		case RTC_TIMETYPE_MONTH:
    271          			RTCx->AMR |= (RTC_AMR_AMRMON);
   \                     ??RTC_AlarmIntConfig_15:
   \   000000CA   0x7C03             LDRB     R3,[R0, #+16]
   \   000000CC   0xF053 0x0340      ORRS     R3,R3,#0x40
   \   000000D0   0x7403             STRB     R3,[R0, #+16]
    272          			break;
   \   000000D2   0xE003             B.N      ??RTC_AlarmIntConfig_9
    273          		case RTC_TIMETYPE_YEAR:
    274          			RTCx->AMR |= (RTC_AMR_AMRYEAR);
   \                     ??RTC_AlarmIntConfig_17:
   \   000000D4   0x7C03             LDRB     R3,[R0, #+16]
   \   000000D6   0xF053 0x0380      ORRS     R3,R3,#0x80
   \   000000DA   0x7403             STRB     R3,[R0, #+16]
    275          			break;
    276          		}
    277          	}
    278          }
   \                     ??RTC_AlarmIntConfig_9:
   \   000000DC   0x4770             BX       LR               ;; return
    279          
    280          
    281          /*********************************************************************//**
    282           * @brief 		Set current time value for each time type in RTC peripheral
    283           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    284           * @param[in]	Timetype: Time Type, should be:
    285           * 				- RTC_TIMETYPE_SECOND
    286           * 				- RTC_TIMETYPE_MINUTE
    287           * 				- RTC_TIMETYPE_HOUR
    288           * 				- RTC_TIMETYPE_DAYOFWEEK
    289           * 				- RTC_TIMETYPE_DAYOFMONTH
    290           * 				- RTC_TIMETYPE_DAYOFYEAR
    291           * 				- RTC_TIMETYPE_MONTH
    292           * 				- RTC_TIMETYPE_YEAR
    293           * @param[in]	TimeValue Time value to set
    294           * @return 		None
    295           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    296          void RTC_SetTime (LPC_RTC_TypeDef *RTCx, uint32_t Timetype, uint32_t TimeValue)
    297          {
   \                     RTC_SetTime:
   \   00000000   0xB410             PUSH     {R4}
    298          	switch ( Timetype)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00B             BEQ.N    ??RTC_SetTime_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD019             BEQ.N    ??RTC_SetTime_1
   \   0000000A   0xD310             BCC.N    ??RTC_SetTime_2
   \   0000000C   0x2904             CMP      R1,#+4
   \   0000000E   0xD026             BEQ.N    ??RTC_SetTime_3
   \   00000010   0xD31D             BCC.N    ??RTC_SetTime_4
   \   00000012   0x2906             CMP      R1,#+6
   \   00000014   0xD04E             BEQ.N    ??RTC_SetTime_5
   \   00000016   0xD337             BCC.N    ??RTC_SetTime_6
   \   00000018   0x2907             CMP      R1,#+7
   \   0000001A   0xD060             BEQ.N    ??RTC_SetTime_7
   \   0000001C   0xE067             B.N      ??RTC_SetTime_8
    299          	{
    300          	case RTC_TIMETYPE_SECOND:
    301          		if(TimeValue > RTC_SECOND_MAX)
   \                     ??RTC_SetTime_0:
   \   0000001E   0x2A3C             CMP      R2,#+60
   \   00000020   0xD300             BCC.N    ??RTC_SetTime_9
    302          			while(1); //error loop
   \                     ??RTC_SetTime_10:
   \   00000022   0xE7FE             B.N      ??RTC_SetTime_10
    303          		RTCx->SEC = TimeValue & RTC_SEC_MASK;
   \                     ??RTC_SetTime_9:
   \   00000024   0xF012 0x033F      ANDS     R3,R2,#0x3F
   \   00000028   0xF880 0x3020      STRB     R3,[R0, #+32]
    304          		break;
   \   0000002C   0xE05F             B.N      ??RTC_SetTime_8
    305          
    306          	case RTC_TIMETYPE_MINUTE:
    307          		if(TimeValue > RTC_MINUTE_MAX)
   \                     ??RTC_SetTime_2:
   \   0000002E   0x2A3C             CMP      R2,#+60
   \   00000030   0xD300             BCC.N    ??RTC_SetTime_11
    308          			while(1); //error loop
   \                     ??RTC_SetTime_12:
   \   00000032   0xE7FE             B.N      ??RTC_SetTime_12
    309          		RTCx->MIN = TimeValue & RTC_MIN_MASK;
   \                     ??RTC_SetTime_11:
   \   00000034   0xF012 0x033F      ANDS     R3,R2,#0x3F
   \   00000038   0xF880 0x3024      STRB     R3,[R0, #+36]
    310          		break;
   \   0000003C   0xE057             B.N      ??RTC_SetTime_8
    311          
    312          	case RTC_TIMETYPE_HOUR:
    313          		if(TimeValue > RTC_HOUR_MAX)
   \                     ??RTC_SetTime_1:
   \   0000003E   0x2A18             CMP      R2,#+24
   \   00000040   0xD300             BCC.N    ??RTC_SetTime_13
    314          			while(1); //error loop
   \                     ??RTC_SetTime_14:
   \   00000042   0xE7FE             B.N      ??RTC_SetTime_14
    315          		RTCx->HOUR = TimeValue & RTC_HOUR_MASK;
   \                     ??RTC_SetTime_13:
   \   00000044   0xF012 0x031F      ANDS     R3,R2,#0x1F
   \   00000048   0xF880 0x3028      STRB     R3,[R0, #+40]
    316          		break;
   \   0000004C   0xE04F             B.N      ??RTC_SetTime_8
    317          
    318          	case RTC_TIMETYPE_DAYOFWEEK:
    319          		if(TimeValue > RTC_DAYOFWEEK_MAX)
   \                     ??RTC_SetTime_4:
   \   0000004E   0x2A07             CMP      R2,#+7
   \   00000050   0xD300             BCC.N    ??RTC_SetTime_15
    320          			while(1); //error loop
   \                     ??RTC_SetTime_16:
   \   00000052   0xE7FE             B.N      ??RTC_SetTime_16
    321          		RTCx->DOW = TimeValue & RTC_DOW_MASK;
   \                     ??RTC_SetTime_15:
   \   00000054   0xF012 0x0307      ANDS     R3,R2,#0x7
   \   00000058   0xF880 0x3030      STRB     R3,[R0, #+48]
    322          		break;
   \   0000005C   0xE047             B.N      ??RTC_SetTime_8
    323          
    324          	case RTC_TIMETYPE_DAYOFMONTH:
    325          		if((TimeValue < RTC_DAYOFMONTH_MIN)|(TimeValue > RTC_DAYOFMONTH_MAX))
   \                     ??RTC_SetTime_3:
   \   0000005E   0x2A00             CMP      R2,#+0
   \   00000060   0xD101             BNE.N    ??RTC_SetTime_17
   \   00000062   0x2301             MOVS     R3,#+1
   \   00000064   0xE000             B.N      ??RTC_SetTime_18
   \                     ??RTC_SetTime_17:
   \   00000066   0x2300             MOVS     R3,#+0
   \                     ??RTC_SetTime_18:
   \   00000068   0x2A20             CMP      R2,#+32
   \   0000006A   0xD301             BCC.N    ??RTC_SetTime_19
   \   0000006C   0x2401             MOVS     R4,#+1
   \   0000006E   0xE000             B.N      ??RTC_SetTime_20
   \                     ??RTC_SetTime_19:
   \   00000070   0x2400             MOVS     R4,#+0
   \                     ??RTC_SetTime_20:
   \   00000072   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x4323             ORRS     R3,R4,R3
   \   00000078   0x2B00             CMP      R3,#+0
   \   0000007A   0xD000             BEQ.N    ??RTC_SetTime_21
    326          			while(1); //error loop
   \                     ??RTC_SetTime_22:
   \   0000007C   0xE7FE             B.N      ??RTC_SetTime_22
    327          		RTCx->DOM = TimeValue & RTC_DOM_MASK;
   \                     ??RTC_SetTime_21:
   \   0000007E   0xF012 0x031F      ANDS     R3,R2,#0x1F
   \   00000082   0xF880 0x302C      STRB     R3,[R0, #+44]
    328          		break;
   \   00000086   0xE032             B.N      ??RTC_SetTime_8
    329          
    330          	case RTC_TIMETYPE_DAYOFYEAR:
    331          		if((TimeValue < RTC_DAYOFYEAR_MIN)|(TimeValue > RTC_DAYOFYEAR_MAX))
   \                     ??RTC_SetTime_6:
   \   00000088   0x2A00             CMP      R2,#+0
   \   0000008A   0xD101             BNE.N    ??RTC_SetTime_23
   \   0000008C   0x2301             MOVS     R3,#+1
   \   0000008E   0xE000             B.N      ??RTC_SetTime_24
   \                     ??RTC_SetTime_23:
   \   00000090   0x2300             MOVS     R3,#+0
   \                     ??RTC_SetTime_24:
   \   00000092   0xF5B2 0x7FB7      CMP      R2,#+366
   \   00000096   0xD901             BLS.N    ??RTC_SetTime_25
   \   00000098   0x2401             MOVS     R4,#+1
   \   0000009A   0xE000             B.N      ??RTC_SetTime_26
   \                     ??RTC_SetTime_25:
   \   0000009C   0x2400             MOVS     R4,#+0
   \                     ??RTC_SetTime_26:
   \   0000009E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A2   0x4323             ORRS     R3,R4,R3
   \   000000A4   0x2B00             CMP      R3,#+0
   \   000000A6   0xD000             BEQ.N    ??RTC_SetTime_27
    332          			while(1); //error loop
   \                     ??RTC_SetTime_28:
   \   000000A8   0xE7FE             B.N      ??RTC_SetTime_28
    333          		RTCx->DOY = TimeValue & RTC_DOY_MASK;
   \                     ??RTC_SetTime_27:
   \   000000AA   0x0013             MOVS     R3,R2
   \   000000AC   0x05DB             LSLS     R3,R3,#+23       ;; ZeroExtS R3,R3,#+23,#+23
   \   000000AE   0x0DDB             LSRS     R3,R3,#+23
   \   000000B0   0x8683             STRH     R3,[R0, #+52]
    334          		break;
   \   000000B2   0xE01C             B.N      ??RTC_SetTime_8
    335          
    336          	case RTC_TIMETYPE_MONTH:
    337          		if((TimeValue < RTC_MONTH_MIN)|(TimeValue > RTC_MONTH_MAX))
   \                     ??RTC_SetTime_5:
   \   000000B4   0x2A00             CMP      R2,#+0
   \   000000B6   0xD101             BNE.N    ??RTC_SetTime_29
   \   000000B8   0x2301             MOVS     R3,#+1
   \   000000BA   0xE000             B.N      ??RTC_SetTime_30
   \                     ??RTC_SetTime_29:
   \   000000BC   0x2300             MOVS     R3,#+0
   \                     ??RTC_SetTime_30:
   \   000000BE   0x2A0D             CMP      R2,#+13
   \   000000C0   0xD301             BCC.N    ??RTC_SetTime_31
   \   000000C2   0x2401             MOVS     R4,#+1
   \   000000C4   0xE000             B.N      ??RTC_SetTime_32
   \                     ??RTC_SetTime_31:
   \   000000C6   0x2400             MOVS     R4,#+0
   \                     ??RTC_SetTime_32:
   \   000000C8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CC   0x4323             ORRS     R3,R4,R3
   \   000000CE   0x2B00             CMP      R3,#+0
   \   000000D0   0xD000             BEQ.N    ??RTC_SetTime_33
    338          			while(1); //error loop
   \                     ??RTC_SetTime_34:
   \   000000D2   0xE7FE             B.N      ??RTC_SetTime_34
    339          		RTCx->MONTH = TimeValue & RTC_MONTH_MASK;
   \                     ??RTC_SetTime_33:
   \   000000D4   0xF012 0x030F      ANDS     R3,R2,#0xF
   \   000000D8   0xF880 0x3038      STRB     R3,[R0, #+56]
    340          		break;
   \   000000DC   0xE007             B.N      ??RTC_SetTime_8
    341          
    342          	case RTC_TIMETYPE_YEAR:
    343          		if(TimeValue > RTC_YEAR_MAX)
   \                     ??RTC_SetTime_7:
   \   000000DE   0xF5B2 0x5F80      CMP      R2,#+4096
   \   000000E2   0xD300             BCC.N    ??RTC_SetTime_35
    344          			while(1); //error loop
   \                     ??RTC_SetTime_36:
   \   000000E4   0xE7FE             B.N      ??RTC_SetTime_36
    345          		RTCx->YEAR = TimeValue & RTC_YEAR_MASK;
   \                     ??RTC_SetTime_35:
   \   000000E6   0x0013             MOVS     R3,R2
   \   000000E8   0x051B             LSLS     R3,R3,#+20       ;; ZeroExtS R3,R3,#+20,#+20
   \   000000EA   0x0D1B             LSRS     R3,R3,#+20
   \   000000EC   0x8783             STRH     R3,[R0, #+60]
    346          		break;
    347          	}
    348          }
   \                     ??RTC_SetTime_8:
   \   000000EE   0xBC10             POP      {R4}
   \   000000F0   0x4770             BX       LR               ;; return
    349          
    350          /*********************************************************************//**
    351           * @brief 		Get current time value for each type time type
    352           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    353           * @param[in]	Timetype: Time Type, should be:
    354           * 				- RTC_TIMETYPE_SECOND
    355           * 				- RTC_TIMETYPE_MINUTE
    356           * 				- RTC_TIMETYPE_HOUR
    357           * 				- RTC_TIMETYPE_DAYOFWEEK
    358           * 				- RTC_TIMETYPE_DAYOFMONTH
    359           * 				- RTC_TIMETYPE_DAYOFYEAR
    360           * 				- RTC_TIMETYPE_MONTH
    361           * 				- RTC_TIMETYPE_YEAR
    362           * @return 		Value of time according to specified time type
    363           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    364          uint32_t RTC_GetTime(LPC_RTC_TypeDef *RTCx, uint32_t Timetype)
    365          {
   \                     RTC_GetTime:
   \   00000000   0x0002             MOVS     R2,R0
    366          	switch (Timetype)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00B             BEQ.N    ??RTC_GetTime_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD013             BEQ.N    ??RTC_GetTime_1
   \   0000000A   0xD30D             BCC.N    ??RTC_GetTime_2
   \   0000000C   0x2904             CMP      R1,#+4
   \   0000000E   0xD01A             BEQ.N    ??RTC_GetTime_3
   \   00000010   0xD314             BCC.N    ??RTC_GetTime_4
   \   00000012   0x2906             CMP      R1,#+6
   \   00000014   0xD020             BEQ.N    ??RTC_GetTime_5
   \   00000016   0xD31B             BCC.N    ??RTC_GetTime_6
   \   00000018   0x2907             CMP      R1,#+7
   \   0000001A   0xD022             BEQ.N    ??RTC_GetTime_7
   \   0000001C   0xE025             B.N      ??RTC_GetTime_8
    367          	{
    368          	case RTC_TIMETYPE_SECOND:
    369          		return (RTCx->SEC & RTC_SEC_MASK);
   \                     ??RTC_GetTime_0:
   \   0000001E   0xF892 0x0020      LDRB     R0,[R2, #+32]
   \   00000022   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000026   0xE021             B.N      ??RTC_GetTime_9
    370          	case RTC_TIMETYPE_MINUTE:
    371          		return (RTCx->MIN & RTC_MIN_MASK);
   \                     ??RTC_GetTime_2:
   \   00000028   0xF892 0x0024      LDRB     R0,[R2, #+36]
   \   0000002C   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000030   0xE01C             B.N      ??RTC_GetTime_9
    372          	case RTC_TIMETYPE_HOUR:
    373          		return (RTCx->HOUR & RTC_HOUR_MASK);
   \                     ??RTC_GetTime_1:
   \   00000032   0xF892 0x0028      LDRB     R0,[R2, #+40]
   \   00000036   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000003A   0xE017             B.N      ??RTC_GetTime_9
    374          	case RTC_TIMETYPE_DAYOFWEEK:
    375          		return (RTCx->DOW & RTC_DOW_MASK);
   \                     ??RTC_GetTime_4:
   \   0000003C   0xF892 0x0030      LDRB     R0,[R2, #+48]
   \   00000040   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000044   0xE012             B.N      ??RTC_GetTime_9
    376          	case RTC_TIMETYPE_DAYOFMONTH:
    377          		return (RTCx->DOM & RTC_DOM_MASK);
   \                     ??RTC_GetTime_3:
   \   00000046   0xF892 0x002C      LDRB     R0,[R2, #+44]
   \   0000004A   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000004E   0xE00D             B.N      ??RTC_GetTime_9
    378          	case RTC_TIMETYPE_DAYOFYEAR:
    379          		return (RTCx->DOY & RTC_DOY_MASK);
   \                     ??RTC_GetTime_6:
   \   00000050   0x8E90             LDRH     R0,[R2, #+52]
   \   00000052   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000054   0x0DC0             LSRS     R0,R0,#+23
   \   00000056   0xE009             B.N      ??RTC_GetTime_9
    380          	case RTC_TIMETYPE_MONTH:
    381          		return (RTCx->MONTH & RTC_MONTH_MASK);
   \                     ??RTC_GetTime_5:
   \   00000058   0xF892 0x0038      LDRB     R0,[R2, #+56]
   \   0000005C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000060   0xE004             B.N      ??RTC_GetTime_9
    382          	case RTC_TIMETYPE_YEAR:
    383          		return (RTCx->YEAR & RTC_YEAR_MASK);
   \                     ??RTC_GetTime_7:
   \   00000062   0x8F90             LDRH     R0,[R2, #+60]
   \   00000064   0x0500             LSLS     R0,R0,#+20       ;; ZeroExtS R0,R0,#+20,#+20
   \   00000066   0x0D00             LSRS     R0,R0,#+20
   \   00000068   0xE000             B.N      ??RTC_GetTime_9
    384          	default:
    385          		return (0);
   \                     ??RTC_GetTime_8:
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??RTC_GetTime_9:
   \   0000006C   0x4770             BX       LR               ;; return
    386          	}
    387          }
    388          
    389          
    390          /*********************************************************************//**
    391           * @brief 		Set full of time in RTC peripheral
    392           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    393           * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
    394           * 				contains time value in full.
    395           * @return 		None
    396           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    397          void RTC_SetFullTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
    398          {
    399          	RTCx->DOM = pFullTime->DOM & RTC_DOM_MASK;
   \                     RTC_SetFullTime:
   \   00000000   0x7B0A             LDRB     R2,[R1, #+12]
   \   00000002   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   00000006   0xF880 0x202C      STRB     R2,[R0, #+44]
    400          	RTCx->DOW = pFullTime->DOW & RTC_DOW_MASK;
   \   0000000A   0x7C0A             LDRB     R2,[R1, #+16]
   \   0000000C   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   00000010   0xF880 0x2030      STRB     R2,[R0, #+48]
    401          	RTCx->DOY = pFullTime->DOY & RTC_DOY_MASK;
   \   00000014   0x694A             LDR      R2,[R1, #+20]
   \   00000016   0x05D2             LSLS     R2,R2,#+23       ;; ZeroExtS R2,R2,#+23,#+23
   \   00000018   0x0DD2             LSRS     R2,R2,#+23
   \   0000001A   0x8682             STRH     R2,[R0, #+52]
    402          	RTCx->HOUR = pFullTime->HOUR & RTC_HOUR_MASK;
   \   0000001C   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000001E   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   00000022   0xF880 0x2028      STRB     R2,[R0, #+40]
    403          	RTCx->MIN = pFullTime->MIN & RTC_MIN_MASK;
   \   00000026   0x790A             LDRB     R2,[R1, #+4]
   \   00000028   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   0000002C   0xF880 0x2024      STRB     R2,[R0, #+36]
    404          	RTCx->SEC = pFullTime->SEC & RTC_SEC_MASK;
   \   00000030   0x780A             LDRB     R2,[R1, #+0]
   \   00000032   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   00000036   0xF880 0x2020      STRB     R2,[R0, #+32]
    405          	RTCx->MONTH = pFullTime->MONTH & RTC_MONTH_MASK;
   \   0000003A   0x7E0A             LDRB     R2,[R1, #+24]
   \   0000003C   0xF012 0x020F      ANDS     R2,R2,#0xF
   \   00000040   0xF880 0x2038      STRB     R2,[R0, #+56]
    406          	RTCx->YEAR = pFullTime->YEAR & RTC_YEAR_MASK;
   \   00000044   0x69CA             LDR      R2,[R1, #+28]
   \   00000046   0x0512             LSLS     R2,R2,#+20       ;; ZeroExtS R2,R2,#+20,#+20
   \   00000048   0x0D12             LSRS     R2,R2,#+20
   \   0000004A   0x8782             STRH     R2,[R0, #+60]
    407          }
   \   0000004C   0x4770             BX       LR               ;; return
    408          
    409          
    410          /*********************************************************************//**
    411           * @brief 		Get full of time in RTC peripheral
    412           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    413           * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
    414           * 				will be stored time in full.
    415           * @return 		None
    416           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    417          void RTC_GetFullTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
    418          {
    419          	pFullTime->DOM = RTCx->DOM & RTC_DOM_MASK;
   \                     RTC_GetFullTime:
   \   00000000   0xF890 0x202C      LDRB     R2,[R0, #+44]
   \   00000004   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   00000008   0x60CA             STR      R2,[R1, #+12]
    420          	pFullTime->DOW = RTCx->DOW & RTC_DOW_MASK;
   \   0000000A   0xF890 0x2030      LDRB     R2,[R0, #+48]
   \   0000000E   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   00000012   0x610A             STR      R2,[R1, #+16]
    421          	pFullTime->DOY = RTCx->DOY & RTC_DOY_MASK;
   \   00000014   0x8E82             LDRH     R2,[R0, #+52]
   \   00000016   0x05D2             LSLS     R2,R2,#+23       ;; ZeroExtS R2,R2,#+23,#+23
   \   00000018   0x0DD2             LSRS     R2,R2,#+23
   \   0000001A   0x614A             STR      R2,[R1, #+20]
    422          	pFullTime->HOUR = RTCx->HOUR & RTC_HOUR_MASK;
   \   0000001C   0xF890 0x2028      LDRB     R2,[R0, #+40]
   \   00000020   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   00000024   0x608A             STR      R2,[R1, #+8]
    423          	pFullTime->MIN = RTCx->MIN & RTC_MIN_MASK;
   \   00000026   0xF890 0x2024      LDRB     R2,[R0, #+36]
   \   0000002A   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   0000002E   0x604A             STR      R2,[R1, #+4]
    424          	pFullTime->SEC = RTCx->SEC & RTC_SEC_MASK;
   \   00000030   0xF890 0x2020      LDRB     R2,[R0, #+32]
   \   00000034   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   00000038   0x600A             STR      R2,[R1, #+0]
    425          	pFullTime->MONTH = RTCx->MONTH & RTC_MONTH_MASK;
   \   0000003A   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   0000003E   0xF012 0x020F      ANDS     R2,R2,#0xF
   \   00000042   0x618A             STR      R2,[R1, #+24]
    426          	pFullTime->YEAR = RTCx->YEAR & RTC_YEAR_MASK;
   \   00000044   0x8F82             LDRH     R2,[R0, #+60]
   \   00000046   0x0512             LSLS     R2,R2,#+20       ;; ZeroExtS R2,R2,#+20,#+20
   \   00000048   0x0D12             LSRS     R2,R2,#+20
   \   0000004A   0x61CA             STR      R2,[R1, #+28]
    427          }
   \   0000004C   0x4770             BX       LR               ;; return
    428          
    429          
    430          /*********************************************************************//**
    431           * @brief 		Set alarm time value for each time type
    432           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    433           * @param[in]	Timetype: Time Type, should be:
    434           * 				- RTC_TIMETYPE_SECOND
    435           * 				- RTC_TIMETYPE_MINUTE
    436           * 				- RTC_TIMETYPE_HOUR
    437           * 				- RTC_TIMETYPE_DAYOFWEEK
    438           * 				- RTC_TIMETYPE_DAYOFMONTH
    439           * 				- RTC_TIMETYPE_DAYOFYEAR
    440           * 				- RTC_TIMETYPE_MONTH
    441           * 				- RTC_TIMETYPE_YEAR
    442           * @param[in]	ALValue Alarm time value to set
    443           * @return 		None
    444           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    445          void RTC_SetAlarmTime (LPC_RTC_TypeDef *RTCx, uint32_t Timetype, uint32_t ALValue)
    446          {
   \                     RTC_SetAlarmTime:
   \   00000000   0xB410             PUSH     {R4}
    447          	switch (Timetype)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00B             BEQ.N    ??RTC_SetAlarmTime_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD019             BEQ.N    ??RTC_SetAlarmTime_1
   \   0000000A   0xD310             BCC.N    ??RTC_SetAlarmTime_2
   \   0000000C   0x2904             CMP      R1,#+4
   \   0000000E   0xD026             BEQ.N    ??RTC_SetAlarmTime_3
   \   00000010   0xD31D             BCC.N    ??RTC_SetAlarmTime_4
   \   00000012   0x2906             CMP      R1,#+6
   \   00000014   0xD04F             BEQ.N    ??RTC_SetAlarmTime_5
   \   00000016   0xD337             BCC.N    ??RTC_SetAlarmTime_6
   \   00000018   0x2907             CMP      R1,#+7
   \   0000001A   0xD061             BEQ.N    ??RTC_SetAlarmTime_7
   \   0000001C   0xE06A             B.N      ??RTC_SetAlarmTime_8
    448          	{
    449          	case RTC_TIMETYPE_SECOND:
    450          		if(ALValue >= RTC_SECOND_MAX)
   \                     ??RTC_SetAlarmTime_0:
   \   0000001E   0x2A3B             CMP      R2,#+59
   \   00000020   0xD300             BCC.N    ??RTC_SetAlarmTime_9
    451          			while(1); //error loop
   \                     ??RTC_SetAlarmTime_10:
   \   00000022   0xE7FE             B.N      ??RTC_SetAlarmTime_10
    452          		RTCx->ALSEC = ALValue & RTC_SEC_MASK;
   \                     ??RTC_SetAlarmTime_9:
   \   00000024   0xF012 0x033F      ANDS     R3,R2,#0x3F
   \   00000028   0xF880 0x3060      STRB     R3,[R0, #+96]
    453          		break;
   \   0000002C   0xE062             B.N      ??RTC_SetAlarmTime_8
    454          
    455          	case RTC_TIMETYPE_MINUTE:
    456          		if(ALValue >= RTC_MINUTE_MAX)
   \                     ??RTC_SetAlarmTime_2:
   \   0000002E   0x2A3B             CMP      R2,#+59
   \   00000030   0xD300             BCC.N    ??RTC_SetAlarmTime_11
    457          			while(1); //error loop
   \                     ??RTC_SetAlarmTime_12:
   \   00000032   0xE7FE             B.N      ??RTC_SetAlarmTime_12
    458          		RTCx->ALMIN = ALValue & RTC_MIN_MASK;
   \                     ??RTC_SetAlarmTime_11:
   \   00000034   0xF012 0x033F      ANDS     R3,R2,#0x3F
   \   00000038   0xF880 0x3064      STRB     R3,[R0, #+100]
    459          		break;
   \   0000003C   0xE05A             B.N      ??RTC_SetAlarmTime_8
    460          
    461          	case RTC_TIMETYPE_HOUR:
    462          		if(ALValue >= RTC_HOUR_MAX)
   \                     ??RTC_SetAlarmTime_1:
   \   0000003E   0x2A17             CMP      R2,#+23
   \   00000040   0xD300             BCC.N    ??RTC_SetAlarmTime_13
    463          			while(1); //error loop
   \                     ??RTC_SetAlarmTime_14:
   \   00000042   0xE7FE             B.N      ??RTC_SetAlarmTime_14
    464          		RTCx->ALHOUR = ALValue & RTC_HOUR_MASK;
   \                     ??RTC_SetAlarmTime_13:
   \   00000044   0xF012 0x031F      ANDS     R3,R2,#0x1F
   \   00000048   0xF880 0x3068      STRB     R3,[R0, #+104]
    465          		break;
   \   0000004C   0xE052             B.N      ??RTC_SetAlarmTime_8
    466          
    467          	case RTC_TIMETYPE_DAYOFWEEK:
    468          		if(ALValue >= RTC_DAYOFWEEK_MAX)
   \                     ??RTC_SetAlarmTime_4:
   \   0000004E   0x2A06             CMP      R2,#+6
   \   00000050   0xD300             BCC.N    ??RTC_SetAlarmTime_15
    469          			while(1); //error loop
   \                     ??RTC_SetAlarmTime_16:
   \   00000052   0xE7FE             B.N      ??RTC_SetAlarmTime_16
    470          		RTCx->ALDOW = ALValue & RTC_DOW_MASK;
   \                     ??RTC_SetAlarmTime_15:
   \   00000054   0xF012 0x0307      ANDS     R3,R2,#0x7
   \   00000058   0xF880 0x3070      STRB     R3,[R0, #+112]
    471          		break;
   \   0000005C   0xE04A             B.N      ??RTC_SetAlarmTime_8
    472          
    473          	case RTC_TIMETYPE_DAYOFMONTH:
    474          		if((ALValue <= RTC_DAYOFMONTH_MIN)|(ALValue >= RTC_DAYOFMONTH_MAX))
   \                     ??RTC_SetAlarmTime_3:
   \   0000005E   0x2A02             CMP      R2,#+2
   \   00000060   0xD201             BCS.N    ??RTC_SetAlarmTime_17
   \   00000062   0x2301             MOVS     R3,#+1
   \   00000064   0xE000             B.N      ??RTC_SetAlarmTime_18
   \                     ??RTC_SetAlarmTime_17:
   \   00000066   0x2300             MOVS     R3,#+0
   \                     ??RTC_SetAlarmTime_18:
   \   00000068   0x2A1F             CMP      R2,#+31
   \   0000006A   0xD301             BCC.N    ??RTC_SetAlarmTime_19
   \   0000006C   0x2401             MOVS     R4,#+1
   \   0000006E   0xE000             B.N      ??RTC_SetAlarmTime_20
   \                     ??RTC_SetAlarmTime_19:
   \   00000070   0x2400             MOVS     R4,#+0
   \                     ??RTC_SetAlarmTime_20:
   \   00000072   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x4323             ORRS     R3,R4,R3
   \   00000078   0x2B00             CMP      R3,#+0
   \   0000007A   0xD000             BEQ.N    ??RTC_SetAlarmTime_21
    475          			while(1); //error loop
   \                     ??RTC_SetAlarmTime_22:
   \   0000007C   0xE7FE             B.N      ??RTC_SetAlarmTime_22
    476          		RTCx->ALDOM = ALValue & RTC_DOM_MASK;
   \                     ??RTC_SetAlarmTime_21:
   \   0000007E   0xF012 0x031F      ANDS     R3,R2,#0x1F
   \   00000082   0xF880 0x306C      STRB     R3,[R0, #+108]
    477          		break;
   \   00000086   0xE035             B.N      ??RTC_SetAlarmTime_8
    478          
    479          	case RTC_TIMETYPE_DAYOFYEAR:
    480          		if((ALValue <= RTC_DAYOFYEAR_MIN)|(ALValue >= RTC_DAYOFYEAR_MAX))
   \                     ??RTC_SetAlarmTime_6:
   \   00000088   0x2A02             CMP      R2,#+2
   \   0000008A   0xD201             BCS.N    ??RTC_SetAlarmTime_23
   \   0000008C   0x2301             MOVS     R3,#+1
   \   0000008E   0xE000             B.N      ??RTC_SetAlarmTime_24
   \                     ??RTC_SetAlarmTime_23:
   \   00000090   0x2300             MOVS     R3,#+0
   \                     ??RTC_SetAlarmTime_24:
   \   00000092   0xF5B2 0x7FB7      CMP      R2,#+366
   \   00000096   0xD301             BCC.N    ??RTC_SetAlarmTime_25
   \   00000098   0x2401             MOVS     R4,#+1
   \   0000009A   0xE000             B.N      ??RTC_SetAlarmTime_26
   \                     ??RTC_SetAlarmTime_25:
   \   0000009C   0x2400             MOVS     R4,#+0
   \                     ??RTC_SetAlarmTime_26:
   \   0000009E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A2   0x4323             ORRS     R3,R4,R3
   \   000000A4   0x2B00             CMP      R3,#+0
   \   000000A6   0xD000             BEQ.N    ??RTC_SetAlarmTime_27
    481          			while(1); //error loop
   \                     ??RTC_SetAlarmTime_28:
   \   000000A8   0xE7FE             B.N      ??RTC_SetAlarmTime_28
    482          		RTCx->ALDOY = ALValue & RTC_DOY_MASK;
   \                     ??RTC_SetAlarmTime_27:
   \   000000AA   0x0013             MOVS     R3,R2
   \   000000AC   0x05DB             LSLS     R3,R3,#+23       ;; ZeroExtS R3,R3,#+23,#+23
   \   000000AE   0x0DDB             LSRS     R3,R3,#+23
   \   000000B0   0xF8A0 0x3074      STRH     R3,[R0, #+116]
    483          		break;
   \   000000B4   0xE01E             B.N      ??RTC_SetAlarmTime_8
    484          
    485          	case RTC_TIMETYPE_MONTH:
    486          		if((ALValue <= RTC_MONTH_MIN)|(ALValue >= RTC_MONTH_MAX))
   \                     ??RTC_SetAlarmTime_5:
   \   000000B6   0x2A02             CMP      R2,#+2
   \   000000B8   0xD201             BCS.N    ??RTC_SetAlarmTime_29
   \   000000BA   0x2301             MOVS     R3,#+1
   \   000000BC   0xE000             B.N      ??RTC_SetAlarmTime_30
   \                     ??RTC_SetAlarmTime_29:
   \   000000BE   0x2300             MOVS     R3,#+0
   \                     ??RTC_SetAlarmTime_30:
   \   000000C0   0x2A0C             CMP      R2,#+12
   \   000000C2   0xD301             BCC.N    ??RTC_SetAlarmTime_31
   \   000000C4   0x2401             MOVS     R4,#+1
   \   000000C6   0xE000             B.N      ??RTC_SetAlarmTime_32
   \                     ??RTC_SetAlarmTime_31:
   \   000000C8   0x2400             MOVS     R4,#+0
   \                     ??RTC_SetAlarmTime_32:
   \   000000CA   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000CC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CE   0x4323             ORRS     R3,R4,R3
   \   000000D0   0x2B00             CMP      R3,#+0
   \   000000D2   0xD000             BEQ.N    ??RTC_SetAlarmTime_33
    487          			while(1); //error loop
   \                     ??RTC_SetAlarmTime_34:
   \   000000D4   0xE7FE             B.N      ??RTC_SetAlarmTime_34
    488          		RTCx->ALMON = ALValue & RTC_MONTH_MASK;
   \                     ??RTC_SetAlarmTime_33:
   \   000000D6   0xF012 0x030F      ANDS     R3,R2,#0xF
   \   000000DA   0xF880 0x3078      STRB     R3,[R0, #+120]
    489          		break;
   \   000000DE   0xE009             B.N      ??RTC_SetAlarmTime_8
    490          
    491          	case RTC_TIMETYPE_YEAR:
    492          		if(ALValue >= RTC_YEAR_MAX)
   \                     ??RTC_SetAlarmTime_7:
   \   000000E0   0xF640 0x73FF      MOVW     R3,#+4095
   \   000000E4   0x429A             CMP      R2,R3
   \   000000E6   0xD300             BCC.N    ??RTC_SetAlarmTime_35
    493          			while(1); //error loop
   \                     ??RTC_SetAlarmTime_36:
   \   000000E8   0xE7FE             B.N      ??RTC_SetAlarmTime_36
    494          		RTCx->ALYEAR = ALValue & RTC_YEAR_MASK;
   \                     ??RTC_SetAlarmTime_35:
   \   000000EA   0x0013             MOVS     R3,R2
   \   000000EC   0x051B             LSLS     R3,R3,#+20       ;; ZeroExtS R3,R3,#+20,#+20
   \   000000EE   0x0D1B             LSRS     R3,R3,#+20
   \   000000F0   0xF8A0 0x307C      STRH     R3,[R0, #+124]
    495          		break;
    496          	}
    497          }
   \                     ??RTC_SetAlarmTime_8:
   \   000000F4   0xBC10             POP      {R4}
   \   000000F6   0x4770             BX       LR               ;; return
    498          
    499          
    500          
    501          /*********************************************************************//**
    502           * @brief 		Get alarm time value for each time type
    503           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    504           * @param[in]	Timetype: Time Type, should be:
    505           * 				- RTC_TIMETYPE_SECOND
    506           * 				- RTC_TIMETYPE_MINUTE
    507           * 				- RTC_TIMETYPE_HOUR
    508           * 				- RTC_TIMETYPE_DAYOFWEEK
    509           * 				- RTC_TIMETYPE_DAYOFMONTH
    510           * 				- RTC_TIMETYPE_DAYOFYEAR
    511           * 				- RTC_TIMETYPE_MONTH
    512           * 				- RTC_TIMETYPE_YEAR
    513            * @return 	Value of Alarm time according to specified time type
    514           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    515          uint32_t RTC_GetAlarmTime (LPC_RTC_TypeDef *RTCx, uint32_t Timetype)
    516          {
   \                     RTC_GetAlarmTime:
   \   00000000   0x0002             MOVS     R2,R0
    517          	switch (Timetype)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00B             BEQ.N    ??RTC_GetAlarmTime_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD013             BEQ.N    ??RTC_GetAlarmTime_1
   \   0000000A   0xD30D             BCC.N    ??RTC_GetAlarmTime_2
   \   0000000C   0x2904             CMP      R1,#+4
   \   0000000E   0xD01A             BEQ.N    ??RTC_GetAlarmTime_3
   \   00000010   0xD314             BCC.N    ??RTC_GetAlarmTime_4
   \   00000012   0x2906             CMP      R1,#+6
   \   00000014   0xD021             BEQ.N    ??RTC_GetAlarmTime_5
   \   00000016   0xD31B             BCC.N    ??RTC_GetAlarmTime_6
   \   00000018   0x2907             CMP      R1,#+7
   \   0000001A   0xD023             BEQ.N    ??RTC_GetAlarmTime_7
   \   0000001C   0xE027             B.N      ??RTC_GetAlarmTime_8
    518          	{
    519          	case RTC_TIMETYPE_SECOND:
    520          		return (RTCx->ALSEC & RTC_SEC_MASK);
   \                     ??RTC_GetAlarmTime_0:
   \   0000001E   0xF892 0x0060      LDRB     R0,[R2, #+96]
   \   00000022   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000026   0xE023             B.N      ??RTC_GetAlarmTime_9
    521          	case RTC_TIMETYPE_MINUTE:
    522          		return (RTCx->ALMIN & RTC_MIN_MASK);
   \                     ??RTC_GetAlarmTime_2:
   \   00000028   0xF892 0x0064      LDRB     R0,[R2, #+100]
   \   0000002C   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000030   0xE01E             B.N      ??RTC_GetAlarmTime_9
    523          	case RTC_TIMETYPE_HOUR:
    524          		return (RTCx->ALHOUR & RTC_HOUR_MASK);
   \                     ??RTC_GetAlarmTime_1:
   \   00000032   0xF892 0x0068      LDRB     R0,[R2, #+104]
   \   00000036   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000003A   0xE019             B.N      ??RTC_GetAlarmTime_9
    525          	case RTC_TIMETYPE_DAYOFWEEK:
    526          		return (RTCx->ALDOW & RTC_DOW_MASK);
   \                     ??RTC_GetAlarmTime_4:
   \   0000003C   0xF892 0x0070      LDRB     R0,[R2, #+112]
   \   00000040   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000044   0xE014             B.N      ??RTC_GetAlarmTime_9
    527          	case RTC_TIMETYPE_DAYOFMONTH:
    528          		return (RTCx->ALDOM & RTC_DOM_MASK);
   \                     ??RTC_GetAlarmTime_3:
   \   00000046   0xF892 0x006C      LDRB     R0,[R2, #+108]
   \   0000004A   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000004E   0xE00F             B.N      ??RTC_GetAlarmTime_9
    529          	case RTC_TIMETYPE_DAYOFYEAR:
    530          		return (RTCx->ALDOY & RTC_DOY_MASK);
   \                     ??RTC_GetAlarmTime_6:
   \   00000050   0xF8B2 0x0074      LDRH     R0,[R2, #+116]
   \   00000054   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000056   0x0DC0             LSRS     R0,R0,#+23
   \   00000058   0xE00A             B.N      ??RTC_GetAlarmTime_9
    531          	case RTC_TIMETYPE_MONTH:
    532          		return (RTCx->ALMON & RTC_MONTH_MASK);
   \                     ??RTC_GetAlarmTime_5:
   \   0000005A   0xF892 0x0078      LDRB     R0,[R2, #+120]
   \   0000005E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000062   0xE005             B.N      ??RTC_GetAlarmTime_9
    533          	case RTC_TIMETYPE_YEAR:
    534          		return (RTCx->ALYEAR & RTC_YEAR_MASK);
   \                     ??RTC_GetAlarmTime_7:
   \   00000064   0xF8B2 0x007C      LDRH     R0,[R2, #+124]
   \   00000068   0x0500             LSLS     R0,R0,#+20       ;; ZeroExtS R0,R0,#+20,#+20
   \   0000006A   0x0D00             LSRS     R0,R0,#+20
   \   0000006C   0xE000             B.N      ??RTC_GetAlarmTime_9
    535          	default:
    536          		return (0);
   \                     ??RTC_GetAlarmTime_8:
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??RTC_GetAlarmTime_9:
   \   00000070   0x4770             BX       LR               ;; return
    537          	}
    538          }
    539          
    540          
    541          /*********************************************************************//**
    542           * @brief 		Set full of alarm time in RTC peripheral
    543           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    544           * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
    545           * 				contains alarm time value in full.
    546           * @return 		None
    547           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    548          void RTC_SetFullAlarmTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
    549          {
    550          	RTCx->ALDOM = pFullTime->DOM & RTC_DOM_MASK;
   \                     RTC_SetFullAlarmTime:
   \   00000000   0x7B0A             LDRB     R2,[R1, #+12]
   \   00000002   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   00000006   0xF880 0x206C      STRB     R2,[R0, #+108]
    551          	RTCx->ALDOW = pFullTime->DOW & RTC_DOW_MASK;
   \   0000000A   0x7C0A             LDRB     R2,[R1, #+16]
   \   0000000C   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   00000010   0xF880 0x2070      STRB     R2,[R0, #+112]
    552          	RTCx->ALDOY = pFullTime->DOY & RTC_DOY_MASK;
   \   00000014   0x694A             LDR      R2,[R1, #+20]
   \   00000016   0x05D2             LSLS     R2,R2,#+23       ;; ZeroExtS R2,R2,#+23,#+23
   \   00000018   0x0DD2             LSRS     R2,R2,#+23
   \   0000001A   0xF8A0 0x2074      STRH     R2,[R0, #+116]
    553          	RTCx->ALHOUR = pFullTime->HOUR & RTC_HOUR_MASK;
   \   0000001E   0x7A0A             LDRB     R2,[R1, #+8]
   \   00000020   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   00000024   0xF880 0x2068      STRB     R2,[R0, #+104]
    554          	RTCx->ALMIN = pFullTime->MIN & RTC_MIN_MASK;
   \   00000028   0x790A             LDRB     R2,[R1, #+4]
   \   0000002A   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   0000002E   0xF880 0x2064      STRB     R2,[R0, #+100]
    555          	RTCx->ALSEC = pFullTime->SEC & RTC_SEC_MASK;
   \   00000032   0x780A             LDRB     R2,[R1, #+0]
   \   00000034   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   00000038   0xF880 0x2060      STRB     R2,[R0, #+96]
    556          	RTCx->ALMON = pFullTime->MONTH & RTC_MONTH_MASK;
   \   0000003C   0x7E0A             LDRB     R2,[R1, #+24]
   \   0000003E   0xF012 0x020F      ANDS     R2,R2,#0xF
   \   00000042   0xF880 0x2078      STRB     R2,[R0, #+120]
    557          	RTCx->ALYEAR = pFullTime->YEAR & RTC_YEAR_MASK;
   \   00000046   0x69CA             LDR      R2,[R1, #+28]
   \   00000048   0x0512             LSLS     R2,R2,#+20       ;; ZeroExtS R2,R2,#+20,#+20
   \   0000004A   0x0D12             LSRS     R2,R2,#+20
   \   0000004C   0xF8A0 0x207C      STRH     R2,[R0, #+124]
    558          }
   \   00000050   0x4770             BX       LR               ;; return
    559          
    560          
    561          /*********************************************************************//**
    562           * @brief 		Get full of alarm time in RTC peripheral
    563           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    564           * @param[in]	pFullTime Pointer to a RTC_TIME_Type structure that
    565           * 				will be stored alarm time in full.
    566           * @return 		None
    567           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    568          void RTC_GetFullAlarmTime (LPC_RTC_TypeDef *RTCx, RTC_TIME_Type *pFullTime)
    569          {
    570          	pFullTime->DOM = RTCx->ALDOM & RTC_DOM_MASK;
   \                     RTC_GetFullAlarmTime:
   \   00000000   0xF890 0x206C      LDRB     R2,[R0, #+108]
   \   00000004   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   00000008   0x60CA             STR      R2,[R1, #+12]
    571          	pFullTime->DOW = RTCx->ALDOW & RTC_DOW_MASK;
   \   0000000A   0xF890 0x2070      LDRB     R2,[R0, #+112]
   \   0000000E   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   00000012   0x610A             STR      R2,[R1, #+16]
    572          	pFullTime->DOY = RTCx->ALDOY & RTC_DOY_MASK;
   \   00000014   0xF8B0 0x2074      LDRH     R2,[R0, #+116]
   \   00000018   0x05D2             LSLS     R2,R2,#+23       ;; ZeroExtS R2,R2,#+23,#+23
   \   0000001A   0x0DD2             LSRS     R2,R2,#+23
   \   0000001C   0x614A             STR      R2,[R1, #+20]
    573          	pFullTime->HOUR = RTCx->ALHOUR & RTC_HOUR_MASK;
   \   0000001E   0xF890 0x2068      LDRB     R2,[R0, #+104]
   \   00000022   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   00000026   0x608A             STR      R2,[R1, #+8]
    574          	pFullTime->MIN = RTCx->ALMIN & RTC_MIN_MASK;
   \   00000028   0xF890 0x2064      LDRB     R2,[R0, #+100]
   \   0000002C   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   00000030   0x604A             STR      R2,[R1, #+4]
    575          	pFullTime->SEC = RTCx->ALSEC & RTC_SEC_MASK;
   \   00000032   0xF890 0x2060      LDRB     R2,[R0, #+96]
   \   00000036   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   0000003A   0x600A             STR      R2,[R1, #+0]
    576          	pFullTime->MONTH = RTCx->ALMON & RTC_MONTH_MASK;
   \   0000003C   0xF890 0x2078      LDRB     R2,[R0, #+120]
   \   00000040   0xF012 0x020F      ANDS     R2,R2,#0xF
   \   00000044   0x618A             STR      R2,[R1, #+24]
    577          	pFullTime->YEAR = RTCx->ALYEAR & RTC_YEAR_MASK;
   \   00000046   0xF8B0 0x207C      LDRH     R2,[R0, #+124]
   \   0000004A   0x0512             LSLS     R2,R2,#+20       ;; ZeroExtS R2,R2,#+20,#+20
   \   0000004C   0x0D12             LSRS     R2,R2,#+20
   \   0000004E   0x61CA             STR      R2,[R1, #+28]
    578          }
   \   00000050   0x4770             BX       LR               ;; return
    579          
    580          
    581          /*********************************************************************//**
    582           * @brief 		Check whether if specified Location interrupt in
    583           * 				RTC peripheral is set or not
    584           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    585           * @param[in]	IntType Interrupt location type, should be:
    586           * 						- RTC_INT_COUNTER_INCREASE: Counter Increment Interrupt
    587           * 							block generated an interrupt.
    588           * 						- RTC_INT_ALARM: Alarm generated an
    589           * 							interrupt.
    590           * @return 		New state of specified Location interrupt in RTC peripheral
    591           * 				(SET or RESET)
    592           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    593          IntStatus RTC_GetIntPending (LPC_RTC_TypeDef *RTCx, uint32_t IntType)
    594          {
    595          	return ((RTCx->ILR & IntType) ? SET : RESET);
   \                     RTC_GetIntPending:
   \   00000000   0x7800             LDRB     R0,[R0, #+0]
   \   00000002   0x4208             TST      R0,R1
   \   00000004   0xD001             BEQ.N    ??RTC_GetIntPending_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE000             B.N      ??RTC_GetIntPending_1
   \                     ??RTC_GetIntPending_0:
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??RTC_GetIntPending_1:
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return
    596          }
    597          
    598          
    599          /*********************************************************************//**
    600           * @brief 		Clear specified Location interrupt pending in
    601           * 				RTC peripheral
    602           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    603           * @param[in]	IntType Interrupt location type, should be:
    604           * 						- RTC_INT_COUNTER_INCREASE: Clear Counter Increment
    605           * 						Interrupt pending.
    606           * 						- RTC_INT_ALARM: Clear alarm interrupt pending
    607           * @return 		None
    608           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    609          void RTC_ClearIntPending (LPC_RTC_TypeDef *RTCx, uint32_t IntType)
    610          {
    611          	RTCx->ILR |= IntType;
   \                     RTC_ClearIntPending:
   \   00000000   0x7802             LDRB     R2,[R0, #+0]
   \   00000002   0x430A             ORRS     R2,R1,R2
   \   00000004   0x7002             STRB     R2,[R0, #+0]
    612          }
   \   00000006   0x4770             BX       LR               ;; return
    613          
    614          /*********************************************************************//**
    615           * @brief 		Enable/Disable calibration counter in RTC peripheral
    616           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    617           * @param[in]	NewState New State of this function, should be:
    618           * 				- ENABLE: The calibration counter is enabled and counting
    619           * 				- DISABLE: The calibration counter is disabled and reset to zero
    620           * @return 		None
    621           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    622          void RTC_CalibCounterCmd(LPC_RTC_TypeDef *RTCx, FunctionalState NewState)
    623          {
    624          	if (NewState == ENABLE)
   \                     RTC_CalibCounterCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD104             BNE.N    ??RTC_CalibCounterCmd_0
    625          	{
    626          		RTCx->CCR &= (~RTC_CCR_CCALEN) & RTC_CCR_BITMASK;
   \   00000006   0x7A02             LDRB     R2,[R0, #+8]
   \   00000008   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   0000000C   0x7202             STRB     R2,[R0, #+8]
   \   0000000E   0xE003             B.N      ??RTC_CalibCounterCmd_1
    627          	}
    628          	else
    629          	{
    630          		RTCx->CCR |= RTC_CCR_CCALEN;
   \                     ??RTC_CalibCounterCmd_0:
   \   00000010   0x7A02             LDRB     R2,[R0, #+8]
   \   00000012   0xF052 0x0210      ORRS     R2,R2,#0x10
   \   00000016   0x7202             STRB     R2,[R0, #+8]
    631          	}
    632          }
   \                     ??RTC_CalibCounterCmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    633          
    634          
    635          /*********************************************************************//**
    636           * @brief 		Configures Calibration in RTC peripheral
    637           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    638           * @param[in]	CalibValue Calibration value, should be in range from
    639           * 					0 to 131,072
    640           * @param[in]	CalibDir Calibration Direction, should be:
    641           * 					- RTC_CALIB_DIR_FORWARD: Forward calibration
    642           * 					- RTC_CALIB_DIR_BACKWARD: Backward calibration
    643           * @return 		None
    644           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    645          void RTC_CalibConfig(LPC_RTC_TypeDef *RTCx, uint32_t CalibValue, uint8_t CalibDir)
    646          {
   \                     RTC_CalibConfig:
   \   00000000   0xB410             PUSH     {R4}
    647          	RTCx->CALIBRATION = ((CalibValue - 1) & RTC_CALIBRATION_CALVAL_MASK) \
    648          			| ((CalibDir == RTC_CALIB_DIR_BACKWARD) ? RTC_CALIBRATION_LIBDIR : 0);
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD102             BNE.N    ??RTC_CalibConfig_0
   \   00000008   0xF45F 0x3300      MOVS     R3,#+131072
   \   0000000C   0xE000             B.N      ??RTC_CalibConfig_1
   \                     ??RTC_CalibConfig_0:
   \   0000000E   0x2300             MOVS     R3,#+0
   \                     ??RTC_CalibConfig_1:
   \   00000010   0x1E4C             SUBS     R4,R1,#+1
   \   00000012   0x03E4             LSLS     R4,R4,#+15       ;; ZeroExtS R4,R4,#+15,#+15
   \   00000014   0x0BE4             LSRS     R4,R4,#+15
   \   00000016   0x4323             ORRS     R3,R3,R4
   \   00000018   0x6403             STR      R3,[R0, #+64]
    649          }
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    650          
    651          
    652          /*********************************************************************//**
    653           * @brief 		Write value to General purpose registers
    654           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    655           * @param[in]	Channel General purpose registers Channel number,
    656           * 				should be in range from 0 to 4.
    657           * @param[in]	Value Value to write
    658           * @return 		None
    659           * Note: These General purpose registers can be used to store important
    660           * information when the main power supply is off. The value in these
    661           * registers is not affected by chip reset.
    662           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    663          void RTC_WriteGPREG (LPC_RTC_TypeDef *RTCx, uint8_t Channel, uint32_t Value)
    664          {
   \                     RTC_WriteGPREG:
   \   00000000   0xB410             PUSH     {R4}
    665          	uint32_t *preg;
    666          
    667          	preg = (uint32_t *)&RTCx->GPREG0;
   \   00000002   0xF110 0x0444      ADDS     R4,R0,#+68
   \   00000006   0x0023             MOVS     R3,R4
    668          	preg += Channel;
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xEB13 0x0381      ADDS     R3,R3,R1, LSL #+2
    669          	*preg = Value;
   \   0000000E   0x601A             STR      R2,[R3, #+0]
    670          }
   \   00000010   0xBC10             POP      {R4}
   \   00000012   0x4770             BX       LR               ;; return
    671          
    672          
    673          /*********************************************************************//**
    674           * @brief 		Read value from General purpose registers
    675           * @param[in]	RTCx	RTC peripheral selected, should be LPC_RTC
    676           * @param[in]	Channel General purpose registers Channel number,
    677           * 				should be in range from 0 to 4.
    678           * @return 		Read Value
    679           * Note: These General purpose registers can be used to store important
    680           * information when the main power supply is off. The value in these
    681           * registers is not affected by chip reset.
    682           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    683          uint32_t RTC_ReadGPREG (LPC_RTC_TypeDef *RTCx, uint8_t Channel)
    684          {
   \                     RTC_ReadGPREG:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    685          	uint32_t *preg;
    686          	uint32_t value;
    687          
    688          	preg = (uint32_t *)&RTCx->GPREG0;
   \   00000004   0xF112 0x0444      ADDS     R4,R2,#+68
   \   00000008   0x0023             MOVS     R3,R4
    689          	preg += Channel;
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0xEB13 0x0381      ADDS     R3,R3,R1, LSL #+2
    690          	value = *preg;
   \   00000010   0x681C             LDR      R4,[R3, #+0]
   \   00000012   0x0020             MOVS     R0,R4
    691          	return (value);
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    692          }
    693          
    694          /**
    695           * @}
    696           */
    697          
    698          
    699          /**
    700           * @}
    701           */
    702          
    703          /* --------------------------------- End Of File ------------------------------ */
    704          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   RTC_AlarmIntConfig
       4   RTC_CalibConfig
       0   RTC_CalibCounterCmd
       0   RTC_ClearIntPending
       0   RTC_Cmd
       0   RTC_CntIncrIntConfig
       8   RTC_DeInit
         8   -> CLKPWR_ConfigPPWR
       0   RTC_GetAlarmTime
       0   RTC_GetFullAlarmTime
       0   RTC_GetFullTime
       0   RTC_GetIntPending
       0   RTC_GetTime
       8   RTC_Init
         8   -> CLKPWR_ConfigPPWR
       4   RTC_ReadGPREG
       0   RTC_ResetClockTickCounter
       4   RTC_SetAlarmTime
       0   RTC_SetFullAlarmTime
       0   RTC_SetFullTime
       4   RTC_SetTime
       4   RTC_WriteGPREG


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     222  RTC_AlarmIntConfig
      30  RTC_CalibConfig
      26  RTC_CalibCounterCmd
       8  RTC_ClearIntPending
      26  RTC_Cmd
     222  RTC_CntIncrIntConfig
      20  RTC_DeInit
     114  RTC_GetAlarmTime
      82  RTC_GetFullAlarmTime
      78  RTC_GetFullTime
      16  RTC_GetIntPending
     110  RTC_GetTime
      36  RTC_Init
      24  RTC_ReadGPREG
      18  RTC_ResetClockTickCounter
     248  RTC_SetAlarmTime
      82  RTC_SetFullAlarmTime
      78  RTC_SetFullTime
     242  RTC_SetTime
      20  RTC_WriteGPREG

 
 1 702 bytes in section .text
 
 1 702 bytes of CODE memory

Errors: none
Warnings: none
