###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:24 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_ssp.c                             #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_ssp.c -lCN                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\ -o D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë #
#                    \RTU_1.2\project\iar\Debug\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\lpc177x_8x_ssp.lst                         #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\lpc177x_8x_ssp.o                            #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Drivers\source\lpc177x_8x_ssp.c
      1          /**********************************************************************
      2          * $Id$		lpc177x_8x_ssp.c			2011-06-02
      3          *//**
      4          * @file		lpc177x_8x_ssp.c
      5          * @brief	Contains all functions support for SSP firmware library
      6          *			on LPC177x_8x
      7          * @version	1.0
      8          * @date		02. June. 2011
      9          * @author	NXP MCU SW Application Team
     10          * 
     11          * Copyright(C) 2011, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          **********************************************************************/
     26          
     27          /* Peripheral group ----------------------------------------------------------- */
     28          /** @addtogroup SSP
     29           * @{
     30           */
     31          
     32          /* Includes ------------------------------------------------------------------- */
     33          #include "lpc177x_8x_ssp.h"
     34          #include "lpc177x_8x_clkpwr.h"
     35          
     36          /* Public Functions ----------------------------------------------------------- */
     37          /** @addtogroup SSP_Public_Functions
     38           * @{
     39           */
     40          static void setSSPclock (LPC_SSP_TypeDef *SSPx, uint32_t target_clock);
     41          
     42          /*********************************************************************//**
     43           * @brief 		Setup clock rate for SSP device
     44           * @param[in] 	SSPx	SSP peripheral definition, should be:
     45           * 						- LPC_SSP0: SSP0 peripheral
     46           * 						- LPC_SSP1: SSP1 peripheral
     47           * @param[in]	target_clock : clock of SSP (Hz)
     48           * @return 		None
     49           ***********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     50          static void setSSPclock (LPC_SSP_TypeDef *SSPx, uint32_t target_clock)
     51          {
   \                     setSSPclock:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     52              uint32_t prescale, cr0_div, cmp_clk, ssp_clk;
     53              ssp_clk = CLKPWR_GetCLK (CLKPWR_CLKTYPE_PER);
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       CLKPWR_GetCLK
   \   0000000E   0x4681             MOV      R9,R0
     54          
     55          	/* Find closest divider to get at or under the target frequency.
     56          	   Use smallest prescale possible and rely on the divider to get
     57          	   the closest target frequency */
     58          	cr0_div = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0007             MOVS     R7,R0
     59          	cmp_clk = 0xFFFFFFFF;
   \   00000014   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000018   0x4680             MOV      R8,R0
     60          	prescale = 2;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x0006             MOVS     R6,R0
     61          	while (cmp_clk > target_clock)
   \                     ??setSSPclock_0:
   \   0000001E   0x4545             CMP      R5,R8
   \   00000020   0xD20D             BCS.N    ??setSSPclock_1
     62          	{
     63          		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
   \   00000022   0x1C78             ADDS     R0,R7,#+1
   \   00000024   0x4370             MULS     R0,R6,R0
   \   00000026   0xFBB9 0xF0F0      UDIV     R0,R9,R0
   \   0000002A   0x4680             MOV      R8,R0
     64          		if (cmp_clk > target_clock)
   \   0000002C   0x4545             CMP      R5,R8
   \   0000002E   0xD2F6             BCS.N    ??setSSPclock_0
     65          		{
     66          			cr0_div++;
   \   00000030   0x1C7F             ADDS     R7,R7,#+1
     67          			if (cr0_div > 0xFF)
   \   00000032   0x2FFF             CMP      R7,#+255
   \   00000034   0xD9F3             BLS.N    ??setSSPclock_0
     68          			{
     69          				cr0_div = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0007             MOVS     R7,R0
     70          				prescale += 2;
   \   0000003A   0x1CB6             ADDS     R6,R6,#+2
   \   0000003C   0xE7EF             B.N      ??setSSPclock_0
     71          			}
     72          		}
     73          	}
     74          
     75              /* Write computed prescaler and divider back to register */
     76              SSPx->CR0 &= (~SSP_CR0_SCR(0xFF)) & SSP_CR0_BITMASK;
   \                     ??setSSPclock_1:
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x6020             STR      R0,[R4, #+0]
     77              SSPx->CR0 |= (SSP_CR0_SCR(cr0_div)) & SSP_CR0_BITMASK;
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x0239             LSLS     R1,R7,#+8
   \   00000048   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004A   0x4308             ORRS     R0,R1,R0
   \   0000004C   0x6020             STR      R0,[R4, #+0]
     78              SSPx->CPSR = prescale & SSP_CPSR_BITMASK;
   \   0000004E   0xB2F0             UXTB     R0,R6            ;; ZeroExt  R0,R6,#+24,#+24
   \   00000050   0x6120             STR      R0,[R4, #+16]
     79          }
   \   00000052   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
     80          
     81          /**
     82           * @}
     83           */
     84          
     85          /* Public Functions ----------------------------------------------------------- */
     86          /** @addtogroup SSP_Public_Functions
     87           * @{
     88           */
     89          
     90          /********************************************************************//**
     91           * @brief		Initializes the SSPx peripheral according to the specified
     92          *               parameters in the SSP_ConfigStruct.
     93           * @param[in]	SSPx	SSP peripheral selected, should be:
     94           * 				 		- LPC_SSP0: SSP0 peripheral
     95           * 						- LPC_SSP1: SSP1 peripheral
     96           * @param[in]	SSP_ConfigStruct Pointer to a SSP_CFG_Type structure
     97          *                    that contains the configuration information for the
     98          *                    specified SSP peripheral.
     99           * @return 		None
    100           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    101          void SSP_Init(LPC_SSP_TypeDef *SSPx, SSP_CFG_Type *SSP_ConfigStruct)
    102          {
   \                     SSP_Init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    103          	uint32_t tmp;
    104          
    105          	if(SSPx == LPC_SSP0) {
   \   00000006   0x....             LDR.N    R0,??DataTable2  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD105             BNE.N    ??SSP_Init_0
    106          		/* Set up clock and power for SSP0 module */
    107          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP0, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000012   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000016   0xE009             B.N      ??SSP_Init_1
    108          	} else if(SSPx == LPC_SSP1) {
   \                     ??SSP_Init_0:
   \   00000018   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40030000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD105             BNE.N    ??SSP_Init_2
    109          		/* Set up clock and power for SSP1 module */
    110          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP1, ENABLE);
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xF44F 0x6080      MOV      R0,#+1024
   \   00000024   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000028   0xE000             B.N      ??SSP_Init_1
    111          	} else {
    112          		return;
   \                     ??SSP_Init_2:
   \   0000002A   0xE012             B.N      ??SSP_Init_3
    113          	}
    114          
    115          	/* Configure SSP, interrupt is disable, LoopBack mode is disable,
    116          	 * SSP is disable, Slave output is disable as default
    117          	 */
    118          	tmp = ((SSP_ConfigStruct->CPHA) | (SSP_ConfigStruct->CPOL) \
    119          		| (SSP_ConfigStruct->FrameFormat) | (SSP_ConfigStruct->Databit))
    120          		& SSP_CR0_BITMASK;
   \                     ??SSP_Init_1:
   \   0000002C   0x6868             LDR      R0,[R5, #+4]
   \   0000002E   0x68A9             LDR      R1,[R5, #+8]
   \   00000030   0x4308             ORRS     R0,R1,R0
   \   00000032   0x6929             LDR      R1,[R5, #+16]
   \   00000034   0x4308             ORRS     R0,R1,R0
   \   00000036   0x6829             LDR      R1,[R5, #+0]
   \   00000038   0x4308             ORRS     R0,R1,R0
   \   0000003A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003C   0x0006             MOVS     R6,R0
    121          	// write back to SSP control register
    122          	SSPx->CR0 = tmp;
   \   0000003E   0x6026             STR      R6,[R4, #+0]
    123          
    124          	tmp = SSP_ConfigStruct->Mode & SSP_CR1_BITMASK;
   \   00000040   0x7B28             LDRB     R0,[R5, #+12]
   \   00000042   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000046   0x0006             MOVS     R6,R0
    125          	// Write back to CR1
    126          	SSPx->CR1 = tmp;
   \   00000048   0x6066             STR      R6,[R4, #+4]
    127          
    128          	// Set clock rate for SSP peripheral
    129          	setSSPclock(SSPx, SSP_ConfigStruct->ClockRate);
   \   0000004A   0x6969             LDR      R1,[R5, #+20]
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       setSSPclock
    130          }
   \                     ??SSP_Init_3:
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    131          
    132          /*********************************************************************//**
    133           * @brief		De-initializes the SSPx peripheral registers to their
    134          *                  default reset values.
    135           * @param[in]	SSPx	SSP peripheral selected, should be:
    136           * 				 		- LPC_SSP0: SSP0 peripheral
    137           * 						- LPC_SSP1: SSP1 peripheral
    138           * @return 		None
    139           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    140          void SSP_DeInit(LPC_SSP_TypeDef* SSPx)
    141          {
   \                     SSP_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    142          	if (SSPx == LPC_SSP0){
   \   00000004   0x....             LDR.N    R0,??DataTable2  ;; 0x40088000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD105             BNE.N    ??SSP_DeInit_0
    143          		/* Set up clock and power for SSP0 module */
    144          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP0, DISABLE);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000010   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000014   0xE007             B.N      ??SSP_DeInit_1
    145          	} else if (SSPx == LPC_SSP1) {
   \                     ??SSP_DeInit_0:
   \   00000016   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40030000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD104             BNE.N    ??SSP_DeInit_1
    146          		/* Set up clock and power for SSP1 module */
    147          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP1, DISABLE);
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000022   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    148          	}
    149          }
   \                     ??SSP_DeInit_1:
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    150          
    151          /*****************************************************************************//**
    152          * @brief		Get data size bit selected
    153          * @param[in]	SSPx pointer to LPC_SSP_TypeDef structure, should be:
    154          * 				- LPC_SSP0: SSP0 peripheral
    155          * 				- LPC_SSP1: SSP1 peripheral
    156          * @return		Data size, could be:
    157          *				- SSP_DATABIT_4: 4 bit transfer
    158          *				- SSP_DATABIT_5: 5 bit transfer
    159          *				...
    160          *				- SSP_DATABIT_16: 16 bit transfer
    161          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    162          uint8_t SSP_GetDataSize(LPC_SSP_TypeDef* SSPx)
    163          {
    164          	return (SSPx->CR0 & (0xF));
   \                     SSP_GetDataSize:
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000006   0x4770             BX       LR               ;; return
    165          }
    166          
    167          /*****************************************************************************//**
    168          * @brief		Fills each SSP_InitStruct member with its default value:
    169          * 				- CPHA = SSP_CPHA_FIRST
    170          * 				- CPOL = SSP_CPOL_HI
    171          * 				- ClockRate = 1000000
    172          * 				- Databit = SSP_DATABIT_8
    173          * 				- Mode = SSP_MASTER_MODE
    174          * 				- FrameFormat = SSP_FRAME_SSP
    175          * @param[in]	SSP_InitStruct Pointer to a SSP_CFG_Type structure
    176          *                    which will be initialized.
    177          * @return		None
    178          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    179          void SSP_ConfigStructInit(SSP_CFG_Type *SSP_InitStruct)
    180          {
    181          	SSP_InitStruct->CPHA = SSP_CPHA_FIRST;
   \                     SSP_ConfigStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6041             STR      R1,[R0, #+4]
    182          	SSP_InitStruct->CPOL = SSP_CPOL_HI;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6081             STR      R1,[R0, #+8]
    183          	SSP_InitStruct->ClockRate = 1000000;
   \   00000008   0x....             LDR.N    R1,??DataTable2_2  ;; 0xf4240
   \   0000000A   0x6141             STR      R1,[R0, #+20]
    184          	SSP_InitStruct->Databit = SSP_DATABIT_8;
   \   0000000C   0x2107             MOVS     R1,#+7
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    185          	SSP_InitStruct->Mode = SSP_SLAVE_MODE;
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x60C1             STR      R1,[R0, #+12]
    186          	SSP_InitStruct->FrameFormat = SSP_FRAME_SPI;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6101             STR      R1,[R0, #+16]
    187          }
   \   00000018   0x4770             BX       LR               ;; return
    188          
    189          
    190          /*********************************************************************//**
    191           * @brief		Enable or disable SSP peripheral's operation
    192           * @param[in]	SSPx	SSP peripheral, should be:
    193           * 				- LPC_SSP0: SSP0 peripheral
    194           * 				- LPC_SSP1: SSP1 peripheral
    195           * @param[in]	NewState New State of SSPx peripheral's operation
    196           * @return 		none
    197           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    198          void SSP_Cmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
    199          {
    200          	if (NewState == ENABLE)
   \                     SSP_Cmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD104             BNE.N    ??SSP_Cmd_0
    201          	{
    202          		SSPx->CR1 |= SSP_CR1_SSP_EN;
   \   00000006   0x6842             LDR      R2,[R0, #+4]
   \   00000008   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   \   0000000E   0xE003             B.N      ??SSP_Cmd_1
    203          	}
    204          	else
    205          	{
    206          		SSPx->CR1 &= (~SSP_CR1_SSP_EN) & SSP_CR1_BITMASK;
   \                     ??SSP_Cmd_0:
   \   00000010   0x6842             LDR      R2,[R0, #+4]
   \   00000012   0xF012 0x020D      ANDS     R2,R2,#0xD
   \   00000016   0x6042             STR      R2,[R0, #+4]
    207          	}
    208          }
   \                     ??SSP_Cmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    209          
    210          /*********************************************************************//**
    211           * @brief		Enable or disable Loop Back mode function in SSP peripheral
    212           * @param[in]	SSPx	SSP peripheral selected, should be:
    213           *  					- LPC_SSP0: SSP0 peripheral
    214           * 						- LPC_SSP1: SSP1 peripheral
    215           * @param[in]	NewState	New State of Loop Back mode, should be:
    216           * 							- ENABLE: Enable this function
    217           * 							- DISABLE: Disable this function
    218           * @return 		None
    219           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    220          void SSP_LoopBackCmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
    221          {
    222          	if (NewState == ENABLE)
   \                     SSP_LoopBackCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD104             BNE.N    ??SSP_LoopBackCmd_0
    223          	{
    224          		SSPx->CR1 |= SSP_CR1_LBM_EN;
   \   00000006   0x6842             LDR      R2,[R0, #+4]
   \   00000008   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   \   0000000E   0xE003             B.N      ??SSP_LoopBackCmd_1
    225          	}
    226          	else
    227          	{
    228          		SSPx->CR1 &= (~SSP_CR1_LBM_EN) & SSP_CR1_BITMASK;
   \                     ??SSP_LoopBackCmd_0:
   \   00000010   0x6842             LDR      R2,[R0, #+4]
   \   00000012   0xF012 0x020E      ANDS     R2,R2,#0xE
   \   00000016   0x6042             STR      R2,[R0, #+4]
    229          	}
    230          }
   \                     ??SSP_LoopBackCmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    231          
    232          /*********************************************************************//**
    233           * @brief		Enable or disable Slave Output function in SSP peripheral
    234           * @param[in]	SSPx	SSP peripheral selected, should be:
    235           * 						- LPC_SSP0: SSP0 peripheral
    236           * 						- LPC_SSP1: SSP1 peripheral
    237           * @param[in]	NewState	New State of Slave Output function, should be:
    238           * 							- ENABLE: Slave Output in normal operation
    239           * 							- DISABLE: Slave Output is disabled. This blocks
    240           * 							SSP controller from driving the transmit data
    241           * 							line (MISO)
    242           * Note: 		This function is available when SSP peripheral in Slave mode
    243           * @return 		None
    244           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    245          void SSP_SlaveOutputCmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
    246          {
    247          	if (NewState == ENABLE)
   \                     SSP_SlaveOutputCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD104             BNE.N    ??SSP_SlaveOutputCmd_0
    248          	{
    249          		SSPx->CR1 &= (~SSP_CR1_SO_DISABLE) & SSP_CR1_BITMASK;
   \   00000006   0x6842             LDR      R2,[R0, #+4]
   \   00000008   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   \   0000000E   0xE003             B.N      ??SSP_SlaveOutputCmd_1
    250          	}
    251          	else
    252          	{
    253          		SSPx->CR1 |= SSP_CR1_SO_DISABLE;
   \                     ??SSP_SlaveOutputCmd_0:
   \   00000010   0x6842             LDR      R2,[R0, #+4]
   \   00000012   0xF052 0x0208      ORRS     R2,R2,#0x8
   \   00000016   0x6042             STR      R2,[R0, #+4]
    254          	}
    255          }
   \                     ??SSP_SlaveOutputCmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    256          
    257          
    258          
    259          /*********************************************************************//**
    260           * @brief		Transmit a single data through SSPx peripheral
    261           * @param[in]	SSPx	SSP peripheral selected, should be:
    262           * 						- LPC_SSP0: SSP0 peripheral
    263           * 						- LPC_SSP1: SSP1 peripheral
    264           * @param[in]	Data	Data to transmit (must be 16 or 8-bit long,
    265           * 						this depend on SSP data bit number configured)
    266           * @return 		none
    267           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    268          void SSP_SendData(LPC_SSP_TypeDef* SSPx, uint16_t Data)
    269          {
    270          	SSPx->DR = SSP_DR_BITMASK(Data);
   \                     SSP_SendData:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x6081             STR      R1,[R0, #+8]
    271          }
   \   00000004   0x4770             BX       LR               ;; return
    272          
    273          
    274          
    275          /*********************************************************************//**
    276           * @brief		Receive a single data from SSPx peripheral
    277           * @param[in]	SSPx	SSP peripheral selected, should be
    278           * 						- LPC_SSP0: SSP0 peripheral
    279           * 						- LPC_SSP1: SSP1 peripheral
    280           * @return 		Data received (16-bit long)
    281           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    282          uint16_t SSP_ReceiveData(LPC_SSP_TypeDef* SSPx)
    283          {
    284          	return ((uint16_t) (SSP_DR_BITMASK(SSPx->DR)));
   \                     SSP_ReceiveData:
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    285          }
    286          
    287          /*********************************************************************//**
    288           * @brief 		SSP Read write data function
    289           * @param[in]	SSPx 	Pointer to SSP peripheral, should be
    290           * 						- LPC_SSP0: SSP0 peripheral
    291           * 						- LPC_SSP1: SSP1 peripheral
    292           * @param[in]	dataCfg	Pointer to a SSP_DATA_SETUP_Type structure that
    293           * 						contains specified information about transmit
    294           * 						data configuration.
    295           * @param[in]	xfType	Transfer type, should be:
    296           * 						- SSP_TRANSFER_POLLING: Polling mode
    297           * 						- SSP_TRANSFER_INTERRUPT: Interrupt mode
    298           * @return 		Actual Data length has been transferred in polling mode.
    299           * 				In interrupt mode, always return (0)
    300           * 				Return (-1) if error.
    301           * Note: This function can be used in both master and slave mode.
    302           ***********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    303          int32_t SSP_ReadWrite (LPC_SSP_TypeDef *SSPx, SSP_DATA_SETUP_Type *dataCfg, \
    304          						SSP_TRANSFER_Type xfType)
    305          {
   \                     SSP_ReadWrite:
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x468B             MOV      R11,R1
    306          	uint8_t *rdata8;
    307              uint8_t *wdata8;
    308          	uint16_t *rdata16;
    309              uint16_t *wdata16;
    310              uint32_t stat;
    311              uint32_t tmp;
    312              int32_t dataword;
    313          
    314              dataCfg->rx_cnt = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF8CB 0x000C      STR      R0,[R11, #+12]
    315              dataCfg->tx_cnt = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8CB 0x0004      STR      R0,[R11, #+4]
    316              dataCfg->status = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8CB 0x0014      STR      R0,[R11, #+20]
    317          
    318          
    319          	/* Clear all remaining data in RX FIFO */
    320          	while (SSPx->SR & SSP_SR_RNE){
   \                     ??SSP_ReadWrite_0:
   \   0000001C   0x68E0             LDR      R0,[R4, #+12]
   \   0000001E   0x0740             LSLS     R0,R0,#+29
   \   00000020   0xD504             BPL.N    ??SSP_ReadWrite_1
    321          		tmp = (uint32_t) SSP_ReceiveData(SSPx);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       SSP_ReceiveData
   \   00000028   0x0005             MOVS     R5,R0
   \   0000002A   0xE7F7             B.N      ??SSP_ReadWrite_0
    322          	}
    323          
    324          	// Clear status
    325          	SSPx->ICR = SSP_ICR_BITMASK;
   \                     ??SSP_ReadWrite_1:
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0x6220             STR      R0,[R4, #+32]
    326          	if(SSP_GetDataSize(SSPx)>8)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       SSP_GetDataSize
   \   00000036   0x2809             CMP      R0,#+9
   \   00000038   0xDB02             BLT.N    ??SSP_ReadWrite_2
    327          		dataword = 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x0006             MOVS     R6,R0
   \   0000003E   0xE001             B.N      ??SSP_ReadWrite_3
    328          	else dataword = 0;
   \                     ??SSP_ReadWrite_2:
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x0006             MOVS     R6,R0
    329          
    330          	// Polling mode ----------------------------------------------------------------------
    331          	if (xfType == SSP_TRANSFER_POLLING){
   \                     ??SSP_ReadWrite_3:
   \   00000044   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xF040 0x80A3      BNE.W    ??SSP_ReadWrite_4
    332          		if (dataword == 0){
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD106             BNE.N    ??SSP_ReadWrite_5
    333          			rdata8 = (uint8_t *)dataCfg->rx_data;
   \   00000052   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000056   0x4681             MOV      R9,R0
    334          			wdata8 = (uint8_t *)dataCfg->tx_data;
   \   00000058   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000005C   0x0007             MOVS     R7,R0
   \   0000005E   0xE005             B.N      ??SSP_ReadWrite_6
    335          		} else {
    336          			rdata16 = (uint16_t *)dataCfg->rx_data;
   \                     ??SSP_ReadWrite_5:
   \   00000060   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000064   0x4682             MOV      R10,R0
    337          			wdata16 = (uint16_t *)dataCfg->tx_data;
   \   00000066   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000006A   0x4680             MOV      R8,R0
    338          		}
    339          		while ((dataCfg->tx_cnt != dataCfg->length) || (dataCfg->rx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_6:
   \   0000006C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000070   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD105             BNE.N    ??SSP_ReadWrite_7
   \   00000078   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   0000007C   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD073             BEQ.N    ??SSP_ReadWrite_8
    340          			if ((SSPx->SR & SSP_SR_TNF) && (dataCfg->tx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_7:
   \   00000084   0x68E0             LDR      R0,[R4, #+12]
   \   00000086   0x0780             LSLS     R0,R0,#+30
   \   00000088   0xD53A             BPL.N    ??SSP_ReadWrite_9
   \   0000008A   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   0000008E   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xD034             BEQ.N    ??SSP_ReadWrite_9
    341          				// Write data to buffer
    342          				if(dataCfg->tx_data == NULL){
   \   00000096   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD116             BNE.N    ??SSP_ReadWrite_10
    343          					if (dataword == 0){
   \   0000009E   0x2E00             CMP      R6,#+0
   \   000000A0   0xD109             BNE.N    ??SSP_ReadWrite_11
    344          						SSP_SendData(SSPx, 0xFF);
   \   000000A2   0x21FF             MOVS     R1,#+255
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       SSP_SendData
    345          						dataCfg->tx_cnt++;
   \   000000AA   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000000B4   0xE024             B.N      ??SSP_ReadWrite_9
    346          					} else {
    347          						SSP_SendData(SSPx, 0xFFFF);
   \                     ??SSP_ReadWrite_11:
   \   000000B6   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       SSP_SendData
    348          						dataCfg->tx_cnt += 2;
   \   000000C0   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000C4   0x1C80             ADDS     R0,R0,#+2
   \   000000C6   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000000CA   0xE019             B.N      ??SSP_ReadWrite_9
    349          					}
    350          				} else {
    351          					if (dataword == 0){
   \                     ??SSP_ReadWrite_10:
   \   000000CC   0x2E00             CMP      R6,#+0
   \   000000CE   0xD10B             BNE.N    ??SSP_ReadWrite_12
    352          						SSP_SendData(SSPx, *wdata8);
   \   000000D0   0x7839             LDRB     R1,[R7, #+0]
   \   000000D2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0x.... 0x....      BL       SSP_SendData
    353          						wdata8++;
   \   000000DA   0x1C7F             ADDS     R7,R7,#+1
    354          						dataCfg->tx_cnt++;
   \   000000DC   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000E0   0x1C40             ADDS     R0,R0,#+1
   \   000000E2   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000000E6   0xE00B             B.N      ??SSP_ReadWrite_9
    355          					} else {
    356          						SSP_SendData(SSPx, *wdata16);
   \                     ??SSP_ReadWrite_12:
   \   000000E8   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       SSP_SendData
    357          						wdata16++;
   \   000000F2   0xF118 0x0802      ADDS     R8,R8,#+2
    358          						dataCfg->tx_cnt += 2;
   \   000000F6   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000FA   0x1C80             ADDS     R0,R0,#+2
   \   000000FC   0xF8CB 0x0004      STR      R0,[R11, #+4]
    359          					}
    360          				}
    361          			}
    362          
    363          			// Check overrun error
    364          			if ((stat = SSPx->RIS) & SSP_RIS_ROR){
   \                     ??SSP_ReadWrite_9:
   \   00000100   0x69A0             LDR      R0,[R4, #+24]
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0x07C0             LSLS     R0,R0,#+31
   \   00000106   0xD507             BPL.N    ??SSP_ReadWrite_13
    365          				// save status and return
    366          				dataCfg->status = stat | SSP_STAT_ERROR;
   \   00000108   0x9800             LDR      R0,[SP, #+0]
   \   0000010A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000010E   0xF8CB 0x0014      STR      R0,[R11, #+20]
    367          				return (-1);
   \   00000112   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000116   0xE0D5             B.N      ??SSP_ReadWrite_14
    368          			}
    369          
    370          			// Check for any data available in RX FIFO
    371          			while ((SSPx->SR & SSP_SR_RNE) && (dataCfg->rx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_13:
   \   00000118   0x68E0             LDR      R0,[R4, #+12]
   \   0000011A   0x0740             LSLS     R0,R0,#+29
   \   0000011C   0xD5A6             BPL.N    ??SSP_ReadWrite_6
   \   0000011E   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000122   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000126   0x4288             CMP      R0,R1
   \   00000128   0xD0A0             BEQ.N    ??SSP_ReadWrite_6
    372          				// Read data from SSP data
    373          				tmp = SSP_ReceiveData(SSPx);
   \   0000012A   0x0020             MOVS     R0,R4
   \   0000012C   0x.... 0x....      BL       SSP_ReceiveData
   \   00000130   0x0005             MOVS     R5,R0
    374          
    375          				// Store data to destination
    376          				if (dataCfg->rx_data != NULL)
   \   00000132   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD00A             BEQ.N    ??SSP_ReadWrite_15
    377          				{
    378          					if (dataword == 0){
   \   0000013A   0x2E00             CMP      R6,#+0
   \   0000013C   0xD104             BNE.N    ??SSP_ReadWrite_16
    379          						*(rdata8) = (uint8_t) tmp;
   \   0000013E   0xF889 0x5000      STRB     R5,[R9, #+0]
    380          						rdata8++;
   \   00000142   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000146   0xE003             B.N      ??SSP_ReadWrite_15
    381          					} else {
    382          						*(rdata16) = (uint16_t) tmp;
   \                     ??SSP_ReadWrite_16:
   \   00000148   0xF8AA 0x5000      STRH     R5,[R10, #+0]
    383          						rdata16++;
   \   0000014C   0xF11A 0x0A02      ADDS     R10,R10,#+2
    384          					}
    385          				}
    386          				// Increase counter
    387          				if (dataword == 0){
   \                     ??SSP_ReadWrite_15:
   \   00000150   0x2E00             CMP      R6,#+0
   \   00000152   0xD105             BNE.N    ??SSP_ReadWrite_17
    388          					dataCfg->rx_cnt++;
   \   00000154   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000158   0x1C40             ADDS     R0,R0,#+1
   \   0000015A   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   0000015E   0xE7DB             B.N      ??SSP_ReadWrite_13
    389          				} else {
    390          					dataCfg->rx_cnt += 2;
   \                     ??SSP_ReadWrite_17:
   \   00000160   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000164   0x1C80             ADDS     R0,R0,#+2
   \   00000166   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   0000016A   0xE7D5             B.N      ??SSP_ReadWrite_13
    391          				}
    392          			}
    393          		}
    394          
    395          		// save status
    396          		dataCfg->status = SSP_STAT_DONE;
   \                     ??SSP_ReadWrite_8:
   \   0000016C   0xF44F 0x7080      MOV      R0,#+256
   \   00000170   0xF8CB 0x0014      STR      R0,[R11, #+20]
    397          
    398          		if (dataCfg->tx_data != NULL){
   \   00000174   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD002             BEQ.N    ??SSP_ReadWrite_18
    399          			return dataCfg->tx_cnt;
   \   0000017C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000180   0xE0A0             B.N      ??SSP_ReadWrite_14
    400          		} else if (dataCfg->rx_data != NULL){
   \                     ??SSP_ReadWrite_18:
   \   00000182   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000186   0x2800             CMP      R0,#+0
   \   00000188   0xD002             BEQ.N    ??SSP_ReadWrite_19
    401          			return dataCfg->rx_cnt;
   \   0000018A   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   0000018E   0xE099             B.N      ??SSP_ReadWrite_14
    402          		} else {
    403          			return (0);
   \                     ??SSP_ReadWrite_19:
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0xE097             B.N      ??SSP_ReadWrite_14
    404          		}
    405          	}
    406          
    407          	// Interrupt mode ----------------------------------------------------------------------
    408          	else if (xfType == SSP_TRANSFER_INTERRUPT){
   \                     ??SSP_ReadWrite_4:
   \   00000194   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000198   0x2801             CMP      R0,#+1
   \   0000019A   0xF040 0x8091      BNE.W    ??SSP_ReadWrite_20
    409          
    410          		while ((SSPx->SR & SSP_SR_TNF) && (dataCfg->tx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_21:
   \   0000019E   0x68E0             LDR      R0,[R4, #+12]
   \   000001A0   0x0780             LSLS     R0,R0,#+30
   \   000001A2   0xD578             BPL.N    ??SSP_ReadWrite_22
   \   000001A4   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000001A8   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   000001AC   0x4288             CMP      R0,R1
   \   000001AE   0xD072             BEQ.N    ??SSP_ReadWrite_22
    411          			// Write data to buffer
    412          			if(dataCfg->tx_data == NULL){
   \   000001B0   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000001B4   0x2800             CMP      R0,#+0
   \   000001B6   0xD116             BNE.N    ??SSP_ReadWrite_23
    413          				if (dataword == 0){
   \   000001B8   0x2E00             CMP      R6,#+0
   \   000001BA   0xD109             BNE.N    ??SSP_ReadWrite_24
    414          					SSP_SendData(SSPx, 0xFF);
   \   000001BC   0x21FF             MOVS     R1,#+255
   \   000001BE   0x0020             MOVS     R0,R4
   \   000001C0   0x.... 0x....      BL       SSP_SendData
    415          					dataCfg->tx_cnt++;
   \   000001C4   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000001C8   0x1C40             ADDS     R0,R0,#+1
   \   000001CA   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000001CE   0xE02A             B.N      ??SSP_ReadWrite_25
    416          				} else {
    417          					SSP_SendData(SSPx, 0xFFFF);
   \                     ??SSP_ReadWrite_24:
   \   000001D0   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000001D4   0x0020             MOVS     R0,R4
   \   000001D6   0x.... 0x....      BL       SSP_SendData
    418          					dataCfg->tx_cnt += 2;
   \   000001DA   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000001DE   0x1C80             ADDS     R0,R0,#+2
   \   000001E0   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000001E4   0xE01F             B.N      ??SSP_ReadWrite_25
    419          				}
    420          			} else {
    421          				if (dataword == 0){
   \                     ??SSP_ReadWrite_23:
   \   000001E6   0x2E00             CMP      R6,#+0
   \   000001E8   0xD10F             BNE.N    ??SSP_ReadWrite_26
    422          					SSP_SendData(SSPx, (*(uint8_t *)((uint32_t)dataCfg->tx_data + dataCfg->tx_cnt)));
   \   000001EA   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000001EE   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \   000001F2   0x5C09             LDRB     R1,[R1, R0]
   \   000001F4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001F6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001F8   0x0020             MOVS     R0,R4
   \   000001FA   0x.... 0x....      BL       SSP_SendData
    423          					dataCfg->tx_cnt++;
   \   000001FE   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000202   0x1C40             ADDS     R0,R0,#+1
   \   00000204   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   00000208   0xE00D             B.N      ??SSP_ReadWrite_25
    424          				} else {
    425          					SSP_SendData(SSPx, (*(uint16_t *)((uint32_t)dataCfg->tx_data + dataCfg->tx_cnt)));
   \                     ??SSP_ReadWrite_26:
   \   0000020A   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000020E   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \   00000212   0x5A09             LDRH     R1,[R1, R0]
   \   00000214   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000216   0x0020             MOVS     R0,R4
   \   00000218   0x.... 0x....      BL       SSP_SendData
    426          					dataCfg->tx_cnt += 2;
   \   0000021C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000220   0x1C80             ADDS     R0,R0,#+2
   \   00000222   0xF8CB 0x0004      STR      R0,[R11, #+4]
    427          				}
    428          			}
    429          
    430          			// Check error
    431          			if ((stat = SSPx->RIS) & SSP_RIS_ROR){
   \                     ??SSP_ReadWrite_25:
   \   00000226   0x69A0             LDR      R0,[R4, #+24]
   \   00000228   0x9000             STR      R0,[SP, #+0]
   \   0000022A   0x07C0             LSLS     R0,R0,#+31
   \   0000022C   0xD507             BPL.N    ??SSP_ReadWrite_27
    432          				// save status and return
    433          				dataCfg->status = stat | SSP_STAT_ERROR;
   \   0000022E   0x9800             LDR      R0,[SP, #+0]
   \   00000230   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000234   0xF8CB 0x0014      STR      R0,[R11, #+20]
    434          				return (-1);
   \   00000238   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000023C   0xE042             B.N      ??SSP_ReadWrite_14
    435          			}
    436          
    437          			// Check for any data available in RX FIFO
    438          			while ((SSPx->SR & SSP_SR_RNE) && (dataCfg->rx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_27:
   \   0000023E   0x68E0             LDR      R0,[R4, #+12]
   \   00000240   0x0740             LSLS     R0,R0,#+29
   \   00000242   0xD5AC             BPL.N    ??SSP_ReadWrite_21
   \   00000244   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000248   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   0000024C   0x4288             CMP      R0,R1
   \   0000024E   0xD0A6             BEQ.N    ??SSP_ReadWrite_21
    439          				// Read data from SSP data
    440          				tmp = SSP_ReceiveData(SSPx);
   \   00000250   0x0020             MOVS     R0,R4
   \   00000252   0x.... 0x....      BL       SSP_ReceiveData
   \   00000256   0x0005             MOVS     R5,R0
    441          
    442          				// Store data to destination
    443          				if (dataCfg->rx_data != NULL)
   \   00000258   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   0000025C   0x2800             CMP      R0,#+0
   \   0000025E   0xD00C             BEQ.N    ??SSP_ReadWrite_28
    444          				{
    445          					if (dataword == 0){
   \   00000260   0x2E00             CMP      R6,#+0
   \   00000262   0xD105             BNE.N    ??SSP_ReadWrite_29
    446          						*(uint8_t *)((uint32_t)dataCfg->rx_data + dataCfg->rx_cnt) = (uint8_t) tmp;
   \   00000264   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000268   0xF8DB 0x100C      LDR      R1,[R11, #+12]
   \   0000026C   0x540D             STRB     R5,[R1, R0]
   \   0000026E   0xE004             B.N      ??SSP_ReadWrite_28
    447          					} else {
    448          						*(uint16_t *)((uint32_t)dataCfg->rx_data + dataCfg->rx_cnt) = (uint16_t) tmp;
   \                     ??SSP_ReadWrite_29:
   \   00000270   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000274   0xF8DB 0x100C      LDR      R1,[R11, #+12]
   \   00000278   0x520D             STRH     R5,[R1, R0]
    449          					}
    450          				}
    451          				// Increase counter
    452          				if (dataword == 0){
   \                     ??SSP_ReadWrite_28:
   \   0000027A   0x2E00             CMP      R6,#+0
   \   0000027C   0xD105             BNE.N    ??SSP_ReadWrite_30
    453          					dataCfg->rx_cnt++;
   \   0000027E   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000282   0x1C40             ADDS     R0,R0,#+1
   \   00000284   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   00000288   0xE7D9             B.N      ??SSP_ReadWrite_27
    454          				} else {
    455          					dataCfg->rx_cnt += 2;
   \                     ??SSP_ReadWrite_30:
   \   0000028A   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   0000028E   0x1C80             ADDS     R0,R0,#+2
   \   00000290   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   00000294   0xE7D3             B.N      ??SSP_ReadWrite_27
    456          				}
    457          			}
    458          		}
    459          
    460          		// If there more data to sent or receive
    461          		if ((dataCfg->rx_cnt != dataCfg->length) || (dataCfg->tx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_22:
   \   00000296   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   0000029A   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   0000029E   0x4288             CMP      R0,R1
   \   000002A0   0xD105             BNE.N    ??SSP_ReadWrite_31
   \   000002A2   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000002A6   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   000002AA   0x4288             CMP      R0,R1
   \   000002AC   0xD002             BEQ.N    ??SSP_ReadWrite_32
    462          			// Enable all interrupt
    463          			SSPx->IMSC = SSP_IMSC_BITMASK;
   \                     ??SSP_ReadWrite_31:
   \   000002AE   0x200F             MOVS     R0,#+15
   \   000002B0   0x6160             STR      R0,[R4, #+20]
   \   000002B2   0xE003             B.N      ??SSP_ReadWrite_33
    464          		} else {
    465          			// Save status
    466          			dataCfg->status = SSP_STAT_DONE;
   \                     ??SSP_ReadWrite_32:
   \   000002B4   0xF44F 0x7080      MOV      R0,#+256
   \   000002B8   0xF8CB 0x0014      STR      R0,[R11, #+20]
    467          		}
    468          		return (0);
   \                     ??SSP_ReadWrite_33:
   \   000002BC   0x2000             MOVS     R0,#+0
   \   000002BE   0xE001             B.N      ??SSP_ReadWrite_14
    469          	}
    470          
    471          	return (-1);
   \                     ??SSP_ReadWrite_20:
   \   000002C0   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??SSP_ReadWrite_14:
   \   000002C4   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    472          }
    473          
    474          /*********************************************************************//**
    475           * @brief		Checks whether the specified SSP status flag is set or not
    476           * @param[in]	SSPx	SSP peripheral selected, should be:
    477           * 		 				- LPC_SSP0: SSP0 peripheral
    478           * 						- LPC_SSP1: SSP1 peripheral
    479           * @param[in]	FlagType	Type of flag to check status, should be one
    480           * 							of following:
    481           *							- SSP_STAT_TXFIFO_EMPTY: TX FIFO is empty
    482           *							- SSP_STAT_TXFIFO_NOTFULL: TX FIFO is not full
    483           *							- SSP_STAT_RXFIFO_NOTEMPTY: RX FIFO is not empty
    484           *							- SSP_STAT_RXFIFO_FULL: RX FIFO is full
    485           *							- SSP_STAT_BUSY: SSP peripheral is busy
    486           * @return		New State of specified SSP status flag
    487           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    488          FlagStatus SSP_GetStatus(LPC_SSP_TypeDef* SSPx, uint32_t FlagType)
    489          {
    490          	return ((SSPx->SR & FlagType) ? SET : RESET);
   \                     SSP_GetStatus:
   \   00000000   0x68C0             LDR      R0,[R0, #+12]
   \   00000002   0x4208             TST      R0,R1
   \   00000004   0xD001             BEQ.N    ??SSP_GetStatus_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE000             B.N      ??SSP_GetStatus_1
   \                     ??SSP_GetStatus_0:
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??SSP_GetStatus_1:
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return
    491          }
    492          
    493          /*********************************************************************//**
    494           * @brief		Enable or disable specified interrupt type in SSP peripheral
    495           * @param[in]	SSPx	SSP peripheral selected, should be:
    496           * 						- LPC_SSP0: SSP0 peripheral
    497           * 						- LPC_SSP1: SSP1 peripheral
    498           * @param[in]	IntType	Interrupt type in SSP peripheral, should be:
    499           * 				- SSP_INTCFG_ROR: Receive Overrun interrupt
    500           * 				- SSP_INTCFG_RT: Receive Time out interrupt
    501           * 				- SSP_INTCFG_RX: RX FIFO is at least half full interrupt
    502           * 				- SSP_INTCFG_TX: TX FIFO is at least half empty interrupt
    503           * @param[in]	NewState New State of specified interrupt type, should be:
    504           * 				- ENABLE: Enable this interrupt type
    505           * 				- DISABLE: Disable this interrupt type
    506           * @return		None
    507           * Note: We can enable/disable multi-interrupt type by OR multi value
    508           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    509          void SSP_IntConfig(LPC_SSP_TypeDef *SSPx, uint32_t IntType, FunctionalState NewState)
    510          {
   \                     SSP_IntConfig:
   \   00000000   0xB410             PUSH     {R4}
    511          	if (NewState == ENABLE)
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD103             BNE.N    ??SSP_IntConfig_0
    512          	{
    513          		SSPx->IMSC |= IntType;
   \   00000008   0x6943             LDR      R3,[R0, #+20]
   \   0000000A   0x430B             ORRS     R3,R1,R3
   \   0000000C   0x6143             STR      R3,[R0, #+20]
   \   0000000E   0xE005             B.N      ??SSP_IntConfig_1
    514          	}
    515          	else
    516          	{
    517          		SSPx->IMSC &= (~IntType) & SSP_IMSC_BITMASK;
   \                     ??SSP_IntConfig_0:
   \   00000010   0x6943             LDR      R3,[R0, #+20]
   \   00000012   0x43CC             MVNS     R4,R1
   \   00000014   0xF014 0x040F      ANDS     R4,R4,#0xF
   \   00000018   0x4023             ANDS     R3,R4,R3
   \   0000001A   0x6143             STR      R3,[R0, #+20]
    518          	}
    519          }
   \                     ??SSP_IntConfig_1:
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    520          
    521          /*********************************************************************//**
    522           * @brief	Check whether the specified Raw interrupt status flag is
    523           * 			set or not
    524           * @param[in]	SSPx	SSP peripheral selected, should be:
    525           * 						- LPC_SSP0: SSP0 peripheral
    526           * 						- LPC_SSP1: SSP1 peripheral
    527           * @param[in]	RawIntType	Raw Interrupt Type, should be:
    528           * 				- SSP_INTSTAT_RAW_ROR: Receive Overrun interrupt
    529           * 				- SSP_INTSTAT_RAW_RT: Receive Time out interrupt
    530           * 				- SSP_INTSTAT_RAW_RX: RX FIFO is at least half full interrupt
    531           * 				- SSP_INTSTAT_RAW_TX: TX FIFO is at least half empty interrupt
    532           * @return	New State of specified Raw interrupt status flag in SSP peripheral
    533           * Note: Enabling/Disabling specified interrupt in SSP peripheral does not
    534           * 		effect to Raw Interrupt Status flag.
    535           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    536          IntStatus SSP_GetRawIntStatus(LPC_SSP_TypeDef *SSPx, uint32_t RawIntType)
    537          {
    538          	return ((SSPx->RIS & RawIntType) ? SET : RESET);
   \                     SSP_GetRawIntStatus:
   \   00000000   0x6980             LDR      R0,[R0, #+24]
   \   00000002   0x4208             TST      R0,R1
   \   00000004   0xD001             BEQ.N    ??SSP_GetRawIntStatus_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE000             B.N      ??SSP_GetRawIntStatus_1
   \                     ??SSP_GetRawIntStatus_0:
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??SSP_GetRawIntStatus_1:
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return
    539          }
    540          
    541          /*********************************************************************//**
    542           * @brief		Get Raw Interrupt Status register
    543           * @param[in]	SSPx	SSP peripheral selected, should be:
    544           * 						- LPC_SSP0: SSP0 peripheral
    545           * 						- LPC_SSP1: SSP1 peripheral
    546           * @return		Raw Interrupt Status (RIS) register value
    547           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    548          uint32_t SSP_GetRawIntStatusReg(LPC_SSP_TypeDef *SSPx)
    549          {
    550          	return (SSPx->RIS);
   \                     SSP_GetRawIntStatusReg:
   \   00000000   0x6980             LDR      R0,[R0, #+24]
   \   00000002   0x4770             BX       LR               ;; return
    551          }
    552          
    553          /*********************************************************************//**
    554           * @brief	Check whether the specified interrupt status flag is
    555           * 			set or not
    556           * @param[in]	SSPx	SSP peripheral selected, should be:
    557           * 						- LPC_SSP0: SSP0 peripheral
    558           * 						- LPC_SSP1: SSP1 peripheral
    559           * @param[in]	IntType	Raw Interrupt Type, should be:
    560           * 				- SSP_INTSTAT_ROR: Receive Overrun interrupt
    561           * 				- SSP_INTSTAT_RT: Receive Time out interrupt
    562           * 				- SSP_INTSTAT_RX: RX FIFO is at least half full interrupt
    563           * 				- SSP_INTSTAT_TX: TX FIFO is at least half empty interrupt
    564           * @return	New State of specified interrupt status flag in SSP peripheral
    565           * Note: Enabling/Disabling specified interrupt in SSP peripheral effects
    566           * 			to Interrupt Status flag.
    567           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    568          IntStatus SSP_GetIntStatus (LPC_SSP_TypeDef *SSPx, uint32_t IntType)
    569          {
    570          	return ((SSPx->MIS & IntType) ? SET :RESET);
   \                     SSP_GetIntStatus:
   \   00000000   0x69C0             LDR      R0,[R0, #+28]
   \   00000002   0x4208             TST      R0,R1
   \   00000004   0xD001             BEQ.N    ??SSP_GetIntStatus_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE000             B.N      ??SSP_GetIntStatus_1
   \                     ??SSP_GetIntStatus_0:
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??SSP_GetIntStatus_1:
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return
    571          }
    572          
    573          /*********************************************************************//**
    574           * @brief				Clear specified interrupt pending in SSP peripheral
    575           * @param[in]	SSPx	SSP peripheral selected, should be:
    576           *  					- LPC_SSP0: SSP0 peripheral
    577           * 						- LPC_SSP1: SSP1 peripheral
    578           * @param[in]	IntType	Interrupt pending to clear, should be:
    579           * 						- SSP_INTCLR_ROR: clears the "frame was received when
    580           * 						RxFIFO was full" interrupt.
    581           * 						- SSP_INTCLR_RT: clears the "Rx FIFO was not empty and
    582           * 						has not been read for a timeout period" interrupt.
    583           * @return		None
    584           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    585          void SSP_ClearIntPending(LPC_SSP_TypeDef *SSPx, uint32_t IntType)
    586          {
    587          	SSPx->ICR = IntType;
   \                     SSP_ClearIntPending:
   \   00000000   0x6201             STR      R1,[R0, #+32]
    588          }
   \   00000002   0x4770             BX       LR               ;; return
    589          
    590          /*********************************************************************//**
    591           * @brief				Enable/Disable DMA function for SSP peripheral
    592           * @param[in]	SSPx	SSP peripheral selected, should be:
    593           *  					- LPC_SSP0: SSP0 peripheral
    594           * 						- LPC_SSP1: SSP1 peripheral
    595           * @param[in]	DMAMode	Type of DMA, should be:
    596           * 						- SSP_DMA_TX: DMA for the transmit FIFO
    597           * 						- SSP_DMA_RX: DMA for the Receive FIFO
    598           * @param[in]	NewState	New State of DMA function on SSP peripheral,
    599           * 						should be:
    600           * 						- ENALBE: Enable this function
    601           * 						- DISABLE: Disable this function
    602           * @return		None
    603           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    604          void SSP_DMACmd(LPC_SSP_TypeDef *SSPx, uint32_t DMAMode, FunctionalState NewState)
    605          {
   \                     SSP_DMACmd:
   \   00000000   0xB410             PUSH     {R4}
    606          	if (NewState == ENABLE)
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD103             BNE.N    ??SSP_DMACmd_0
    607          	{
    608          		SSPx->DMACR |= DMAMode;
   \   00000008   0x6A43             LDR      R3,[R0, #+36]
   \   0000000A   0x430B             ORRS     R3,R1,R3
   \   0000000C   0x6243             STR      R3,[R0, #+36]
   \   0000000E   0xE005             B.N      ??SSP_DMACmd_1
    609          	}
    610          	else
    611          	{
    612          		SSPx->DMACR &= (~DMAMode) & SSP_DMA_BITMASK;
   \                     ??SSP_DMACmd_0:
   \   00000010   0x6A43             LDR      R3,[R0, #+36]
   \   00000012   0x43CC             MVNS     R4,R1
   \   00000014   0xF014 0x0403      ANDS     R4,R4,#0x3
   \   00000018   0x4023             ANDS     R3,R4,R3
   \   0000001A   0x6243             STR      R3,[R0, #+36]
    613          	}
    614          }
   \                     ??SSP_DMACmd_1:
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40088000         DC32     0x40088000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40030000         DC32     0x40030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x000F4240         DC32     0xf4240
    615          
    616          /**
    617           * @}
    618           */
    619          
    620          /**
    621           * @}
    622           */
    623          
    624          /* --------------------------------- End Of File ------------------------------ */
    625          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SSP_ClearIntPending
       0   SSP_Cmd
       0   SSP_ConfigStructInit
       4   SSP_DMACmd
       8   SSP_DeInit
         8   -> CLKPWR_ConfigPPWR
       0   SSP_GetDataSize
       0   SSP_GetIntStatus
       0   SSP_GetRawIntStatus
       0   SSP_GetRawIntStatusReg
       0   SSP_GetStatus
      16   SSP_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> setSSPclock
       4   SSP_IntConfig
       0   SSP_LoopBackCmd
      48   SSP_ReadWrite
        48   -> SSP_GetDataSize
        48   -> SSP_ReceiveData
        48   -> SSP_SendData
       0   SSP_ReceiveData
       0   SSP_SendData
       0   SSP_SlaveOutputCmd
      32   setSSPclock
        32   -> CLKPWR_GetCLK


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  SSP_ClearIntPending
      26  SSP_Cmd
      26  SSP_ConfigStructInit
      32  SSP_DMACmd
      40  SSP_DeInit
       8  SSP_GetDataSize
      16  SSP_GetIntStatus
      16  SSP_GetRawIntStatus
       4  SSP_GetRawIntStatusReg
      16  SSP_GetStatus
      84  SSP_Init
      32  SSP_IntConfig
      26  SSP_LoopBackCmd
     712  SSP_ReadWrite
       6  SSP_ReceiveData
       6  SSP_SendData
      26  SSP_SlaveOutputCmd
      86  setSSPclock

 
 1 178 bytes in section .text
 
 1 178 bytes of CODE memory

Errors: none
Warnings: none
