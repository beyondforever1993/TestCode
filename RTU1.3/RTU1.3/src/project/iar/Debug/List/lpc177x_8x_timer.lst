###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:42 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_timer.c                           #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_timer.c -lCN                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\ -o D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë #
#                    \RTU_1.2\project\iar\Debug\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\lpc177x_8x_timer.lst                       #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\lpc177x_8x_timer.o                          #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Drivers\source\lpc177x_8x_timer.c
      1          /**********************************************************************
      2          * $Id$		lpc177x_8x_timer.c			2011-06-02
      3          *//**
      4          * @file		lpc177x_8x_timer.c
      5          * @brief	Contains all functions support for Timer firmware library
      6          *			on LPC177x_8x
      7          * @version	1.0
      8          * @date		02. June. 2011
      9          * @author	NXP MCU SW Application Team
     10          * 
     11          * Copyright(C) 2011, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          **********************************************************************/
     26          
     27          /* Peripheral group ----------------------------------------------------------- */
     28          /** @addtogroup TIMER
     29           * @{
     30           */
     31          
     32          /* Includes ------------------------------------------------------------------- */
     33          #include "lpc177x_8x_timer.h"
     34          #include "lpc177x_8x_clkpwr.h"
     35          #include "lpc177x_8x_pinsel.h"
     36          
     37          /* Private Functions ---------------------------------------------------------- */
     38          
     39          static uint32_t getPClock (uint32_t timernum);
     40          static uint32_t converUSecToVal (uint32_t timernum, uint32_t usec);
     41          static uint32_t converPtrToTimeNum (LPC_TIM_TypeDef *TIMx);
     42          
     43          
     44          /*********************************************************************//**
     45           * @brief 		Get peripheral clock of each timer controller
     46           * @param[in]	timernum Timer number
     47           * @return 		Peripheral clock of timer
     48           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     49          static uint32_t getPClock (uint32_t timernum)
     50          {
   \                     getPClock:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     51          	uint32_t clkdlycnt;
     52          	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       CLKPWR_GetCLK
   \   0000000A   0x0005             MOVS     R5,R0
     53          	return clkdlycnt;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     54          }
     55          
     56          
     57          /*********************************************************************//**
     58           * @brief 		Convert a time to a timer count value
     59           * @param[in]	timernum Timer number
     60           * @param[in]	usec Time in microseconds
     61           * @return 		The number of required clock ticks to give the time delay
     62           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     63          uint32_t converUSecToVal (uint32_t timernum, uint32_t usec)
     64          {
   \                     converUSecToVal:
   \   00000000   0xE92D 0x4370      PUSH     {R4-R6,R8,R9,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x4688             MOV      R8,R1
     65          	uint64_t clkdlycnt;
     66          
     67          	// Get Pclock of timer
     68          	clkdlycnt = (uint64_t) getPClock(timernum);
   \   00000008   0x0030             MOVS     R0,R6
   \   0000000A   0x.... 0x....      BL       getPClock
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x0004             MOVS     R4,R0
   \   00000012   0x000D             MOVS     R5,R1
     69          
     70          	clkdlycnt = (clkdlycnt * usec) / 1000000;
   \   00000014   0xF05F 0x0900      MOVS     R9,#+0
   \   00000018   0xFBA8 0x0104      UMULL    R0,R1,R8,R4
   \   0000001C   0xFB08 0x1105      MLA      R1,R8,R5,R1
   \   00000020   0xFB09 0x1104      MLA      R1,R9,R4,R1
   \   00000024   0x....             LDR.N    R2,??DataTable3  ;; 0xf4240
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x.... 0x....      BL       __aeabi_uldivmod
   \   0000002C   0x0004             MOVS     R4,R0
   \   0000002E   0x000D             MOVS     R5,R1
     71          	return (uint32_t) clkdlycnt;
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xE8BD 0x8370      POP      {R4-R6,R8,R9,PC}  ;; return
     72          }
     73          
     74          
     75          /*********************************************************************//**
     76           * @brief 		Convert a timer register pointer to a timer number
     77           * @param[in]	TIMx Pointer to LPC_TIM_TypeDef, should be:
     78           * 				- LPC_TIM0: TIMER0 peripheral
     79           * 				- LPC_TIM1: TIMER1 peripheral
     80           * 				- LPC_TIM2: TIMER2 peripheral
     81           * 				- LPC_TIM3: TIMER3 peripheral
     82           * @return 		The timer number (0 to 3) or -1 if register pointer is bad
     83           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     84          uint32_t converPtrToTimeNum (LPC_TIM_TypeDef *TIMx)
     85          {
   \                     converPtrToTimeNum:
   \   00000000   0x0001             MOVS     R1,R0
     86          	uint32_t tnum = -1;
   \   00000002   0xF05F 0x30FF      MOVS     R0,#-1
     87          
     88          	if (TIMx == LPC_TIM0)
   \   00000006   0xF1B1 0x2F40      CMP      R1,#+1073758208
   \   0000000A   0xD102             BNE.N    ??converPtrToTimeNum_0
     89          	{
     90          		tnum = 0;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x0010             MOVS     R0,R2
   \   00000010   0xE010             B.N      ??converPtrToTimeNum_1
     91          	}
     92          	else if (TIMx == LPC_TIM1)
   \                     ??converPtrToTimeNum_0:
   \   00000012   0x....             LDR.N    R2,??DataTable3_1  ;; 0x40008000
   \   00000014   0x4291             CMP      R1,R2
   \   00000016   0xD102             BNE.N    ??converPtrToTimeNum_2
     93          	{
     94          		tnum = 1;
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x0010             MOVS     R0,R2
   \   0000001C   0xE00A             B.N      ??converPtrToTimeNum_1
     95          	}
     96          	else if (TIMx == LPC_TIM2)
   \                     ??converPtrToTimeNum_2:
   \   0000001E   0x....             LDR.N    R2,??DataTable3_2  ;; 0x40090000
   \   00000020   0x4291             CMP      R1,R2
   \   00000022   0xD102             BNE.N    ??converPtrToTimeNum_3
     97          	{
     98          		tnum = 2;
   \   00000024   0x2202             MOVS     R2,#+2
   \   00000026   0x0010             MOVS     R0,R2
   \   00000028   0xE004             B.N      ??converPtrToTimeNum_1
     99          	}
    100          	else if (TIMx == LPC_TIM3)
   \                     ??converPtrToTimeNum_3:
   \   0000002A   0x....             LDR.N    R2,??DataTable3_3  ;; 0x40094000
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD101             BNE.N    ??converPtrToTimeNum_1
    101          	{
    102          		tnum = 3;
   \   00000030   0x2203             MOVS     R2,#+3
   \   00000032   0x0010             MOVS     R0,R2
    103          	}
    104          
    105          	return tnum;
   \                     ??converPtrToTimeNum_1:
   \   00000034   0x4770             BX       LR               ;; return
    106          }
    107          
    108          /* End of Private Functions ---------------------------------------------------- */
    109          
    110          
    111          /* Public Functions ----------------------------------------------------------- */
    112          /** @addtogroup TIM_Public_Functions
    113           * @{
    114           */
    115          
    116          /*********************************************************************//**
    117           * @brief 		Get Interrupt Status
    118           * @param[in]	TIMx Timer selection, should be:
    119           *   			- LPC_TIM0: TIMER0 peripheral
    120           * 				- LPC_TIM1: TIMER1 peripheral
    121           * 				- LPC_TIM2: TIMER2 peripheral
    122           * 				- LPC_TIM3: TIMER3 peripheral
    123           * @param[in]	IntFlag: interrupt type, should be:
    124           * 				- TIM_MR0_INT: Interrupt for Match channel 0
    125           * 				- TIM_MR1_INT: Interrupt for Match channel 1
    126           * 				- TIM_MR2_INT: Interrupt for Match channel 2
    127           * 				- TIM_MR3_INT: Interrupt for Match channel 3
    128           * 				- TIM_CR0_INT: Interrupt for Capture channel 0
    129           * 				- TIM_CR1_INT: Interrupt for Capture channel 1
    130           * @return 		FlagStatus
    131           * 				- SET : interrupt
    132           * 				- RESET : no interrupt
    133           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    134          FlagStatus TIM_GetIntStatus(LPC_TIM_TypeDef *TIMx, TIM_INT_TYPE IntFlag)
    135          {
   \                     TIM_GetIntStatus:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    136          	uint8_t temp;
    137          	temp = (TIMx->IR)& TIM_IR_CLR(IntFlag);
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x408C             LSLS     R4,R4,R1
   \   0000000A   0x4020             ANDS     R0,R4,R0
   \   0000000C   0x0003             MOVS     R3,R0
    138          	if (temp)
   \   0000000E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD001             BEQ.N    ??TIM_GetIntStatus_0
    139          		return SET;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B.N      ??TIM_GetIntStatus_1
    140          
    141          	return RESET;
   \                     ??TIM_GetIntStatus_0:
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??TIM_GetIntStatus_1:
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    142          
    143          }
    144          /*********************************************************************//**
    145           * @brief 		Get Capture Interrupt Status
    146           * @param[in]	TIMx Timer selection, should be:
    147           *  	   		- LPC_TIM0: TIMER0 peripheral
    148           * 				- LPC_TIM1: TIMER1 peripheral
    149           * 				- LPC_TIM2: TIMER2 peripheral
    150           * 				- LPC_TIM3: TIMER3 peripheral
    151           * @param[in]	IntFlag: interrupt type, should be:
    152           * 				- TIM_MR0_INT: Interrupt for Match channel 0
    153           * 				- TIM_MR1_INT: Interrupt for Match channel 1
    154           * 				- TIM_MR2_INT: Interrupt for Match channel 2
    155           * 				- TIM_MR3_INT: Interrupt for Match channel 3
    156           * 				- TIM_CR0_INT: Interrupt for Capture channel 0
    157           * 				- TIM_CR1_INT: Interrupt for Capture channel 1
    158           * @return 		FlagStatus
    159           * 				- SET : interrupt
    160           * 				- RESET : no interrupt
    161           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    162          FlagStatus TIM_GetIntCaptureStatus(LPC_TIM_TypeDef *TIMx, TIM_INT_TYPE IntFlag)
    163          {
   \                     TIM_GetIntCaptureStatus:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    164          	uint8_t temp;
    165          	//temp = (TIMx->IR) & (1<<(4+IntFlag));
    166                  
    167                  temp = (TIMx->IR) & (1<<IntFlag);
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x408C             LSLS     R4,R4,R1
   \   0000000A   0x4020             ANDS     R0,R4,R0
   \   0000000C   0x0003             MOVS     R3,R0
    168                  
    169          	if(temp)
   \   0000000E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD001             BEQ.N    ??TIM_GetIntCaptureStatus_0
    170          		return SET;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B.N      ??TIM_GetIntCaptureStatus_1
    171          	return RESET;
   \                     ??TIM_GetIntCaptureStatus_0:
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??TIM_GetIntCaptureStatus_1:
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    172          }
    173          /*********************************************************************//**
    174           * @brief 		Clear Interrupt pending
    175           * @param[in]	TIMx Timer selection, should be:
    176           *    			- LPC_TIM0: TIMER0 peripheral
    177           * 				- LPC_TIM1: TIMER1 peripheral
    178           * 				- LPC_TIM2: TIMER2 peripheral
    179           * 				- LPC_TIM3: TIMER3 peripheral
    180           * @param[in]	IntFlag: interrupt type, should be:
    181           * 				- TIM_MR0_INT: Interrupt for Match channel 0
    182           * 				- TIM_MR1_INT: Interrupt for Match channel 1
    183           * 				- TIM_MR2_INT: Interrupt for Match channel 2
    184           * 				- TIM_MR3_INT: Interrupt for Match channel 3
    185           * 				- TIM_CR0_INT: Interrupt for Capture channel 0
    186           * 				- TIM_CR1_INT: Interrupt for Capture channel 1
    187           * @return 		None
    188           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    189          void TIM_ClearIntPending(LPC_TIM_TypeDef *TIMx, TIM_INT_TYPE IntFlag)
    190          {
    191          	TIMx->IR = TIM_IR_CLR(IntFlag);
   \                     TIM_ClearIntPending:
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x408A             LSLS     R2,R2,R1
   \   00000004   0x6002             STR      R2,[R0, #+0]
    192          }
   \   00000006   0x4770             BX       LR               ;; return
    193          
    194          /*********************************************************************//**
    195           * @brief 		Clear Capture Interrupt pending
    196           * @param[in]	TIMx Timer selection, should be
    197           *    			- LPC_TIM0: TIMER0 peripheral
    198           * 				- LPC_TIM1: TIMER1 peripheral
    199           * 				- LPC_TIM2: TIMER2 peripheral
    200           * 				- LPC_TIM3: TIMER3 peripheral
    201           * @param[in]	IntFlag interrupt type, should be:
    202           *				- TIM_MR0_INT: Interrupt for Match channel 0
    203           * 				- TIM_MR1_INT: Interrupt for Match channel 1
    204           * 				- TIM_MR2_INT: Interrupt for Match channel 2
    205           * 				- TIM_MR3_INT: Interrupt for Match channel 3
    206           * 				- TIM_CR0_INT: Interrupt for Capture channel 0
    207           * 				- TIM_CR1_INT: Interrupt for Capture channel 1
    208           * @return 		None
    209           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    210          void TIM_ClearIntCapturePending(LPC_TIM_TypeDef *TIMx, TIM_INT_TYPE IntFlag)
    211          {
    212          	//TIMx->IR = (1<<(4+IntFlag));
    213            TIMx->IR = (1<<IntFlag);
   \                     TIM_ClearIntCapturePending:
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x408A             LSLS     R2,R2,R1
   \   00000004   0x6002             STR      R2,[R0, #+0]
    214          }
   \   00000006   0x4770             BX       LR               ;; return
    215          
    216          /*********************************************************************//**
    217           * @brief 		Configuration for Timer at initial time
    218           * @param[in] 	TimerCounterMode timer counter mode, should be:
    219           * 				- TIM_TIMER_MODE: Timer mode
    220           * 				- TIM_COUNTER_RISING_MODE: Counter rising mode
    221           * 				- TIM_COUNTER_FALLING_MODE: Counter falling mode
    222           * 				- TIM_COUNTER_ANY_MODE:Counter on both edges
    223           * @param[in] 	TIM_ConfigStruct pointer to TIM_TIMERCFG_Type or
    224           * 				TIM_COUNTERCFG_Type
    225           * @return 		None
    226           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    227          void TIM_ConfigStructInit(TIM_MODE_OPT TimerCounterMode, void *TIM_ConfigStruct)
    228          {
    229          	if (TimerCounterMode == TIM_TIMER_MODE )
   \                     TIM_ConfigStructInit:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD104             BNE.N    ??TIM_ConfigStructInit_0
    230          	{
    231          		TIM_TIMERCFG_Type * pTimeCfg = (TIM_TIMERCFG_Type *)TIM_ConfigStruct;
    232          		pTimeCfg->PrescaleOption = TIM_PRESCALE_USVAL;
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x700A             STRB     R2,[R1, #+0]
    233          		pTimeCfg->PrescaleValue = 1;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   \   0000000E   0xE001             B.N      ??TIM_ConfigStructInit_1
    234          	}
    235          	else
    236          	{
    237          		TIM_COUNTERCFG_Type * pCounterCfg = (TIM_COUNTERCFG_Type *)TIM_ConfigStruct;
    238          		pCounterCfg->CountInputSelect = TIM_COUNTER_INCAP0;
   \                     ??TIM_ConfigStructInit_0:
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x704A             STRB     R2,[R1, #+1]
    239          	}
    240          }
   \                     ??TIM_ConfigStructInit_1:
   \   00000014   0x4770             BX       LR               ;; return
    241          
    242          /*********************************************************************//**
    243           * @brief 		Initial Timer/Counter device
    244           * 				 	Set Clock frequency for Timer
    245           * 					Set initial configuration for Timer
    246           * @param[in]	TIMx  Timer selection, should be:
    247           * 				- LPC_TIM0: TIMER0 peripheral
    248           * 				- LPC_TIM1: TIMER1 peripheral
    249           * 				- LPC_TIM2: TIMER2 peripheral
    250           * 				- LPC_TIM3: TIMER3 peripheral
    251           * @param[in]	TimerCounterMode Timer counter mode, should be:
    252           * 				- TIM_TIMER_MODE: Timer mode
    253           * 				- TIM_COUNTER_RISING_MODE: Counter rising mode
    254           * 				- TIM_COUNTER_FALLING_MODE: Counter falling mode
    255           * 				- TIM_COUNTER_ANY_MODE:Counter on both edges
    256           * @param[in]	TIM_ConfigStruct pointer to TIM_TIMERCFG_Type
    257           * 				that contains the configuration information for the
    258           *                    specified Timer peripheral.
    259           * @return 		None
    260           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    261          void TIM_Init(LPC_TIM_TypeDef *TIMx, TIM_MODE_OPT TimerCounterMode, void *TIM_ConfigStruct)
    262          {
   \                     TIM_Init:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    263          	TIM_TIMERCFG_Type *pTimeCfg;
    264          	TIM_COUNTERCFG_Type *pCounterCfg;
    265          
    266          	//set power
    267          	if (TIMx== LPC_TIM0)
   \   0000000A   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000E   0xD104             BNE.N    ??TIM_Init_0
    268          	{
    269          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM0, ENABLE);
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000018   0xE018             B.N      ??TIM_Init_1
    270          	}
    271          	else if (TIMx== LPC_TIM1)
   \                     ??TIM_Init_0:
   \   0000001A   0x....             LDR.N    R0,??DataTable3_1  ;; 0x40008000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD104             BNE.N    ??TIM_Init_2
    272          	{
    273          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM1, ENABLE);
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000028   0xE010             B.N      ??TIM_Init_1
    274          	}
    275          
    276          	else if (TIMx== LPC_TIM2)
   \                     ??TIM_Init_2:
   \   0000002A   0x....             LDR.N    R0,??DataTable3_2  ;; 0x40090000
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD105             BNE.N    ??TIM_Init_3
    277          	{
    278          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, ENABLE);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000036   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   0000003A   0xE007             B.N      ??TIM_Init_1
    279          	}
    280          	else if (TIMx== LPC_TIM3)
   \                     ??TIM_Init_3:
   \   0000003C   0x....             LDR.N    R0,??DataTable3_3  ;; 0x40094000
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD104             BNE.N    ??TIM_Init_1
    281          	{
    282          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM3, ENABLE);
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000048   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    283          	}
    284          
    285          	TIMx->CCR &= ~TIM_CTCR_MODE_MASK;
   \                     ??TIM_Init_1:
   \   0000004C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004E   0x0880             LSRS     R0,R0,#+2
   \   00000050   0x0080             LSLS     R0,R0,#+2
   \   00000052   0x62A0             STR      R0,[R4, #+40]
    286          	TIMx->CCR |= TIM_TIMER_MODE;
   \   00000054   0x6AA0             LDR      R0,[R4, #+40]
   \   00000056   0x62A0             STR      R0,[R4, #+40]
    287          
    288          	TIMx->TC =0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x60A0             STR      R0,[R4, #+8]
    289          	TIMx->PC =0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6120             STR      R0,[R4, #+16]
    290          	TIMx->PR =0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x60E0             STR      R0,[R4, #+12]
    291          	TIMx->TCR |= (1<<1); //Reset Counter
   \   00000064   0x6860             LDR      R0,[R4, #+4]
   \   00000066   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000006A   0x6060             STR      R0,[R4, #+4]
    292          	TIMx->TCR &= ~(1<<1); //release reset
   \   0000006C   0x6860             LDR      R0,[R4, #+4]
   \   0000006E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000072   0x6060             STR      R0,[R4, #+4]
    293          	if (TimerCounterMode == TIM_TIMER_MODE )
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD110             BNE.N    ??TIM_Init_4
    294          	{
    295          		pTimeCfg = (TIM_TIMERCFG_Type *)TIM_ConfigStruct;
   \   0000007A   0x0037             MOVS     R7,R6
    296          		if (pTimeCfg->PrescaleOption  == TIM_PRESCALE_TICKVAL)
   \   0000007C   0x7838             LDRB     R0,[R7, #+0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD103             BNE.N    ??TIM_Init_5
    297          		{
    298          			TIMx->PR   = pTimeCfg->PrescaleValue -1  ;
   \   00000082   0x6878             LDR      R0,[R7, #+4]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0x60E0             STR      R0,[R4, #+12]
   \   00000088   0xE015             B.N      ??TIM_Init_6
    299          		}
    300          		else
    301          		{
    302          			TIMx->PR   = converUSecToVal (converPtrToTimeNum(TIMx),pTimeCfg->PrescaleValue)-1;
   \                     ??TIM_Init_5:
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       converPtrToTimeNum
   \   00000090   0x6879             LDR      R1,[R7, #+4]
   \   00000092   0x.... 0x....      BL       converUSecToVal
   \   00000096   0x1E40             SUBS     R0,R0,#+1
   \   00000098   0x60E0             STR      R0,[R4, #+12]
   \   0000009A   0xE00C             B.N      ??TIM_Init_6
    303          		}
    304          	}
    305          	else
    306          	{
    307          
    308          		pCounterCfg = (TIM_COUNTERCFG_Type *)TIM_ConfigStruct;
   \                     ??TIM_Init_4:
   \   0000009C   0x46B0             MOV      R8,R6
    309          		TIMx->CCR  &= ~TIM_CTCR_INPUT_MASK;
   \   0000009E   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A0   0xF030 0x000C      BICS     R0,R0,#0xC
   \   000000A4   0x62A0             STR      R0,[R4, #+40]
    310          		if (pCounterCfg->CountInputSelect == TIM_COUNTER_INCAP1)
   \   000000A6   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xD103             BNE.N    ??TIM_Init_6
    311          			TIMx->CCR |= _BIT(2);
   \   000000AE   0x6AA0             LDR      R0,[R4, #+40]
   \   000000B0   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000B4   0x62A0             STR      R0,[R4, #+40]
    312          	}
    313          
    314          	// Clear interrupt pending
    315          	TIMx->IR = 0xFFFFFFFF;
   \                     ??TIM_Init_6:
   \   000000B6   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000BA   0x6020             STR      R0,[R4, #+0]
    316          
    317          }
   \   000000BC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    318          
    319          /*********************************************************************//**
    320           * @brief 		Close Timer/Counter device
    321           * @param[in]	TIMx  Pointer to timer device, should be:
    322           * 				- LPC_TIM0: TIMER0 peripheral
    323           * 				- LPC_TIM1: TIMER1 peripheral
    324           * 				- LPC_TIM2: TIMER2 peripheral
    325           * 				- LPC_TIM3: TIMER3 peripheral
    326           * @return 		None
    327           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    328          void TIM_DeInit (LPC_TIM_TypeDef *TIMx)
    329          {
   \                     TIM_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    330          	// Disable timer/counter
    331          	TIMx->TCR = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6060             STR      R0,[R4, #+4]
    332          
    333          	// Disable power
    334          	if (TIMx== LPC_TIM0)
   \   00000008   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000C   0xD104             BNE.N    ??TIM_DeInit_0
    335          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM0, DISABLE);
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000016   0xE018             B.N      ??TIM_DeInit_1
    336          
    337          	else if (TIMx== LPC_TIM1)
   \                     ??TIM_DeInit_0:
   \   00000018   0x....             LDR.N    R0,??DataTable3_1  ;; 0x40008000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD104             BNE.N    ??TIM_DeInit_2
    338          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM1, DISABLE);
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000026   0xE010             B.N      ??TIM_DeInit_1
    339          
    340          	else if (TIMx== LPC_TIM2)
   \                     ??TIM_DeInit_2:
   \   00000028   0x....             LDR.N    R0,??DataTable3_2  ;; 0x40090000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD105             BNE.N    ??TIM_DeInit_3
    341          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, DISABLE);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000034   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000038   0xE007             B.N      ??TIM_DeInit_1
    342          
    343          	else if (TIMx== LPC_TIM3)
   \                     ??TIM_DeInit_3:
   \   0000003A   0x....             LDR.N    R0,??DataTable3_3  ;; 0x40094000
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD104             BNE.N    ??TIM_DeInit_1
    344          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, DISABLE);
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000046   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    345          
    346          }
   \                     ??TIM_DeInit_1:
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    347          
    348          /*********************************************************************//**
    349           * @brief	 	Start/Stop Timer/Counter device
    350           * @param[in]	TIMx Pointer to timer device, should be:
    351           *  			- LPC_TIM0: TIMER0 peripheral
    352           * 				- LPC_TIM1: TIMER1 peripheral
    353           * 				- LPC_TIM2: TIMER2 peripheral
    354           * 				- LPC_TIM3: TIMER3 peripheral
    355           * @param[in]	NewState
    356           * 				-	ENABLE  : set timer enable
    357           * 				-	DISABLE : disable timer
    358           * @return 		None
    359           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    360          void TIM_Cmd(LPC_TIM_TypeDef *TIMx, FunctionalState NewState)
    361          {
    362          	if (NewState == ENABLE)
   \                     TIM_Cmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD104             BNE.N    ??TIM_Cmd_0
    363          	{
    364          		TIMx->TCR	|=  TIM_ENABLE;
   \   00000006   0x6842             LDR      R2,[R0, #+4]
   \   00000008   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   \   0000000E   0xE003             B.N      ??TIM_Cmd_1
    365          	}
    366          	else
    367          	{
    368          		TIMx->TCR &= ~TIM_ENABLE;
   \                     ??TIM_Cmd_0:
   \   00000010   0x6842             LDR      R2,[R0, #+4]
   \   00000012   0x0852             LSRS     R2,R2,#+1
   \   00000014   0x0052             LSLS     R2,R2,#+1
   \   00000016   0x6042             STR      R2,[R0, #+4]
    369          	}
    370          }
   \                     ??TIM_Cmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    371          
    372          /*********************************************************************//**
    373           * @brief 		Reset Timer/Counter device,
    374           * 					Make TC and PC are synchronously reset on the next
    375           * 					positive edge of PCLK
    376           * @param[in]	TIMx Pointer to timer device, should be:
    377           *   			- LPC_TIM0: TIMER0 peripheral
    378           * 				- LPC_TIM1: TIMER1 peripheral
    379           * 				- LPC_TIM2: TIMER2 peripheral
    380           * 				- LPC_TIM3: TIMER3 peripheral
    381           * @return 		None
    382           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    383          void TIM_ResetCounter(LPC_TIM_TypeDef *TIMx)
    384          {
    385          	TIMx->TCR |= TIM_RESET;
   \                     TIM_ResetCounter:
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000006   0x6041             STR      R1,[R0, #+4]
    386          	TIMx->TCR &= ~TIM_RESET;
   \   00000008   0x6841             LDR      R1,[R0, #+4]
   \   0000000A   0xF031 0x0102      BICS     R1,R1,#0x2
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    387          }
   \   00000010   0x4770             BX       LR               ;; return
    388          
    389          /*********************************************************************//**
    390           * @brief 		Configuration for Match register
    391           * @param[in]	TIMx Pointer to timer device, should be:
    392           *   			- LPC_TIM0: TIMER0 peripheral
    393           * 				- LPC_TIM1: TIMER1 peripheral
    394           * 				- LPC_TIM2: TIMER2 peripheral
    395           * 				- LPC_TIM3: TIMER3 peripheral
    396           * @param[in]   TIM_MatchConfigStruct Pointer to TIM_MATCHCFG_Type
    397           * 					- MatchChannel : choose channel 0 or 1
    398           * 					- IntOnMatch	 : if SET, interrupt will be generated when MRxx match
    399           * 									the value in TC
    400           * 					- StopOnMatch	 : if SET, TC and PC will be stopped whenM Rxx match
    401           * 									the value in TC
    402           * 					- ResetOnMatch : if SET, Reset on MR0 when MRxx match
    403           * 									the value in TC
    404           * 					-ExtMatchOutputType: Select output for external match
    405           * 						 +	 0:	Do nothing for external output pin if match
    406           *						 +   1:	Force external output pin to low if match
    407           *						 + 	 2: Force external output pin to high if match
    408           *						 + 	 3: Toggle external output pin if match
    409           *					MatchValue: Set the value to be compared with TC value
    410           * @return 		None
    411           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    412          void TIM_ConfigMatch(LPC_TIM_TypeDef *TIMx, TIM_MATCHCFG_Type *TIM_MatchConfigStruct)
    413          {
   \                     TIM_ConfigMatch:
   \   00000000   0xB430             PUSH     {R4,R5}
    414          	switch(TIM_MatchConfigStruct->MatchChannel)
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD005             BEQ.N    ??TIM_ConfigMatch_0
   \   00000008   0x2A02             CMP      R2,#+2
   \   0000000A   0xD009             BEQ.N    ??TIM_ConfigMatch_1
   \   0000000C   0xD305             BCC.N    ??TIM_ConfigMatch_2
   \   0000000E   0x2A03             CMP      R2,#+3
   \   00000010   0xD009             BEQ.N    ??TIM_ConfigMatch_3
   \   00000012   0xE00B             B.N      ??TIM_ConfigMatch_4
    415          	{
    416          	case 0:
    417          		TIMx->MR0 = TIM_MatchConfigStruct->MatchValue;
   \                     ??TIM_ConfigMatch_0:
   \   00000014   0x688A             LDR      R2,[R1, #+8]
   \   00000016   0x6182             STR      R2,[R0, #+24]
    418          		break;
   \   00000018   0xE009             B.N      ??TIM_ConfigMatch_5
    419          	case 1:
    420          		TIMx->MR1 = TIM_MatchConfigStruct->MatchValue;
   \                     ??TIM_ConfigMatch_2:
   \   0000001A   0x688A             LDR      R2,[R1, #+8]
   \   0000001C   0x61C2             STR      R2,[R0, #+28]
    421          		break;
   \   0000001E   0xE006             B.N      ??TIM_ConfigMatch_5
    422          	case 2:
    423          		TIMx->MR2 = TIM_MatchConfigStruct->MatchValue;
   \                     ??TIM_ConfigMatch_1:
   \   00000020   0x688A             LDR      R2,[R1, #+8]
   \   00000022   0x6202             STR      R2,[R0, #+32]
    424          		break;
   \   00000024   0xE003             B.N      ??TIM_ConfigMatch_5
    425          	case 3:
    426          		TIMx->MR3 = TIM_MatchConfigStruct->MatchValue;
   \                     ??TIM_ConfigMatch_3:
   \   00000026   0x688A             LDR      R2,[R1, #+8]
   \   00000028   0x6242             STR      R2,[R0, #+36]
    427          		break;
   \   0000002A   0xE000             B.N      ??TIM_ConfigMatch_5
    428          	default:
    429          		//Error match value
    430          		//Error loop
    431          		while(1);
   \                     ??TIM_ConfigMatch_4:
   \   0000002C   0xE7FE             B.N      ??TIM_ConfigMatch_4
    432          	}
    433          	//interrupt on MRn
    434          	TIMx->MCR &= ~ TIM_MCR_CHANNEL_MASKBIT(TIM_MatchConfigStruct->MatchChannel);
   \                     ??TIM_ConfigMatch_5:
   \   0000002E   0x6942             LDR      R2,[R0, #+20]
   \   00000030   0x2307             MOVS     R3,#+7
   \   00000032   0x780C             LDRB     R4,[R1, #+0]
   \   00000034   0x2503             MOVS     R5,#+3
   \   00000036   0x436C             MULS     R4,R5,R4
   \   00000038   0x40A3             LSLS     R3,R3,R4
   \   0000003A   0x439A             BICS     R2,R2,R3
   \   0000003C   0x6142             STR      R2,[R0, #+20]
    435          
    436          	if (TIM_MatchConfigStruct->IntOnMatch)
   \   0000003E   0x784A             LDRB     R2,[R1, #+1]
   \   00000040   0x2A00             CMP      R2,#+0
   \   00000042   0xD007             BEQ.N    ??TIM_ConfigMatch_6
    437          		TIMx->MCR |= TIM_INT_ON_MATCH(TIM_MatchConfigStruct->MatchChannel);
   \   00000044   0x6942             LDR      R2,[R0, #+20]
   \   00000046   0x2301             MOVS     R3,#+1
   \   00000048   0x780C             LDRB     R4,[R1, #+0]
   \   0000004A   0x2503             MOVS     R5,#+3
   \   0000004C   0x436C             MULS     R4,R5,R4
   \   0000004E   0x40A3             LSLS     R3,R3,R4
   \   00000050   0x431A             ORRS     R2,R3,R2
   \   00000052   0x6142             STR      R2,[R0, #+20]
    438          
    439          	//reset on MRn
    440          	if (TIM_MatchConfigStruct->ResetOnMatch)
   \                     ??TIM_ConfigMatch_6:
   \   00000054   0x78CA             LDRB     R2,[R1, #+3]
   \   00000056   0x2A00             CMP      R2,#+0
   \   00000058   0xD008             BEQ.N    ??TIM_ConfigMatch_7
    441          		TIMx->MCR |= TIM_RESET_ON_MATCH(TIM_MatchConfigStruct->MatchChannel);
   \   0000005A   0x6942             LDR      R2,[R0, #+20]
   \   0000005C   0x2301             MOVS     R3,#+1
   \   0000005E   0x780C             LDRB     R4,[R1, #+0]
   \   00000060   0x2503             MOVS     R5,#+3
   \   00000062   0x436C             MULS     R4,R5,R4
   \   00000064   0x1C64             ADDS     R4,R4,#+1
   \   00000066   0x40A3             LSLS     R3,R3,R4
   \   00000068   0x431A             ORRS     R2,R3,R2
   \   0000006A   0x6142             STR      R2,[R0, #+20]
    442          
    443          	//stop on MRn
    444          	if (TIM_MatchConfigStruct->StopOnMatch)
   \                     ??TIM_ConfigMatch_7:
   \   0000006C   0x788A             LDRB     R2,[R1, #+2]
   \   0000006E   0x2A00             CMP      R2,#+0
   \   00000070   0xD008             BEQ.N    ??TIM_ConfigMatch_8
    445          		TIMx->MCR |= TIM_STOP_ON_MATCH(TIM_MatchConfigStruct->MatchChannel);
   \   00000072   0x6942             LDR      R2,[R0, #+20]
   \   00000074   0x2301             MOVS     R3,#+1
   \   00000076   0x780C             LDRB     R4,[R1, #+0]
   \   00000078   0x2503             MOVS     R5,#+3
   \   0000007A   0x436C             MULS     R4,R5,R4
   \   0000007C   0x1CA4             ADDS     R4,R4,#+2
   \   0000007E   0x40A3             LSLS     R3,R3,R4
   \   00000080   0x431A             ORRS     R2,R3,R2
   \   00000082   0x6142             STR      R2,[R0, #+20]
    446          
    447          	// match output type
    448          
    449          	TIMx->EMR 	&= ~ TIM_EM_MASK(TIM_MatchConfigStruct->MatchChannel);
   \                     ??TIM_ConfigMatch_8:
   \   00000084   0x6BC2             LDR      R2,[R0, #+60]
   \   00000086   0x2303             MOVS     R3,#+3
   \   00000088   0x780C             LDRB     R4,[R1, #+0]
   \   0000008A   0x0064             LSLS     R4,R4,#+1
   \   0000008C   0x1D24             ADDS     R4,R4,#+4
   \   0000008E   0x40A3             LSLS     R3,R3,R4
   \   00000090   0x439A             BICS     R2,R2,R3
   \   00000092   0x63C2             STR      R2,[R0, #+60]
    450          	TIMx->EMR   |= TIM_EM_SET(TIM_MatchConfigStruct->MatchChannel,TIM_MatchConfigStruct->ExtMatchOutputType);
   \   00000094   0x6BC2             LDR      R2,[R0, #+60]
   \   00000096   0x790B             LDRB     R3,[R1, #+4]
   \   00000098   0xF013 0x0303      ANDS     R3,R3,#0x3
   \   0000009C   0x780C             LDRB     R4,[R1, #+0]
   \   0000009E   0x0064             LSLS     R4,R4,#+1
   \   000000A0   0x1D24             ADDS     R4,R4,#+4
   \   000000A2   0x40A3             LSLS     R3,R3,R4
   \   000000A4   0x431A             ORRS     R2,R3,R2
   \   000000A6   0x63C2             STR      R2,[R0, #+60]
    451          }
   \   000000A8   0xBC30             POP      {R4,R5}
   \   000000AA   0x4770             BX       LR               ;; return
    452          /*********************************************************************//**
    453           * @brief 		Update Match value
    454           * @param[in]	TIMx Pointer to timer device, should be:
    455           *   			- LPC_TIM0: TIMER0 peripheral
    456           * 				- LPC_TIM1: TIMER1 peripheral
    457           * 				- LPC_TIM2: TIMER2 peripheral
    458           * 				- LPC_TIM3: TIMER3 peripheral
    459           * @param[in]	MatchChannel	Match channel, should be: 0..3
    460           * @param[in]	MatchValue		updated match value
    461           * @return 		None
    462           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    463          void TIM_UpdateMatchValue(LPC_TIM_TypeDef *TIMx,uint8_t MatchChannel, uint32_t MatchValue)
    464          {
    465          	switch(MatchChannel)
   \                     TIM_UpdateMatchValue:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??TIM_UpdateMatchValue_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD007             BEQ.N    ??TIM_UpdateMatchValue_1
   \   0000000A   0xD304             BCC.N    ??TIM_UpdateMatchValue_2
   \   0000000C   0x2903             CMP      R1,#+3
   \   0000000E   0xD006             BEQ.N    ??TIM_UpdateMatchValue_3
   \   00000010   0xE007             B.N      ??TIM_UpdateMatchValue_4
    466          	{
    467          	case 0:
    468          		TIMx->MR0 = MatchValue;
   \                     ??TIM_UpdateMatchValue_0:
   \   00000012   0x6182             STR      R2,[R0, #+24]
    469          		break;
   \   00000014   0xE006             B.N      ??TIM_UpdateMatchValue_5
    470          	case 1:
    471          		TIMx->MR1 = MatchValue;
   \                     ??TIM_UpdateMatchValue_2:
   \   00000016   0x61C2             STR      R2,[R0, #+28]
    472          		break;
   \   00000018   0xE004             B.N      ??TIM_UpdateMatchValue_5
    473          	case 2:
    474          		TIMx->MR2 = MatchValue;
   \                     ??TIM_UpdateMatchValue_1:
   \   0000001A   0x6202             STR      R2,[R0, #+32]
    475          		break;
   \   0000001C   0xE002             B.N      ??TIM_UpdateMatchValue_5
    476          	case 3:
    477          		TIMx->MR3 = MatchValue;
   \                     ??TIM_UpdateMatchValue_3:
   \   0000001E   0x6242             STR      R2,[R0, #+36]
    478          		break;
   \   00000020   0xE000             B.N      ??TIM_UpdateMatchValue_5
    479          	default:
    480          		//Error Loop
    481          		while(1);
   \                     ??TIM_UpdateMatchValue_4:
   \   00000022   0xE7FE             B.N      ??TIM_UpdateMatchValue_4
    482          	}
    483          }
   \                     ??TIM_UpdateMatchValue_5:
   \   00000024   0x4770             BX       LR               ;; return
    484          
    485          /*********************************************************************//**
    486           * @brief 		Configuration for Capture register
    487           * @param[in]	TIMx Pointer to timer device, should be:
    488           *   			- LPC_TIM0: TIMER0 peripheral
    489           * 				- LPC_TIM1: TIMER1 peripheral
    490           * 				- LPC_TIM2: TIMER2 peripheral
    491           * 				- LPC_TIM3: TIMER3 peripheral
    492           * 					- CaptureChannel: set the channel to capture data
    493           * 					- RisingEdge    : if SET, Capture at rising edge
    494           * 					- FallingEdge	: if SET, Capture at falling edge
    495           * 					- IntOnCaption  : if SET, Capture generate interrupt
    496           * @param[in]   TIM_CaptureConfigStruct	Pointer to TIM_CAPTURECFG_Type
    497           * @return 		None
    498           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    499          void TIM_ConfigCapture(LPC_TIM_TypeDef *TIMx, TIM_CAPTURECFG_Type *TIM_CaptureConfigStruct)
    500          {
   \                     TIM_ConfigCapture:
   \   00000000   0xB430             PUSH     {R4,R5}
    501          	TIMx->CCR &= ~TIM_CCR_CHANNEL_MASKBIT(TIM_CaptureConfigStruct->CaptureChannel);
   \   00000002   0x6A82             LDR      R2,[R0, #+40]
   \   00000004   0x2307             MOVS     R3,#+7
   \   00000006   0x780C             LDRB     R4,[R1, #+0]
   \   00000008   0x2503             MOVS     R5,#+3
   \   0000000A   0x436C             MULS     R4,R5,R4
   \   0000000C   0x40A3             LSLS     R3,R3,R4
   \   0000000E   0x439A             BICS     R2,R2,R3
   \   00000010   0x6282             STR      R2,[R0, #+40]
    502          
    503          	if (TIM_CaptureConfigStruct->RisingEdge)
   \   00000012   0x784A             LDRB     R2,[R1, #+1]
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD007             BEQ.N    ??TIM_ConfigCapture_0
    504          		TIMx->CCR |= TIM_CAP_RISING(TIM_CaptureConfigStruct->CaptureChannel);
   \   00000018   0x6A82             LDR      R2,[R0, #+40]
   \   0000001A   0x2301             MOVS     R3,#+1
   \   0000001C   0x780C             LDRB     R4,[R1, #+0]
   \   0000001E   0x2503             MOVS     R5,#+3
   \   00000020   0x436C             MULS     R4,R5,R4
   \   00000022   0x40A3             LSLS     R3,R3,R4
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x6282             STR      R2,[R0, #+40]
    505          
    506          	if (TIM_CaptureConfigStruct->FallingEdge)
   \                     ??TIM_ConfigCapture_0:
   \   00000028   0x788A             LDRB     R2,[R1, #+2]
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xD008             BEQ.N    ??TIM_ConfigCapture_1
    507          		TIMx->CCR |= TIM_CAP_FALLING(TIM_CaptureConfigStruct->CaptureChannel);
   \   0000002E   0x6A82             LDR      R2,[R0, #+40]
   \   00000030   0x2301             MOVS     R3,#+1
   \   00000032   0x780C             LDRB     R4,[R1, #+0]
   \   00000034   0x2503             MOVS     R5,#+3
   \   00000036   0x436C             MULS     R4,R5,R4
   \   00000038   0x1C64             ADDS     R4,R4,#+1
   \   0000003A   0x40A3             LSLS     R3,R3,R4
   \   0000003C   0x431A             ORRS     R2,R3,R2
   \   0000003E   0x6282             STR      R2,[R0, #+40]
    508          
    509          	if (TIM_CaptureConfigStruct->IntOnCaption)
   \                     ??TIM_ConfigCapture_1:
   \   00000040   0x78CA             LDRB     R2,[R1, #+3]
   \   00000042   0x2A00             CMP      R2,#+0
   \   00000044   0xD008             BEQ.N    ??TIM_ConfigCapture_2
    510          		TIMx->CCR |= TIM_INT_ON_CAP(TIM_CaptureConfigStruct->CaptureChannel);
   \   00000046   0x6A82             LDR      R2,[R0, #+40]
   \   00000048   0x2301             MOVS     R3,#+1
   \   0000004A   0x780C             LDRB     R4,[R1, #+0]
   \   0000004C   0x2503             MOVS     R5,#+3
   \   0000004E   0x436C             MULS     R4,R5,R4
   \   00000050   0x1CA4             ADDS     R4,R4,#+2
   \   00000052   0x40A3             LSLS     R3,R3,R4
   \   00000054   0x431A             ORRS     R2,R3,R2
   \   00000056   0x6282             STR      R2,[R0, #+40]
    511          }
   \                     ??TIM_ConfigCapture_2:
   \   00000058   0xBC30             POP      {R4,R5}
   \   0000005A   0x4770             BX       LR               ;; return
    512          
    513          /*********************************************************************//**
    514           * @brief 		Read value of capture register in timer/counter device
    515           * @param[in]	TIMx Pointer to timer/counter device, should be:
    516           *  			- LPC_TIM0: TIMER0 peripheral
    517           * 				- LPC_TIM1: TIMER1 peripheral
    518           * 				- LPC_TIM2: TIMER2 peripheral
    519           * 				- LPC_TIM3: TIMER3 peripheral
    520           * @param[in]	CaptureChannel: capture channel number, should be:
    521           * 				- TIM_COUNTER_INCAP0: CAPn.0 input pin for TIMERn
    522           * 				- TIM_COUNTER_INCAP1: CAPn.1 input pin for TIMERn
    523           * @return 		Value of capture register
    524           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    525          uint32_t TIM_GetCaptureValue(LPC_TIM_TypeDef *TIMx, TIM_COUNTER_INPUT_OPT CaptureChannel)
    526          {
    527          	if(CaptureChannel==0)
   \                     TIM_GetCaptureValue:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??TIM_GetCaptureValue_0
    528          		return TIMx->CR0;
   \   00000006   0x6AC0             LDR      R0,[R0, #+44]
   \   00000008   0xE000             B.N      ??TIM_GetCaptureValue_1
    529          	else
    530          		return TIMx->CR1;
   \                     ??TIM_GetCaptureValue_0:
   \   0000000A   0x6B00             LDR      R0,[R0, #+48]
   \                     ??TIM_GetCaptureValue_1:
   \   0000000C   0x4770             BX       LR               ;; return
    531          }
    532          
    533          /*---------------Advanced TIMER functions -----------------------------------------*/
    534          /*********************************************************************//**
    535           * @brief 		Timer wait (microseconds)
    536           * @param[in]	time	number of microseconds waiting
    537           * @return 		None
    538           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    539          void TIM_Waitus(uint32_t time)
    540          {
   \                     TIM_Waitus:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
    541          	TIM_MATCHCFG_Type MatchConfigStruct;
    542          	LPC_TIM0->IR = 0xFFFFFFFF;
   \   00000006   0xF05F 0x2040      MOVS     R0,#+1073758208
   \   0000000A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    543          
    544          	MatchConfigStruct.MatchChannel = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
    545          	MatchConfigStruct.IntOnMatch = ENABLE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF88D 0x0001      STRB     R0,[SP, #+1]
    546          	MatchConfigStruct.ResetOnMatch = ENABLE;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    547          	MatchConfigStruct.StopOnMatch = ENABLE;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0002      STRB     R0,[SP, #+2]
    548          	MatchConfigStruct.ExtMatchOutputType = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    549          	MatchConfigStruct.MatchValue = time;
   \   0000002E   0x9402             STR      R4,[SP, #+8]
    550          
    551          	TIM_ConfigMatch(LPC_TIM0, &MatchConfigStruct);
   \   00000030   0xA900             ADD      R1,SP,#+0
   \   00000032   0xF05F 0x2040      MOVS     R0,#+1073758208
   \   00000036   0x.... 0x....      BL       TIM_ConfigMatch
    552          	TIM_Cmd(LPC_TIM0,ENABLE);
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0xF05F 0x2040      MOVS     R0,#+1073758208
   \   00000040   0x.... 0x....      BL       TIM_Cmd
    553          	//wait until interrupt flag occur
    554          	while(!(LPC_TIM0->IR & 0x01));
   \                     ??TIM_Waitus_0:
   \   00000044   0xF05F 0x2040      MOVS     R0,#+1073758208
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x07C0             LSLS     R0,R0,#+31
   \   0000004C   0xD5FA             BPL.N    ??TIM_Waitus_0
    555          	TIM_ResetCounter(LPC_TIM0);
   \   0000004E   0xF05F 0x2040      MOVS     R0,#+1073758208
   \   00000052   0x.... 0x....      BL       TIM_ResetCounter
    556          }
   \   00000056   0xBD1F             POP      {R0-R4,PC}       ;; return
    557          /*********************************************************************//**
    558           * @brief 		Timer wait (milliseconds)
    559           * @param[in]	time	number of millisecond waiting
    560           * @return 		None
    561           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    562          void TIM_Waitms(uint32_t time)
    563          {
   \                     TIM_Waitms:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    564          	TIM_Waitus(time * 1000);
   \   00000004   0xF44F 0x707A      MOV      R0,#+1000
   \   00000008   0xFB00 0xF004      MUL      R0,R0,R4
   \   0000000C   0x.... 0x....      BL       TIM_Waitus
    565          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40090000         DC32     0x40090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40094000         DC32     0x40094000
    566          /**
    567           * @}
    568           */
    569          
    570          /**
    571           * @}
    572           */
    573          
    574          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   TIM_ClearIntCapturePending
       0   TIM_ClearIntPending
       0   TIM_Cmd
       8   TIM_ConfigCapture
       8   TIM_ConfigMatch
       0   TIM_ConfigStructInit
       8   TIM_DeInit
         8   -> CLKPWR_ConfigPPWR
       0   TIM_GetCaptureValue
       4   TIM_GetIntCaptureStatus
       4   TIM_GetIntStatus
      24   TIM_Init
        24   -> CLKPWR_ConfigPPWR
        24   -> converPtrToTimeNum
        24   -> converUSecToVal
       0   TIM_ResetCounter
       0   TIM_UpdateMatchValue
       8   TIM_Waitms
         8   -> TIM_Waitus
      24   TIM_Waitus
        24   -> TIM_Cmd
        24   -> TIM_ConfigMatch
        24   -> TIM_ResetCounter
       0   converPtrToTimeNum
      24   converUSecToVal
        24   -> __aeabi_uldivmod
        24   -> getPClock
      16   getPClock
        16   -> CLKPWR_GetCLK


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       8  TIM_ClearIntCapturePending
       8  TIM_ClearIntPending
      26  TIM_Cmd
      92  TIM_ConfigCapture
     172  TIM_ConfigMatch
      22  TIM_ConfigStructInit
      76  TIM_DeInit
      14  TIM_GetCaptureValue
      30  TIM_GetIntCaptureStatus
      30  TIM_GetIntStatus
     192  TIM_Init
      18  TIM_ResetCounter
      38  TIM_UpdateMatchValue
      18  TIM_Waitms
      88  TIM_Waitus
      54  converPtrToTimeNum
      54  converUSecToVal
      16  getPClock

 
 972 bytes in section .text
 
 972 bytes of CODE memory

Errors: none
Warnings: none
