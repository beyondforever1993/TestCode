###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:19 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_uart.c                            #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Dri #
#                    vers\source\lpc177x_8x_uart.c -lCN                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\ -o D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë #
#                    \RTU_1.2\project\iar\Debug\Obj\ --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\lpc177x_8x_uart.lst                        #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\lpc177x_8x_uart.o                           #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\cmsis\Drivers\source\lpc177x_8x_uart.c
      1          /**********************************************************************
      2          * $Id$		lpc177x_8x_uart.c			2011-06-02
      3          *//**
      4          * @file		lpc177x_8x_uart.c
      5          * @brief	Contains all functions support for UART firmware library
      6          *			on LPC177x_8x
      7          * @version	1.0
      8          * @date		02. June. 2011
      9          * @author	NXP MCU SW Application Team
     10          * 
     11          * Copyright(C) 2011, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          **********************************************************************/
     26          
     27          /* Peripheral group ----------------------------------------------------------- */
     28          /** @addtogroup UART
     29           * @{
     30           */
     31          
     32          /* Includes ------------------------------------------------------------------- */
     33          #include "lpc177x_8x_uart.h"
     34          #include "lpc177x_8x_clkpwr.h"
     35          
     36          /* Private Functions ---------------------------------------------------------- */
     37          
     38          static Status uart_set_divisors(LPC_UART_TypeDef *UARTx, uint32_t baudrate);
     39          static Status uart4_set_divisors(LPC_UART4_TypeDef *UARTx, uint32_t baudrate);
     40          
     41          /*********************************************************************//**
     42           * @brief		Determines best dividers to get a target clock rate
     43           * @param[in]	UARTx	Pointer to selected UART peripheral, should be:
     44           * 				- LPC_UART0: UART0 peripheral
     45           * 				- LPC_UART1: UART1 peripheral
     46           * 				- LPC_UART2: UART2 peripheral
     47           * 				- LPC_UART3: UART3 peripheral
     48           * @param[in]	baudrate Desired UART baud rate.
     49           * @return 		Error status, could be:
     50           * 				- SUCCESS
     51           * 				- ERROR
     52           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     53          static Status uart_set_divisors(LPC_UART_TypeDef *UARTx, uint32_t baudrate)
     54          {
   \                     uart_set_divisors:
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
     55          	Status errorStatus = ERROR;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0008      STRB     R0,[SP, #+8]
     56          
     57          	uint32_t uClk;
     58          	uint32_t d, m, bestd, bestm, tmp;
     59          	uint64_t best_divisor, divisor;
     60          	uint32_t current_error, best_error;
     61          	uint32_t recalcbaud;
     62          
     63          	/* get UART block clock */
     64          	uClk = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       CLKPWR_GetCLK
   \   00000012   0x9007             STR      R0,[SP, #+28]
     65          
     66          	/* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
     67          	* The formula is :
     68          	* BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
     69          	* It involves floating point calculations. That's the reason the formulae are adjusted with
     70          	* Multiply and divide method.*/
     71          	
     72          	/* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
     73          	* 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15 */
     74          	best_error = 0xFFFFFFFF; /* Worst case */
   \   00000014   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000018   0x9003             STR      R0,[SP, #+12]
     75          	bestd = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9005             STR      R0,[SP, #+20]
     76          	bestm = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x9004             STR      R0,[SP, #+16]
     77          	best_divisor = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xE9CD 0x0108      STRD     R0,R1,[SP, #+32]
     78          	
     79          	for (m = 1 ; m <= 15 ;m++)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x0007             MOVS     R7,R0
   \                     ??uart_set_divisors_0:
   \   0000002E   0x2F10             CMP      R7,#+16
   \   00000030   0xD23F             BCS.N    ??uart_set_divisors_1
     80          	{
     81          		for (d = 0 ; d < m ; d++)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x0006             MOVS     R6,R0
   \                     ??uart_set_divisors_2:
   \   00000036   0x42BE             CMP      R6,R7
   \   00000038   0xD236             BCS.N    ??uart_set_divisors_3
     82          		{
     83          			divisor = ((uint64_t)uClk << 28)*m / (baudrate*(m+d));
   \   0000003A   0x9A07             LDR      R2,[SP, #+28]
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x071B             LSLS     R3,R3,#+28
   \   00000040   0xEA43 0x1312      ORR      R3,R3,R2, LSR #+4
   \   00000044   0x0712             LSLS     R2,R2,#+28
   \   00000046   0x46BA             MOV      R10,R7
   \   00000048   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000004C   0xFBAA 0x0102      UMULL    R0,R1,R10,R2
   \   00000050   0xFB0A 0x1103      MLA      R1,R10,R3,R1
   \   00000054   0xFB0B 0x1102      MLA      R1,R11,R2,R1
   \   00000058   0x9A0C             LDR      R2,[SP, #+48]
   \   0000005A   0x19F3             ADDS     R3,R6,R7
   \   0000005C   0x435A             MULS     R2,R3,R2
   \   0000005E   0x2300             MOVS     R3,#+0
   \   00000060   0x.... 0x....      BL       __aeabi_uldivmod
   \   00000064   0x0004             MOVS     R4,R0
   \   00000066   0x000D             MOVS     R5,R1
     84          			current_error = divisor & 0xFFFFFFFF;
   \   00000068   0x46A1             MOV      R9,R4
     85          
     86          			tmp = divisor>>32;
   \   0000006A   0x46A8             MOV      R8,R5
     87          
     88          			/* Adjust error */
     89          			if(current_error > ((uint32_t)1<<31))
   \   0000006C   0xF1B9 0x4F00      CMP      R9,#-2147483648
   \   00000070   0xD903             BLS.N    ??uart_set_divisors_4
     90          			{
     91          				current_error = -current_error;
   \   00000072   0xF1D9 0x0900      RSBS     R9,R9,#+0
     92          				tmp++;
   \   00000076   0xF118 0x0801      ADDS     R8,R8,#+1
     93          			}
     94          
     95          			/* Out of range */
     96          			if(tmp < 1 || tmp > 65536)
   \                     ??uart_set_divisors_4:
   \   0000007A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000007E   0xD002             BEQ.N    ??uart_set_divisors_5
   \   00000080   0xF1B8 0x1F01      CMP      R8,#+65537
   \   00000084   0xD300             BCC.N    ??uart_set_divisors_6
     97          				continue;
   \                     ??uart_set_divisors_5:
   \   00000086   0xE00D             B.N      ??uart_set_divisors_7
     98          
     99          			if( current_error < best_error)
   \                     ??uart_set_divisors_6:
   \   00000088   0x9803             LDR      R0,[SP, #+12]
   \   0000008A   0x4581             CMP      R9,R0
   \   0000008C   0xD20A             BCS.N    ??uart_set_divisors_7
    100          			{
    101          				best_error = current_error;
   \   0000008E   0xF8CD 0x900C      STR      R9,[SP, #+12]
    102          				best_divisor = tmp;
   \   00000092   0x4640             MOV      R0,R8
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0xE9CD 0x0108      STRD     R0,R1,[SP, #+32]
    103          				bestd = d;
   \   0000009A   0x9605             STR      R6,[SP, #+20]
    104          				bestm = m;
   \   0000009C   0x9704             STR      R7,[SP, #+16]
    105          				
    106          				if(best_error == 0) 
   \   0000009E   0x9803             LDR      R0,[SP, #+12]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD001             BEQ.N    ??uart_set_divisors_3
    107          					break;
    108          			}
    109          		} /* end of inner for loop */
   \                     ??uart_set_divisors_7:
   \   000000A4   0x1C76             ADDS     R6,R6,#+1
   \   000000A6   0xE7C6             B.N      ??uart_set_divisors_2
    110          
    111          		if (best_error == 0)
   \                     ??uart_set_divisors_3:
   \   000000A8   0x9803             LDR      R0,[SP, #+12]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD001             BEQ.N    ??uart_set_divisors_1
    112          			break;
    113          	} /* end of outer for loop  */
   \                     ??uart_set_divisors_8:
   \   000000AE   0x1C7F             ADDS     R7,R7,#+1
   \   000000B0   0xE7BD             B.N      ??uart_set_divisors_0
    114          
    115          	/* can not find best match */
    116          	if(best_divisor == 0) 
   \                     ??uart_set_divisors_1:
   \   000000B2   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   000000B6   0x2900             CMP      R1,#+0
   \   000000B8   0xD103             BNE.N    ??uart_set_divisors_9
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD101             BNE.N    ??uart_set_divisors_9
    117          		return ERROR;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xE077             B.N      ??uart_set_divisors_10
    118          
    119          	recalcbaud = (uClk >> 4) * bestm / (best_divisor * (bestm + bestd));
   \                     ??uart_set_divisors_9:
   \   000000C2   0x9807             LDR      R0,[SP, #+28]
   \   000000C4   0x0900             LSRS     R0,R0,#+4
   \   000000C6   0x9904             LDR      R1,[SP, #+16]
   \   000000C8   0x4348             MULS     R0,R1,R0
   \   000000CA   0x2100             MOVS     R1,#+0
   \   000000CC   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000000D0   0xE9DD 0xAB08      LDRD     R10,R11,[SP, #+32]
   \   000000D4   0x9804             LDR      R0,[SP, #+16]
   \   000000D6   0x9905             LDR      R1,[SP, #+20]
   \   000000D8   0x1808             ADDS     R0,R1,R0
   \   000000DA   0x2100             MOVS     R1,#+0
   \   000000DC   0xFBA0 0x230A      UMULL    R2,R3,R0,R10
   \   000000E0   0xFB00 0x330B      MLA      R3,R0,R11,R3
   \   000000E4   0xFB01 0x330A      MLA      R3,R1,R10,R3
   \   000000E8   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   000000EC   0x.... 0x....      BL       __aeabi_uldivmod
   \   000000F0   0x9006             STR      R0,[SP, #+24]
    120          
    121          	/* reuse best_error to evaluate baud error*/
    122          	if(baudrate > recalcbaud) 
   \   000000F2   0x9806             LDR      R0,[SP, #+24]
   \   000000F4   0x990C             LDR      R1,[SP, #+48]
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD204             BCS.N    ??uart_set_divisors_11
    123          		best_error = baudrate - recalcbaud;
   \   000000FA   0x980C             LDR      R0,[SP, #+48]
   \   000000FC   0x9906             LDR      R1,[SP, #+24]
   \   000000FE   0x1A40             SUBS     R0,R0,R1
   \   00000100   0x9003             STR      R0,[SP, #+12]
   \   00000102   0xE003             B.N      ??uart_set_divisors_12
    124          	else 
    125          		best_error = recalcbaud -baudrate;
   \                     ??uart_set_divisors_11:
   \   00000104   0x9806             LDR      R0,[SP, #+24]
   \   00000106   0x990C             LDR      R1,[SP, #+48]
   \   00000108   0x1A40             SUBS     R0,R0,R1
   \   0000010A   0x9003             STR      R0,[SP, #+12]
    126          
    127          	best_error = best_error * 100 / baudrate;
   \                     ??uart_set_divisors_12:
   \   0000010C   0x9803             LDR      R0,[SP, #+12]
   \   0000010E   0x2164             MOVS     R1,#+100
   \   00000110   0x4348             MULS     R0,R1,R0
   \   00000112   0x990C             LDR      R1,[SP, #+48]
   \   00000114   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000118   0x9003             STR      R0,[SP, #+12]
    128          
    129          	if (best_error < UART_ACCEPTED_BAUDRATE_ERROR)
   \   0000011A   0x9803             LDR      R0,[SP, #+12]
   \   0000011C   0x2803             CMP      R0,#+3
   \   0000011E   0xD246             BCS.N    ??uart_set_divisors_13
    130          	{
    131          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000120   0x980B             LDR      R0,[SP, #+44]
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40010000
   \   00000126   0x4288             CMP      R0,R1
   \   00000128   0xD11F             BNE.N    ??uart_set_divisors_14
    132          		{
    133          			((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_DLAB_EN;
   \   0000012A   0x980B             LDR      R0,[SP, #+44]
   \   0000012C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000012E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000132   0x990B             LDR      R1,[SP, #+44]
   \   00000134   0x7308             STRB     R0,[R1, #+12]
    134          			
    135          			((LPC_UART1_TypeDef *)UARTx)->DLM = UART_LOAD_DLM(best_divisor);
   \   00000136   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   0000013A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000013C   0x0A00             LSRS     R0,R0,#+8
   \   0000013E   0x990B             LDR      R1,[SP, #+44]
   \   00000140   0x7108             STRB     R0,[R1, #+4]
    136          			
    137          			((LPC_UART1_TypeDef *)UARTx)->DLL = UART_LOAD_DLL(best_divisor);
   \   00000142   0x9A0B             LDR      R2,[SP, #+44]
   \   00000144   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   00000148   0x7010             STRB     R0,[R2, #+0]
    138          			
    139          			/* Then reset DLAB bit */
    140          			((LPC_UART1_TypeDef *)UARTx)->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
   \   0000014A   0x980B             LDR      R0,[SP, #+44]
   \   0000014C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000014E   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000152   0x990B             LDR      R1,[SP, #+44]
   \   00000154   0x7308             STRB     R0,[R1, #+12]
    141          			
    142          			((LPC_UART1_TypeDef *)UARTx)->FDR = (UART_FDR_MULVAL(bestm)
    143          													| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
   \   00000156   0x9804             LDR      R0,[SP, #+16]
   \   00000158   0x9905             LDR      R1,[SP, #+20]
   \   0000015A   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   0000015E   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   00000162   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000164   0x990B             LDR      R1,[SP, #+44]
   \   00000166   0x6288             STR      R0,[R1, #+40]
   \   00000168   0xE01E             B.N      ??uart_set_divisors_15
    144          		}
    145          		else
    146          		{
    147          			UARTx->LCR |= UART_LCR_DLAB_EN;
   \                     ??uart_set_divisors_14:
   \   0000016A   0x980B             LDR      R0,[SP, #+44]
   \   0000016C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000016E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000172   0x990B             LDR      R1,[SP, #+44]
   \   00000174   0x7308             STRB     R0,[R1, #+12]
    148          			
    149          			UARTx->DLM = UART_LOAD_DLM(best_divisor);
   \   00000176   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   0000017A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000017C   0x0A00             LSRS     R0,R0,#+8
   \   0000017E   0x990B             LDR      R1,[SP, #+44]
   \   00000180   0x7108             STRB     R0,[R1, #+4]
    150          			
    151          			UARTx->DLL = UART_LOAD_DLL(best_divisor);
   \   00000182   0x9A0B             LDR      R2,[SP, #+44]
   \   00000184   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   00000188   0x7010             STRB     R0,[R2, #+0]
    152          			
    153          			/* Then reset DLAB bit */
    154          			UARTx->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
   \   0000018A   0x980B             LDR      R0,[SP, #+44]
   \   0000018C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000018E   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000192   0x990B             LDR      R1,[SP, #+44]
   \   00000194   0x7308             STRB     R0,[R1, #+12]
    155          			
    156          			UARTx->FDR = (UART_FDR_MULVAL(bestm) \
    157          							| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
   \   00000196   0x9804             LDR      R0,[SP, #+16]
   \   00000198   0x9905             LDR      R1,[SP, #+20]
   \   0000019A   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   0000019E   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   000001A2   0x990B             LDR      R1,[SP, #+44]
   \   000001A4   0xF881 0x0028      STRB     R0,[R1, #+40]
    158          		}
    159          		errorStatus = SUCCESS;
   \                     ??uart_set_divisors_15:
   \   000001A8   0x2001             MOVS     R0,#+1
   \   000001AA   0xF88D 0x0008      STRB     R0,[SP, #+8]
    160          	}
    161          
    162          	return errorStatus;
   \                     ??uart_set_divisors_13:
   \   000001AE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \                     ??uart_set_divisors_10:
   \   000001B2   0xB00D             ADD      SP,SP,#+52
   \   000001B4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    163          }
    164          
    165          /* End of Private Functions ---------------------------------------------------- */
    166          
    167          
    168          /* Public Functions ----------------------------------------------------------- */
    169          /** @addtogroup UART_Public_Functions
    170           * @{
    171           */
    172          /* UART Init/DeInit functions -------------------------------------------------*/
    173          /********************************************************************//**
    174           * @brief		Initializes the UARTx peripheral according to the specified
    175           *               parameters in the UART_ConfigStruct.
    176           * @param[in]	UARTx	UART peripheral selected, should be:
    177           *   			- LPC_UART0: UART0 peripheral
    178           * 				- LPC_UART1: UART1 peripheral
    179           * 				- LPC_UART2: UART2 peripheral
    180           * 				- LPC_UART3: UART3 peripheral
    181           *				- LPC_UART4: UART4 peripheral
    182           * @param[in]	UART_ConfigStruct Pointer to a UART_CFG_Type structure
    183          *                    that contains the configuration information for the
    184          *                    specified UART peripheral.
    185           * @return 		None
    186           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    187          void UART_Init(LPC_UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct)
    188          {
   \                     UART_Init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    189          	uint32_t tmp;
    190          
    191          	if(UARTx == LPC_UART0)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x4000c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD103             BNE.N    ??UART_Init_0
    192          	{
    193          		/* Set up clock and power for UART module */
    194          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x2008             MOVS     R0,#+8
   \   00000012   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    195          	}
    196          	if(((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_Init_0:
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD103             BNE.N    ??UART_Init_1
    197          	{
    198          		/* Set up clock and power for UART module */
    199          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, ENABLE);
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x2010             MOVS     R0,#+16
   \   00000022   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    200          	}
    201          	if(UARTx == LPC_UART2)
   \                     ??UART_Init_1:
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40098000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD104             BNE.N    ??UART_Init_2
    202          	{
    203          		/* Set up clock and power for UART module */
    204          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, ENABLE);
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000034   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    205          	}
    206          	if(UARTx == LPC_UART3)
   \                     ??UART_Init_2:
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x4009c000
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD104             BNE.N    ??UART_Init_3
    207          	{
    208          		/* Set up clock and power for UART module */
    209          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, ENABLE);
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0xF05F 0x7000      MOVS     R0,#+33554432
   \   00000046   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    210          	}
    211          
    212          	/* FIFOs are empty */
    213          	UARTx->FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
   \                     ??UART_Init_3:
   \   0000004A   0x2007             MOVS     R0,#+7
   \   0000004C   0x7220             STRB     R0,[R4, #+8]
    214          
    215          	// Disable FIFO
    216          	UARTx->FCR = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x7220             STRB     R0,[R4, #+8]
    217          
    218          	// Dummy reading
    219          	while (UARTx->LSR & UART_LSR_RDR)
   \                     ??UART_Init_4:
   \   00000052   0x7D20             LDRB     R0,[R4, #+20]
   \   00000054   0x07C0             LSLS     R0,R0,#+31
   \   00000056   0xD502             BPL.N    ??UART_Init_5
    220          	{
    221          		tmp = UARTx->RBR;
   \   00000058   0x7820             LDRB     R0,[R4, #+0]
   \   0000005A   0x0006             MOVS     R6,R0
   \   0000005C   0xE7F9             B.N      ??UART_Init_4
    222          	}
    223          
    224          	UARTx->TER = UART_TER_TXEN;
   \                     ??UART_Init_5:
   \   0000005E   0x2080             MOVS     R0,#+128
   \   00000060   0xF884 0x0030      STRB     R0,[R4, #+48]
    225          
    226          	// Wait for current transmit complete
    227          	while (!(UARTx->LSR & UART_LSR_THRE));
   \                     ??UART_Init_6:
   \   00000064   0x7D20             LDRB     R0,[R4, #+20]
   \   00000066   0x0680             LSLS     R0,R0,#+26
   \   00000068   0xD5FC             BPL.N    ??UART_Init_6
    228          
    229          	// Disable Tx
    230          	UARTx->TER = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF884 0x0030      STRB     R0,[R4, #+48]
    231          
    232          	// Disable interrupt
    233          	UARTx->IER = 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x6060             STR      R0,[R4, #+4]
    234          
    235          	// Set LCR to default state
    236          	UARTx->LCR = 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x7320             STRB     R0,[R4, #+12]
    237          
    238          	// Set ACR to default state
    239          	UARTx->ACR = 0;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x6220             STR      R0,[R4, #+32]
    240          
    241          	// Set RS485 control to default state
    242          	UARTx->RS485CTRL = 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xF884 0x004C      STRB     R0,[R4, #+76]
    243          
    244          	// Set RS485 delay timer to default state
    245          	UARTx->RS485DLY = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF884 0x0054      STRB     R0,[R4, #+84]
    246          
    247          	// Set RS485 addr match to default state
    248          	UARTx->ADRMATCH = 0;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF884 0x0050      STRB     R0,[R4, #+80]
    249          
    250          	// Dummy reading
    251          	tmp = UARTx->LSR;
   \   0000008E   0x7D20             LDRB     R0,[R4, #+20]
   \   00000090   0x0006             MOVS     R6,R0
    252          
    253          	if(((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   00000096   0x4284             CMP      R4,R0
   \   00000098   0xD104             BNE.N    ??UART_Init_7
    254          	{
    255          		// Set Modem Control to default state
    256          		((LPC_UART1_TypeDef *)UARTx)->MCR = 0;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x7420             STRB     R0,[R4, #+16]
    257          
    258          		//Dummy Reading to Clear Status
    259          		tmp = ((LPC_UART1_TypeDef *)UARTx)->MSR;
   \   0000009E   0x7E20             LDRB     R0,[R4, #+24]
   \   000000A0   0x0006             MOVS     R6,R0
   \   000000A2   0xE002             B.N      ??UART_Init_8
    260          	}
    261          	else
    262          	{
    263          		// Set IrDA to default state for all UART other than UART1
    264          		UARTx->ICR = 0;
   \                     ??UART_Init_7:
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF884 0x0024      STRB     R0,[R4, #+36]
    265          	}
    266          
    267          	// Set Line Control register ----------------------------
    268          
    269          	uart_set_divisors(UARTx, (UART_ConfigStruct->Baud_rate));
   \                     ??UART_Init_8:
   \   000000AA   0x6829             LDR      R1,[R5, #+0]
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       uart_set_divisors
    270          
    271          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   000000B6   0x4284             CMP      R4,R0
   \   000000B8   0xD104             BNE.N    ??UART_Init_9
    272          	{
    273          		tmp = (((LPC_UART1_TypeDef *)UARTx)->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
    274          													& UART_LCR_BITMASK;
   \   000000BA   0x7B20             LDRB     R0,[R4, #+12]
   \   000000BC   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   000000C0   0x0006             MOVS     R6,R0
   \   000000C2   0xE003             B.N      ??UART_Init_10
    275          	}
    276          	else
    277          	{
    278          		tmp = (UARTx->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) & UART_LCR_BITMASK;
   \                     ??UART_Init_9:
   \   000000C4   0x7B20             LDRB     R0,[R4, #+12]
   \   000000C6   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   000000CA   0x0006             MOVS     R6,R0
    279          	}
    280          
    281          	switch (UART_ConfigStruct->Databits)
   \                     ??UART_Init_10:
   \   000000CC   0x7968             LDRB     R0,[R5, #+5]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD003             BEQ.N    ??UART_Init_11
   \   000000D2   0x2802             CMP      R0,#+2
   \   000000D4   0xD005             BEQ.N    ??UART_Init_12
   \   000000D6   0xD301             BCC.N    ??UART_Init_13
   \   000000D8   0xE006             B.N      ??UART_Init_14
    282          	{
    283          		case UART_DATABIT_5:
    284          			tmp |= UART_LCR_WLEN5;
    285          			break;
   \                     ??UART_Init_11:
   \   000000DA   0xE007             B.N      ??UART_Init_15
    286          
    287          		case UART_DATABIT_6:
    288          			tmp |= UART_LCR_WLEN6;
   \                     ??UART_Init_13:
   \   000000DC   0xF056 0x0601      ORRS     R6,R6,#0x1
    289          			break;
   \   000000E0   0xE004             B.N      ??UART_Init_15
    290          
    291          		case UART_DATABIT_7:
    292          			tmp |= UART_LCR_WLEN7;
   \                     ??UART_Init_12:
   \   000000E2   0xF056 0x0602      ORRS     R6,R6,#0x2
    293          			break;
   \   000000E6   0xE001             B.N      ??UART_Init_15
    294          
    295          		case UART_DATABIT_8:
    296          
    297          		default:
    298          			tmp |= UART_LCR_WLEN8;
   \                     ??UART_Init_14:
   \   000000E8   0xF056 0x0603      ORRS     R6,R6,#0x3
    299          			break;
    300          	}
    301          
    302          	if (UART_ConfigStruct->Parity == UART_PARITY_NONE)
   \                     ??UART_Init_15:
   \   000000EC   0x7928             LDRB     R0,[R5, #+4]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD015             BEQ.N    ??UART_Init_16
    303          	{
    304          		// Do nothing...
    305          	}
    306          	else
    307          	{
    308          		tmp |= UART_LCR_PARITY_EN;
   \   000000F2   0xF056 0x0608      ORRS     R6,R6,#0x8
    309          		switch (UART_ConfigStruct->Parity)
   \   000000F6   0x7928             LDRB     R0,[R5, #+4]
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xD006             BEQ.N    ??UART_Init_17
   \   000000FC   0xD30F             BCC.N    ??UART_Init_18
   \   000000FE   0x2803             CMP      R0,#+3
   \   00000100   0xD007             BEQ.N    ??UART_Init_19
   \   00000102   0xD303             BCC.N    ??UART_Init_20
   \   00000104   0x2804             CMP      R0,#+4
   \   00000106   0xD007             BEQ.N    ??UART_Init_21
   \   00000108   0xE009             B.N      ??UART_Init_18
    310          		{
    311          			case UART_PARITY_ODD:
    312          				tmp |= UART_LCR_PARITY_ODD;
    313          				break;
   \                     ??UART_Init_17:
   \   0000010A   0xE008             B.N      ??UART_Init_16
    314          
    315          			case UART_PARITY_EVEN:
    316          				tmp |= UART_LCR_PARITY_EVEN;
   \                     ??UART_Init_20:
   \   0000010C   0xF056 0x0610      ORRS     R6,R6,#0x10
    317          				break;
   \   00000110   0xE005             B.N      ??UART_Init_16
    318          
    319          			case UART_PARITY_SP_1:
    320          				tmp |= UART_LCR_PARITY_F_1;
   \                     ??UART_Init_19:
   \   00000112   0xF056 0x0620      ORRS     R6,R6,#0x20
    321          				break;
   \   00000116   0xE002             B.N      ??UART_Init_16
    322          
    323          			case UART_PARITY_SP_0:
    324          				tmp |= UART_LCR_PARITY_F_0;
   \                     ??UART_Init_21:
   \   00000118   0xF056 0x0630      ORRS     R6,R6,#0x30
    325          				break;
   \   0000011C   0xE7FF             B.N      ??UART_Init_16
    326          
    327          			default:
    328          				break;
    329          		}
    330          	}
    331          
    332          	switch (UART_ConfigStruct->Stopbits)
   \                     ??UART_Init_18:
   \                     ??UART_Init_16:
   \   0000011E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000120   0x2801             CMP      R0,#+1
   \   00000122   0xD102             BNE.N    ??UART_Init_22
    333          	{
    334          		case UART_STOPBIT_2:
    335          			tmp |= UART_LCR_STOPBIT_SEL;
   \   00000124   0xF056 0x0604      ORRS     R6,R6,#0x4
    336          			break;
   \   00000128   0xE7FF             B.N      ??UART_Init_23
    337          
    338          		case UART_STOPBIT_1:
    339          
    340          		default:
    341          			// Do no thing
    342          			break;
    343          	}
    344          
    345          
    346          	// Write back to LCR, configure FIFO and Disable Tx
    347          	if (((LPC_UART1_TypeDef *)UARTx) ==  LPC_UART1)
   \                     ??UART_Init_22:
   \                     ??UART_Init_23:
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   0000012E   0x4284             CMP      R4,R0
   \   00000130   0xD101             BNE.N    ??UART_Init_24
    348          	{
    349          		((LPC_UART1_TypeDef *)UARTx)->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
   \   00000132   0x7326             STRB     R6,[R4, #+12]
   \   00000134   0xE000             B.N      ??UART_Init_25
    350          	}
    351          	else
    352          	{
    353          		UARTx->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
   \                     ??UART_Init_24:
   \   00000136   0x7326             STRB     R6,[R4, #+12]
    354          	}
    355          }
   \                     ??UART_Init_25:
   \   00000138   0xBD70             POP      {R4-R6,PC}       ;; return
    356          
    357          /*********************************************************************//**
    358           * @brief		De-initializes the UARTx peripheral registers to their
    359           *                  default reset values.
    360           * @param[in]	UARTx	UART peripheral selected, should be:
    361           *   			- LPC_UART0: UART0 peripheral
    362           * 				- LPC_UART1: UART1 peripheral
    363           * 				- LPC_UART2: UART2 peripheral
    364           * 				- LPC_UART3: UART3 peripheral
    365           * @return 		None
    366           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    367          void UART_DeInit(LPC_UART_TypeDef* UARTx)
    368          {
   \                     UART_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    369          	UART_TxCmd(UARTx, DISABLE);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       UART_TxCmd
    370          
    371          	if (UARTx == LPC_UART0)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x4000c000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD103             BNE.N    ??UART_DeInit_0
    372          	{
    373          		/* Set up clock and power for UART module */
    374          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, DISABLE);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2008             MOVS     R0,#+8
   \   00000018   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    375          	}
    376          
    377          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_DeInit_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD103             BNE.N    ??UART_DeInit_1
    378          	{
    379          		/* Set up clock and power for UART module */
    380          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, DISABLE);
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x2010             MOVS     R0,#+16
   \   00000028   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    381          	}
    382          
    383          	if (UARTx == LPC_UART2)
   \                     ??UART_DeInit_1:
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40098000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD104             BNE.N    ??UART_DeInit_2
    384          	{
    385          		/* Set up clock and power for UART module */
    386          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, DISABLE);
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xF05F 0x7080      MOVS     R0,#+16777216
   \   0000003A   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    387          	}
    388          
    389          	if (UARTx == LPC_UART3)
   \                     ??UART_DeInit_2:
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x4009c000
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD104             BNE.N    ??UART_DeInit_3
    390          	{
    391          		/* Set up clock and power for UART module */
    392          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, DISABLE);
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF05F 0x7000      MOVS     R0,#+33554432
   \   0000004C   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    393          	}
    394          }
   \                     ??UART_DeInit_3:
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    395          
    396          /*****************************************************************************//**
    397          * @brief		Fills each UART_InitStruct member with its default value:
    398          * 				- 9600 bps
    399          * 				- 8-bit data
    400          * 				- 1 Stopbit
    401          * 				- None Parity
    402          * @param[in]	UART_InitStruct Pointer to a UART_CFG_Type structure
    403          *                    which will be initialized.
    404          * @return		None
    405          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    406          void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct)
    407          {
    408          	UART_InitStruct->Baud_rate = 9600;
   \                     UART_ConfigStructInit:
   \   00000000   0xF44F 0x5116      MOV      R1,#+9600
   \   00000004   0x6001             STR      R1,[R0, #+0]
    409          
    410          	UART_InitStruct->Databits = UART_DATABIT_8;
   \   00000006   0x2103             MOVS     R1,#+3
   \   00000008   0x7141             STRB     R1,[R0, #+5]
    411          
    412          	UART_InitStruct->Parity = UART_PARITY_NONE;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7101             STRB     R1,[R0, #+4]
    413          
    414          	UART_InitStruct->Stopbits = UART_STOPBIT_1;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7181             STRB     R1,[R0, #+6]
    415          }
   \   00000012   0x4770             BX       LR               ;; return
    416          
    417          /* UART Send/Recieve functions -------------------------------------------------*/
    418          /*********************************************************************//**
    419           * @brief		Transmit a single data through UART peripheral
    420           * @param[in]	UARTx	UART peripheral selected, should be:
    421           *   			- LPC_UART0: UART0 peripheral
    422           * 				- LPC_UART1: UART1 peripheral
    423           * 				- LPC_UART2: UART2 peripheral
    424           * 				- LPC_UART3: UART3 peripheral
    425           * @param[in]	Data	Data to transmit (must be 8-bit long)
    426           * @return 		None
    427           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    428          void UART_SendByte(LPC_UART_TypeDef* UARTx, uint8_t Data)
    429          {
    430          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     UART_SendByte:
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable16  ;; 0x40010000
   \   00000004   0x4290             CMP      R0,R2
   \   00000006   0xD101             BNE.N    ??UART_SendByte_0
    431          	{
    432          		((LPC_UART1_TypeDef *)UARTx)->THR = Data & UART_THR_MASKBIT;
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   \   0000000A   0xE000             B.N      ??UART_SendByte_1
    433          	}
    434          	else
    435          	{
    436          		UARTx->THR = Data & UART_THR_MASKBIT;
   \                     ??UART_SendByte_0:
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    437          	}
    438          
    439          }
   \                     ??UART_SendByte_1:
   \   0000000E   0x4770             BX       LR               ;; return
    440          
    441          
    442          /*********************************************************************//**
    443           * @brief		Receive a single data from UART peripheral
    444           * @param[in]	UARTx	UART peripheral selected, should be:
    445           *  			- LPC_UART0: UART0 peripheral
    446           * 				- LPC_UART1: UART1 peripheral
    447           * 				- LPC_UART2: UART2 peripheral
    448           * 				- LPC_UART3: UART3 peripheral
    449           * @return 		Data received
    450           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    451          uint8_t UART_ReceiveByte(LPC_UART_TypeDef* UARTx)
    452          {
    453          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     UART_ReceiveByte:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40010000
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD101             BNE.N    ??UART_ReceiveByte_0
    454          	{
    455          		return (((LPC_UART1_TypeDef *)UARTx)->RBR & UART_RBR_MASKBIT);
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xE000             B.N      ??UART_ReceiveByte_1
    456          	}
    457          	else
    458          	{
    459          		return (UARTx->RBR & UART_RBR_MASKBIT);
   \                     ??UART_ReceiveByte_0:
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \                     ??UART_ReceiveByte_1:
   \   0000000E   0x4770             BX       LR               ;; return
    460          	}
    461          }
    462          
    463          /*********************************************************************//**
    464           * @brief		Send a block of data via UART peripheral
    465           * @param[in]	UARTx	Selected UART peripheral used to send data, should be:
    466           *   			- LPC_UART0: UART0 peripheral
    467           * 				- LPC_UART1: UART1 peripheral
    468           * 				- LPC_UART2: UART2 peripheral
    469           * 				- LPC_UART3: UART3 peripheral
    470           * @param[in]	txbuf 	Pointer to Transmit buffer
    471           * @param[in]	buflen 	Length of Transmit buffer
    472           * @param[in] 	flag 	Flag used in  UART transfer, should be
    473           * 						NONE_BLOCKING or BLOCKING
    474           * @return 		Number of bytes sent.
    475           *
    476           * Note: when using UART in BLOCKING mode, a time-out condition is used
    477           * via defined symbol UART_BLOCKING_TIMEOUT.
    478           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    479          uint32_t UART_Send(LPC_UART_TypeDef *UARTx, uint8_t *txbuf,
    480          							uint32_t buflen, TRANSFER_BLOCK_Type flag)
    481          {
   \                     UART_Send:
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001E             MOVS     R6,R3
    482          	uint32_t bToSend, bSent, timeOut, fifo_cnt;
    483          	uint8_t *pChar = txbuf;
   \   0000000A   0xF8DD 0xB000      LDR      R11,[SP, #+0]
    484          
    485          	bToSend = buflen;
   \   0000000E   0x002F             MOVS     R7,R5
    486          
    487          	// blocking mode
    488          	if (flag == BLOCKING)
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E01             CMP      R6,#+1
   \   00000014   0xD126             BNE.N    ??UART_Send_0
    489          	{
    490          		bSent = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4680             MOV      R8,R0
    491          		while (bToSend)
   \                     ??UART_Send_1:
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD03F             BEQ.N    ??UART_Send_2
    492          		{
    493          			timeOut = UART_BLOCKING_TIMEOUT;
   \   0000001E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000022   0x4681             MOV      R9,R0
    494          
    495          			// Wait for THR empty with timeout
    496          			while (!(UARTx->LSR & UART_LSR_THRE))
   \                     ??UART_Send_3:
   \   00000024   0x7D20             LDRB     R0,[R4, #+20]
   \   00000026   0x0680             LSLS     R0,R0,#+26
   \   00000028   0xD405             BMI.N    ??UART_Send_4
    497          			{
    498          				if (timeOut == 0)
   \   0000002A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002E   0xD002             BEQ.N    ??UART_Send_4
    499          					break;
    500          
    501          				timeOut--;
   \                     ??UART_Send_5:
   \   00000030   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   00000034   0xE7F6             B.N      ??UART_Send_3
    502          			}
    503          
    504          			// Time out!
    505          			if(timeOut == 0)
   \                     ??UART_Send_4:
   \   00000036   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000003A   0xD030             BEQ.N    ??UART_Send_2
    506          				break;
    507          
    508          			fifo_cnt = UART_TX_FIFO_SIZE;
   \                     ??UART_Send_6:
   \   0000003C   0x2010             MOVS     R0,#+16
   \   0000003E   0x4682             MOV      R10,R0
    509          
    510          			while (fifo_cnt && bToSend)
   \                     ??UART_Send_7:
   \   00000040   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000044   0xD0E9             BEQ.N    ??UART_Send_1
   \   00000046   0x2F00             CMP      R7,#+0
   \   00000048   0xD0E7             BEQ.N    ??UART_Send_1
    511          			{
    512          				UART_SendByte(UARTx, (*pChar++));
   \   0000004A   0xF89B 0x1000      LDRB     R1,[R11, #+0]
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       UART_SendByte
   \   00000054   0xF11B 0x0B01      ADDS     R11,R11,#+1
    513          
    514          				fifo_cnt--;
   \   00000058   0xF1BA 0x0A01      SUBS     R10,R10,#+1
    515          
    516          				bToSend--;
   \   0000005C   0x1E7F             SUBS     R7,R7,#+1
    517          
    518          				bSent++;
   \   0000005E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000062   0xE7ED             B.N      ??UART_Send_7
    519          			}
    520          		}
    521          	}
    522          
    523          	// None blocking mode
    524          	else
    525          	{
    526          		bSent = 0;
   \                     ??UART_Send_0:
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x4680             MOV      R8,R0
    527          		while (bToSend)
   \                     ??UART_Send_8:
   \   00000068   0x2F00             CMP      R7,#+0
   \   0000006A   0xD018             BEQ.N    ??UART_Send_2
    528          		{
    529          			if (bToSend == 0)
   \   0000006C   0x2F00             CMP      R7,#+0
   \   0000006E   0xD016             BEQ.N    ??UART_Send_2
    530          				break;
    531          
    532          			if (!(UARTx->LSR & UART_LSR_THRE))
   \                     ??UART_Send_9:
   \   00000070   0x7D20             LDRB     R0,[R4, #+20]
   \   00000072   0x0680             LSLS     R0,R0,#+26
   \   00000074   0xD513             BPL.N    ??UART_Send_2
    533          			{
    534          				break;
    535          			}
    536          
    537          			fifo_cnt = UART_TX_FIFO_SIZE;
   \                     ??UART_Send_10:
   \   00000076   0x2010             MOVS     R0,#+16
   \   00000078   0x4682             MOV      R10,R0
    538          
    539          			while (fifo_cnt && bToSend)
   \                     ??UART_Send_11:
   \   0000007A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000007E   0xD0F3             BEQ.N    ??UART_Send_8
   \   00000080   0x2F00             CMP      R7,#+0
   \   00000082   0xD0F1             BEQ.N    ??UART_Send_8
    540          			{
    541          				UART_SendByte(UARTx, (*pChar++));
   \   00000084   0xF89B 0x1000      LDRB     R1,[R11, #+0]
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       UART_SendByte
   \   0000008E   0xF11B 0x0B01      ADDS     R11,R11,#+1
    542          
    543          				bToSend--;
   \   00000092   0x1E7F             SUBS     R7,R7,#+1
    544          
    545          				fifo_cnt--;
   \   00000094   0xF1BA 0x0A01      SUBS     R10,R10,#+1
    546          
    547          				bSent++;
   \   00000098   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000009C   0xE7ED             B.N      ??UART_Send_11
    548          			}
    549          		}
    550          	}
    551          
    552          	return bSent;
   \                     ??UART_Send_2:
   \   0000009E   0x4640             MOV      R0,R8
   \   000000A0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    553          }
    554          
    555          /*********************************************************************//**
    556           * @brief		Receive a block of data via UART peripheral
    557           * @param[in]	UARTx	Selected UART peripheral used to send data,
    558           * 				should be:
    559           *   			- LPC_UART0: UART0 peripheral
    560           * 				- LPC_UART1: UART1 peripheral
    561           * 				- LPC_UART2: UART2 peripheral
    562           * 				- LPC_UART3: UART3 peripheral
    563           * @param[out]	rxbuf 	Pointer to Received buffer
    564           * @param[in]	buflen 	Length of Received buffer
    565           * @param[in] 	flag 	Flag mode, should be NONE_BLOCKING or BLOCKING
    566          
    567           * @return 		Number of bytes received
    568           *
    569           * Note: when using UART in BLOCKING mode, a time-out condition is used
    570           * via defined symbol UART_BLOCKING_TIMEOUT.
    571           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    572          uint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf,
    573          								uint32_t buflen, TRANSFER_BLOCK_Type flag)
    574          {
   \                     UART_Receive:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    575          	uint32_t bToRecv, bRecv, timeOut;
    576          	uint8_t *pChar = rxbuf;
   \   0000000C   0x46AB             MOV      R11,R5
    577          
    578          	bToRecv = buflen;
   \   0000000E   0x46B0             MOV      R8,R6
    579          
    580          	// Blocking mode
    581          	if (flag == BLOCKING)
   \   00000010   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000012   0x2F01             CMP      R7,#+1
   \   00000014   0xD11F             BNE.N    ??UART_Receive_0
    582          	{
    583          		bRecv = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4681             MOV      R9,R0
    584          		while (bToRecv)
   \                     ??UART_Receive_1:
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xD02E             BEQ.N    ??UART_Receive_2
    585          		{
    586          			timeOut = UART_BLOCKING_TIMEOUT;
   \   00000020   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000024   0x4682             MOV      R10,R0
    587          			while (!(UARTx->LSR & UART_LSR_RDR))
   \                     ??UART_Receive_3:
   \   00000026   0x7D20             LDRB     R0,[R4, #+20]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD405             BMI.N    ??UART_Receive_4
    588          			{
    589          				if (timeOut == 0)
   \   0000002C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000030   0xD002             BEQ.N    ??UART_Receive_4
    590          					break;
    591          
    592          				timeOut--;
   \                     ??UART_Receive_5:
   \   00000032   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000036   0xE7F6             B.N      ??UART_Receive_3
    593          			}
    594          
    595          			// Time out!
    596          			if(timeOut == 0)
   \                     ??UART_Receive_4:
   \   00000038   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000003C   0xD01F             BEQ.N    ??UART_Receive_2
    597          				break;
    598          
    599          			// Get data from the buffer
    600          			(*pChar++) = UART_ReceiveByte(UARTx);
   \                     ??UART_Receive_6:
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       UART_ReceiveByte
   \   00000044   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000048   0xF11B 0x0B01      ADDS     R11,R11,#+1
    601          
    602          			bToRecv--;
   \   0000004C   0xF1B8 0x0801      SUBS     R8,R8,#+1
    603          
    604          			bRecv++;
   \   00000050   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000054   0xE7E1             B.N      ??UART_Receive_1
    605          		}
    606          	}
    607          	// None blocking mode
    608          	else
    609          	{
    610          		bRecv = 0;
   \                     ??UART_Receive_0:
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x4681             MOV      R9,R0
    611          		while (bToRecv)
   \                     ??UART_Receive_7:
   \   0000005A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000005E   0xD00E             BEQ.N    ??UART_Receive_2
    612          		{
    613          			if (!(UARTx->LSR & UART_LSR_RDR))
   \   00000060   0x7D20             LDRB     R0,[R4, #+20]
   \   00000062   0x07C0             LSLS     R0,R0,#+31
   \   00000064   0xD50B             BPL.N    ??UART_Receive_2
    614          			{
    615          				break;
    616          			}
    617          			else
    618          			{
    619          				(*pChar++) = UART_ReceiveByte(UARTx);
   \                     ??UART_Receive_8:
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       UART_ReceiveByte
   \   0000006C   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000070   0xF11B 0x0B01      ADDS     R11,R11,#+1
    620          
    621          				bRecv++;
   \   00000074   0xF119 0x0901      ADDS     R9,R9,#+1
    622          
    623          				bToRecv--;
   \   00000078   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   0000007C   0xE7ED             B.N      ??UART_Receive_7
    624          			}
    625          		}
    626          	}
    627          
    628          	return bRecv;
   \                     ??UART_Receive_2:
   \   0000007E   0x4648             MOV      R0,R9
   \   00000080   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    629          }
    630          
    631          /*********************************************************************//**
    632           * @brief		Force BREAK character on UART line, output pin UARTx TXD is
    633          				forced to logic 0.
    634           * @param[in]	UARTx	UART peripheral selected, should be:
    635           *  			- LPC_UART0: UART0 peripheral
    636           * 				- LPC_UART1: UART1 peripheral
    637           * 				- LPC_UART2: UART2 peripheral
    638           * 				- LPC_UART3: UART3 peripheral
    639           * @return 		None
    640           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    641          void UART_ForceBreak(LPC_UART_TypeDef* UARTx)
    642          {
    643          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     UART_ForceBreak:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40010000
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD104             BNE.N    ??UART_ForceBreak_0
    644          	{
    645          		((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_BREAK_EN;
   \   00000008   0x7B01             LDRB     R1,[R0, #+12]
   \   0000000A   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   0000000E   0x7301             STRB     R1,[R0, #+12]
   \   00000010   0xE003             B.N      ??UART_ForceBreak_1
    646          	}
    647          	else
    648          	{
    649          		UARTx->LCR |= UART_LCR_BREAK_EN;
   \                     ??UART_ForceBreak_0:
   \   00000012   0x7B01             LDRB     R1,[R0, #+12]
   \   00000014   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   00000018   0x7301             STRB     R1,[R0, #+12]
    650          	}
    651          }
   \                     ??UART_ForceBreak_1:
   \   0000001A   0x4770             BX       LR               ;; return
    652          
    653          
    654          /********************************************************************//**
    655           * @brief 		Enable or disable specified UART interrupt.
    656           * @param[in]	UARTx	UART peripheral selected, should be
    657           *  			- LPC_UART0: UART0 peripheral
    658           * 				- LPC_UART1: UART1 peripheral
    659           * 				- LPC_UART2: UART2 peripheral
    660           * 				- LPC_UART3: UART3 peripheral
    661           * @param[in]	UARTIntCfg	Specifies the interrupt flag,
    662           * 				should be one of the following:
    663          				- UART_INTCFG_RBR 	:  RBR Interrupt enable
    664          				- UART_INTCFG_THRE 	:  THR Interrupt enable
    665          				- UART_INTCFG_RLS 	:  RX line status interrupt enable
    666          				- UART1_INTCFG_MS	:  Modem status interrupt enable (UART1 only)
    667          				- UART1_INTCFG_CTS	:  CTS1 signal transition interrupt enable (UART1 only)
    668          				- UART_INTCFG_ABEO 	:  Enables the end of auto-baud interrupt
    669          				- UART_INTCFG_ABTO 	:  Enables the auto-baud time-out interrupt
    670           * @param[in]	NewState New state of specified UART interrupt type,
    671           * 				should be:
    672           * 				- ENALBE: Enable this UART interrupt type.
    673          * 				- DISALBE: Disable this UART interrupt type.
    674           * @return 		None
    675           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    676          void UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, FunctionalState NewState)
    677          {
   \                     UART_IntConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
    678          	uint32_t tmp;
    679          
    680          	switch(UARTIntCfg)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD009             BEQ.N    ??UART_IntConfig_0
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xD00D             BEQ.N    ??UART_IntConfig_1
   \   0000000C   0xD309             BCC.N    ??UART_IntConfig_2
   \   0000000E   0x2904             CMP      R1,#+4
   \   00000010   0xD010             BEQ.N    ??UART_IntConfig_3
   \   00000012   0xD30C             BCC.N    ??UART_IntConfig_4
   \   00000014   0x2906             CMP      R1,#+6
   \   00000016   0xD014             BEQ.N    ??UART_IntConfig_5
   \   00000018   0xD30F             BCC.N    ??UART_IntConfig_6
   \   0000001A   0xE015             B.N      ??UART_IntConfig_7
    681          	{
    682          		case UART_INTCFG_RBR:
    683          			tmp = UART_IER_RBRINT_EN;
   \                     ??UART_IntConfig_0:
   \   0000001C   0x2401             MOVS     R4,#+1
   \   0000001E   0x0023             MOVS     R3,R4
    684          			break;
   \   00000020   0xE012             B.N      ??UART_IntConfig_7
    685          
    686          		case UART_INTCFG_THRE:
    687          			tmp = UART_IER_THREINT_EN;
   \                     ??UART_IntConfig_2:
   \   00000022   0x2402             MOVS     R4,#+2
   \   00000024   0x0023             MOVS     R3,R4
    688          			break;
   \   00000026   0xE00F             B.N      ??UART_IntConfig_7
    689          
    690          		case UART_INTCFG_RLS:
    691          			tmp = UART_IER_RLSINT_EN;
   \                     ??UART_IntConfig_1:
   \   00000028   0x2404             MOVS     R4,#+4
   \   0000002A   0x0023             MOVS     R3,R4
    692          			break;
   \   0000002C   0xE00C             B.N      ??UART_IntConfig_7
    693          
    694          		case UART1_INTCFG_MS:
    695          			tmp = UART1_IER_MSINT_EN;
   \                     ??UART_IntConfig_4:
   \   0000002E   0x2408             MOVS     R4,#+8
   \   00000030   0x0023             MOVS     R3,R4
    696          			break;
   \   00000032   0xE009             B.N      ??UART_IntConfig_7
    697          
    698          		case UART1_INTCFG_CTS:
    699          			tmp = UART1_IER_CTSINT_EN;
   \                     ??UART_IntConfig_3:
   \   00000034   0x2480             MOVS     R4,#+128
   \   00000036   0x0023             MOVS     R3,R4
    700          			break;
   \   00000038   0xE006             B.N      ??UART_IntConfig_7
    701          
    702          		case UART_INTCFG_ABEO:
    703          			tmp = UART_IER_ABEOINT_EN;
   \                     ??UART_IntConfig_6:
   \   0000003A   0xF44F 0x7480      MOV      R4,#+256
   \   0000003E   0x0023             MOVS     R3,R4
    704          			break;
   \   00000040   0xE002             B.N      ??UART_IntConfig_7
    705          
    706          		case UART_INTCFG_ABTO:
    707          			tmp = UART_IER_ABTOINT_EN;
   \                     ??UART_IntConfig_5:
   \   00000042   0xF44F 0x7400      MOV      R4,#+512
   \   00000046   0x0023             MOVS     R3,R4
    708          			break;
    709          	}
    710          
    711          	if (NewState == ENABLE)
   \                     ??UART_IntConfig_7:
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0x2A01             CMP      R2,#+1
   \   0000004C   0xD10B             BNE.N    ??UART_IntConfig_8
    712          	{
    713          		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
   \   0000004E   0x.... 0x....      LDR.W    R4,??DataTable16  ;; 0x40010000
   \   00000052   0x42A0             CMP      R0,R4
   \   00000054   0xD103             BNE.N    ??UART_IntConfig_9
    714          		{
    715          			((LPC_UART1_TypeDef *)UARTx)->IER |= tmp;
   \   00000056   0x6844             LDR      R4,[R0, #+4]
   \   00000058   0x431C             ORRS     R4,R3,R4
   \   0000005A   0x6044             STR      R4,[R0, #+4]
   \   0000005C   0xE014             B.N      ??UART_IntConfig_10
    716          		}
    717          		else
    718          		{
    719          			UARTx->IER |= tmp;
   \                     ??UART_IntConfig_9:
   \   0000005E   0x6844             LDR      R4,[R0, #+4]
   \   00000060   0x431C             ORRS     R4,R3,R4
   \   00000062   0x6044             STR      R4,[R0, #+4]
   \   00000064   0xE010             B.N      ??UART_IntConfig_10
    720          		}
    721          	}
    722          	else
    723          	{
    724          		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
   \                     ??UART_IntConfig_8:
   \   00000066   0x.... 0x....      LDR.W    R4,??DataTable16  ;; 0x40010000
   \   0000006A   0x42A0             CMP      R0,R4
   \   0000006C   0xD106             BNE.N    ??UART_IntConfig_11
    725          		{
    726          			((LPC_UART1_TypeDef *)UARTx)->IER &= (~tmp) & UART1_IER_BITMASK;
   \   0000006E   0x6844             LDR      R4,[R0, #+4]
   \   00000070   0xF240 0x358F      MOVW     R5,#+911
   \   00000074   0x439D             BICS     R5,R5,R3
   \   00000076   0x402C             ANDS     R4,R5,R4
   \   00000078   0x6044             STR      R4,[R0, #+4]
   \   0000007A   0xE005             B.N      ??UART_IntConfig_10
    727          		}
    728          		else
    729          		{
    730          			UARTx->IER &= (~tmp) & UART_IER_BITMASK;
   \                     ??UART_IntConfig_11:
   \   0000007C   0x6844             LDR      R4,[R0, #+4]
   \   0000007E   0xF240 0x3507      MOVW     R5,#+775
   \   00000082   0x439D             BICS     R5,R5,R3
   \   00000084   0x402C             ANDS     R4,R5,R4
   \   00000086   0x6044             STR      R4,[R0, #+4]
    731          		}
    732          	}
    733          }
   \                     ??UART_IntConfig_10:
   \   00000088   0xBC30             POP      {R4,R5}
   \   0000008A   0x4770             BX       LR               ;; return
    734          
    735          
    736          /********************************************************************//**
    737           * @brief 		Get current value of Line Status register in UART peripheral.
    738           * @param[in]	UARTx	UART peripheral selected, should be:
    739           *  			- LPC_UART0: UART0 peripheral
    740           * 				- LPC_UART1: UART1 peripheral
    741           * 				- LPC_UART2: UART2 peripheral
    742           * 				- LPC_UART3: UART3 peripheral
    743           * @return		Current value of Line Status register in UART peripheral.
    744           * Note:	The return value of this function must be ANDed with each member in
    745           * 			UART_LS_Type enumeration to determine current flag status
    746           * 			corresponding to each Line status type. Because some flags in
    747           * 			Line Status register will be cleared after reading, the next reading
    748           * 			Line Status register could not be correct. So this function used to
    749           * 			read Line status register in one time only, then the return value
    750           * 			used to check all flags.
    751           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    752          uint8_t UART_GetLineStatus(LPC_UART_TypeDef* UARTx)
    753          {
   \                     UART_GetLineStatus:
   \   00000000   0x0001             MOVS     R1,R0
    754          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD104             BNE.N    ??UART_GetLineStatus_0
    755          	{
    756          		return ((((LPC_UART1_TypeDef *)LPC_UART1)->LSR) & UART_LSR_BITMASK);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010014
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xE000             B.N      ??UART_GetLineStatus_1
    757          	}
    758          	else
    759          	{
    760          		return ((UARTx->LSR) & UART_LSR_BITMASK);
   \                     ??UART_GetLineStatus_0:
   \   00000014   0x7D08             LDRB     R0,[R1, #+20]
   \                     ??UART_GetLineStatus_1:
   \   00000016   0x4770             BX       LR               ;; return
    761          	}
    762          }
    763          
    764          /********************************************************************//**
    765           * @brief 		Get Interrupt Identification value
    766           * @param[in]	UARTx	UART peripheral selected, should be:
    767           *  			- LPC_UART0: UART0 peripheral
    768           * 				- LPC_UART1: UART1 peripheral
    769           * 				- LPC_UART2: UART2 peripheral
    770           * 				- LPC_UART3: UART3 peripheral
    771           * @return		Current value of UART UIIR register in UART peripheral.
    772           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    773          uint32_t UART_GetIntId(LPC_UART_TypeDef* UARTx)
    774          {
    775          	return (UARTx->IIR & 0x03CF);
   \                     UART_GetIntId:
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0xF240 0x31CF      MOVW     R1,#+975
   \   00000006   0x4008             ANDS     R0,R1,R0
   \   00000008   0x4770             BX       LR               ;; return
    776          }
    777          
    778          /*********************************************************************//**
    779           * @brief		Check whether if UART is busy or not
    780           * @param[in]	UARTx	UART peripheral selected, should be:
    781           *  			- LPC_UART0: UART0 peripheral
    782           * 				- LPC_UART1: UART1 peripheral
    783           * 				- LPC_UART2: UART2 peripheral
    784           * 				- LPC_UART3: UART3 peripheral
    785           * @return		RESET if UART is not busy, otherwise return SET.
    786           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    787          FlagStatus UART_CheckBusy(LPC_UART_TypeDef *UARTx)
    788          {
   \                     UART_CheckBusy:
   \   00000000   0x0001             MOVS     R1,R0
    789          	if (UARTx->LSR & UART_LSR_TEMT)
   \   00000002   0x7D08             LDRB     R0,[R1, #+20]
   \   00000004   0x0640             LSLS     R0,R0,#+25
   \   00000006   0xD501             BPL.N    ??UART_CheckBusy_0
    790          	{
    791          		return RESET;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE000             B.N      ??UART_CheckBusy_1
    792          	}
    793          	else
    794          	{
    795          		return SET;
   \                     ??UART_CheckBusy_0:
   \   0000000C   0x2001             MOVS     R0,#+1
   \                     ??UART_CheckBusy_1:
   \   0000000E   0x4770             BX       LR               ;; return
    796          	}
    797          }
    798          
    799          
    800          /*********************************************************************//**
    801           * @brief		Configure FIFO function on selected UART peripheral
    802           * @param[in]	UARTx	UART peripheral selected, should be:
    803           *  			- LPC_UART0: UART0 peripheral
    804           * 				- LPC_UART1: UART1 peripheral
    805           * 				- LPC_UART2: UART2 peripheral
    806           * 				- LPC_UART3: UART3 peripheral
    807           * @param[in]	FIFOCfg	Pointer to a UART_FIFO_CFG_Type Structure that
    808           * 						contains specified information about FIFO configuration
    809           * @return 		none
    810           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    811          void UART_FIFOConfig(LPC_UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg)
    812          {
    813          	uint8_t tmp = 0;
   \                     UART_FIFOConfig:
   \   00000000   0x2200             MOVS     R2,#+0
    814          
    815          	tmp |= UART_FCR_FIFO_EN;
   \   00000002   0xF052 0x0201      ORRS     R2,R2,#0x1
    816          
    817          	switch (FIFOCfg->FIFO_Level)
   \   00000006   0x78CB             LDRB     R3,[R1, #+3]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD003             BEQ.N    ??UART_FIFOConfig_0
   \   0000000C   0x2B02             CMP      R3,#+2
   \   0000000E   0xD005             BEQ.N    ??UART_FIFOConfig_1
   \   00000010   0xD301             BCC.N    ??UART_FIFOConfig_2
   \   00000012   0xE006             B.N      ??UART_FIFOConfig_3
    818          	{
    819          		case UART_FIFO_TRGLEV0:
    820          			tmp |= UART_FCR_TRG_LEV0;
    821          			break;
   \                     ??UART_FIFOConfig_0:
   \   00000014   0xE007             B.N      ??UART_FIFOConfig_4
    822          
    823          		case UART_FIFO_TRGLEV1:
    824          			tmp |= UART_FCR_TRG_LEV1;
   \                     ??UART_FIFOConfig_2:
   \   00000016   0xF052 0x0240      ORRS     R2,R2,#0x40
    825          			break;
   \   0000001A   0xE004             B.N      ??UART_FIFOConfig_4
    826          
    827          		case UART_FIFO_TRGLEV2:
    828          			tmp |= UART_FCR_TRG_LEV2;
   \                     ??UART_FIFOConfig_1:
   \   0000001C   0xF052 0x0280      ORRS     R2,R2,#0x80
    829          			break;
   \   00000020   0xE001             B.N      ??UART_FIFOConfig_4
    830          
    831          		case UART_FIFO_TRGLEV3:
    832          
    833          		default:
    834          			tmp |= UART_FCR_TRG_LEV3;
   \                     ??UART_FIFOConfig_3:
   \   00000022   0xF052 0x02C0      ORRS     R2,R2,#0xC0
    835          			break;
    836          	}
    837          
    838          	if (FIFOCfg->FIFO_ResetTxBuf == ENABLE)
   \                     ??UART_FIFOConfig_4:
   \   00000026   0x784B             LDRB     R3,[R1, #+1]
   \   00000028   0x2B01             CMP      R3,#+1
   \   0000002A   0xD101             BNE.N    ??UART_FIFOConfig_5
    839          	{
    840          		tmp |= UART_FCR_TX_RS;
   \   0000002C   0xF052 0x0204      ORRS     R2,R2,#0x4
    841          	}
    842          
    843          	if (FIFOCfg->FIFO_ResetRxBuf == ENABLE)
   \                     ??UART_FIFOConfig_5:
   \   00000030   0x780B             LDRB     R3,[R1, #+0]
   \   00000032   0x2B01             CMP      R3,#+1
   \   00000034   0xD101             BNE.N    ??UART_FIFOConfig_6
    844          	{
    845          		tmp |= UART_FCR_RX_RS;
   \   00000036   0xF052 0x0202      ORRS     R2,R2,#0x2
    846          	}
    847          
    848          	if (FIFOCfg->FIFO_DMAMode == ENABLE)
   \                     ??UART_FIFOConfig_6:
   \   0000003A   0x788B             LDRB     R3,[R1, #+2]
   \   0000003C   0x2B01             CMP      R3,#+1
   \   0000003E   0xD101             BNE.N    ??UART_FIFOConfig_7
    849          	{
    850          		tmp |= UART_FCR_DMAMODE_SEL;
   \   00000040   0xF052 0x0208      ORRS     R2,R2,#0x8
    851          	}
    852          
    853          
    854          	//write to FIFO control register
    855          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_FIFOConfig_7:
   \   00000044   0x.... 0x....      LDR.W    R3,??DataTable16  ;; 0x40010000
   \   00000048   0x4298             CMP      R0,R3
   \   0000004A   0xD103             BNE.N    ??UART_FIFOConfig_8
    856          	{
    857          		((LPC_UART1_TypeDef *)UARTx)->FCR = tmp & UART_FCR_BITMASK;
   \   0000004C   0xF012 0x03CF      ANDS     R3,R2,#0xCF
   \   00000050   0x7203             STRB     R3,[R0, #+8]
   \   00000052   0xE002             B.N      ??UART_FIFOConfig_9
    858          	}
    859          	else
    860          	{
    861          		UARTx->FCR = tmp & UART_FCR_BITMASK;
   \                     ??UART_FIFOConfig_8:
   \   00000054   0xF012 0x03CF      ANDS     R3,R2,#0xCF
   \   00000058   0x7203             STRB     R3,[R0, #+8]
    862          	}
    863          }
   \                     ??UART_FIFOConfig_9:
   \   0000005A   0x4770             BX       LR               ;; return
    864          
    865          /*****************************************************************************//**
    866          * @brief		Fills each UART_FIFOInitStruct member with its default value:
    867          * 				- FIFO_DMAMode = DISABLE
    868          * 				- FIFO_Level = UART_FIFO_TRGLEV0
    869          * 				- FIFO_ResetRxBuf = ENABLE
    870          * 				- FIFO_ResetTxBuf = ENABLE
    871          * 				- FIFO_State = ENABLE
    872          
    873          * @param[in]	UART_FIFOInitStruct Pointer to a UART_FIFO_CFG_Type structure
    874          *                    which will be initialized.
    875          * @return		None
    876          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    877          void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct)
    878          {
    879          	UART_FIFOInitStruct->FIFO_DMAMode = DISABLE;
   \                     UART_FIFOConfigStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7081             STRB     R1,[R0, #+2]
    880          
    881          	UART_FIFOInitStruct->FIFO_Level = UART_FIFO_TRGLEV0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x70C1             STRB     R1,[R0, #+3]
    882          
    883          	UART_FIFOInitStruct->FIFO_ResetRxBuf = ENABLE;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    884          
    885          	UART_FIFOInitStruct->FIFO_ResetTxBuf = ENABLE;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x7041             STRB     R1,[R0, #+1]
    886          }
   \   00000010   0x4770             BX       LR               ;; return
    887          
    888          
    889          /*********************************************************************//**
    890           * @brief		Start/Stop Auto Baudrate activity
    891           * @param[in]	UARTx	UART peripheral selected, should be
    892           *   			- LPC_UART0: UART0 peripheral
    893           * 				- LPC_UART1: UART1 peripheral
    894           * 				- LPC_UART2: UART2 peripheral
    895           * 				- LPC_UART3: UART3 peripheral
    896           * @param[in]	ABConfigStruct	A pointer to UART_AB_CFG_Type structure that
    897           * 								contains specified information about UART
    898           * 								auto baudrate configuration
    899           * @param[in]	NewState New State of Auto baudrate activity, should be:
    900           * 				- ENABLE: Start this activity
    901           *				- DISABLE: Stop this activity
    902           * Note:		Auto-baudrate mode enable bit will be cleared once this mode
    903           * 				completed.
    904           * @return 		none
    905           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    906          void UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct,
    907          							FunctionalState NewState)
    908          {
   \                     UART_ABCmd:
   \   00000000   0xB410             PUSH     {R4}
    909          	uint32_t tmp;
    910          
    911          	tmp = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x0023             MOVS     R3,R4
    912          	if (NewState == ENABLE)
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xD109             BNE.N    ??UART_ABCmd_0
    913          	{
    914          		if (ABConfigStruct->ABMode == UART_AUTOBAUD_MODE1)
   \   0000000C   0x780C             LDRB     R4,[R1, #+0]
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD101             BNE.N    ??UART_ABCmd_1
    915          		{
    916          			tmp |= UART_ACR_MODE;
   \   00000012   0xF053 0x0302      ORRS     R3,R3,#0x2
    917          		}
    918          		if (ABConfigStruct->AutoRestart == ENABLE)
   \                     ??UART_ABCmd_1:
   \   00000016   0x784C             LDRB     R4,[R1, #+1]
   \   00000018   0x2C01             CMP      R4,#+1
   \   0000001A   0xD101             BNE.N    ??UART_ABCmd_0
    919          		{
    920          			tmp |= UART_ACR_AUTO_RESTART;
   \   0000001C   0xF053 0x0304      ORRS     R3,R3,#0x4
    921          		}
    922          	}
    923          
    924          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_ABCmd_0:
   \   00000020   0x.... 0x....      LDR.W    R4,??DataTable16  ;; 0x40010000
   \   00000024   0x42A0             CMP      R0,R4
   \   00000026   0xD117             BNE.N    ??UART_ABCmd_2
    925          	{
    926          		if (NewState == ENABLE)
   \   00000028   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002A   0x2A01             CMP      R2,#+1
   \   0000002C   0xD111             BNE.N    ??UART_ABCmd_3
    927          		{
    928          			// Clear DLL and DLM value
    929          			((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_DLAB_EN;
   \   0000002E   0x7B04             LDRB     R4,[R0, #+12]
   \   00000030   0xF054 0x0480      ORRS     R4,R4,#0x80
   \   00000034   0x7304             STRB     R4,[R0, #+12]
    930          
    931          			((LPC_UART1_TypeDef *)UARTx)->DLL = 0;
   \   00000036   0x2400             MOVS     R4,#+0
   \   00000038   0x7004             STRB     R4,[R0, #+0]
    932          
    933          			((LPC_UART1_TypeDef *)UARTx)->DLM = 0;
   \   0000003A   0x2400             MOVS     R4,#+0
   \   0000003C   0x7104             STRB     R4,[R0, #+4]
    934          
    935          			((LPC_UART1_TypeDef *)UARTx)->LCR &= ~UART_LCR_DLAB_EN;
   \   0000003E   0x7B04             LDRB     R4,[R0, #+12]
   \   00000040   0xF014 0x047F      ANDS     R4,R4,#0x7F
   \   00000044   0x7304             STRB     R4,[R0, #+12]
    936          
    937          			// FDR value must be reset to default value
    938          			((LPC_UART1_TypeDef *)UARTx)->FDR = 0x10;
   \   00000046   0x2410             MOVS     R4,#+16
   \   00000048   0x6284             STR      R4,[R0, #+40]
    939          
    940          			((LPC_UART1_TypeDef *)UARTx)->ACR = UART_ACR_START | tmp;
   \   0000004A   0xF053 0x0401      ORRS     R4,R3,#0x1
   \   0000004E   0x6204             STR      R4,[R0, #+32]
   \   00000050   0xE01A             B.N      ??UART_ABCmd_4
    941          		}
    942          		else
    943          		{
    944          			((LPC_UART1_TypeDef *)UARTx)->ACR = 0;
   \                     ??UART_ABCmd_3:
   \   00000052   0x2400             MOVS     R4,#+0
   \   00000054   0x6204             STR      R4,[R0, #+32]
   \   00000056   0xE017             B.N      ??UART_ABCmd_4
    945          		}
    946          	}
    947          	else
    948          	{
    949          		if (NewState == ENABLE)
   \                     ??UART_ABCmd_2:
   \   00000058   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005A   0x2A01             CMP      R2,#+1
   \   0000005C   0xD112             BNE.N    ??UART_ABCmd_5
    950          		{
    951          			// Clear DLL and DLM value
    952          			UARTx->LCR |= UART_LCR_DLAB_EN;
   \   0000005E   0x7B04             LDRB     R4,[R0, #+12]
   \   00000060   0xF054 0x0480      ORRS     R4,R4,#0x80
   \   00000064   0x7304             STRB     R4,[R0, #+12]
    953          
    954          			UARTx->DLL = 0;
   \   00000066   0x2400             MOVS     R4,#+0
   \   00000068   0x7004             STRB     R4,[R0, #+0]
    955          
    956          			UARTx->DLM = 0;
   \   0000006A   0x2400             MOVS     R4,#+0
   \   0000006C   0x7104             STRB     R4,[R0, #+4]
    957          
    958          			UARTx->LCR &= ~UART_LCR_DLAB_EN;
   \   0000006E   0x7B04             LDRB     R4,[R0, #+12]
   \   00000070   0xF014 0x047F      ANDS     R4,R4,#0x7F
   \   00000074   0x7304             STRB     R4,[R0, #+12]
    959          
    960          			// FDR value must be reset to default value
    961          			UARTx->FDR = 0x10;
   \   00000076   0x2410             MOVS     R4,#+16
   \   00000078   0xF880 0x4028      STRB     R4,[R0, #+40]
    962          
    963          			UARTx->ACR = UART_ACR_START | tmp;
   \   0000007C   0xF053 0x0401      ORRS     R4,R3,#0x1
   \   00000080   0x6204             STR      R4,[R0, #+32]
   \   00000082   0xE001             B.N      ??UART_ABCmd_4
    964          		}
    965          		else
    966          		{
    967          			UARTx->ACR = 0;
   \                     ??UART_ABCmd_5:
   \   00000084   0x2400             MOVS     R4,#+0
   \   00000086   0x6204             STR      R4,[R0, #+32]
    968          		}
    969          	}
    970          }
   \                     ??UART_ABCmd_4:
   \   00000088   0xBC10             POP      {R4}
   \   0000008A   0x4770             BX       LR               ;; return
    971          
    972          /*********************************************************************//**
    973           * @brief		Clear Autobaud Interrupt Pending
    974           * @param[in]	UARTx	UART peripheral selected, should be
    975           *   			- LPC_UART0: UART0 peripheral
    976           * 				- LPC_UART1: UART1 peripheral
    977           * 				- LPC_UART2: UART2 peripheral
    978           * 				- LPC_UART3: UART3 peripheral
    979           * @param[in]	ABIntType	type of auto-baud interrupt, should be:
    980           * 				- UART_AUTOBAUD_INTSTAT_ABEO: End of Auto-baud interrupt
    981           * 				- UART_AUTOBAUD_INTSTAT_ABTO: Auto-baud time out interrupt
    982           * @return 		none
    983           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    984          void UART_ABClearIntPending(LPC_UART_TypeDef *UARTx, UART_ABEO_Type ABIntType)
    985          {
    986          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     UART_ABClearIntPending:
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable16  ;; 0x40010000
   \   00000004   0x4290             CMP      R0,R2
   \   00000006   0xD104             BNE.N    ??UART_ABClearIntPending_0
    987          	{
    988          		UARTx->ACR |= ABIntType;
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x6202             STR      R2,[R0, #+32]
   \   00000010   0xE003             B.N      ??UART_ABClearIntPending_1
    989          	}
    990          	else
    991          		UARTx->ACR |= ABIntType;
   \                     ??UART_ABClearIntPending_0:
   \   00000012   0x6A02             LDR      R2,[R0, #+32]
   \   00000014   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000016   0x430A             ORRS     R2,R1,R2
   \   00000018   0x6202             STR      R2,[R0, #+32]
    992          }
   \                     ??UART_ABClearIntPending_1:
   \   0000001A   0x4770             BX       LR               ;; return
    993          
    994          /*********************************************************************//**
    995           * @brief		Enable/Disable transmission on UART TxD pin
    996           * @param[in]	UARTx	UART peripheral selected, should be:
    997           *   			- LPC_UART0: UART0 peripheral
    998           * 				- LPC_UART1: UART1 peripheral
    999           * 				- LPC_UART2: UART2 peripheral
   1000           * 				- LPC_UART3: UART3 peripheral
   1001           * @param[in]	NewState New State of Tx transmission function, should be:
   1002           * 				- ENABLE: Enable this function
   1003          				- DISABLE: Disable this function
   1004           * @return none
   1005           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1006          void UART_TxCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState)
   1007          {
   1008          	if (NewState == ENABLE)
   \                     UART_TxCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD111             BNE.N    ??UART_TxCmd_0
   1009          	{
   1010          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable16  ;; 0x40010000
   \   0000000A   0x4290             CMP      R0,R2
   \   0000000C   0xD106             BNE.N    ??UART_TxCmd_1
   1011          		{
   1012          			((LPC_UART1_TypeDef *)UARTx)->TER |= UART_TER_TXEN;
   \   0000000E   0xF890 0x2030      LDRB     R2,[R0, #+48]
   \   00000012   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000016   0xF880 0x2030      STRB     R2,[R0, #+48]
   \   0000001A   0xE015             B.N      ??UART_TxCmd_2
   1013          		}
   1014          		else
   1015          		{
   1016          			UARTx->TER |= UART_TER_TXEN;
   \                     ??UART_TxCmd_1:
   \   0000001C   0xF890 0x2030      LDRB     R2,[R0, #+48]
   \   00000020   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000024   0xF880 0x2030      STRB     R2,[R0, #+48]
   \   00000028   0xE00E             B.N      ??UART_TxCmd_2
   1017          		}
   1018          	}
   1019          	else
   1020          	{
   1021          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_TxCmd_0:
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable16  ;; 0x40010000
   \   0000002E   0x4290             CMP      R0,R2
   \   00000030   0xD105             BNE.N    ??UART_TxCmd_3
   1022          		{
   1023          			((LPC_UART1_TypeDef *)UARTx)->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
   \   00000032   0xF890 0x2030      LDRB     R2,[R0, #+48]
   \   00000036   0x2300             MOVS     R3,#+0
   \   00000038   0xF880 0x3030      STRB     R3,[R0, #+48]
   \   0000003C   0xE004             B.N      ??UART_TxCmd_2
   1024          		}
   1025          		else
   1026          		{
   1027          			UARTx->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
   \                     ??UART_TxCmd_3:
   \   0000003E   0xF890 0x2030      LDRB     R2,[R0, #+48]
   \   00000042   0x2300             MOVS     R3,#+0
   \   00000044   0xF880 0x3030      STRB     R3,[R0, #+48]
   1028          		}
   1029          	}
   1030          }
   \                     ??UART_TxCmd_2:
   \   00000048   0x4770             BX       LR               ;; return
   1031          
   1032          /* UART IrDA functions ---------------------------------------------------*/
   1033          /*********************************************************************//**
   1034           * @brief		Enable or disable inverting serial input function of IrDA
   1035           * 				on UART peripheral.
   1036           * @param[in]	UARTx UART peripheral selected, should be LPC_UART3 (only)
   1037           * @param[in]	NewState New state of inverting serial input, should be:
   1038           * 				- ENABLE: Enable this function.
   1039           * 				- DISABLE: Disable this function.
   1040           * @return none
   1041           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1042          void UART_IrDAInvtInputCmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState)
   1043          {
   1044          	if (NewState == ENABLE)
   \                     UART_IrDAInvtInputCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD106             BNE.N    ??UART_IrDAInvtInputCmd_0
   1045          	{
   1046          		UARTx->ICR |= UART_ICR_IRDAINV;
   \   00000006   0xF890 0x2024      LDRB     R2,[R0, #+36]
   \   0000000A   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000000E   0xF880 0x2024      STRB     R2,[R0, #+36]
   \   00000012   0xE008             B.N      ??UART_IrDAInvtInputCmd_1
   1047          	}
   1048          	else if (NewState == DISABLE)
   \                     ??UART_IrDAInvtInputCmd_0:
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD105             BNE.N    ??UART_IrDAInvtInputCmd_1
   1049          	{
   1050          		UARTx->ICR &= (~UART_ICR_IRDAINV) & UART_ICR_BITMASK;
   \   0000001A   0xF890 0x2024      LDRB     R2,[R0, #+36]
   \   0000001E   0xF012 0x023D      ANDS     R2,R2,#0x3D
   \   00000022   0xF880 0x2024      STRB     R2,[R0, #+36]
   1051          	}
   1052          }
   \                     ??UART_IrDAInvtInputCmd_1:
   \   00000026   0x4770             BX       LR               ;; return
   1053          
   1054          
   1055          /*********************************************************************//**
   1056           * @brief		Enable or disable IrDA function on UART peripheral.
   1057           * @param[in]	UARTx UART peripheral selected, should be LPC_UART3 (only)
   1058           * @param[in]	NewState New state of IrDA function, should be:
   1059           * 				- ENABLE: Enable this function.
   1060           * 				- DISABLE: Disable this function.
   1061           * @return none
   1062           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1063          void UART_IrDACmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState)
   1064          {
   1065          	if (NewState == ENABLE)
   \                     UART_IrDACmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD106             BNE.N    ??UART_IrDACmd_0
   1066          	{
   1067          		UARTx->ICR |= UART_ICR_IRDAEN;
   \   00000006   0xF890 0x2024      LDRB     R2,[R0, #+36]
   \   0000000A   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000000E   0xF880 0x2024      STRB     R2,[R0, #+36]
   \   00000012   0xE005             B.N      ??UART_IrDACmd_1
   1068          	}
   1069          	else
   1070          	{
   1071          		UARTx->ICR &= (~UART_ICR_IRDAEN) & UART_ICR_BITMASK;
   \                     ??UART_IrDACmd_0:
   \   00000014   0xF890 0x2024      LDRB     R2,[R0, #+36]
   \   00000018   0xF012 0x023E      ANDS     R2,R2,#0x3E
   \   0000001C   0xF880 0x2024      STRB     R2,[R0, #+36]
   1072          	}
   1073          }
   \                     ??UART_IrDACmd_1:
   \   00000020   0x4770             BX       LR               ;; return
   1074          
   1075          
   1076          /*********************************************************************//**
   1077           * @brief		Configure Pulse divider for IrDA function on UART peripheral.
   1078           * @param[in]	UARTx UART peripheral selected, should be LPC_UART3 (only)
   1079           * @param[in]	PulseDiv Pulse Divider value from Peripheral clock,
   1080           * 				should be one of the following:
   1081          				- UART_IrDA_PULSEDIV2 	: Pulse width = 2 * Tpclk
   1082          				- UART_IrDA_PULSEDIV4 	: Pulse width = 4 * Tpclk
   1083          				- UART_IrDA_PULSEDIV8 	: Pulse width = 8 * Tpclk
   1084          				- UART_IrDA_PULSEDIV16 	: Pulse width = 16 * Tpclk
   1085          				- UART_IrDA_PULSEDIV32 	: Pulse width = 32 * Tpclk
   1086          				- UART_IrDA_PULSEDIV64 	: Pulse width = 64 * Tpclk
   1087          				- UART_IrDA_PULSEDIV128 : Pulse width = 128 * Tpclk
   1088          				- UART_IrDA_PULSEDIV256 : Pulse width = 256 * Tpclk
   1089          
   1090           * @return none
   1091           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1092          void UART_IrDAPulseDivConfig(LPC_UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv)
   1093          {
   \                     UART_IrDAPulseDivConfig:
   \   00000000   0xB410             PUSH     {R4}
   1094          	uint32_t tmp, tmp1;
   1095          
   1096          	tmp1 = UART_ICR_PULSEDIV(PulseDiv);
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0xF011 0x0407      ANDS     R4,R1,#0x7
   \   00000008   0x00E4             LSLS     R4,R4,#+3
   \   0000000A   0x0023             MOVS     R3,R4
   1097          
   1098          	tmp = UARTx->ICR & (~ UART_ICR_PULSEDIV(7));
   \   0000000C   0xF890 0x4024      LDRB     R4,[R0, #+36]
   \   00000010   0xF034 0x0438      BICS     R4,R4,#0x38
   \   00000014   0x0022             MOVS     R2,R4
   1099          
   1100          	tmp |= tmp1 | UART_ICR_FIXPULSE_EN;
   \   00000016   0xF053 0x0404      ORRS     R4,R3,#0x4
   \   0000001A   0x4322             ORRS     R2,R4,R2
   1101          
   1102          	UARTx->ICR = tmp & UART_ICR_BITMASK;
   \   0000001C   0xF012 0x043F      ANDS     R4,R2,#0x3F
   \   00000020   0xF880 0x4024      STRB     R4,[R0, #+36]
   1103          }
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return
   1104          
   1105          /* UART1 FullModem function ---------------------------------------------*/
   1106          
   1107          /*********************************************************************//**
   1108           * @brief		Force pin DTR/RTS corresponding to given state (Full modem mode)
   1109           * @param[in]	UARTx	LPC_UART1 (only)
   1110           * @param[in]	Pin	Pin that NewState will be applied to, should be:
   1111           * 				- UART1_MODEM_PIN_DTR: DTR pin.
   1112           * 				- UART1_MODEM_PIN_RTS: RTS pin.
   1113           * @param[in]	NewState New State of DTR/RTS pin, should be:
   1114           * 				- INACTIVE: Force the pin to inactive signal.
   1115          				- ACTIVE: Force the pin to active signal.
   1116           * @return none
   1117           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1118          void UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx,
   1119          													UART_MODEM_PIN_Type Pin,
   1120          													UART1_SignalState NewState)
   1121          {
   \                     UART_FullModemForcePinState:
   \   00000000   0xB430             PUSH     {R4,R5}
   1122          	uint8_t tmp = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   1123          
   1124          	switch (Pin)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD002             BEQ.N    ??UART_FullModemForcePinState_0
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD003             BEQ.N    ??UART_FullModemForcePinState_1
   \   0000000E   0xE005             B.N      ??UART_FullModemForcePinState_2
   1125          	{
   1126          		case UART1_MODEM_PIN_DTR:
   1127          			tmp = UART1_MCR_DTR_CTRL;
   \                     ??UART_FullModemForcePinState_0:
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0x0023             MOVS     R3,R4
   1128          			break;
   \   00000014   0xE002             B.N      ??UART_FullModemForcePinState_3
   1129          
   1130          		case UART1_MODEM_PIN_RTS:
   1131          			tmp = UART1_MCR_RTS_CTRL;
   \                     ??UART_FullModemForcePinState_1:
   \   00000016   0x2402             MOVS     R4,#+2
   \   00000018   0x0023             MOVS     R3,R4
   1132          			break;
   \   0000001A   0xE7FF             B.N      ??UART_FullModemForcePinState_3
   1133          
   1134          		default:
   1135          			break;
   1136          	}
   1137          
   1138          	if (NewState == ACTIVE)
   \                     ??UART_FullModemForcePinState_2:
   \                     ??UART_FullModemForcePinState_3:
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0x2A01             CMP      R2,#+1
   \   00000020   0xD103             BNE.N    ??UART_FullModemForcePinState_4
   1139          	{
   1140          		UARTx->MCR |= tmp;
   \   00000022   0x7C04             LDRB     R4,[R0, #+16]
   \   00000024   0x431C             ORRS     R4,R3,R4
   \   00000026   0x7404             STRB     R4,[R0, #+16]
   \   00000028   0xE005             B.N      ??UART_FullModemForcePinState_5
   1141          	}
   1142          	else
   1143          	{
   1144          		UARTx->MCR &= (~tmp) & UART1_MCR_BITMASK;
   \                     ??UART_FullModemForcePinState_4:
   \   0000002A   0x7C04             LDRB     R4,[R0, #+16]
   \   0000002C   0x43DD             MVNS     R5,R3
   \   0000002E   0xF015 0x05F3      ANDS     R5,R5,#0xF3
   \   00000032   0x402C             ANDS     R4,R5,R4
   \   00000034   0x7404             STRB     R4,[R0, #+16]
   1145          	}
   1146          }
   \                     ??UART_FullModemForcePinState_5:
   \   00000036   0xBC30             POP      {R4,R5}
   \   00000038   0x4770             BX       LR               ;; return
   1147          
   1148          
   1149          /*********************************************************************//**
   1150           * @brief		Configure Full Modem mode for UART peripheral
   1151           * @param[in]	UARTx	LPC_UART1 (only)
   1152           * @param[in]	Mode Full Modem mode, should be:
   1153           * 				- UART1_MODEM_MODE_LOOPBACK: Loop back mode.
   1154           * 				- UART1_MODEM_MODE_AUTO_RTS: Auto-RTS mode.
   1155           * 				- UART1_MODEM_MODE_AUTO_CTS: Auto-CTS mode.
   1156           * @param[in]	NewState New State of this mode, should be:
   1157           * 				- ENABLE: Enable this mode.
   1158          				- DISABLE: Disable this mode.
   1159           * @return none
   1160           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1161          void UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode,
   1162          											FunctionalState NewState)
   1163          {
   \                     UART_FullModemConfigMode:
   \   00000000   0xB430             PUSH     {R4,R5}
   1164          	uint8_t tmp;
   1165          
   1166          	switch(Mode)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD003             BEQ.N    ??UART_FullModemConfigMode_0
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xD007             BEQ.N    ??UART_FullModemConfigMode_1
   \   0000000C   0xD303             BCC.N    ??UART_FullModemConfigMode_2
   \   0000000E   0xE008             B.N      ??UART_FullModemConfigMode_3
   1167          	{
   1168          		case UART1_MODEM_MODE_LOOPBACK:
   1169          			tmp = UART1_MCR_LOOPB_EN;
   \                     ??UART_FullModemConfigMode_0:
   \   00000010   0x2410             MOVS     R4,#+16
   \   00000012   0x0023             MOVS     R3,R4
   1170          			break;
   \   00000014   0xE005             B.N      ??UART_FullModemConfigMode_4
   1171          
   1172          		case UART1_MODEM_MODE_AUTO_RTS:
   1173          			tmp = UART1_MCR_AUTO_RTS_EN;
   \                     ??UART_FullModemConfigMode_2:
   \   00000016   0x2440             MOVS     R4,#+64
   \   00000018   0x0023             MOVS     R3,R4
   1174          			break;
   \   0000001A   0xE002             B.N      ??UART_FullModemConfigMode_4
   1175          
   1176          		case UART1_MODEM_MODE_AUTO_CTS:
   1177          			tmp = UART1_MCR_AUTO_CTS_EN;
   \                     ??UART_FullModemConfigMode_1:
   \   0000001C   0x2480             MOVS     R4,#+128
   \   0000001E   0x0023             MOVS     R3,R4
   1178          			break;
   \   00000020   0xE7FF             B.N      ??UART_FullModemConfigMode_4
   1179          
   1180          		default:
   1181          			break;
   1182          	}
   1183          
   1184          	if (NewState == ENABLE)
   \                     ??UART_FullModemConfigMode_3:
   \                     ??UART_FullModemConfigMode_4:
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x2A01             CMP      R2,#+1
   \   00000026   0xD103             BNE.N    ??UART_FullModemConfigMode_5
   1185          	{
   1186          		UARTx->MCR |= tmp;
   \   00000028   0x7C04             LDRB     R4,[R0, #+16]
   \   0000002A   0x431C             ORRS     R4,R3,R4
   \   0000002C   0x7404             STRB     R4,[R0, #+16]
   \   0000002E   0xE005             B.N      ??UART_FullModemConfigMode_6
   1187          	}
   1188          	else
   1189          	{
   1190          		UARTx->MCR &= (~tmp) & UART1_MCR_BITMASK;
   \                     ??UART_FullModemConfigMode_5:
   \   00000030   0x7C04             LDRB     R4,[R0, #+16]
   \   00000032   0x43DD             MVNS     R5,R3
   \   00000034   0xF015 0x05F3      ANDS     R5,R5,#0xF3
   \   00000038   0x402C             ANDS     R4,R5,R4
   \   0000003A   0x7404             STRB     R4,[R0, #+16]
   1191          	}
   1192          }
   \                     ??UART_FullModemConfigMode_6:
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0x4770             BX       LR               ;; return
   1193          
   1194          
   1195          /*********************************************************************//**
   1196           * @brief		Get current status of modem status register
   1197           * @param[in]	UARTx	LPC_UART1 (only)
   1198           * @return 		Current value of modem status register
   1199           * Note:	The return value of this function must be ANDed with each member
   1200           * 			UART_MODEM_STAT_type enumeration to determine current flag status
   1201           * 			corresponding to each modem flag status. Because some flags in
   1202           * 			modem status register will be cleared after reading, the next reading
   1203           * 			modem register could not be correct. So this function used to
   1204           * 			read modem status register in one time only, then the return value
   1205           * 			used to check all flags.
   1206           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1207          uint8_t UART_FullModemGetStatus(LPC_UART1_TypeDef *UARTx)
   1208          {
   1209          	return ((UARTx->MSR) & UART1_MSR_BITMASK);
   \                     UART_FullModemGetStatus:
   \   00000000   0x7E00             LDRB     R0,[R0, #+24]
   \   00000002   0x4770             BX       LR               ;; return
   1210          }
   1211          
   1212          
   1213          /* UART RS485 functions --------------------------------------------------------------*/
   1214          
   1215          /*********************************************************************//**
   1216           * @brief		Configure UART peripheral in RS485 mode according to the specified
   1217          *               parameters in the RS485ConfigStruct.
   1218           * @param[in]	UARTx	LPC_UART1 (only)
   1219           * @param[in]	RS485ConfigStruct Pointer to a UART1_RS485_CTRLCFG_Type structure
   1220          *                    that contains the configuration information for specified UART
   1221          *                    in RS485 mode.
   1222           * @return		None
   1223           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1224          void UART_RS485Config(LPC_UART_TypeDef *UARTx, UART1_RS485_CTRLCFG_Type *RS485ConfigStruct)
   1225          {
   1226          	uint32_t tmp;
   1227          
   1228          	tmp = 0;
   \                     UART_RS485Config:
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0x001A             MOVS     R2,R3
   1229          
   1230          	// If Auto Direction Control is enabled -  This function is used in Master mode
   1231          	if (RS485ConfigStruct->AutoDirCtrl_State == ENABLE)
   \   00000004   0x78CB             LDRB     R3,[R1, #+3]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD112             BNE.N    ??UART_RS485Config_0
   1232          	{
   1233          		tmp |= UART1_RS485CTRL_DCTRL_EN;
   \   0000000A   0xF052 0x0210      ORRS     R2,R2,#0x10
   1234          
   1235          		// Set polar
   1236          		if (RS485ConfigStruct->DirCtrlPol_Level == SET)
   \   0000000E   0x794B             LDRB     R3,[R1, #+5]
   \   00000010   0x2B01             CMP      R3,#+1
   \   00000012   0xD101             BNE.N    ??UART_RS485Config_1
   1237          		{
   1238          			tmp |= UART1_RS485CTRL_OINV_1;
   \   00000014   0xF052 0x0220      ORRS     R2,R2,#0x20
   1239          		}
   1240          
   1241          		// Set pin according to. This condition is only with UART1. The others are used
   1242          		// OE pin as default for control the direction of RS485 buffer IC
   1243          		if ((RS485ConfigStruct->DirCtrlPin == UART1_RS485_DIRCTRL_DTR)
   1244          								&& ((LPC_UART1_TypeDef *)UARTx == LPC_UART1))
   \                     ??UART_RS485Config_1:
   \   00000018   0x790B             LDRB     R3,[R1, #+4]
   \   0000001A   0x2B01             CMP      R3,#+1
   \   0000001C   0xD105             BNE.N    ??UART_RS485Config_2
   \   0000001E   0x.... 0x....      LDR.W    R3,??DataTable16  ;; 0x40010000
   \   00000022   0x4298             CMP      R0,R3
   \   00000024   0xD101             BNE.N    ??UART_RS485Config_2
   1245          		{
   1246          			tmp |= UART1_RS485CTRL_SEL_DTR;
   \   00000026   0xF052 0x0208      ORRS     R2,R2,#0x8
   1247          		}
   1248          
   1249          		// Fill delay time
   1250          		UARTx->RS485DLY = RS485ConfigStruct->DelayValue & UART1_RS485DLY_BITMASK;
   \                     ??UART_RS485Config_2:
   \   0000002A   0x79CB             LDRB     R3,[R1, #+7]
   \   0000002C   0xF880 0x3054      STRB     R3,[R0, #+84]
   1251          	}
   1252          
   1253          	// MultiDrop mode is enable
   1254          	if (RS485ConfigStruct->NormalMultiDropMode_State == ENABLE)
   \                     ??UART_RS485Config_0:
   \   00000030   0x780B             LDRB     R3,[R1, #+0]
   \   00000032   0x2B01             CMP      R3,#+1
   \   00000034   0xD101             BNE.N    ??UART_RS485Config_3
   1255          	{
   1256          		tmp |= UART1_RS485CTRL_NMM_EN;
   \   00000036   0xF052 0x0201      ORRS     R2,R2,#0x1
   1257          	}
   1258          
   1259          	// Auto Address Detect function
   1260          	if (RS485ConfigStruct->AutoAddrDetect_State == ENABLE)
   \                     ??UART_RS485Config_3:
   \   0000003A   0x788B             LDRB     R3,[R1, #+2]
   \   0000003C   0x2B01             CMP      R3,#+1
   \   0000003E   0xD104             BNE.N    ??UART_RS485Config_4
   1261          	{
   1262          		tmp |= UART1_RS485CTRL_AADEN;
   \   00000040   0xF052 0x0204      ORRS     R2,R2,#0x4
   1263          
   1264          		// Fill Match Address
   1265          		UARTx->ADRMATCH = RS485ConfigStruct->MatchAddrValue & UART1_RS485ADRMATCH_BITMASK;
   \   00000044   0x798B             LDRB     R3,[R1, #+6]
   \   00000046   0xF880 0x3050      STRB     R3,[R0, #+80]
   1266          	}
   1267          
   1268          	// Receiver is disable
   1269          	if (RS485ConfigStruct->Rx_State == DISABLE)
   \                     ??UART_RS485Config_4:
   \   0000004A   0x784B             LDRB     R3,[R1, #+1]
   \   0000004C   0x2B00             CMP      R3,#+0
   \   0000004E   0xD101             BNE.N    ??UART_RS485Config_5
   1270          	{
   1271          		tmp |= UART1_RS485CTRL_RX_DIS;
   \   00000050   0xF052 0x0202      ORRS     R2,R2,#0x2
   1272          	}
   1273          
   1274          	// write back to RS485 control register
   1275          	UARTx->RS485CTRL = tmp & UART1_RS485CTRL_BITMASK;
   \                     ??UART_RS485Config_5:
   \   00000054   0xF012 0x033F      ANDS     R3,R2,#0x3F
   \   00000058   0xF880 0x304C      STRB     R3,[R0, #+76]
   1276          
   1277          	// Enable Parity function and leave parity in stick '0' parity as default
   1278          	UARTx->LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
   \   0000005C   0x7B03             LDRB     R3,[R0, #+12]
   \   0000005E   0xF053 0x0338      ORRS     R3,R3,#0x38
   \   00000062   0x7303             STRB     R3,[R0, #+12]
   1279          }
   \   00000064   0x4770             BX       LR               ;; return
   1280          
   1281          /*********************************************************************//**
   1282           * @brief		Enable/Disable receiver in RS485 module in UART1
   1283           * @param[in]	UARTx	LPC_UART1 (only)
   1284           * @param[in]	NewState	New State of command, should be:
   1285           * 							- ENABLE: Enable this function.
   1286           * 							- DISABLE: Disable this function.
   1287           * @return		None
   1288           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1289          void UART_RS485ReceiverCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState)
   1290          {
   1291          	if (NewState == ENABLE)
   \                     UART_RS485ReceiverCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD106             BNE.N    ??UART_RS485ReceiverCmd_0
   1292          	{
   1293          		UARTx->RS485CTRL &= ~UART1_RS485CTRL_RX_DIS;
   \   00000006   0xF890 0x204C      LDRB     R2,[R0, #+76]
   \   0000000A   0xF012 0x02FD      ANDS     R2,R2,#0xFD
   \   0000000E   0xF880 0x204C      STRB     R2,[R0, #+76]
   \   00000012   0xE005             B.N      ??UART_RS485ReceiverCmd_1
   1294          	}
   1295          	else
   1296          	{
   1297          		UARTx->RS485CTRL |= UART1_RS485CTRL_RX_DIS;
   \                     ??UART_RS485ReceiverCmd_0:
   \   00000014   0xF890 0x204C      LDRB     R2,[R0, #+76]
   \   00000018   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000001C   0xF880 0x204C      STRB     R2,[R0, #+76]
   1298          	}
   1299          }
   \                     ??UART_RS485ReceiverCmd_1:
   \   00000020   0x4770             BX       LR               ;; return
   1300          
   1301          /*********************************************************************//**
   1302           * @brief		Send data on RS485 bus with specified parity stick value (9-bit mode).
   1303           * @param[in]	UARTx	LPC_UART1 (only)
   1304           * @param[in]	pDatFrm 	Pointer to data frame.
   1305           * @param[in]	size		Size of data.
   1306           * @param[in]	ParityStick	Parity Stick value, should be 0 or 1.
   1307           * @return		None
   1308           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1309          uint32_t UART_RS485Send(LPC_UART_TypeDef *UARTx, uint8_t *pDatFrm,
   1310          											uint32_t size, uint8_t ParityStick)
   1311          {
   \                     UART_RS485Send:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1312          	uint8_t tmp, save;
   1313          	uint32_t cnt;
   1314          
   1315          	if (ParityStick)
   \   0000000C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000000E   0x2F00             CMP      R7,#+0
   \   00000010   0xD013             BEQ.N    ??UART_RS485Send_0
   1316          	{
   1317          		save = tmp = UARTx->LCR & UART_LCR_BITMASK;
   \   00000012   0x7B20             LDRB     R0,[R4, #+12]
   \   00000014   0x4682             MOV      R10,R0
   \   00000016   0x4680             MOV      R8,R0
   1318          
   1319          		tmp &= ~(UART_LCR_PARITY_EVEN);
   \   00000018   0xF01A 0x0AEF      ANDS     R10,R10,#0xEF
   1320          
   1321          		UARTx->LCR = tmp;
   \   0000001C   0xF884 0xA00C      STRB     R10,[R4, #+12]
   1322          
   1323          		cnt = UART_Send((LPC_UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
   \   00000020   0x2301             MOVS     R3,#+1
   \   00000022   0x0032             MOVS     R2,R6
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       UART_Send
   \   0000002C   0x4681             MOV      R9,R0
   1324          
   1325          		while (!(UARTx->LSR & UART_LSR_TEMT));
   \                     ??UART_RS485Send_1:
   \   0000002E   0x7D20             LDRB     R0,[R4, #+20]
   \   00000030   0x0640             LSLS     R0,R0,#+25
   \   00000032   0xD5FC             BPL.N    ??UART_RS485Send_1
   1326          
   1327          		UARTx->LCR = save;
   \   00000034   0xF884 0x800C      STRB     R8,[R4, #+12]
   \   00000038   0xE009             B.N      ??UART_RS485Send_2
   1328          	}
   1329          	else
   1330          	{
   1331          		cnt = UART_Send((LPC_UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
   \                     ??UART_RS485Send_0:
   \   0000003A   0x2301             MOVS     R3,#+1
   \   0000003C   0x0032             MOVS     R2,R6
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       UART_Send
   \   00000046   0x4681             MOV      R9,R0
   1332          
   1333          		while (!(UARTx->LSR & UART_LSR_TEMT));
   \                     ??UART_RS485Send_3:
   \   00000048   0x7D20             LDRB     R0,[R4, #+20]
   \   0000004A   0x0640             LSLS     R0,R0,#+25
   \   0000004C   0xD5FC             BPL.N    ??UART_RS485Send_3
   1334          	}
   1335          
   1336          	return cnt;
   \                     ??UART_RS485Send_2:
   \   0000004E   0x4648             MOV      R0,R9
   \   00000050   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1337          }
   1338          
   1339          /*********************************************************************//**
   1340           * @brief		Send Slave address frames on RS485 bus.
   1341           * @param[in]	UARTx	LPC_UART1 (only)
   1342           * @param[in]	SlvAddr Slave Address.
   1343           * @return		None
   1344           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1345          void UART_RS485SendSlvAddr(LPC_UART_TypeDef *UARTx, uint8_t SlvAddr)
   1346          {
   \                     UART_RS485SendSlvAddr:
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1347          	UART_RS485Send(UARTx, &SlvAddr, 1, 1);
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA901             ADD      R1,SP,#+4
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       UART_RS485Send
   1348          }
   \   00000010   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1349          
   1350          /*********************************************************************//**
   1351           * @brief		Send Data frames on RS485 bus.
   1352           * @param[in]	UARTx	LPC_UART1 (only)
   1353           * @param[in]	pData Pointer to data to be sent.
   1354           * @param[in]	size Size of data frame to be sent.
   1355           * @return		None
   1356           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1357          uint32_t UART_RS485SendData(LPC_UART_TypeDef *UARTx, uint8_t *pData, uint32_t size)
   1358          {
   \                     UART_RS485SendData:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1359          	return (UART_RS485Send(UARTx, pData, size, 0));
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       UART_RS485Send
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
   1360          }
   1361          
   1362          /**
   1363           * @}
   1364           */
   1365          
   1366          /**
   1367           * @}
   1368           */
   1369          /* --------------------------------- End Of File ------------------------------ */
   1370          /******************************2011-10-31 XULIANG*********************/
   1371          /********************************************************************//**
   1372           * @brief		Initializes the UARTx peripheral according to the specified
   1373           *               parameters in the UART_ConfigStruct.
   1374           * @param[in]	UARTx	UART peripheral selected, should be:
   1375           *   			- LPC_UART0: UART0 peripheral
   1376           * 				- LPC_UART1: UART1 peripheral
   1377           * 				- LPC_UART2: UART2 peripheral
   1378           * 				- LPC_UART3: UART3 peripheral
   1379           *				- LPC_UART4: UART4 peripheral
   1380           * @param[in]	UART_ConfigStruct Pointer to a UART_CFG_Type structure
   1381          *                    that contains the configuration information for the
   1382          *                    specified UART peripheral.
   1383           * @return 		None
   1384           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1385          void UART4_Init(LPC_UART4_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct)
   1386          {
   \                     UART4_Init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1387          	uint32_t tmp;
   1388          
   1389          	if(UARTx == LPC_UART4)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x400a4000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD104             BNE.N    ??UART4_Init_0
   1390          	{
   1391          		/* Set up clock and power for UART module */
   1392          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART4, ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF44F 0x7080      MOV      R0,#+256
   \   00000014   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   1393          	}
   1394          
   1395          	/* FIFOs are empty */
   1396          	UARTx->FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
   \                     ??UART4_Init_0:
   \   00000018   0x2007             MOVS     R0,#+7
   \   0000001A   0x60A0             STR      R0,[R4, #+8]
   1397          
   1398          	// Disable FIFO
   1399          	UARTx->FCR = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x60A0             STR      R0,[R4, #+8]
   1400          
   1401          	// Dummy reading
   1402          	while (UARTx->LSR & UART_LSR_RDR)
   \                     ??UART4_Init_1:
   \   00000020   0x6960             LDR      R0,[R4, #+20]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD502             BPL.N    ??UART4_Init_2
   1403          	{
   1404          		tmp = UARTx->RBR;
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0xE7F9             B.N      ??UART4_Init_1
   1405          	}
   1406          
   1407          	UARTx->TER = UART_TER_TXEN;
   \                     ??UART4_Init_2:
   \   0000002C   0x2080             MOVS     R0,#+128
   \   0000002E   0x65E0             STR      R0,[R4, #+92]
   1408          
   1409          	// Wait for current transmit complete
   1410          	while (!(UARTx->LSR & UART_LSR_THRE));
   \                     ??UART4_Init_3:
   \   00000030   0x6960             LDR      R0,[R4, #+20]
   \   00000032   0x0680             LSLS     R0,R0,#+26
   \   00000034   0xD5FC             BPL.N    ??UART4_Init_3
   1411          
   1412          	// Disable Tx
   1413          	UARTx->TER = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x65E0             STR      R0,[R4, #+92]
   1414          
   1415          	// Disable interrupt
   1416          	UARTx->IER = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6060             STR      R0,[R4, #+4]
   1417          
   1418          	// Set LCR to default state
   1419          	UARTx->LCR = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x60E0             STR      R0,[R4, #+12]
   1420          
   1421          	// Set ACR to default state
   1422          	UARTx->ACR = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6220             STR      R0,[R4, #+32]
   1423          
   1424          	// Set RS485 control to default state
   1425          	UARTx->RS485CTRL = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x64E0             STR      R0,[R4, #+76]
   1426          
   1427          	// Set RS485 delay timer to default state
   1428          	UARTx->RS485DLY = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6560             STR      R0,[R4, #+84]
   1429          
   1430          	// Set RS485 addr match to default state
   1431          	UARTx->ADRMATCH = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x6520             STR      R0,[R4, #+80]
   1432          
   1433          	// Dummy reading
   1434          	tmp = UARTx->LSR;
   \   00000052   0x6960             LDR      R0,[R4, #+20]
   \   00000054   0x0006             MOVS     R6,R0
   1435          
   1436          	if(((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000056   0x....             LDR.N    R0,??DataTable16  ;; 0x40010000
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD104             BNE.N    ??UART4_Init_4
   1437          	{
   1438          		// Set Modem Control to default state
   1439          		((LPC_UART1_TypeDef *)UARTx)->MCR = 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x7420             STRB     R0,[R4, #+16]
   1440          
   1441          		//Dummy Reading to Clear Status
   1442          		tmp = ((LPC_UART1_TypeDef *)UARTx)->MSR;
   \   00000060   0x7E20             LDRB     R0,[R4, #+24]
   \   00000062   0x0006             MOVS     R6,R0
   \   00000064   0xE001             B.N      ??UART4_Init_5
   1443          	}
   1444          	else
   1445          	{
   1446          		// Set IrDA to default state for all UART other than UART1
   1447          		UARTx->ICR = 0;
   \                     ??UART4_Init_4:
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x6260             STR      R0,[R4, #+36]
   1448          	}
   1449          
   1450          	// Set Line Control register ----------------------------
   1451          
   1452          	uart4_set_divisors(UARTx, (UART_ConfigStruct->Baud_rate));
   \                     ??UART4_Init_5:
   \   0000006A   0x6829             LDR      R1,[R5, #+0]
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       uart4_set_divisors
   1453          
   1454          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000072   0x....             LDR.N    R0,??DataTable16  ;; 0x40010000
   \   00000074   0x4284             CMP      R4,R0
   \   00000076   0xD104             BNE.N    ??UART4_Init_6
   1455          	{
   1456          		tmp = (((LPC_UART1_TypeDef *)UARTx)->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
   1457          													& UART_LCR_BITMASK;
   \   00000078   0x7B20             LDRB     R0,[R4, #+12]
   \   0000007A   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   0000007E   0x0006             MOVS     R6,R0
   \   00000080   0xE003             B.N      ??UART4_Init_7
   1458          	}
   1459          	else
   1460          	{
   1461          		tmp = (UARTx->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) & UART_LCR_BITMASK;
   \                     ??UART4_Init_6:
   \   00000082   0x68E0             LDR      R0,[R4, #+12]
   \   00000084   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   00000088   0x0006             MOVS     R6,R0
   1462          	}
   1463          
   1464          	switch (UART_ConfigStruct->Databits)
   \                     ??UART4_Init_7:
   \   0000008A   0x7968             LDRB     R0,[R5, #+5]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD003             BEQ.N    ??UART4_Init_8
   \   00000090   0x2802             CMP      R0,#+2
   \   00000092   0xD005             BEQ.N    ??UART4_Init_9
   \   00000094   0xD301             BCC.N    ??UART4_Init_10
   \   00000096   0xE006             B.N      ??UART4_Init_11
   1465          	{
   1466          		case UART_DATABIT_5:
   1467          			tmp |= UART_LCR_WLEN5;
   1468          			break;
   \                     ??UART4_Init_8:
   \   00000098   0xE007             B.N      ??UART4_Init_12
   1469          
   1470          		case UART_DATABIT_6:
   1471          			tmp |= UART_LCR_WLEN6;
   \                     ??UART4_Init_10:
   \   0000009A   0xF056 0x0601      ORRS     R6,R6,#0x1
   1472          			break;
   \   0000009E   0xE004             B.N      ??UART4_Init_12
   1473          
   1474          		case UART_DATABIT_7:
   1475          			tmp |= UART_LCR_WLEN7;
   \                     ??UART4_Init_9:
   \   000000A0   0xF056 0x0602      ORRS     R6,R6,#0x2
   1476          			break;
   \   000000A4   0xE001             B.N      ??UART4_Init_12
   1477          
   1478          		case UART_DATABIT_8:
   1479          
   1480          		default:
   1481          			tmp |= UART_LCR_WLEN8;
   \                     ??UART4_Init_11:
   \   000000A6   0xF056 0x0603      ORRS     R6,R6,#0x3
   1482          			break;
   1483          	}
   1484          
   1485          	if (UART_ConfigStruct->Parity == UART_PARITY_NONE)
   \                     ??UART4_Init_12:
   \   000000AA   0x7928             LDRB     R0,[R5, #+4]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD015             BEQ.N    ??UART4_Init_13
   1486          	{
   1487          		// Do nothing...
   1488          	}
   1489          	else
   1490          	{
   1491          		tmp |= UART_LCR_PARITY_EN;
   \   000000B0   0xF056 0x0608      ORRS     R6,R6,#0x8
   1492          		switch (UART_ConfigStruct->Parity)
   \   000000B4   0x7928             LDRB     R0,[R5, #+4]
   \   000000B6   0x2801             CMP      R0,#+1
   \   000000B8   0xD006             BEQ.N    ??UART4_Init_14
   \   000000BA   0xD30F             BCC.N    ??UART4_Init_15
   \   000000BC   0x2803             CMP      R0,#+3
   \   000000BE   0xD007             BEQ.N    ??UART4_Init_16
   \   000000C0   0xD303             BCC.N    ??UART4_Init_17
   \   000000C2   0x2804             CMP      R0,#+4
   \   000000C4   0xD007             BEQ.N    ??UART4_Init_18
   \   000000C6   0xE009             B.N      ??UART4_Init_15
   1493          		{
   1494          			case UART_PARITY_ODD:
   1495          				tmp |= UART_LCR_PARITY_ODD;
   1496          				break;
   \                     ??UART4_Init_14:
   \   000000C8   0xE008             B.N      ??UART4_Init_13
   1497          
   1498          			case UART_PARITY_EVEN:
   1499          				tmp |= UART_LCR_PARITY_EVEN;
   \                     ??UART4_Init_17:
   \   000000CA   0xF056 0x0610      ORRS     R6,R6,#0x10
   1500          				break;
   \   000000CE   0xE005             B.N      ??UART4_Init_13
   1501          
   1502          			case UART_PARITY_SP_1:
   1503          				tmp |= UART_LCR_PARITY_F_1;
   \                     ??UART4_Init_16:
   \   000000D0   0xF056 0x0620      ORRS     R6,R6,#0x20
   1504          				break;
   \   000000D4   0xE002             B.N      ??UART4_Init_13
   1505          
   1506          			case UART_PARITY_SP_0:
   1507          				tmp |= UART_LCR_PARITY_F_0;
   \                     ??UART4_Init_18:
   \   000000D6   0xF056 0x0630      ORRS     R6,R6,#0x30
   1508          				break;
   \   000000DA   0xE7FF             B.N      ??UART4_Init_13
   1509          
   1510          			default:
   1511          				break;
   1512          		}
   1513          	}
   1514          
   1515          	switch (UART_ConfigStruct->Stopbits)
   \                     ??UART4_Init_15:
   \                     ??UART4_Init_13:
   \   000000DC   0x79A8             LDRB     R0,[R5, #+6]
   \   000000DE   0x2801             CMP      R0,#+1
   \   000000E0   0xD102             BNE.N    ??UART4_Init_19
   1516          	{
   1517          		case UART_STOPBIT_2:
   1518          			tmp |= UART_LCR_STOPBIT_SEL;
   \   000000E2   0xF056 0x0604      ORRS     R6,R6,#0x4
   1519          			break;
   \   000000E6   0xE7FF             B.N      ??UART4_Init_20
   1520          
   1521          		case UART_STOPBIT_1:
   1522          
   1523          		default:
   1524          			// Do no thing
   1525          			break;
   1526          	}
   1527          
   1528          
   1529          	// Write back to LCR, configure FIFO and Disable Tx
   1530          	if (((LPC_UART1_TypeDef *)UARTx) ==  LPC_UART1)
   \                     ??UART4_Init_19:
   \                     ??UART4_Init_20:
   \   000000E8   0x....             LDR.N    R0,??DataTable16  ;; 0x40010000
   \   000000EA   0x4284             CMP      R4,R0
   \   000000EC   0xD101             BNE.N    ??UART4_Init_21
   1531          	{
   1532          		((LPC_UART1_TypeDef *)UARTx)->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
   \   000000EE   0x7326             STRB     R6,[R4, #+12]
   \   000000F0   0xE002             B.N      ??UART4_Init_22
   1533          	}
   1534          	else
   1535          	{
   1536          		UARTx->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
   \                     ??UART4_Init_21:
   \   000000F2   0x0030             MOVS     R0,R6
   \   000000F4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F6   0x60E0             STR      R0,[R4, #+12]
   1537          	}
   1538          }
   \                     ??UART4_Init_22:
   \   000000F8   0xBD70             POP      {R4-R6,PC}       ;; return
   1539          /********************************************************************//**
   1540           * @brief 		Enable or disable specified UART interrupt.
   1541           * @param[in]	UARTx	UART peripheral selected, should be
   1542           *  			- LPC_UART0: UART0 peripheral
   1543           * 				- LPC_UART1: UART1 peripheral
   1544           * 				- LPC_UART2: UART2 peripheral
   1545           * 				- LPC_UART3: UART3 peripheral
   1546           * @param[in]	UARTIntCfg	Specifies the interrupt flag,
   1547           * 				should be one of the following:
   1548          				- UART_INTCFG_RBR 	:  RBR Interrupt enable
   1549          				- UART_INTCFG_THRE 	:  THR Interrupt enable
   1550          				- UART_INTCFG_RLS 	:  RX line status interrupt enable
   1551          				- UART1_INTCFG_MS	:  Modem status interrupt enable (UART1 only)
   1552          				- UART1_INTCFG_CTS	:  CTS1 signal transition interrupt enable (UART1 only)
   1553          				- UART_INTCFG_ABEO 	:  Enables the end of auto-baud interrupt
   1554          				- UART_INTCFG_ABTO 	:  Enables the auto-baud time-out interrupt
   1555           * @param[in]	NewState New state of specified UART interrupt type,
   1556           * 				should be:
   1557           * 				- ENALBE: Enable this UART interrupt type.
   1558          * 				- DISALBE: Disable this UART interrupt type.
   1559           * @return 		None
   1560           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1561          void UART4_IntConfig(LPC_UART4_TypeDef *UARTx, UART_INT_Type UARTIntCfg, FunctionalState NewState)
   1562          {
   \                     UART4_IntConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
   1563          	uint32_t tmp;
   1564          
   1565          	switch(UARTIntCfg)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD009             BEQ.N    ??UART4_IntConfig_0
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xD00D             BEQ.N    ??UART4_IntConfig_1
   \   0000000C   0xD309             BCC.N    ??UART4_IntConfig_2
   \   0000000E   0x2904             CMP      R1,#+4
   \   00000010   0xD010             BEQ.N    ??UART4_IntConfig_3
   \   00000012   0xD30C             BCC.N    ??UART4_IntConfig_4
   \   00000014   0x2906             CMP      R1,#+6
   \   00000016   0xD014             BEQ.N    ??UART4_IntConfig_5
   \   00000018   0xD30F             BCC.N    ??UART4_IntConfig_6
   \   0000001A   0xE015             B.N      ??UART4_IntConfig_7
   1566          	{
   1567          		case UART_INTCFG_RBR:
   1568          			tmp = UART_IER_RBRINT_EN;
   \                     ??UART4_IntConfig_0:
   \   0000001C   0x2401             MOVS     R4,#+1
   \   0000001E   0x0023             MOVS     R3,R4
   1569          			break;
   \   00000020   0xE012             B.N      ??UART4_IntConfig_7
   1570          
   1571          		case UART_INTCFG_THRE:
   1572          			tmp = UART_IER_THREINT_EN;
   \                     ??UART4_IntConfig_2:
   \   00000022   0x2402             MOVS     R4,#+2
   \   00000024   0x0023             MOVS     R3,R4
   1573          			break;
   \   00000026   0xE00F             B.N      ??UART4_IntConfig_7
   1574          
   1575          		case UART_INTCFG_RLS:
   1576          			tmp = UART_IER_RLSINT_EN;
   \                     ??UART4_IntConfig_1:
   \   00000028   0x2404             MOVS     R4,#+4
   \   0000002A   0x0023             MOVS     R3,R4
   1577          			break;
   \   0000002C   0xE00C             B.N      ??UART4_IntConfig_7
   1578          
   1579          		case UART1_INTCFG_MS:
   1580          			tmp = UART1_IER_MSINT_EN;
   \                     ??UART4_IntConfig_4:
   \   0000002E   0x2408             MOVS     R4,#+8
   \   00000030   0x0023             MOVS     R3,R4
   1581          			break;
   \   00000032   0xE009             B.N      ??UART4_IntConfig_7
   1582          
   1583          		case UART1_INTCFG_CTS:
   1584          			tmp = UART1_IER_CTSINT_EN;
   \                     ??UART4_IntConfig_3:
   \   00000034   0x2480             MOVS     R4,#+128
   \   00000036   0x0023             MOVS     R3,R4
   1585          			break;
   \   00000038   0xE006             B.N      ??UART4_IntConfig_7
   1586          
   1587          		case UART_INTCFG_ABEO:
   1588          			tmp = UART_IER_ABEOINT_EN;
   \                     ??UART4_IntConfig_6:
   \   0000003A   0xF44F 0x7480      MOV      R4,#+256
   \   0000003E   0x0023             MOVS     R3,R4
   1589          			break;
   \   00000040   0xE002             B.N      ??UART4_IntConfig_7
   1590          
   1591          		case UART_INTCFG_ABTO:
   1592          			tmp = UART_IER_ABTOINT_EN;
   \                     ??UART4_IntConfig_5:
   \   00000042   0xF44F 0x7400      MOV      R4,#+512
   \   00000046   0x0023             MOVS     R3,R4
   1593          			break;
   1594          	}
   1595          
   1596          	if (NewState == ENABLE)
   \                     ??UART4_IntConfig_7:
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0x2A01             CMP      R2,#+1
   \   0000004C   0xD10A             BNE.N    ??UART4_IntConfig_8
   1597          	{
   1598          		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
   \   0000004E   0x....             LDR.N    R4,??DataTable16  ;; 0x40010000
   \   00000050   0x42A0             CMP      R0,R4
   \   00000052   0xD103             BNE.N    ??UART4_IntConfig_9
   1599          		{
   1600          			((LPC_UART1_TypeDef *)UARTx)->IER |= tmp;
   \   00000054   0x6844             LDR      R4,[R0, #+4]
   \   00000056   0x431C             ORRS     R4,R3,R4
   \   00000058   0x6044             STR      R4,[R0, #+4]
   \   0000005A   0xE013             B.N      ??UART4_IntConfig_10
   1601          		}
   1602          		else
   1603          		{
   1604          			UARTx->IER |= tmp;
   \                     ??UART4_IntConfig_9:
   \   0000005C   0x6844             LDR      R4,[R0, #+4]
   \   0000005E   0x431C             ORRS     R4,R3,R4
   \   00000060   0x6044             STR      R4,[R0, #+4]
   \   00000062   0xE00F             B.N      ??UART4_IntConfig_10
   1605          		}
   1606          	}
   1607          	else
   1608          	{
   1609          		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
   \                     ??UART4_IntConfig_8:
   \   00000064   0x....             LDR.N    R4,??DataTable16  ;; 0x40010000
   \   00000066   0x42A0             CMP      R0,R4
   \   00000068   0xD106             BNE.N    ??UART4_IntConfig_11
   1610          		{
   1611          			((LPC_UART1_TypeDef *)UARTx)->IER &= (~tmp) & UART1_IER_BITMASK;
   \   0000006A   0x6844             LDR      R4,[R0, #+4]
   \   0000006C   0xF240 0x358F      MOVW     R5,#+911
   \   00000070   0x439D             BICS     R5,R5,R3
   \   00000072   0x402C             ANDS     R4,R5,R4
   \   00000074   0x6044             STR      R4,[R0, #+4]
   \   00000076   0xE005             B.N      ??UART4_IntConfig_10
   1612          		}
   1613          		else
   1614          		{
   1615          			UARTx->IER &= (~tmp) & UART_IER_BITMASK;
   \                     ??UART4_IntConfig_11:
   \   00000078   0x6844             LDR      R4,[R0, #+4]
   \   0000007A   0xF240 0x3507      MOVW     R5,#+775
   \   0000007E   0x439D             BICS     R5,R5,R3
   \   00000080   0x402C             ANDS     R4,R5,R4
   \   00000082   0x6044             STR      R4,[R0, #+4]
   1616          		}
   1617          	}
   1618          }
   \                     ??UART4_IntConfig_10:
   \   00000084   0xBC30             POP      {R4,R5}
   \   00000086   0x4770             BX       LR               ;; return
   1619          /*********************************************************************//**
   1620           * @brief		Enable/Disable transmission on UART TxD pin
   1621           * @param[in]	UARTx	UART peripheral selected, should be:
   1622           *   			- LPC_UART0: UART0 peripheral
   1623           * 				- LPC_UART1: UART1 peripheral
   1624           * 				- LPC_UART2: UART2 peripheral
   1625           * 				- LPC_UART3: UART3 peripheral
   1626           * @param[in]	NewState New State of Tx transmission function, should be:
   1627           * 				- ENABLE: Enable this function
   1628          				- DISABLE: Disable this function
   1629           * @return none
   1630           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1631          void UART4_TxCmd(LPC_UART4_TypeDef *UARTx, FunctionalState NewState)
   1632          {
   1633          	if (NewState == ENABLE)
   \                     UART4_TxCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD10E             BNE.N    ??UART4_TxCmd_0
   1634          	{
   1635          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000006   0x....             LDR.N    R2,??DataTable16  ;; 0x40010000
   \   00000008   0x4290             CMP      R0,R2
   \   0000000A   0xD106             BNE.N    ??UART4_TxCmd_1
   1636          		{
   1637          			((LPC_UART1_TypeDef *)UARTx)->TER |= UART_TER_TXEN;
   \   0000000C   0xF890 0x2030      LDRB     R2,[R0, #+48]
   \   00000010   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000014   0xF880 0x2030      STRB     R2,[R0, #+48]
   \   00000018   0xE010             B.N      ??UART4_TxCmd_2
   1638          		}
   1639          		else
   1640          		{
   1641          			UARTx->TER |= UART_TER_TXEN;
   \                     ??UART4_TxCmd_1:
   \   0000001A   0x6DC2             LDR      R2,[R0, #+92]
   \   0000001C   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000020   0x65C2             STR      R2,[R0, #+92]
   \   00000022   0xE00B             B.N      ??UART4_TxCmd_2
   1642          		}
   1643          	}
   1644          	else
   1645          	{
   1646          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART4_TxCmd_0:
   \   00000024   0x....             LDR.N    R2,??DataTable16  ;; 0x40010000
   \   00000026   0x4290             CMP      R0,R2
   \   00000028   0xD105             BNE.N    ??UART4_TxCmd_3
   1647          		{
   1648          			((LPC_UART1_TypeDef *)UARTx)->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
   \   0000002A   0xF890 0x2030      LDRB     R2,[R0, #+48]
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0xF880 0x3030      STRB     R3,[R0, #+48]
   \   00000034   0xE002             B.N      ??UART4_TxCmd_2
   1649          		}
   1650          		else
   1651          		{
   1652          			UARTx->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
   \                     ??UART4_TxCmd_3:
   \   00000036   0x6DC2             LDR      R2,[R0, #+92]
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x65C3             STR      R3,[R0, #+92]
   1653          		}
   1654          	}
   1655          }
   \                     ??UART4_TxCmd_2:
   \   0000003C   0x4770             BX       LR               ;; return
   1656          /*********************************************************************//**
   1657           * @brief		Determines best dividers to get a target clock rate
   1658           * @param[in]	UARTx	Pointer to selected UART peripheral, should be:
   1659           * 				- LPC_UART0: UART0 peripheral
   1660           * 				- LPC_UART1: UART1 peripheral
   1661           * 				- LPC_UART2: UART2 peripheral
   1662           * 				- LPC_UART3: UART3 peripheral
   1663           * @param[in]	baudrate Desired UART baud rate.
   1664           * @return 		Error status, could be:
   1665           * 				- SUCCESS
   1666           * 				- ERROR
   1667           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1668          static Status uart4_set_divisors(LPC_UART4_TypeDef *UARTx, uint32_t baudrate)
   1669          {
   \                     uart4_set_divisors:
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   1670          	Status errorStatus = ERROR;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1671          
   1672          	uint32_t uClk;
   1673          	uint32_t d, m, bestd, bestm, tmp;
   1674          	uint64_t best_divisor, divisor;
   1675          	uint32_t current_error, best_error;
   1676          	uint32_t recalcbaud;
   1677          
   1678          	/* get UART block clock */
   1679          	uClk = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       CLKPWR_GetCLK
   \   00000012   0x9007             STR      R0,[SP, #+28]
   1680          
   1681          	/* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
   1682          	* The formula is :
   1683          	* BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
   1684          	* It involves floating point calculations. That's the reason the formulae are adjusted with
   1685          	* Multiply and divide method.*/
   1686          	
   1687          	/* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
   1688          	* 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15 */
   1689          	best_error = 0xFFFFFFFF; /* Worst case */
   \   00000014   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000018   0x9003             STR      R0,[SP, #+12]
   1690          	bestd = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9005             STR      R0,[SP, #+20]
   1691          	bestm = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x9004             STR      R0,[SP, #+16]
   1692          	best_divisor = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xE9CD 0x0108      STRD     R0,R1,[SP, #+32]
   1693          	
   1694          	for (m = 1 ; m <= 15 ;m++)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x0007             MOVS     R7,R0
   \                     ??uart4_set_divisors_0:
   \   0000002E   0x2F10             CMP      R7,#+16
   \   00000030   0xD23F             BCS.N    ??uart4_set_divisors_1
   1695          	{
   1696          		for (d = 0 ; d < m ; d++)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x0006             MOVS     R6,R0
   \                     ??uart4_set_divisors_2:
   \   00000036   0x42BE             CMP      R6,R7
   \   00000038   0xD236             BCS.N    ??uart4_set_divisors_3
   1697          		{
   1698          			divisor = ((uint64_t)uClk << 28)*m / (baudrate*(m+d));
   \   0000003A   0x9A07             LDR      R2,[SP, #+28]
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x071B             LSLS     R3,R3,#+28
   \   00000040   0xEA43 0x1312      ORR      R3,R3,R2, LSR #+4
   \   00000044   0x0712             LSLS     R2,R2,#+28
   \   00000046   0x46BA             MOV      R10,R7
   \   00000048   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000004C   0xFBAA 0x0102      UMULL    R0,R1,R10,R2
   \   00000050   0xFB0A 0x1103      MLA      R1,R10,R3,R1
   \   00000054   0xFB0B 0x1102      MLA      R1,R11,R2,R1
   \   00000058   0x9A0C             LDR      R2,[SP, #+48]
   \   0000005A   0x19F3             ADDS     R3,R6,R7
   \   0000005C   0x435A             MULS     R2,R3,R2
   \   0000005E   0x2300             MOVS     R3,#+0
   \   00000060   0x.... 0x....      BL       __aeabi_uldivmod
   \   00000064   0x0004             MOVS     R4,R0
   \   00000066   0x000D             MOVS     R5,R1
   1699          			current_error = divisor & 0xFFFFFFFF;
   \   00000068   0x46A1             MOV      R9,R4
   1700          
   1701          			tmp = divisor>>32;
   \   0000006A   0x46A8             MOV      R8,R5
   1702          
   1703          			/* Adjust error */
   1704          			if(current_error > ((uint32_t)1<<31))
   \   0000006C   0xF1B9 0x4F00      CMP      R9,#-2147483648
   \   00000070   0xD903             BLS.N    ??uart4_set_divisors_4
   1705          			{
   1706          				current_error = -current_error;
   \   00000072   0xF1D9 0x0900      RSBS     R9,R9,#+0
   1707          				tmp++;
   \   00000076   0xF118 0x0801      ADDS     R8,R8,#+1
   1708          			}
   1709          
   1710          			/* Out of range */
   1711          			if(tmp < 1 || tmp > 65536)
   \                     ??uart4_set_divisors_4:
   \   0000007A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000007E   0xD002             BEQ.N    ??uart4_set_divisors_5
   \   00000080   0xF1B8 0x1F01      CMP      R8,#+65537
   \   00000084   0xD300             BCC.N    ??uart4_set_divisors_6
   1712          				continue;
   \                     ??uart4_set_divisors_5:
   \   00000086   0xE00D             B.N      ??uart4_set_divisors_7
   1713          
   1714          			if( current_error < best_error)
   \                     ??uart4_set_divisors_6:
   \   00000088   0x9803             LDR      R0,[SP, #+12]
   \   0000008A   0x4581             CMP      R9,R0
   \   0000008C   0xD20A             BCS.N    ??uart4_set_divisors_7
   1715          			{
   1716          				best_error = current_error;
   \   0000008E   0xF8CD 0x900C      STR      R9,[SP, #+12]
   1717          				best_divisor = tmp;
   \   00000092   0x4640             MOV      R0,R8
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0xE9CD 0x0108      STRD     R0,R1,[SP, #+32]
   1718          				bestd = d;
   \   0000009A   0x9605             STR      R6,[SP, #+20]
   1719          				bestm = m;
   \   0000009C   0x9704             STR      R7,[SP, #+16]
   1720          				
   1721          				if(best_error == 0) 
   \   0000009E   0x9803             LDR      R0,[SP, #+12]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD001             BEQ.N    ??uart4_set_divisors_3
   1722          					break;
   1723          			}
   1724          		} /* end of inner for loop */
   \                     ??uart4_set_divisors_7:
   \   000000A4   0x1C76             ADDS     R6,R6,#+1
   \   000000A6   0xE7C6             B.N      ??uart4_set_divisors_2
   1725          
   1726          		if (best_error == 0)
   \                     ??uart4_set_divisors_3:
   \   000000A8   0x9803             LDR      R0,[SP, #+12]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD001             BEQ.N    ??uart4_set_divisors_1
   1727          			break;
   1728          	} /* end of outer for loop  */
   \                     ??uart4_set_divisors_8:
   \   000000AE   0x1C7F             ADDS     R7,R7,#+1
   \   000000B0   0xE7BD             B.N      ??uart4_set_divisors_0
   1729          
   1730          	/* can not find best match */
   1731          	if(best_divisor == 0) 
   \                     ??uart4_set_divisors_1:
   \   000000B2   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   000000B6   0x2900             CMP      R1,#+0
   \   000000B8   0xD103             BNE.N    ??uart4_set_divisors_9
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD101             BNE.N    ??uart4_set_divisors_9
   1732          		return ERROR;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xE077             B.N      ??uart4_set_divisors_10
   1733          
   1734          	recalcbaud = (uClk >> 4) * bestm / (best_divisor * (bestm + bestd));
   \                     ??uart4_set_divisors_9:
   \   000000C2   0x9807             LDR      R0,[SP, #+28]
   \   000000C4   0x0900             LSRS     R0,R0,#+4
   \   000000C6   0x9904             LDR      R1,[SP, #+16]
   \   000000C8   0x4348             MULS     R0,R1,R0
   \   000000CA   0x2100             MOVS     R1,#+0
   \   000000CC   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000000D0   0xE9DD 0xAB08      LDRD     R10,R11,[SP, #+32]
   \   000000D4   0x9804             LDR      R0,[SP, #+16]
   \   000000D6   0x9905             LDR      R1,[SP, #+20]
   \   000000D8   0x1808             ADDS     R0,R1,R0
   \   000000DA   0x2100             MOVS     R1,#+0
   \   000000DC   0xFBA0 0x230A      UMULL    R2,R3,R0,R10
   \   000000E0   0xFB00 0x330B      MLA      R3,R0,R11,R3
   \   000000E4   0xFB01 0x330A      MLA      R3,R1,R10,R3
   \   000000E8   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   000000EC   0x.... 0x....      BL       __aeabi_uldivmod
   \   000000F0   0x9006             STR      R0,[SP, #+24]
   1735          
   1736          	/* reuse best_error to evaluate baud error*/
   1737          	if(baudrate > recalcbaud) 
   \   000000F2   0x9806             LDR      R0,[SP, #+24]
   \   000000F4   0x990C             LDR      R1,[SP, #+48]
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD204             BCS.N    ??uart4_set_divisors_11
   1738          		best_error = baudrate - recalcbaud;
   \   000000FA   0x980C             LDR      R0,[SP, #+48]
   \   000000FC   0x9906             LDR      R1,[SP, #+24]
   \   000000FE   0x1A40             SUBS     R0,R0,R1
   \   00000100   0x9003             STR      R0,[SP, #+12]
   \   00000102   0xE003             B.N      ??uart4_set_divisors_12
   1739          	else 
   1740          		best_error = recalcbaud -baudrate;
   \                     ??uart4_set_divisors_11:
   \   00000104   0x9806             LDR      R0,[SP, #+24]
   \   00000106   0x990C             LDR      R1,[SP, #+48]
   \   00000108   0x1A40             SUBS     R0,R0,R1
   \   0000010A   0x9003             STR      R0,[SP, #+12]
   1741          
   1742          	best_error = best_error * 100 / baudrate;
   \                     ??uart4_set_divisors_12:
   \   0000010C   0x9803             LDR      R0,[SP, #+12]
   \   0000010E   0x2164             MOVS     R1,#+100
   \   00000110   0x4348             MULS     R0,R1,R0
   \   00000112   0x990C             LDR      R1,[SP, #+48]
   \   00000114   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000118   0x9003             STR      R0,[SP, #+12]
   1743          
   1744          	if (best_error < UART_ACCEPTED_BAUDRATE_ERROR)
   \   0000011A   0x9803             LDR      R0,[SP, #+12]
   \   0000011C   0x2803             CMP      R0,#+3
   \   0000011E   0xD246             BCS.N    ??uart4_set_divisors_13
   1745          	{
   1746          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000120   0x980B             LDR      R0,[SP, #+44]
   \   00000122   0x....             LDR.N    R1,??DataTable16  ;; 0x40010000
   \   00000124   0x4288             CMP      R0,R1
   \   00000126   0xD11F             BNE.N    ??uart4_set_divisors_14
   1747          		{
   1748          			((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_DLAB_EN;
   \   00000128   0x980B             LDR      R0,[SP, #+44]
   \   0000012A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000012C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000130   0x990B             LDR      R1,[SP, #+44]
   \   00000132   0x7308             STRB     R0,[R1, #+12]
   1749          			
   1750          			((LPC_UART1_TypeDef *)UARTx)->DLM = UART_LOAD_DLM(best_divisor);
   \   00000134   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   00000138   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000013A   0x0A00             LSRS     R0,R0,#+8
   \   0000013C   0x990B             LDR      R1,[SP, #+44]
   \   0000013E   0x7108             STRB     R0,[R1, #+4]
   1751          			
   1752          			((LPC_UART1_TypeDef *)UARTx)->DLL = UART_LOAD_DLL(best_divisor);
   \   00000140   0x9A0B             LDR      R2,[SP, #+44]
   \   00000142   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   00000146   0x7010             STRB     R0,[R2, #+0]
   1753          			
   1754          			/* Then reset DLAB bit */
   1755          			((LPC_UART1_TypeDef *)UARTx)->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
   \   00000148   0x980B             LDR      R0,[SP, #+44]
   \   0000014A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000014C   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000150   0x990B             LDR      R1,[SP, #+44]
   \   00000152   0x7308             STRB     R0,[R1, #+12]
   1756          			
   1757          			((LPC_UART1_TypeDef *)UARTx)->FDR = (UART_FDR_MULVAL(bestm)
   1758          													| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
   \   00000154   0x9804             LDR      R0,[SP, #+16]
   \   00000156   0x9905             LDR      R1,[SP, #+20]
   \   00000158   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   0000015C   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   00000160   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000162   0x990B             LDR      R1,[SP, #+44]
   \   00000164   0x6288             STR      R0,[R1, #+40]
   \   00000166   0xE01F             B.N      ??uart4_set_divisors_15
   1759          		}
   1760          		else
   1761          		{
   1762          			UARTx->LCR |= UART_LCR_DLAB_EN;
   \                     ??uart4_set_divisors_14:
   \   00000168   0x980B             LDR      R0,[SP, #+44]
   \   0000016A   0x68C0             LDR      R0,[R0, #+12]
   \   0000016C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000170   0x990B             LDR      R1,[SP, #+44]
   \   00000172   0x60C8             STR      R0,[R1, #+12]
   1763          			
   1764          			UARTx->DLM = UART_LOAD_DLM(best_divisor);
   \   00000174   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   00000178   0xF3C0 0x2007      UBFX     R0,R0,#+8,#+8
   \   0000017C   0x990B             LDR      R1,[SP, #+44]
   \   0000017E   0x6048             STR      R0,[R1, #+4]
   1765          			
   1766          			UARTx->DLL = UART_LOAD_DLL(best_divisor);
   \   00000180   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   00000184   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000186   0x990B             LDR      R1,[SP, #+44]
   \   00000188   0x6008             STR      R0,[R1, #+0]
   1767          			
   1768          			/* Then reset DLAB bit */
   1769          			UARTx->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
   \   0000018A   0x980B             LDR      R0,[SP, #+44]
   \   0000018C   0x68C0             LDR      R0,[R0, #+12]
   \   0000018E   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000192   0x990B             LDR      R1,[SP, #+44]
   \   00000194   0x60C8             STR      R0,[R1, #+12]
   1770          			
   1771          			UARTx->FDR = (UART_FDR_MULVAL(bestm) \
   1772          							| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
   \   00000196   0x9804             LDR      R0,[SP, #+16]
   \   00000198   0x9905             LDR      R1,[SP, #+20]
   \   0000019A   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   0000019E   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   000001A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A4   0x990B             LDR      R1,[SP, #+44]
   \   000001A6   0x6288             STR      R0,[R1, #+40]
   1773          		}
   1774          		errorStatus = SUCCESS;
   \                     ??uart4_set_divisors_15:
   \   000001A8   0x2001             MOVS     R0,#+1
   \   000001AA   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1775          	}
   1776          
   1777          	return errorStatus;
   \                     ??uart4_set_divisors_13:
   \   000001AE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \                     ??uart4_set_divisors_10:
   \   000001B2   0xB00D             ADD      SP,SP,#+52
   \   000001B4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1778          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x4000C000         DC32     0x4000c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x4009C000         DC32     0x4009c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x40010014         DC32     0x40010014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x400A4000         DC32     0x400a4000

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   UART4_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> uart4_set_divisors
       8   UART4_IntConfig
       0   UART4_TxCmd
       0   UART_ABClearIntPending
       4   UART_ABCmd
       0   UART_CheckBusy
       0   UART_ConfigStructInit
       8   UART_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> UART_TxCmd
       0   UART_FIFOConfig
       0   UART_FIFOConfigStructInit
       0   UART_ForceBreak
       8   UART_FullModemConfigMode
       8   UART_FullModemForcePinState
       0   UART_FullModemGetStatus
       0   UART_GetIntId
       0   UART_GetLineStatus
      16   UART_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> uart_set_divisors
       8   UART_IntConfig
       0   UART_IrDACmd
       0   UART_IrDAInvtInputCmd
       4   UART_IrDAPulseDivConfig
       0   UART_RS485Config
       0   UART_RS485ReceiverCmd
      32   UART_RS485Send
        32   -> UART_Send
      16   UART_RS485SendData
        16   -> UART_RS485Send
      16   UART_RS485SendSlvAddr
        16   -> UART_RS485Send
      40   UART_Receive
        40   -> UART_ReceiveByte
       0   UART_ReceiveByte
      40   UART_Send
        40   -> UART_SendByte
       0   UART_SendByte
       0   UART_TxCmd
      88   uart4_set_divisors
        88   -> CLKPWR_GetCLK
        88   -> __aeabi_uldivmod
      88   uart_set_divisors
        88   -> CLKPWR_GetCLK
        88   -> __aeabi_uldivmod


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
     250  UART4_Init
     136  UART4_IntConfig
      62  UART4_TxCmd
      28  UART_ABClearIntPending
     140  UART_ABCmd
      16  UART_CheckBusy
      20  UART_ConfigStructInit
      82  UART_DeInit
      92  UART_FIFOConfig
      18  UART_FIFOConfigStructInit
      28  UART_ForceBreak
      64  UART_FullModemConfigMode
      58  UART_FullModemForcePinState
       4  UART_FullModemGetStatus
      10  UART_GetIntId
      24  UART_GetLineStatus
     314  UART_Init
     140  UART_IntConfig
      34  UART_IrDACmd
      40  UART_IrDAInvtInputCmd
      40  UART_IrDAPulseDivConfig
     102  UART_RS485Config
      34  UART_RS485ReceiverCmd
      84  UART_RS485Send
      22  UART_RS485SendData
      18  UART_RS485SendSlvAddr
     132  UART_Receive
      16  UART_ReceiveByte
     164  UART_Send
      16  UART_SendByte
      74  UART_TxCmd
     440  uart4_set_divisors
     440  uart_set_divisors

 
 3 166 bytes in section .text
 
 3 166 bytes of CODE memory

Errors: none
Warnings: none
