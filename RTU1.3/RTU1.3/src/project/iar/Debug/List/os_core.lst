###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:13 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_core.c                                    #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_core.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm #
#                    \RTU\´úÂë\RTU_1.2\project\iar\Debug\List\ -o             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\os_core.lst                                #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\os_core.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCOS-II\Source\os_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             CORE FUNCTIONS
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_CORE.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.89
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #define  OS_GLOBALS
     26          #include <ucos_ii.h>

   \                                 In section .bss, align 4
   \   __absolute INT32U OSCtxSwCtr
   \                     OSCtxSwCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_event *OSEventFreeList
   \                     OSEventFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_EVENT OSEventTbl[63U]
   \                     OSEventTbl:
   \   00000000                      DS8 1260

   \                                 In section .bss, align 4
   \   __absolute OS_FLAG_GRP OSFlagTbl[30U]
   \                     OSFlagTbl:
   \   00000000                      DS8 480

   \                                 In section .bss, align 4
   \   __absolute struct os_flag_grp *OSFlagFreeList
   \                     OSFlagFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute INT8U OSIntNesting
   \                     OSIntNesting:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U OSLockNesting
   \                     OSLockNesting:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U OSPrioCur
   \                     OSPrioCur:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U OSPrioHighRdy
   \                     OSPrioHighRdy:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U OSRdyGrp
   \                     OSRdyGrp:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT8U OSRdyTbl[4U]
   \                     OSRdyTbl:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute BOOLEAN OSRunning
   \                     OSRunning:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U OSTaskCtr
   \                     OSTaskCtr:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT32U volatile OSIdleCtr
   \                     OSIdleCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_STK OSTaskIdleStk[256U]
   \                     OSTaskIdleStk:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 4
   \   __absolute struct os_tcb *OSTCBCur
   \                     OSTCBCur:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_tcb *OSTCBFreeList
   \                     OSTCBFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_tcb *OSTCBHighRdy
   \                     OSTCBHighRdy:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_tcb *OSTCBList
   \                     OSTCBList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_tcb *OSTCBPrioTbl[32U]
   \                     OSTCBPrioTbl:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
   \   __absolute OS_TCB OSTCBTbl[16U]
   \                     OSTCBTbl:
   \   00000000                      DS8 1344

   \                                 In section .bss, align 1
   \   __absolute INT8U OSTickStepState
   \                     OSTickStepState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute struct os_mem *OSMemFreeList
   \                     OSMemFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_MEM OSMemTbl[20U]
   \                     OSMemTbl:
   \   00000000                      DS8 480

   \                                 In section .bss, align 4
   \   __absolute OS_Q *OSQFreeList
   \                     OSQFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_Q OSQTbl[20U]
   \                     OSQTbl:
   \   00000000                      DS8 480

   \                                 In section .bss, align 4
   \   __absolute INT32U volatile OSTime
   \                     OSTime:
   \   00000000                      DS8 4
     27          #endif
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                       PRIORITY RESOLUTION TABLE
     32          *
     33          * Note: Index into table is bit pattern to resolve highest priority
     34          *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
     35          *********************************************************************************************************
     36          */
     37          

   \                                 In section .rodata, align 4
     38          INT8U  const  OSUnMapTbl[256] = {
   \                     OSUnMapTbl:
   \   00000000   0x00 0x00          DC8 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \   00000017   0x00 0x03          DC8 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \   0000002E   0x01 0x00          DC8 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02         
   \   00000045   0x00 0x01          DC8 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00         
   \   0000005C   0x02 0x00          DC8 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1
   \              0x01 0x00    
   \              0x05 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01         
   \   00000073   0x00 0x02          DC8 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x07    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00         
   \   0000008A   0x01 0x00          DC8 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x05         
   \   000000A1   0x00 0x01          DC8 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00         
   \   000000B8   0x03 0x00          DC8 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \   000000CF   0x00 0x04          DC8 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \   000000E6   0x01 0x00          DC8 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02         
   \   000000FD   0x00 0x01          DC8 0, 1, 0
   \              0x00         
     39              0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x00 to 0x0F                             */
     40              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x10 to 0x1F                             */
     41              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x20 to 0x2F                             */
     42              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x30 to 0x3F                             */
     43              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x40 to 0x4F                             */
     44              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x50 to 0x5F                             */
     45              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x60 to 0x6F                             */
     46              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x70 to 0x7F                             */
     47              7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x80 to 0x8F                             */
     48              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x90 to 0x9F                             */
     49              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xA0 to 0xAF                             */
     50              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xB0 to 0xBF                             */
     51              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xC0 to 0xCF                             */
     52              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xD0 to 0xDF                             */
     53              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xE0 to 0xEF                             */
     54              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0        /* 0xF0 to 0xFF                             */
     55          };
     56          
     57          /*$PAGE*/
     58          /*
     59          *********************************************************************************************************
     60          *                                       FUNCTION PROTOTYPES
     61          *********************************************************************************************************
     62          */
     63          
     64          static  void  OS_InitEventList(void);
     65          
     66          static  void  OS_InitMisc(void);
     67          
     68          static  void  OS_InitRdyList(void);
     69          
     70          static  void  OS_InitTaskIdle(void);
     71          
     72          #if OS_TASK_STAT_EN > 0u
     73          static  void  OS_InitTaskStat(void);
     74          #endif
     75          
     76          static  void  OS_InitTCBList(void);
     77          
     78          static  void  OS_SchedNew(void);
     79          
     80          /*$PAGE*/
     81          /*
     82          *********************************************************************************************************
     83          *                         GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
     84          *
     85          * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
     86          *
     87          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
     88          *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
     89          *                        type is irrelevant.
     90          *
     91          *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
     92          *                        mutex, mailbox or queue.
     93          *
     94          *              perr      is a pointer to an error code that can contain one of the following values:
     95          *
     96          *                        OS_ERR_NONE                if the name was copied to 'pname'
     97          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
     98          *                                                   control block type.
     99          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    100          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    101          *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
    102          *
    103          * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
    104          *********************************************************************************************************
    105          */
    106          
    107          #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    108          INT8U  OSEventNameGet (OS_EVENT   *pevent,
    109                                 INT8U     **pname,
    110                                 INT8U      *perr)
    111          {
   \                     OSEventNameGet:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    112              INT8U      len;
    113          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    114              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    115          #endif
    116          
    117          
    118          
    119          #if OS_ARG_CHK_EN > 0u
    120              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    121                  return (0u);
    122              }
    123              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    124                  *perr = OS_ERR_PEVENT_NULL;
    125                  return (0u);
    126              }
    127              if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
    128                  *perr = OS_ERR_PNAME_NULL;
    129                  return (0u);
    130              }
    131          #endif
    132              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSEventNameGet_0
    133                  *perr  = OS_ERR_NAME_GET_ISR;
   \   00000018   0x2011             MOVS     R0,#+17
   \   0000001A   0x7030             STRB     R0,[R6, #+0]
    134                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE017             B.N      ??OSEventNameGet_1
    135              }
    136              switch (pevent->OSEventType) {
   \                     ??OSEventNameGet_0:
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x1E40             SUBS     R0,R0,#+1
   \   00000024   0x2803             CMP      R0,#+3
   \   00000026   0xD810             BHI.N    ??OSEventNameGet_2
    137                  case OS_EVENT_TYPE_SEM:
    138                  case OS_EVENT_TYPE_MUTEX:
    139                  case OS_EVENT_TYPE_MBOX:
    140                  case OS_EVENT_TYPE_Q:
    141                       break;
    142          
    143                  default:
    144                       *perr = OS_ERR_EVENT_TYPE;
    145                       return (0u);
    146              }
    147              OS_ENTER_CRITICAL();
   \                     ??OSEventNameGet_3:
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000002C   0x4680             MOV      R8,R0
    148              *pname = pevent->OSEventName;
   \   0000002E   0x6920             LDR      R0,[R4, #+16]
   \   00000030   0x6028             STR      R0,[R5, #+0]
    149              len    = OS_StrLen(*pname);
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0x.... 0x....      BL       OS_StrLen
   \   00000038   0x0007             MOVS     R7,R0
    150              OS_EXIT_CRITICAL();
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x.... 0x....      BL       OS_CPU_SR_Restore
    151              *perr  = OS_ERR_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7030             STRB     R0,[R6, #+0]
    152              return (len);
   \   00000044   0x0038             MOVS     R0,R7
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xE002             B.N      ??OSEventNameGet_1
   \                     ??OSEventNameGet_2:
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x7030             STRB     R0,[R6, #+0]
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??OSEventNameGet_1:
   \   00000050   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    153          }
    154          #endif
    155          
    156          /*$PAGE*/
    157          /*
    158          *********************************************************************************************************
    159          *                         ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
    160          *
    161          * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
    162          *
    163          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
    164          *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
    165          *                        matter the actual type.
    166          *
    167          *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
    168          *                        mutex, mailbox or queue.
    169          *
    170          *              perr      is a pointer to an error code that can contain one of the following values:
    171          *
    172          *                        OS_ERR_NONE                if the requested task is resumed
    173          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
    174          *                                                   control block type.
    175          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    176          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    177          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    178          *
    179          * Returns    : None
    180          *********************************************************************************************************
    181          */
    182          
    183          #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    184          void  OSEventNameSet (OS_EVENT  *pevent,
    185                                INT8U     *pname,
    186                                INT8U     *perr)
    187          {
   \                     OSEventNameSet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    188          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    189              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
    190          #endif
    191          
    192          
    193          
    194          #if OS_ARG_CHK_EN > 0u
    195              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    196                  return;
    197              }
    198              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    199                  *perr = OS_ERR_PEVENT_NULL;
    200                  return;
    201              }
    202              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    203                  *perr = OS_ERR_PNAME_NULL;
    204                  return;
    205              }
    206          #endif
    207              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??OSEventNameSet_0
    208                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000014   0x2012             MOVS     R0,#+18
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    209                  return;
   \   00000018   0xE00F             B.N      ??OSEventNameSet_1
    210              }
    211              switch (pevent->OSEventType) {
   \                     ??OSEventNameSet_0:
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD809             BHI.N    ??OSEventNameSet_2
    212                  case OS_EVENT_TYPE_SEM:
    213                  case OS_EVENT_TYPE_MUTEX:
    214                  case OS_EVENT_TYPE_MBOX:
    215                  case OS_EVENT_TYPE_Q:
    216                       break;
    217          
    218                  default:
    219                       *perr = OS_ERR_EVENT_TYPE;
    220                       return;
    221              }
    222              OS_ENTER_CRITICAL();
   \                     ??OSEventNameSet_3:
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000026   0x0007             MOVS     R7,R0
    223              pevent->OSEventName = pname;
   \   00000028   0x6125             STR      R5,[R4, #+16]
    224              OS_EXIT_CRITICAL();
   \   0000002A   0x0038             MOVS     R0,R7
   \   0000002C   0x.... 0x....      BL       OS_CPU_SR_Restore
    225              *perr = OS_ERR_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x7030             STRB     R0,[R6, #+0]
    226          }
   \   00000034   0xE001             B.N      ??OSEventNameSet_1
   \                     ??OSEventNameSet_2:
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x7030             STRB     R0,[R6, #+0]
   \                     ??OSEventNameSet_1:
   \   0000003A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    227          #endif
    228          
    229          /*$PAGE*/
    230          /*
    231          *********************************************************************************************************
    232          *                                      PEND ON MULTIPLE EVENTS
    233          *
    234          * Description: This function waits for multiple events.  If multiple events are ready at the start of the
    235          *              pend call, then all available events are returned as ready.  If the task must pend on the
    236          *              multiple events, then only the first posted or aborted event is returned as ready.
    237          *
    238          * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
    239          *
    240          *              pevents_rdy   is a pointer to an array to return which event control blocks are available
    241          *                            or ready.  The size of the array MUST be greater than or equal to the size
    242          *                            of the 'pevents_pend' array, including terminating NULL.
    243          *
    244          *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
    245          *                            events.  The size of the array MUST be greater than or equal to the size of
    246          *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
    247          *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
    248          *                            every available message-type event returns its messages in the 'pmsgs_rdy'
    249          *                            array at the same index as the event is returned in the 'pevents_rdy' array.
    250          *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
    251          *
    252          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    253          *                            wait for the resources up to the amount of time specified by this argument.
    254          *                            If you specify 0, however, your task will wait forever for the specified
    255          *                            events or, until the resources becomes available (or the events occur).
    256          *
    257          *              perr          is a pointer to where an error message will be deposited.  Possible error
    258          *                            messages are:
    259          *
    260          *                            OS_ERR_NONE         The call was successful and your task owns the resources
    261          *                                                or, the events you are waiting for occurred; check the
    262          *                                                'pevents_rdy' array for which events are available.
    263          *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
    264          *                                                'pevents_rdy' array for which events were aborted.
    265          *                            OS_ERR_TIMEOUT      The events were not received within the specified
    266          *                                                'timeout'.
    267          *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
    268          *                                                NULL pointer.
    269          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
    270          *                                                mailboxes, and/or queues.
    271          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    272          *                                                would lead to a suspension.
    273          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
    274          *
    275          * Returns    : >  0          the number of events returned as ready or aborted.
    276          *              == 0          if no events are returned as ready because of timeout or upon error.
    277          *
    278          * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
    279          *
    280          *                        semaphores, mailboxes, queues
    281          *
    282          *                 b. Return ALL available events and messages, if any
    283          *
    284          *                 c. Add    current task priority as pending to   each events's wait list
    285          *                      Performed in OS_EventTaskWaitMulti()
    286          *
    287          *                 d. Wait on any of multiple events
    288          *
    289          *                 e. Remove current task priority as pending from each events's wait list
    290          *                      Performed in OS_EventTaskRdy(), if events posted or aborted
    291          *
    292          *                 f. Return any event posted or aborted, if any
    293          *                      else
    294          *                    Return timeout
    295          *
    296          *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
    297          *                 case of any error(s).
    298          *********************************************************************************************************
    299          */
    300          /*$PAGE*/
    301          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))

   \                                 In section .text, align 2, keep-with-next
    302          INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
    303                                    OS_EVENT  **pevents_rdy,
    304                                    void      **pmsgs_rdy,
    305                                    INT32U      timeout,
    306                                    INT8U      *perr)
    307          {
   \                     OSEventPendMulti:
   \   00000000   0xE92D 0x4FF9      PUSH     {R0,R3-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x9C0E             LDR      R4,[SP, #+56]
    308              OS_EVENT  **pevents;
    309              OS_EVENT   *pevent;
    310          #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
    311              OS_Q       *pq;
    312          #endif
    313              BOOLEAN     events_rdy;
    314              INT16U      events_rdy_nbr;
    315              INT8U       events_stat;
    316          #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
    317              OS_CPU_SR   cpu_sr = 0u;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    318          #endif
    319          
    320          
    321          
    322          #if (OS_ARG_CHK_EN > 0u)
    323              if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
    324                  return (0u);
    325              }
    326              if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
    327                 *perr =  OS_ERR_PEVENT_NULL;
    328                  return (0u);
    329              }
    330              if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
    331                 *perr =  OS_ERR_PEVENT_NULL;
    332                  return (0u);
    333              }
    334              if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
    335                 *perr =  OS_ERR_PEVENT_NULL;
    336                  return (0u);
    337              }
    338              if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
    339                 *perr =  OS_ERR_PEVENT_NULL;
    340                  return (0u);
    341              }
    342          #endif
    343          
    344             *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8CB 0x0000      STR      R0,[R11, #+0]
    345          
    346              pevents     =  pevents_pend;
   \   00000016   0x9803             LDR      R0,[SP, #+12]
   \   00000018   0x0007             MOVS     R7,R0
    347              pevent      = *pevents;
   \   0000001A   0x6838             LDR      R0,[R7, #+0]
   \   0000001C   0x0005             MOVS     R5,R0
    348              while  (pevent != (OS_EVENT *)0) {
   \                     ??OSEventPendMulti_0:
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD012             BEQ.N    ??OSEventPendMulti_1
    349                  switch (pevent->OSEventType) {                  /* Validate event block types                  */
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD005             BEQ.N    ??OSEventPendMulti_2
   \   00000028   0xD306             BCC.N    ??OSEventPendMulti_3
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD001             BEQ.N    ??OSEventPendMulti_4
   \   0000002E   0xD302             BCC.N    ??OSEventPendMulti_5
   \   00000030   0xE002             B.N      ??OSEventPendMulti_3
    350          #if (OS_SEM_EN  > 0u)
    351                      case OS_EVENT_TYPE_SEM:
    352                           break;
   \                     ??OSEventPendMulti_4:
   \   00000032   0xE005             B.N      ??OSEventPendMulti_6
    353          #endif
    354          #if (OS_MBOX_EN > 0u)
    355                      case OS_EVENT_TYPE_MBOX:
    356                           break;
   \                     ??OSEventPendMulti_2:
   \   00000034   0xE004             B.N      ??OSEventPendMulti_6
    357          #endif
    358          #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
    359                      case OS_EVENT_TYPE_Q:
    360                           break;
   \                     ??OSEventPendMulti_5:
   \   00000036   0xE003             B.N      ??OSEventPendMulti_6
    361          #endif
    362          
    363                      case OS_EVENT_TYPE_MUTEX:
    364                      case OS_EVENT_TYPE_FLAG:
    365                      default:
    366                          *perr = OS_ERR_EVENT_TYPE;
   \                     ??OSEventPendMulti_3:
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
    367                           return (0u);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE149             B.N      ??OSEventPendMulti_7
    368                  }
    369                  pevents++;
   \                     ??OSEventPendMulti_6:
   \   00000040   0x1D3F             ADDS     R7,R7,#+4
    370                  pevent = *pevents;
   \   00000042   0x6838             LDR      R0,[R7, #+0]
   \   00000044   0x0005             MOVS     R5,R0
   \   00000046   0xE7EA             B.N      ??OSEventPendMulti_0
    371              }
    372          
    373              if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
   \                     ??OSEventPendMulti_1:
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD003             BEQ.N    ??OSEventPendMulti_8
    374                 *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x7020             STRB     R0,[R4, #+0]
    375                  return (0u);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE13C             B.N      ??OSEventPendMulti_7
    376              }
    377              if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
   \                     ??OSEventPendMulti_8:
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD003             BEQ.N    ??OSEventPendMulti_9
    378                 *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
   \   00000064   0x200D             MOVS     R0,#+13
   \   00000066   0x7020             STRB     R0,[R4, #+0]
    379                  return (0u);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE133             B.N      ??OSEventPendMulti_7
    380              }
    381          
    382          /*$PAGE*/
    383              OS_ENTER_CRITICAL();
   \                     ??OSEventPendMulti_9:
   \   0000006C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000070   0x9000             STR      R0,[SP, #+0]
    384              events_rdy     =  OS_FALSE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF88D 0x0004      STRB     R0,[SP, #+4]
    385              events_rdy_nbr =  0u;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x4680             MOV      R8,R0
    386              events_stat    =  OS_STAT_RDY;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x4681             MOV      R9,R0
    387              pevents        =  pevents_pend;
   \   00000080   0x9803             LDR      R0,[SP, #+12]
   \   00000082   0x0007             MOVS     R7,R0
    388              pevent         = *pevents;
   \   00000084   0x6838             LDR      R0,[R7, #+0]
   \   00000086   0x0005             MOVS     R5,R0
    389              while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
   \                     ??OSEventPendMulti_10:
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD068             BEQ.N    ??OSEventPendMulti_11
    390                  switch (pevent->OSEventType) {
   \   0000008C   0x7828             LDRB     R0,[R5, #+0]
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xD01C             BEQ.N    ??OSEventPendMulti_12
   \   00000092   0xD355             BCC.N    ??OSEventPendMulti_13
   \   00000094   0x2803             CMP      R0,#+3
   \   00000096   0xD001             BEQ.N    ??OSEventPendMulti_14
   \   00000098   0xD32F             BCC.N    ??OSEventPendMulti_15
   \   0000009A   0xE051             B.N      ??OSEventPendMulti_13
    391          #if (OS_SEM_EN > 0u)
    392                      case OS_EVENT_TYPE_SEM:
    393                           if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
   \                     ??OSEventPendMulti_14:
   \   0000009C   0x8928             LDRH     R0,[R5, #+8]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD011             BEQ.N    ??OSEventPendMulti_16
    394                               pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
   \   000000A2   0x8928             LDRH     R0,[R5, #+8]
   \   000000A4   0x1E40             SUBS     R0,R0,#+1
   \   000000A6   0x8128             STRH     R0,[R5, #+8]
    395                              *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
   \   000000A8   0xF8CB 0x5000      STR      R5,[R11, #+0]
   \   000000AC   0xF11B 0x0B04      ADDS     R11,R11,#+4
    396                                events_rdy   =  OS_TRUE;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xF88D 0x0004      STRB     R0,[SP, #+4]
    397                              *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000000BC   0xF11A 0x0A04      ADDS     R10,R10,#+4
    398                                events_rdy_nbr++;
   \   000000C0   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000C4   0xE001             B.N      ??OSEventPendMulti_17
    399          
    400                           } else {
    401                                events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
   \                     ??OSEventPendMulti_16:
   \   000000C6   0xF059 0x0901      ORRS     R9,R9,#0x1
    402                           }
    403                           break;
   \                     ??OSEventPendMulti_17:
   \   000000CA   0xE044             B.N      ??OSEventPendMulti_18
    404          #endif
    405          
    406          #if (OS_MBOX_EN > 0u)
    407                      case OS_EVENT_TYPE_MBOX:
    408                           if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
   \                     ??OSEventPendMulti_12:
   \   000000CC   0x6868             LDR      R0,[R5, #+4]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD010             BEQ.N    ??OSEventPendMulti_19
    409                                                                  /* ... return available message,           ... */
    410                              *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
   \   000000D2   0x6868             LDR      R0,[R5, #+4]
   \   000000D4   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000000D8   0xF11A 0x0A04      ADDS     R10,R10,#+4
    411                               pevent->OSEventPtr  = (void *)0;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x6068             STR      R0,[R5, #+4]
    412                              *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
   \   000000E0   0xF8CB 0x5000      STR      R5,[R11, #+0]
   \   000000E4   0xF11B 0x0B04      ADDS     R11,R11,#+4
    413                                events_rdy         =  OS_TRUE;
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0xF88D 0x0004      STRB     R0,[SP, #+4]
    414                                events_rdy_nbr++;
   \   000000EE   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000F2   0xE001             B.N      ??OSEventPendMulti_20
    415          
    416                           } else {
    417                                events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
   \                     ??OSEventPendMulti_19:
   \   000000F4   0xF059 0x0902      ORRS     R9,R9,#0x2
    418                           }
    419                           break;
   \                     ??OSEventPendMulti_20:
   \   000000F8   0xE02D             B.N      ??OSEventPendMulti_18
    420          #endif
    421          
    422          #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
    423                      case OS_EVENT_TYPE_Q:
    424                           pq = (OS_Q *)pevent->OSEventPtr;
   \                     ??OSEventPendMulti_15:
   \   000000FA   0x6868             LDR      R0,[R5, #+4]
   \   000000FC   0x0006             MOVS     R6,R0
    425                           if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
   \   000000FE   0x8AF0             LDRH     R0,[R6, #+22]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD01A             BEQ.N    ??OSEventPendMulti_21
    426                                                                  /* ... return available message,           ... */
    427                              *pmsgs_rdy++ = (void *)*pq->OSQOut++;
   \   00000104   0x6930             LDR      R0,[R6, #+16]
   \   00000106   0x1D01             ADDS     R1,R0,#+4
   \   00000108   0x6131             STR      R1,[R6, #+16]
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   00000110   0xF11A 0x0A04      ADDS     R10,R10,#+4
    428                               if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
   \   00000114   0x6930             LDR      R0,[R6, #+16]
   \   00000116   0x68B1             LDR      R1,[R6, #+8]
   \   00000118   0x4288             CMP      R0,R1
   \   0000011A   0xD101             BNE.N    ??OSEventPendMulti_22
    429                                   pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
   \   0000011C   0x6870             LDR      R0,[R6, #+4]
   \   0000011E   0x6130             STR      R0,[R6, #+16]
    430                               }
    431                               pq->OSQEntries--;                  /* Update number of queue entries              */
   \                     ??OSEventPendMulti_22:
   \   00000120   0x8AF0             LDRH     R0,[R6, #+22]
   \   00000122   0x1E40             SUBS     R0,R0,#+1
   \   00000124   0x82F0             STRH     R0,[R6, #+22]
    432                              *pevents_rdy++ = pevent;            /* ... and return available queue event        */
   \   00000126   0xF8CB 0x5000      STR      R5,[R11, #+0]
   \   0000012A   0xF11B 0x0B04      ADDS     R11,R11,#+4
    433                                events_rdy   = OS_TRUE;
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0xF88D 0x0004      STRB     R0,[SP, #+4]
    434                                events_rdy_nbr++;
   \   00000134   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000138   0xE001             B.N      ??OSEventPendMulti_23
    435          
    436                           } else {
    437                                events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
   \                     ??OSEventPendMulti_21:
   \   0000013A   0xF059 0x0904      ORRS     R9,R9,#0x4
    438                           }
    439                           break;
   \                     ??OSEventPendMulti_23:
   \   0000013E   0xE00A             B.N      ??OSEventPendMulti_18
    440          #endif
    441          
    442                      case OS_EVENT_TYPE_MUTEX:
    443                      case OS_EVENT_TYPE_FLAG:
    444                      default:
    445                           OS_EXIT_CRITICAL();
   \                     ??OSEventPendMulti_13:
   \   00000140   0x9800             LDR      R0,[SP, #+0]
   \   00000142   0x.... 0x....      BL       OS_CPU_SR_Restore
    446                          *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0xF8CB 0x0000      STR      R0,[R11, #+0]
    447                          *perr        =  OS_ERR_EVENT_TYPE;
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0x7020             STRB     R0,[R4, #+0]
    448                           return (events_rdy_nbr);
   \   00000150   0x4640             MOV      R0,R8
   \   00000152   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000154   0xE0BE             B.N      ??OSEventPendMulti_7
    449                  }
    450                  pevents++;
   \                     ??OSEventPendMulti_18:
   \   00000156   0x1D3F             ADDS     R7,R7,#+4
    451                  pevent = *pevents;
   \   00000158   0x6838             LDR      R0,[R7, #+0]
   \   0000015A   0x0005             MOVS     R5,R0
   \   0000015C   0xE794             B.N      ??OSEventPendMulti_10
    452              }
    453          
    454              if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
   \                     ??OSEventPendMulti_11:
   \   0000015E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000162   0x2801             CMP      R0,#+1
   \   00000164   0xD10A             BNE.N    ??OSEventPendMulti_24
    455                 *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0xF8CB 0x0000      STR      R0,[R11, #+0]
    456                  OS_EXIT_CRITICAL();
   \   0000016C   0x9800             LDR      R0,[SP, #+0]
   \   0000016E   0x.... 0x....      BL       OS_CPU_SR_Restore
    457                 *perr        =  OS_ERR_NONE;
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x7020             STRB     R0,[R4, #+0]
    458                  return (events_rdy_nbr);
   \   00000176   0x4640             MOV      R0,R8
   \   00000178   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000017A   0xE0AB             B.N      ??OSEventPendMulti_7
    459              }
    460          /*$PAGE*/
    461                                                                  /* Otherwise, must wait until any event occurs */
    462              OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
    463                                         OS_STAT_MULTI;           /* ... pend on multiple events                 */
   \                     ??OSEventPendMulti_24:
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000180   0x6800             LDR      R0,[R0, #+0]
   \   00000182   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000186   0xF059 0x0180      ORRS     R1,R9,#0x80
   \   0000018A   0x4308             ORRS     R0,R1,R0
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000190   0x6809             LDR      R1,[R1, #+0]
   \   00000192   0xF881 0x0034      STRB     R0,[R1, #+52]
    464              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   0000019A   0x6800             LDR      R0,[R0, #+0]
   \   0000019C   0x2100             MOVS     R1,#+0
   \   0000019E   0xF880 0x1035      STRB     R1,[R0, #+53]
    465              OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0x9904             LDR      R1,[SP, #+16]
   \   000001AA   0x6301             STR      R1,[R0, #+48]
    466              OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
   \   000001AC   0x9803             LDR      R0,[SP, #+12]
   \   000001AE   0x.... 0x....      BL       OS_EventTaskWaitMulti
    467          
    468              OS_EXIT_CRITICAL();
   \   000001B2   0x9800             LDR      R0,[SP, #+0]
   \   000001B4   0x.... 0x....      BL       OS_CPU_SR_Restore
    469              OS_Sched();                                         /* Find next highest priority task ready       */
   \   000001B8   0x.... 0x....      BL       OS_Sched
    470              OS_ENTER_CRITICAL();
   \   000001BC   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000001C0   0x9000             STR      R0,[SP, #+0]
    471          
    472              switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000001C6   0x6800             LDR      R0,[R0, #+0]
   \   000001C8   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   000001CC   0x2800             CMP      R0,#+0
   \   000001CE   0xD001             BEQ.N    ??OSEventPendMulti_25
   \   000001D0   0x2802             CMP      R0,#+2
   \   000001D2   0xD11D             BNE.N    ??OSEventPendMulti_26
    473                  case OS_STAT_PEND_OK:
    474                  case OS_STAT_PEND_ABORT:
    475                       pevent = OSTCBCur->OSTCBEventPtr;
   \                     ??OSEventPendMulti_25:
   \   000001D4   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000001D8   0x6800             LDR      R0,[R0, #+0]
   \   000001DA   0x69C0             LDR      R0,[R0, #+28]
   \   000001DC   0x0005             MOVS     R5,R0
    476                       if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
   \   000001DE   0x2D00             CMP      R5,#+0
   \   000001E0   0xD009             BEQ.N    ??OSEventPendMulti_27
    477                          *pevents_rdy++ =  pevent;               /* ... return available event ...              */
   \   000001E2   0xF8CB 0x5000      STR      R5,[R11, #+0]
   \   000001E6   0xF11B 0x0B04      ADDS     R11,R11,#+4
    478                          *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
   \   000001EA   0x2000             MOVS     R0,#+0
   \   000001EC   0xF8CB 0x0000      STR      R0,[R11, #+0]
    479                            events_rdy_nbr++;
   \   000001F0   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000001F4   0xE00B             B.N      ??OSEventPendMulti_28
    480          
    481                       } else {                                   /* Else NO event available, handle as timeout  */
    482                           OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
   \                     ??OSEventPendMulti_27:
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000001FA   0x6800             LDR      R0,[R0, #+0]
   \   000001FC   0x2101             MOVS     R1,#+1
   \   000001FE   0xF880 0x1035      STRB     R1,[R0, #+53]
    483                           OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \   00000202   0x9903             LDR      R1,[SP, #+12]
   \   00000204   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000208   0x6800             LDR      R0,[R0, #+0]
   \   0000020A   0x.... 0x....      BL       OS_EventTaskRemoveMulti
    484                       }
    485          			 break;
   \                     ??OSEventPendMulti_28:
   \   0000020E   0xE005             B.N      ??OSEventPendMulti_29
    486          
    487                  case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
    488                  default:                                        /* ... remove task from events' wait lists     */
    489                       OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \                     ??OSEventPendMulti_26:
   \   00000210   0x9903             LDR      R1,[SP, #+12]
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000216   0x6800             LDR      R0,[R0, #+0]
   \   00000218   0x.... 0x....      BL       OS_EventTaskRemoveMulti
    490                       break;
    491              }
    492          
    493              switch (OSTCBCur->OSTCBStatPend) {
   \                     ??OSEventPendMulti_29:
   \   0000021C   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000220   0x6800             LDR      R0,[R0, #+0]
   \   00000222   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000226   0x2800             CMP      R0,#+0
   \   00000228   0xD002             BEQ.N    ??OSEventPendMulti_30
   \   0000022A   0x2802             CMP      R0,#+2
   \   0000022C   0xD023             BEQ.N    ??OSEventPendMulti_31
   \   0000022E   0xE02A             B.N      ??OSEventPendMulti_32
    494                  case OS_STAT_PEND_OK:
    495                       switch (pevent->OSEventType) {             /* Return event's message                      */
   \                     ??OSEventPendMulti_30:
   \   00000230   0x7828             LDRB     R0,[R5, #+0]
   \   00000232   0x1E40             SUBS     R0,R0,#+1
   \   00000234   0x2801             CMP      R0,#+1
   \   00000236   0xD907             BLS.N    ??OSEventPendMulti_33
   \   00000238   0x1E80             SUBS     R0,R0,#+2
   \   0000023A   0xD10E             BNE.N    ??OSEventPendMulti_34
    496          #if (OS_SEM_EN > 0u)
    497                           case OS_EVENT_TYPE_SEM:
    498                               *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
   \                     ??OSEventPendMulti_35:
   \   0000023C   0x2000             MOVS     R0,#+0
   \   0000023E   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   00000242   0xF11A 0x0A04      ADDS     R10,R10,#+4
    499                                break;
   \   00000246   0xE013             B.N      ??OSEventPendMulti_36
    500          #endif
    501          
    502          #if ((OS_MBOX_EN > 0u) ||                 \
    503              ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
    504                           case OS_EVENT_TYPE_MBOX:
    505                           case OS_EVENT_TYPE_Q:
    506                               *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
   \                     ??OSEventPendMulti_33:
   \   00000248   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   0000024C   0x6800             LDR      R0,[R0, #+0]
   \   0000024E   0x6A40             LDR      R0,[R0, #+36]
   \   00000250   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   00000254   0xF11A 0x0A04      ADDS     R10,R10,#+4
    507                                break;
   \   00000258   0xE00A             B.N      ??OSEventPendMulti_36
    508          #endif
    509          
    510                           case OS_EVENT_TYPE_MUTEX:
    511                           case OS_EVENT_TYPE_FLAG:
    512                           default:
    513                                OS_EXIT_CRITICAL();
   \                     ??OSEventPendMulti_34:
   \   0000025A   0x9800             LDR      R0,[SP, #+0]
   \   0000025C   0x.... 0x....      BL       OS_CPU_SR_Restore
    514                               *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0xF8CB 0x0000      STR      R0,[R11, #+0]
    515                               *perr        =  OS_ERR_EVENT_TYPE;
   \   00000266   0x2001             MOVS     R0,#+1
   \   00000268   0x7020             STRB     R0,[R4, #+0]
    516                                return (events_rdy_nbr);
   \   0000026A   0x4640             MOV      R0,R8
   \   0000026C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000026E   0xE031             B.N      ??OSEventPendMulti_7
    517                       }
    518                      *perr = OS_ERR_NONE;
   \                     ??OSEventPendMulti_36:
   \   00000270   0x2000             MOVS     R0,#+0
   \   00000272   0x7020             STRB     R0,[R4, #+0]
    519                       break;
   \   00000274   0xE00E             B.N      ??OSEventPendMulti_37
    520          
    521                  case OS_STAT_PEND_ABORT:
    522                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
   \                     ??OSEventPendMulti_31:
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   0000027C   0xF11A 0x0A04      ADDS     R10,R10,#+4
    523                      *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
   \   00000280   0x200E             MOVS     R0,#+14
   \   00000282   0x7020             STRB     R0,[R4, #+0]
    524                       break;
   \   00000284   0xE006             B.N      ??OSEventPendMulti_37
    525          
    526                  case OS_STAT_PEND_TO:
    527                  default:
    528                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
   \                     ??OSEventPendMulti_32:
   \   00000286   0x2000             MOVS     R0,#+0
   \   00000288   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   0000028C   0xF11A 0x0A04      ADDS     R10,R10,#+4
    529                      *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
   \   00000290   0x200A             MOVS     R0,#+10
   \   00000292   0x7020             STRB     R0,[R4, #+0]
    530                       break;
    531              }
    532          
    533              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
   \                     ??OSEventPendMulti_37:
   \   00000294   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000298   0x6800             LDR      R0,[R0, #+0]
   \   0000029A   0x2100             MOVS     R1,#+0
   \   0000029C   0xF880 0x1034      STRB     R1,[R0, #+52]
    534              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
   \   000002A0   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000002A4   0x6800             LDR      R0,[R0, #+0]
   \   000002A6   0x2100             MOVS     R1,#+0
   \   000002A8   0xF880 0x1035      STRB     R1,[R0, #+53]
    535              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
   \   000002AC   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000002B0   0x6800             LDR      R0,[R0, #+0]
   \   000002B2   0x2100             MOVS     R1,#+0
   \   000002B4   0x61C1             STR      R1,[R0, #+28]
    536              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   000002B6   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000002BA   0x6800             LDR      R0,[R0, #+0]
   \   000002BC   0x2100             MOVS     R1,#+0
   \   000002BE   0x6201             STR      R1,[R0, #+32]
    537          #if ((OS_MBOX_EN > 0u) ||                 \
    538              ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
    539              OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
   \   000002C0   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000002C4   0x6800             LDR      R0,[R0, #+0]
   \   000002C6   0x2100             MOVS     R1,#+0
   \   000002C8   0x6241             STR      R1,[R0, #+36]
    540          #endif
    541              OS_EXIT_CRITICAL();
   \   000002CA   0x9800             LDR      R0,[SP, #+0]
   \   000002CC   0x.... 0x....      BL       OS_CPU_SR_Restore
    542          
    543              return (events_rdy_nbr);
   \   000002D0   0x4640             MOV      R0,R8
   \   000002D2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSEventPendMulti_7:
   \   000002D4   0xB005             ADD      SP,SP,#+20
   \   000002D6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    544          }
    545          #endif
    546          
    547          /*$PAGE*/
    548          /*
    549          *********************************************************************************************************
    550          *                                             INITIALIZATION
    551          *
    552          * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
    553          *              creating any uC/OS-II object and, prior to calling OSStart().
    554          *
    555          * Arguments  : none
    556          *
    557          * Returns    : none
    558          *********************************************************************************************************
    559          */
    560          

   \                                 In section .text, align 2, keep-with-next
    561          void  OSInit (void)
    562          {
   \                     OSInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    563              OSInitHookBegin();                                           /* Call port specific initialization code   */
   \   00000002   0x.... 0x....      BL       OSInitHookBegin
    564          
    565              OS_InitMisc();                                               /* Initialize miscellaneous variables       */
   \   00000006   0x.... 0x....      BL       OS_InitMisc
    566          
    567              OS_InitRdyList();                                            /* Initialize the Ready List                */
   \   0000000A   0x.... 0x....      BL       OS_InitRdyList
    568          
    569              OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
   \   0000000E   0x.... 0x....      BL       OS_InitTCBList
    570          
    571              OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
   \   00000012   0x.... 0x....      BL       OS_InitEventList
    572          
    573          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
    574              OS_FlagInit();                                               /* Initialize the event flag structures     */
   \   00000016   0x.... 0x....      BL       OS_FlagInit
    575          #endif
    576          
    577          #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
    578              OS_MemInit();                                                /* Initialize the memory manager            */
   \   0000001A   0x.... 0x....      BL       OS_MemInit
    579          #endif
    580          
    581          #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
    582              OS_QInit();                                                  /* Initialize the message queue structures  */
   \   0000001E   0x.... 0x....      BL       OS_QInit
    583          #endif
    584          
    585              OS_InitTaskIdle();                                           /* Create the Idle Task                     */
   \   00000022   0x.... 0x....      BL       OS_InitTaskIdle
    586          #if OS_TASK_STAT_EN > 0u
    587              OS_InitTaskStat();                                           /* Create the Statistic Task                */
    588          #endif
    589          
    590          #if OS_TMR_EN > 0u
    591              OSTmr_Init();                                                /* Initialize the Timer Manager             */
    592          #endif
    593          
    594              OSInitHookEnd();                                             /* Call port specific init. code            */
   \   00000026   0x.... 0x....      BL       OSInitHookEnd
    595          
    596          #if OS_DEBUG_EN > 0u
    597              OSDebugInit();
    598          #endif
    599          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    600          /*$PAGE*/
    601          /*
    602          *********************************************************************************************************
    603          *                                              ENTER ISR
    604          *
    605          * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
    606          *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
    607          *              only perform rescheduling at the last nested ISR.
    608          *
    609          * Arguments  : none
    610          *
    611          * Returns    : none
    612          *
    613          * Notes      : 1) This function should be called ith interrupts already disabled
    614          *              2) Your ISR can directly increment OSIntNesting without calling this function because
    615          *                 OSIntNesting has been declared 'global'.
    616          *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
    617          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    618          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    619          *                 end of the ISR.
    620          *              5) You are allowed to nest interrupts up to 255 levels deep.
    621          *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
    622          *                 OSIntEnter() is always called with interrupts disabled.
    623          *********************************************************************************************************
    624          */
    625          

   \                                 In section .text, align 2, keep-with-next
    626          void  OSIntEnter (void)
    627          {
    628              if (OSRunning == OS_TRUE) {
   \                     OSIntEnter:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10B             BNE.N    ??OSIntEnter_0
    629                  if (OSIntNesting < 255u) {
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x28FF             CMP      R0,#+255
   \   00000012   0xD006             BEQ.N    ??OSIntEnter_0
    630                      OSIntNesting++;                      /* Increment ISR nesting level                        */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    631                  }
    632              }
    633          }
   \                     ??OSIntEnter_0:
   \   00000022   0x4770             BX       LR               ;; return
    634          /*$PAGE*/
    635          /*
    636          *********************************************************************************************************
    637          *                                               EXIT ISR
    638          *
    639          * Description: This function is used to notify uC/OS-II that you have completed serviving an ISR.  When
    640          *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
    641          *              a new, high-priority task, is ready to run.
    642          *
    643          * Arguments  : none
    644          *
    645          * Returns    : none
    646          *
    647          * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    648          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    649          *                 end of the ISR.
    650          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
    651          *********************************************************************************************************
    652          */
    653          

   \                                 In section .text, align 2, keep-with-next
    654          void  OSIntExit (void)
    655          {
   \                     OSIntExit:
   \   00000000   0xB510             PUSH     {R4,LR}
    656          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    657              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2400             MOVS     R4,#+0
    658          #endif
    659          
    660          
    661          
    662              if (OSRunning == OS_TRUE) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD141             BNE.N    ??OSIntExit_0
    663                  OS_ENTER_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000012   0x0004             MOVS     R4,R0
    664                  if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD006             BEQ.N    ??OSIntExit_1
    665                      OSIntNesting--;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    666                  }
    667                  if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
   \                     ??OSIntExit_1:
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD12A             BNE.N    ??OSIntExit_2
    668                      if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD125             BNE.N    ??OSIntExit_2
    669                          OS_SchedNew();
   \   00000040   0x.... 0x....      BL       OS_SchedNew
    670                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable20_5
   \   0000004E   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable20_6
   \   00000056   0x6008             STR      R0,[R1, #+0]
    671                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   00000062   0x7809             LDRB     R1,[R1, #+0]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD011             BEQ.N    ??OSIntExit_2
    672          #if OS_TASK_PROFILE_EN > 0u
    673                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x6BC0             LDR      R0,[R0, #+60]
   \   00000070   0x1C40             ADDS     R0,R0,#+1
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable20_6
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x63C8             STR      R0,[R1, #+60]
    674          #endif
    675                              OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   00000086   0x6008             STR      R0,[R1, #+0]
    676                              OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
   \   00000088   0x.... 0x....      BL       OSIntCtxSw
    677                          }
    678                      }
    679                  }
    680                  OS_EXIT_CRITICAL();
   \                     ??OSIntExit_2:
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       OS_CPU_SR_Restore
    681              }
    682          }
   \                     ??OSIntExit_0:
   \   00000092   0xBD10             POP      {R4,PC}          ;; return
    683          /*$PAGE*/
    684          /*
    685          *********************************************************************************************************
    686          *                                          PREVENT SCHEDULING
    687          *
    688          * Description: This function is used to prevent rescheduling to take place.  This allows your application
    689          *              to prevent context switches until you are ready to permit context switching.
    690          *
    691          * Arguments  : none
    692          *
    693          * Returns    : none
    694          *
    695          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    696          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    697          *********************************************************************************************************
    698          */
    699          
    700          #if OS_SCHED_LOCK_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    701          void  OSSchedLock (void)
    702          {
   \                     OSSchedLock:
   \   00000000   0xB510             PUSH     {R4,LR}
    703          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    704              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2400             MOVS     R4,#+0
    705          #endif
    706          
    707          
    708          
    709              if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD116             BNE.N    ??OSSchedLock_0
    710                  OS_ENTER_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000012   0x0004             MOVS     R4,R0
    711                  if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD10B             BNE.N    ??OSSchedLock_1
    712                      if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x28FF             CMP      R0,#+255
   \   00000026   0xD006             BEQ.N    ??OSSchedLock_1
    713                          OSLockNesting++;                 /* Increment lock nesting level                       */
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    714                      }
    715                  }
    716                  OS_EXIT_CRITICAL();
   \                     ??OSSchedLock_1:
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Restore
    717              }
    718          }
   \                     ??OSSchedLock_0:
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    719          #endif
    720          
    721          /*$PAGE*/
    722          /*
    723          *********************************************************************************************************
    724          *                                          ENABLE SCHEDULING
    725          *
    726          * Description: This function is used to re-allow rescheduling.
    727          *
    728          * Arguments  : none
    729          *
    730          * Returns    : none
    731          *
    732          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    733          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    734          *********************************************************************************************************
    735          */
    736          
    737          #if OS_SCHED_LOCK_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    738          void  OSSchedUnlock (void)
    739          {
   \                     OSSchedUnlock:
   \   00000000   0xB510             PUSH     {R4,LR}
    740          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    741              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2400             MOVS     R4,#+0
    742          #endif
    743          
    744          
    745          
    746              if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD129             BNE.N    ??OSSchedUnlock_0
    747                  OS_ENTER_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000012   0x0004             MOVS     R4,R0
    748                  if (OSLockNesting > 0u) {                          /* Do not decrement if already 0            */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD01E             BEQ.N    ??OSSchedUnlock_1
    749                      OSLockNesting--;                               /* Decrement lock nesting level             */
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    750                      if (OSLockNesting == 0u) {                     /* See if scheduler is enabled and ...      */
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD10E             BNE.N    ??OSSchedUnlock_2
    751                          if (OSIntNesting == 0u) {                  /* ... not in an ISR                        */
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD105             BNE.N    ??OSSchedUnlock_3
    752                              OS_EXIT_CRITICAL();
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       OS_CPU_SR_Restore
    753                              OS_Sched();                            /* See if a HPT is ready                    */
   \   00000046   0x.... 0x....      BL       OS_Sched
   \   0000004A   0xE00A             B.N      ??OSSchedUnlock_0
    754                          } else {
    755                              OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_3:
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000052   0xE006             B.N      ??OSSchedUnlock_0
    756                          }
    757                      } else {
    758                          OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_2:
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   0000005A   0xE002             B.N      ??OSSchedUnlock_0
    759                      }
    760                  } else {
    761                      OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_1:
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       OS_CPU_SR_Restore
    762                  }
    763              }
    764          }
   \                     ??OSSchedUnlock_0:
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    765          #endif
    766          
    767          /*$PAGE*/
    768          /*
    769          *********************************************************************************************************
    770          *                                          START MULTITASKING
    771          *
    772          * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
    773          *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
    774          *              and you MUST have created at least one task.
    775          *
    776          * Arguments  : none
    777          *
    778          * Returns    : none
    779          *
    780          * Note       : OSStartHighRdy() MUST:
    781          *                 a) Call OSTaskSwHook() then,
    782          *                 b) Set OSRunning to OS_TRUE.
    783          *                 c) Load the context of the task pointed to by OSTCBHighRdy.
    784          *                 d_ Execute the task.
    785          *********************************************************************************************************
    786          */
    787          

   \                                 In section .text, align 2, keep-with-next
    788          void  OSStart (void)
    789          {
   \                     OSStart:
   \   00000000   0xB580             PUSH     {R7,LR}
    790              if (OSRunning == OS_FALSE) {
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD119             BNE.N    ??OSStart_0
    791                  OS_SchedNew();                               /* Find highest priority's task priority number   */
   \   0000000C   0x.... 0x....      BL       OS_SchedNew
    792                  OSPrioCur     = OSPrioHighRdy;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
    793                  OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable20_5
   \   00000026   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable20_6
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    794                  OSTCBCur      = OSTCBHighRdy;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable20_6
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    795                  OSStartHighRdy();                            /* Execute target specific code to start task     */
   \   0000003C   0x.... 0x....      BL       OSStartHighRdy
    796              }
    797          }
   \                     ??OSStart_0:
   \   00000040   0xBD01             POP      {R0,PC}          ;; return
    798          /*$PAGE*/
    799          /*
    800          *********************************************************************************************************
    801          *                                        STATISTICS INITIALIZATION
    802          *
    803          * Description: This function is called by your application to establish CPU usage by first determining
    804          *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
    805          *              during that time.  CPU usage is then determined by a low priority task which keeps track
    806          *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
    807          *              determined by:
    808          *
    809          *                                             OSIdleCtr
    810          *                 CPU Usage (%) = 100 * (1 - ------------)
    811          *                                            OSIdleCtrMax
    812          *
    813          * Arguments  : none
    814          *
    815          * Returns    : none
    816          *********************************************************************************************************
    817          */
    818          
    819          #if OS_TASK_STAT_EN > 0u
    820          void  OSStatInit (void)
    821          {
    822          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    823              OS_CPU_SR  cpu_sr = 0u;
    824          #endif
    825          
    826          
    827          
    828              OSTimeDly(2);                                /* Synchronize with clock tick                        */
    829              OS_ENTER_CRITICAL();
    830              OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
    831              OS_EXIT_CRITICAL();
    832              OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
    833              OS_ENTER_CRITICAL();
    834              OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
    835              OSStatRdy    = OS_TRUE;
    836              OS_EXIT_CRITICAL();
    837          }
    838          #endif
    839          /*$PAGE*/
    840          /*
    841          *********************************************************************************************************
    842          *                                         PROCESS SYSTEM TICK
    843          *
    844          * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
    845          *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
    846          *              called by a high priority task.
    847          *
    848          * Arguments  : none
    849          *
    850          * Returns    : none
    851          *********************************************************************************************************
    852          */
    853          

   \                                 In section .text, align 2, keep-with-next
    854          void  OSTimeTick (void)
    855          {
   \                     OSTimeTick:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    856              OS_TCB    *ptcb;
    857          #if OS_TICK_STEP_EN > 0u
    858              BOOLEAN    step;
    859          #endif
    860          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
    861              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2600             MOVS     R6,#+0
    862          #endif
    863          
    864          
    865          
    866          #if OS_TIME_TICK_HOOK_EN > 0u
    867              OSTimeTickHook();                                      /* Call user definable hook                     */
   \   00000004   0x.... 0x....      BL       OSTimeTickHook
    868          #endif
    869          #if OS_TIME_GET_SET_EN > 0u
    870              OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
   \   00000008   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
    871              OSTime++;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20_9
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable20_9
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    872              OS_EXIT_CRITICAL();
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Restore
    873          #endif
    874              if (OSRunning == OS_TRUE) {
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD163             BNE.N    ??OSTimeTick_0
    875          #if OS_TICK_STEP_EN > 0u
    876                  switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable20_10
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD003             BEQ.N    ??OSTimeTick_1
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD007             BEQ.N    ??OSTimeTick_2
   \   0000003A   0xD303             BCC.N    ??OSTimeTick_3
   \   0000003C   0xE00C             B.N      ??OSTimeTick_4
    877                      case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
    878                           step = OS_TRUE;
   \                     ??OSTimeTick_1:
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x0005             MOVS     R5,R0
    879                           break;
   \   00000042   0xE00F             B.N      ??OSTimeTick_5
    880          
    881                      case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
    882                           step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
   \                     ??OSTimeTick_3:
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0005             MOVS     R5,R0
    883                           break;
   \   00000048   0xE00C             B.N      ??OSTimeTick_5
    884          
    885                      case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
    886                           step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
   \                     ??OSTimeTick_2:
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x0005             MOVS     R5,R0
    887                           OSTickStepState = OS_TICK_STEP_WAIT;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable20_10
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x7001             STRB     R1,[R0, #+0]
    888                           break;
   \   00000056   0xE005             B.N      ??OSTimeTick_5
    889          
    890                      default:                                       /* Invalid case, correct situation              */
    891                           step            = OS_TRUE;
   \                     ??OSTimeTick_4:
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x0005             MOVS     R5,R0
    892                           OSTickStepState = OS_TICK_STEP_DIS;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable20_10
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x7001             STRB     R1,[R0, #+0]
    893                           break;
    894                  }
    895                  if (step == OS_FALSE) {                            /* Return if waiting for step command           */
   \                     ??OSTimeTick_5:
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0xD044             BEQ.N    ??OSTimeTick_6
    896                      return;
    897                  }
    898          #endif
    899                  ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
   \                     ??OSTimeTick_7:
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable20_11
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x0004             MOVS     R4,R0
    900                  while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
   \                     ??OSTimeTick_8:
   \   00000072   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   00000076   0x281F             CMP      R0,#+31
   \   00000078   0xD03C             BEQ.N    ??OSTimeTick_0
    901                      OS_ENTER_CRITICAL();
   \   0000007A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000007E   0x0006             MOVS     R6,R0
    902                      if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
   \   00000080   0x6B20             LDR      R0,[R4, #+48]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD031             BEQ.N    ??OSTimeTick_9
    903                          ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
   \   00000086   0x6B20             LDR      R0,[R4, #+48]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x6320             STR      R0,[R4, #+48]
    904                          if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
   \   0000008C   0x6B20             LDR      R0,[R4, #+48]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD12B             BNE.N    ??OSTimeTick_9
    905          
    906                              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
   \   00000092   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000096   0x2137             MOVS     R1,#+55
   \   00000098   0x4208             TST      R0,R1
   \   0000009A   0xD009             BEQ.N    ??OSTimeTick_10
    907                                  ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
   \   0000009C   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   000000A0   0xF010 0x00C8      ANDS     R0,R0,#0xC8
   \   000000A4   0xF884 0x0034      STRB     R0,[R4, #+52]
    908                                  ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000AE   0xE002             B.N      ??OSTimeTick_11
    909                              } else {
    910                                  ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \                     ??OSTimeTick_10:
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF884 0x0035      STRB     R0,[R4, #+53]
    911                              }
    912          
    913                              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
   \                     ??OSTimeTick_11:
   \   000000B6   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   000000BA   0x0700             LSLS     R0,R0,#+28
   \   000000BC   0xD415             BMI.N    ??OSTimeTick_9
    914                                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0xF894 0x103A      LDRB     R1,[R4, #+58]
   \   000000C8   0x4308             ORRS     R0,R1,R0
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   000000CE   0x7008             STRB     R0,[R1, #+0]
    915                                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000000D0   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable20_13
   \   000000D8   0x5C40             LDRB     R0,[R0, R1]
   \   000000DA   0xF894 0x1039      LDRB     R1,[R4, #+57]
   \   000000DE   0x4308             ORRS     R0,R1,R0
   \   000000E0   0xF894 0x1038      LDRB     R1,[R4, #+56]
   \   000000E4   0x.... 0x....      LDR.W    R2,??DataTable20_13
   \   000000E8   0x5488             STRB     R0,[R1, R2]
    916                              }
    917                          }
    918                      }
    919                      ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
   \                     ??OSTimeTick_9:
   \   000000EA   0x6964             LDR      R4,[R4, #+20]
    920                      OS_EXIT_CRITICAL();
   \   000000EC   0x0030             MOVS     R0,R6
   \   000000EE   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   000000F2   0xE7BE             B.N      ??OSTimeTick_8
    921                  }
    922              }
    923          }
   \                     ??OSTimeTick_0:
   \                     ??OSTimeTick_6:
   \   000000F4   0xBD70             POP      {R4-R6,PC}       ;; return
    924          
    925          /*$PAGE*/
    926          /*
    927          *********************************************************************************************************
    928          *                                             GET VERSION
    929          *
    930          * Description: This function is used to return the version number of uC/OS-II.  The returned value
    931          *              corresponds to uC/OS-II's version number multiplied by 100.  In other words, version 2.00
    932          *              would be returned as 200.
    933          *
    934          * Arguments  : none
    935          *
    936          * Returns    : the version number of uC/OS-II multiplied by 100.
    937          *********************************************************************************************************
    938          */
    939          

   \                                 In section .text, align 2, keep-with-next
    940          INT16U  OSVersion (void)
    941          {
    942              return (OS_VERSION);
   \                     OSVersion:
   \   00000000   0xF240 0x1021      MOVW     R0,#+289
   \   00000004   0x4770             BX       LR               ;; return
    943          }
    944          
    945          /*$PAGE*/
    946          /*
    947          *********************************************************************************************************
    948          *                                            DUMMY FUNCTION
    949          *
    950          * Description: This function doesn't do anything.  It is called by OSTaskDel().
    951          *
    952          * Arguments  : none
    953          *
    954          * Returns    : none
    955          *********************************************************************************************************
    956          */
    957          
    958          #if OS_TASK_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    959          void  OS_Dummy (void)
    960          {
    961          }
   \                     OS_Dummy:
   \   00000000   0x4770             BX       LR               ;; return
    962          #endif
    963          
    964          /*$PAGE*/
    965          /*
    966          *********************************************************************************************************
    967          *                             MAKE TASK READY TO RUN BASED ON EVENT OCCURING
    968          *
    969          * Description: This function is called by other uC/OS-II services and is used to ready a task that was
    970          *              waiting for an event to occur.
    971          *
    972          * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
    973          *
    974          *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
    975          *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
    976          *                          service functions.
    977          *
    978          *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
    979          *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
    980          *
    981          *              pend_stat   is used to indicate the readied task's pending status:
    982          *
    983          *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
    984          *                                               an abort.
    985          *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
    986          *
    987          * Returns    : none
    988          *
    989          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
    990          *********************************************************************************************************
    991          */
    992          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
    993          INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
    994                                  void      *pmsg,
    995                                  INT8U      msk,
    996                                  INT8U      pend_stat)
    997          {
   \                     OS_EventTaskRdy:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    998              OS_TCB  *ptcb;
    999              INT8U    y;
   1000              INT8U    x;
   1001              INT8U    prio;
   1002          #if OS_LOWEST_PRIO > 63u
   1003              INT16U  *ptbl;
   1004          #endif
   1005          
   1006          
   1007          #if OS_LOWEST_PRIO <= 63u
   1008              y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
   \   0000000C   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   00000012   0x5C40             LDRB     R0,[R0, R1]
   \   00000014   0x4681             MOV      R9,R0
   1009              x    = OSUnMapTbl[pevent->OSEventTbl[y]];
   \   00000016   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000001A   0xEB19 0x0004      ADDS     R0,R9,R4
   \   0000001E   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   00000024   0x5C40             LDRB     R0,[R0, R1]
   \   00000026   0x4682             MOV      R10,R0
   1010              prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
   \   00000028   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000002C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000030   0xEB1A 0x00C9      ADDS     R0,R10,R9, LSL #+3
   \   00000034   0x4683             MOV      R11,R0
   1011          #else
   1012              if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
   1013                  y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
   1014              } else {
   1015                  y = OSUnMapTbl[(pevent->OSEventGrp >> 8u) & 0xFF] + 8u;
   1016              }
   1017              ptbl = &pevent->OSEventTbl[y];
   1018              if ((*ptbl & 0xFF) != 0u) {
   1019                  x = OSUnMapTbl[*ptbl & 0xFF];
   1020              } else {
   1021                  x = OSUnMapTbl[(*ptbl >> 8u) & 0xFF] + 8u;
   1022              }
   1023              prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
   1024          #endif
   1025          
   1026              ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
   \   00000036   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000003E   0xF850 0x002B      LDR      R0,[R0, R11, LSL #+2]
   \   00000042   0x4680             MOV      R8,R0
   1027              ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF8C8 0x0030      STR      R0,[R8, #+48]
   1028          #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
   1029              ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
   \   0000004A   0xF8C8 0x5024      STR      R5,[R8, #+36]
   1030          #else
   1031              pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
   1032          #endif
   1033              ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
   \   0000004E   0xF898 0x0034      LDRB     R0,[R8, #+52]
   \   00000052   0x43B0             BICS     R0,R0,R6
   \   00000054   0xF888 0x0034      STRB     R0,[R8, #+52]
   1034              ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
   \   00000058   0xF888 0x7035      STRB     R7,[R8, #+53]
   1035                                                                  /* See if task is ready (could be susp'd)      */
   1036              if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
   \   0000005C   0xF898 0x0034      LDRB     R0,[R8, #+52]
   \   00000060   0x0700             LSLS     R0,R0,#+28
   \   00000062   0xD417             BMI.N    ??OS_EventTaskRdy_0
   1037                  OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0xF898 0x103A      LDRB     R1,[R8, #+58]
   \   0000006E   0x4308             ORRS     R0,R1,R0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   00000074   0x7008             STRB     R0,[R1, #+0]
   1038                  OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
   \   00000076   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable20_13
   \   0000007E   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   00000082   0xF898 0x1039      LDRB     R1,[R8, #+57]
   \   00000086   0x4308             ORRS     R0,R1,R0
   \   00000088   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable20_13
   \   00000090   0xF809 0x0001      STRB     R0,[R9, R1]
   1039              }
   1040          
   1041              OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
   \                     ??OS_EventTaskRdy_0:
   \   00000094   0x0021             MOVS     R1,R4
   \   00000096   0x4640             MOV      R0,R8
   \   00000098   0x.... 0x....      BL       OS_EventTaskRemove
   1042          #if (OS_EVENT_MULTI_EN > 0u)
   1043              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
   \   0000009C   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD006             BEQ.N    ??OS_EventTaskRdy_1
   1044                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \   000000A4   0xF8D8 0x1020      LDR      R1,[R8, #+32]
   \   000000A8   0x4640             MOV      R0,R8
   \   000000AA   0x.... 0x....      BL       OS_EventTaskRemoveMulti
   1045                  ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
   \   000000AE   0xF8C8 0x401C      STR      R4,[R8, #+28]
   1046              }
   1047          #endif
   1048          
   1049              return (prio);
   \                     ??OS_EventTaskRdy_1:
   \   000000B2   0x4658             MOV      R0,R11
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1050          }
   1051          #endif
   1052          /*$PAGE*/
   1053          /*
   1054          *********************************************************************************************************
   1055          *                                   MAKE TASK WAIT FOR EVENT TO OCCUR
   1056          *
   1057          * Description: This function is called by other uC/OS-II services to suspend a task because an event has
   1058          *              not occurred.
   1059          *
   1060          * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
   1061          *
   1062          * Returns    : none
   1063          *
   1064          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1065          *********************************************************************************************************
   1066          */
   1067          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1068          void  OS_EventTaskWait (OS_EVENT *pevent)
   1069          {
   1070              INT8U  y;
   1071          
   1072          
   1073              OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
   \                     OS_EventTaskWait:
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x61D0             STR      R0,[R2, #+28]
   1074          
   1075              pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0xF892 0x2038      LDRB     R2,[R2, #+56]
   \   00000012   0x1812             ADDS     R2,R2,R0
   \   00000014   0x7AD2             LDRB     R2,[R2, #+11]
   \   00000016   0x.... 0x....      LDR.W    R3,??DataTable20_2
   \   0000001A   0x681B             LDR      R3,[R3, #+0]
   \   0000001C   0xF893 0x3039      LDRB     R3,[R3, #+57]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable20_2
   \   00000026   0x681B             LDR      R3,[R3, #+0]
   \   00000028   0xF893 0x3038      LDRB     R3,[R3, #+56]
   \   0000002C   0x181B             ADDS     R3,R3,R0
   \   0000002E   0x72DA             STRB     R2,[R3, #+11]
   1076              pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   00000030   0x7A82             LDRB     R2,[R0, #+10]
   \   00000032   0x.... 0x....      LDR.W    R3,??DataTable20_2
   \   00000036   0x681B             LDR      R3,[R3, #+0]
   \   00000038   0xF893 0x303A      LDRB     R3,[R3, #+58]
   \   0000003C   0x431A             ORRS     R2,R3,R2
   \   0000003E   0x7282             STRB     R2,[R0, #+10]
   1077          
   1078              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   00000044   0x6812             LDR      R2,[R2, #+0]
   \   00000046   0xF892 0x2038      LDRB     R2,[R2, #+56]
   \   0000004A   0x0011             MOVS     R1,R2
   1079              OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable20_13
   \   00000052   0x5C8A             LDRB     R2,[R1, R2]
   \   00000054   0x.... 0x....      LDR.W    R3,??DataTable20_2
   \   00000058   0x681B             LDR      R3,[R3, #+0]
   \   0000005A   0xF893 0x3039      LDRB     R3,[R3, #+57]
   \   0000005E   0x439A             BICS     R2,R2,R3
   \   00000060   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable20_13
   \   00000066   0x54CA             STRB     R2,[R1, R3]
   1080              if (OSRdyTbl[y] == 0u) {
   \   00000068   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable20_13
   \   0000006E   0x5C8A             LDRB     R2,[R1, R2]
   \   00000070   0x2A00             CMP      R2,#+0
   \   00000072   0xD10B             BNE.N    ??OS_EventTaskWait_0
   1081                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   \   00000074   0x.... 0x....      LDR.W    R2,??DataTable20_12
   \   00000078   0x7812             LDRB     R2,[R2, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R3,??DataTable20_2
   \   0000007E   0x681B             LDR      R3,[R3, #+0]
   \   00000080   0xF893 0x303A      LDRB     R3,[R3, #+58]
   \   00000084   0x439A             BICS     R2,R2,R3
   \   00000086   0x.... 0x....      LDR.W    R3,??DataTable20_12
   \   0000008A   0x701A             STRB     R2,[R3, #+0]
   1082              }
   1083          }
   \                     ??OS_EventTaskWait_0:
   \   0000008C   0x4770             BX       LR               ;; return
   1084          #endif
   1085          /*$PAGE*/
   1086          /*
   1087          *********************************************************************************************************
   1088          *                          MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
   1089          *
   1090          * Description: This function is called by other uC/OS-II services to suspend a task because any one of
   1091          *              multiple events has not occurred.
   1092          *
   1093          * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
   1094          *                               which the task will be waiting for.
   1095          *
   1096          * Returns    : none.
   1097          *
   1098          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1099          *********************************************************************************************************
   1100          */
   1101          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))

   \                                 In section .text, align 2, keep-with-next
   1102          void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
   1103          {
   \                     OS_EventTaskWaitMulti:
   \   00000000   0xB430             PUSH     {R4,R5}
   1104              OS_EVENT **pevents;
   1105              OS_EVENT  *pevent;
   1106              INT8U      y;
   1107          
   1108          
   1109              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable20_2
   \   00000006   0x6824             LDR      R4,[R4, #+0]
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x61E5             STR      R5,[R4, #+28]
   1110              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable20_2
   \   00000010   0x6824             LDR      R4,[R4, #+0]
   \   00000012   0x6220             STR      R0,[R4, #+32]
   1111          
   1112              pevents =  pevents_wait;
   \   00000014   0x0001             MOVS     R1,R0
   1113              pevent  = *pevents;
   \   00000016   0x680C             LDR      R4,[R1, #+0]
   \   00000018   0x0022             MOVS     R2,R4
   1114              while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
   \                     ??OS_EventTaskWaitMulti_0:
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD01F             BEQ.N    ??OS_EventTaskWaitMulti_1
   1115                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
   \   0000001E   0x.... 0x....      LDR.W    R4,??DataTable20_2
   \   00000022   0x6824             LDR      R4,[R4, #+0]
   \   00000024   0xF894 0x4038      LDRB     R4,[R4, #+56]
   \   00000028   0x18A4             ADDS     R4,R4,R2
   \   0000002A   0x7AE4             LDRB     R4,[R4, #+11]
   \   0000002C   0x.... 0x....      LDR.W    R5,??DataTable20_2
   \   00000030   0x682D             LDR      R5,[R5, #+0]
   \   00000032   0xF895 0x5039      LDRB     R5,[R5, #+57]
   \   00000036   0x432C             ORRS     R4,R5,R4
   \   00000038   0x.... 0x....      LDR.W    R5,??DataTable20_2
   \   0000003C   0x682D             LDR      R5,[R5, #+0]
   \   0000003E   0xF895 0x5038      LDRB     R5,[R5, #+56]
   \   00000042   0x18AD             ADDS     R5,R5,R2
   \   00000044   0x72EC             STRB     R4,[R5, #+11]
   1116                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   00000046   0x7A94             LDRB     R4,[R2, #+10]
   \   00000048   0x.... 0x....      LDR.W    R5,??DataTable20_2
   \   0000004C   0x682D             LDR      R5,[R5, #+0]
   \   0000004E   0xF895 0x503A      LDRB     R5,[R5, #+58]
   \   00000052   0x432C             ORRS     R4,R5,R4
   \   00000054   0x7294             STRB     R4,[R2, #+10]
   1117                  pevents++;
   \   00000056   0x1D09             ADDS     R1,R1,#+4
   1118                  pevent = *pevents;
   \   00000058   0x680C             LDR      R4,[R1, #+0]
   \   0000005A   0x0022             MOVS     R2,R4
   \   0000005C   0xE7DD             B.N      ??OS_EventTaskWaitMulti_0
   1119              }
   1120          
   1121              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \                     ??OS_EventTaskWaitMulti_1:
   \   0000005E   0x.... 0x....      LDR.W    R4,??DataTable20_2
   \   00000062   0x6824             LDR      R4,[R4, #+0]
   \   00000064   0xF894 0x4038      LDRB     R4,[R4, #+56]
   \   00000068   0x0023             MOVS     R3,R4
   1122              OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
   \   0000006A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000006C   0x.... 0x....      LDR.W    R4,??DataTable20_13
   \   00000070   0x5D1C             LDRB     R4,[R3, R4]
   \   00000072   0x.... 0x....      LDR.W    R5,??DataTable20_2
   \   00000076   0x682D             LDR      R5,[R5, #+0]
   \   00000078   0xF895 0x5039      LDRB     R5,[R5, #+57]
   \   0000007C   0x43AC             BICS     R4,R4,R5
   \   0000007E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000080   0x.... 0x....      LDR.W    R5,??DataTable20_13
   \   00000084   0x555C             STRB     R4,[R3, R5]
   1123              if (OSRdyTbl[y] == 0u) {
   \   00000086   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000088   0x.... 0x....      LDR.W    R4,??DataTable20_13
   \   0000008C   0x5D1C             LDRB     R4,[R3, R4]
   \   0000008E   0x2C00             CMP      R4,#+0
   \   00000090   0xD10B             BNE.N    ??OS_EventTaskWaitMulti_2
   1124                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   \   00000092   0x.... 0x....      LDR.W    R4,??DataTable20_12
   \   00000096   0x7824             LDRB     R4,[R4, #+0]
   \   00000098   0x.... 0x....      LDR.W    R5,??DataTable20_2
   \   0000009C   0x682D             LDR      R5,[R5, #+0]
   \   0000009E   0xF895 0x503A      LDRB     R5,[R5, #+58]
   \   000000A2   0x43AC             BICS     R4,R4,R5
   \   000000A4   0x.... 0x....      LDR.W    R5,??DataTable20_12
   \   000000A8   0x702C             STRB     R4,[R5, #+0]
   1125              }
   1126          }
   \                     ??OS_EventTaskWaitMulti_2:
   \   000000AA   0xBC30             POP      {R4,R5}
   \   000000AC   0x4770             BX       LR               ;; return
   1127          #endif
   1128          /*$PAGE*/
   1129          /*
   1130          *********************************************************************************************************
   1131          *                                   REMOVE TASK FROM EVENT WAIT LIST
   1132          *
   1133          * Description: Remove a task from an event's wait list.
   1134          *
   1135          * Arguments  : ptcb     is a pointer to the task to remove.
   1136          *
   1137          *              pevent   is a pointer to the event control block.
   1138          *
   1139          * Returns    : none
   1140          *
   1141          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1142          *********************************************************************************************************
   1143          */
   1144          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1145          void  OS_EventTaskRemove (OS_TCB   *ptcb,
   1146                                    OS_EVENT *pevent)
   1147          {
   \                     OS_EventTaskRemove:
   \   00000000   0xB410             PUSH     {R4}
   1148              INT8U  y;
   1149          
   1150          
   1151              y                       =  ptcb->OSTCBY;
   \   00000002   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000006   0x001A             MOVS     R2,R3
   1152              pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x1853             ADDS     R3,R2,R1
   \   0000000C   0x7ADB             LDRB     R3,[R3, #+11]
   \   0000000E   0xF890 0x4039      LDRB     R4,[R0, #+57]
   \   00000012   0x43A3             BICS     R3,R3,R4
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x1854             ADDS     R4,R2,R1
   \   00000018   0x72E3             STRB     R3,[R4, #+11]
   1153              if (pevent->OSEventTbl[y] == 0u) {
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0x1853             ADDS     R3,R2,R1
   \   0000001E   0x7ADB             LDRB     R3,[R3, #+11]
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD104             BNE.N    ??OS_EventTaskRemove_0
   1154                  pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
   \   00000024   0x7A8B             LDRB     R3,[R1, #+10]
   \   00000026   0xF890 0x403A      LDRB     R4,[R0, #+58]
   \   0000002A   0x43A3             BICS     R3,R3,R4
   \   0000002C   0x728B             STRB     R3,[R1, #+10]
   1155              }
   1156          }
   \                     ??OS_EventTaskRemove_0:
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
   1157          #endif
   1158          /*$PAGE*/
   1159          /*
   1160          *********************************************************************************************************
   1161          *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
   1162          *
   1163          * Description: Remove a task from multiple events' wait lists.
   1164          *
   1165          * Arguments  : ptcb             is a pointer to the task to remove.
   1166          *
   1167          *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
   1168          *
   1169          * Returns    : none
   1170          *
   1171          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1172          *********************************************************************************************************
   1173          */
   1174          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))

   \                                 In section .text, align 2, keep-with-next
   1175          void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
   1176                                         OS_EVENT **pevents_multi)
   1177          {
   \                     OS_EventTaskRemoveMulti:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1178              OS_EVENT **pevents;
   1179              OS_EVENT  *pevent;
   1180              INT8U      y;
   1181          #if (OS_LOWEST_PRIO <= 63u)
   1182              INT8U      bity;
   1183              INT8U      bitx;
   1184          #else
   1185              INT16U     bity;
   1186              INT16U     bitx;
   1187          #endif
   1188          
   1189          
   1190              y       =  ptcb->OSTCBY;
   \   00000002   0xF890 0x7038      LDRB     R7,[R0, #+56]
   \   00000006   0x003C             MOVS     R4,R7
   1191              bity    =  ptcb->OSTCBBitY;
   \   00000008   0xF890 0x703A      LDRB     R7,[R0, #+58]
   \   0000000C   0x003D             MOVS     R5,R7
   1192              bitx    =  ptcb->OSTCBBitX;
   \   0000000E   0xF890 0x7039      LDRB     R7,[R0, #+57]
   \   00000012   0x003E             MOVS     R6,R7
   1193              pevents =  pevents_multi;
   \   00000014   0x000A             MOVS     R2,R1
   1194              pevent  = *pevents;
   \   00000016   0x6817             LDR      R7,[R2, #+0]
   \   00000018   0x003B             MOVS     R3,R7
   1195              while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
   \                     ??OS_EventTaskRemoveMulti_0:
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD014             BEQ.N    ??OS_EventTaskRemoveMulti_1
   1196                  pevent->OSEventTbl[y]  &= ~bitx;
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x18E7             ADDS     R7,R4,R3
   \   00000022   0x7AFF             LDRB     R7,[R7, #+11]
   \   00000024   0x43B7             BICS     R7,R7,R6
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0xEB14 0x0C03      ADDS     R12,R4,R3
   \   0000002C   0xF88C 0x700B      STRB     R7,[R12, #+11]
   1197                  if (pevent->OSEventTbl[y] == 0u) {
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x18E7             ADDS     R7,R4,R3
   \   00000034   0x7AFF             LDRB     R7,[R7, #+11]
   \   00000036   0x2F00             CMP      R7,#+0
   \   00000038   0xD102             BNE.N    ??OS_EventTaskRemoveMulti_2
   1198                      pevent->OSEventGrp &= ~bity;
   \   0000003A   0x7A9F             LDRB     R7,[R3, #+10]
   \   0000003C   0x43AF             BICS     R7,R7,R5
   \   0000003E   0x729F             STRB     R7,[R3, #+10]
   1199                  }
   1200                  pevents++;
   \                     ??OS_EventTaskRemoveMulti_2:
   \   00000040   0x1D12             ADDS     R2,R2,#+4
   1201                  pevent = *pevents;
   \   00000042   0x6817             LDR      R7,[R2, #+0]
   \   00000044   0x003B             MOVS     R3,R7
   \   00000046   0xE7E8             B.N      ??OS_EventTaskRemoveMulti_0
   1202              }
   1203          }
   \                     ??OS_EventTaskRemoveMulti_1:
   \   00000048   0xBCF0             POP      {R4-R7}
   \   0000004A   0x4770             BX       LR               ;; return
   1204          #endif
   1205          /*$PAGE*/
   1206          /*
   1207          *********************************************************************************************************
   1208          *                                 INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
   1209          *
   1210          * Description: This function is called by other uC/OS-II services to initialize the event wait list.
   1211          *
   1212          * Arguments  : pevent    is a pointer to the event control block allocated to the event.
   1213          *
   1214          * Returns    : none
   1215          *
   1216          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1217          *********************************************************************************************************
   1218          */
   1219          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1220          void  OS_EventWaitListInit (OS_EVENT *pevent)
   1221          {
   1222          #if OS_LOWEST_PRIO <= 63u
   1223              INT8U  *ptbl;
   1224          #else
   1225              INT16U *ptbl;
   1226          #endif
   1227              INT8U   i;
   1228          
   1229          
   1230              pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
   \                     OS_EventWaitListInit:
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0x7283             STRB     R3,[R0, #+10]
   1231              ptbl               = &pevent->OSEventTbl[0];
   \   00000004   0xF200 0x030B      ADDW     R3,R0,#+11
   \   00000008   0x0019             MOVS     R1,R3
   1232          
   1233              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x001A             MOVS     R2,R3
   \                     ??OS_EventWaitListInit_0:
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x2A04             CMP      R2,#+4
   \   00000012   0xD204             BCS.N    ??OS_EventWaitListInit_1
   1234                  *ptbl++ = 0u;
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x700B             STRB     R3,[R1, #+0]
   \   00000018   0x1C49             ADDS     R1,R1,#+1
   1235              }
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0xE7F7             B.N      ??OS_EventWaitListInit_0
   1236          }
   \                     ??OS_EventWaitListInit_1:
   \   0000001E   0x4770             BX       LR               ;; return
   1237          #endif
   1238          /*$PAGE*/
   1239          /*
   1240          *********************************************************************************************************
   1241          *                                             INITIALIZATION
   1242          *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
   1243          *
   1244          * Description: This function is called by OSInit() to initialize the free list of event control blocks.
   1245          *
   1246          * Arguments  : none
   1247          *
   1248          * Returns    : none
   1249          *********************************************************************************************************
   1250          */
   1251          

   \                                 In section .text, align 2, keep-with-next
   1252          static  void  OS_InitEventList (void)
   1253          {
   \                     OS_InitEventList:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1254          #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
   1255          #if (OS_MAX_EVENTS > 1u)
   1256              INT16U     i;
   1257              OS_EVENT  *pevent1;
   1258              OS_EVENT  *pevent2;
   1259          
   1260          
   1261              OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
   \   00000002   0xF240 0x41EC      MOVW     R1,#+1260
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20_15
   \   0000000A   0x.... 0x....      BL       OS_MemClr
   1262              pevent1 = &OSEventTbl[0];
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20_15
   \   00000012   0x0004             MOVS     R4,R0
   1263              pevent2 = &OSEventTbl[1];
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable20_16
   \   00000018   0x0005             MOVS     R5,R0
   1264              for (i = 0u; i < (OS_MAX_EVENTS - 1u); i++) {           /* Init. list of free EVENT control blocks */
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0006             MOVS     R6,R0
   \                     ??OS_InitEventList_0:
   \   0000001E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000020   0x2E3E             CMP      R6,#+62
   \   00000022   0xD208             BCS.N    ??OS_InitEventList_1
   1265                  pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x7020             STRB     R0,[R4, #+0]
   1266                  pevent1->OSEventPtr     = pevent2;
   \   00000028   0x6065             STR      R5,[R4, #+4]
   1267          #if OS_EVENT_NAME_EN > 0u
   1268                  pevent1->OSEventName    = (INT8U *)"?";             /* Unknown name                            */
   \   0000002A   0x....             ADR.N    R0,??DataTable19  ;; "\?"
   \   0000002C   0x6120             STR      R0,[R4, #+16]
   1269          #endif
   1270                  pevent1++;
   \   0000002E   0x3414             ADDS     R4,R4,#+20
   1271                  pevent2++;
   \   00000030   0x3514             ADDS     R5,R5,#+20
   1272              }
   \   00000032   0x1C76             ADDS     R6,R6,#+1
   \   00000034   0xE7F3             B.N      ??OS_InitEventList_0
   1273              pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
   \                     ??OS_InitEventList_1:
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7020             STRB     R0,[R4, #+0]
   1274              pevent1->OSEventPtr             = (OS_EVENT *)0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6060             STR      R0,[R4, #+4]
   1275          #if OS_EVENT_NAME_EN > 0u
   1276              pevent1->OSEventName            = (INT8U *)"?";         /* Unknown name                            */
   \   0000003E   0x....             ADR.N    R0,??DataTable19  ;; "\?"
   \   00000040   0x6120             STR      R0,[R4, #+16]
   1277          #endif
   1278              OSEventFreeList                 = &OSEventTbl[0];
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable20_17
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable20_15
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   1279          #else
   1280              OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
   1281              OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
   1282              OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
   1283          #if OS_EVENT_NAME_EN > 0u
   1284              OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
   1285          #endif
   1286          #endif
   1287          #endif
   1288          }
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
   1289          /*$PAGE*/
   1290          /*
   1291          *********************************************************************************************************
   1292          *                                             INITIALIZATION
   1293          *                                    INITIALIZE MISCELLANEOUS VARIABLES
   1294          *
   1295          * Description: This function is called by OSInit() to initialize miscellaneous variables.
   1296          *
   1297          * Arguments  : none
   1298          *
   1299          * Returns    : none
   1300          *********************************************************************************************************
   1301          */
   1302          

   \                                 In section .text, align 2, keep-with-next
   1303          static  void  OS_InitMisc (void)
   1304          {
   1305          #if OS_TIME_GET_SET_EN > 0u
   1306              OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
   \                     OS_InitMisc:
   \   00000000   0x....             LDR.N    R0,??DataTable20_9
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
   1307          #endif
   1308          
   1309              OSIntNesting  = 0u;                                    /* Clear the interrupt nesting counter      */
   \   00000006   0x....             LDR.N    R0,??DataTable20
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
   1310              OSLockNesting = 0u;                                    /* Clear the scheduling lock counter        */
   \   0000000C   0x....             LDR.N    R0,??DataTable20_1
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7001             STRB     R1,[R0, #+0]
   1311          
   1312              OSTaskCtr     = 0u;                                    /* Clear the number of tasks                */
   \   00000012   0x....             LDR.N    R0,??DataTable20_18
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7001             STRB     R1,[R0, #+0]
   1313          
   1314              OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
   \   00000018   0x....             LDR.N    R0,??DataTable20_3
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x7001             STRB     R1,[R0, #+0]
   1315          
   1316              OSCtxSwCtr    = 0u;                                    /* Clear the context switch counter         */
   \   0000001E   0x....             LDR.N    R0,??DataTable20_8
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6001             STR      R1,[R0, #+0]
   1317              OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
   \   00000024   0x....             LDR.N    R0,??DataTable20_19
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x6001             STR      R1,[R0, #+0]
   1318          
   1319          #if OS_TASK_STAT_EN > 0u
   1320              OSIdleCtrRun  = 0L;
   1321              OSIdleCtrMax  = 0L;
   1322              OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
   1323          #endif
   1324          }
   \   0000002A   0x4770             BX       LR               ;; return
   1325          /*$PAGE*/
   1326          /*
   1327          *********************************************************************************************************
   1328          *                                             INITIALIZATION
   1329          *                                       INITIALIZE THE READY LIST
   1330          *
   1331          * Description: This function is called by OSInit() to initialize the Ready List.
   1332          *
   1333          * Arguments  : none
   1334          *
   1335          * Returns    : none
   1336          *********************************************************************************************************
   1337          */
   1338          

   \                                 In section .text, align 2, keep-with-next
   1339          static  void  OS_InitRdyList (void)
   1340          {
   1341              INT8U    i;
   1342          #if OS_LOWEST_PRIO <= 63u
   1343              INT8U   *prdytbl;
   1344          #else
   1345              INT16U  *prdytbl;
   1346          #endif
   1347          
   1348          
   1349              OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
   \                     OS_InitRdyList:
   \   00000000   0x....             LDR.N    R2,??DataTable20_12
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x7013             STRB     R3,[R2, #+0]
   1350              prdytbl       = &OSRdyTbl[0];
   \   00000006   0x....             LDR.N    R2,??DataTable20_13
   \   00000008   0x0010             MOVS     R0,R2
   1351              for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0011             MOVS     R1,R2
   \                     ??OS_InitRdyList_0:
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD204             BCS.N    ??OS_InitRdyList_1
   1352                  *prdytbl++ = 0u;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x7002             STRB     R2,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   1353              }
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0xE7F7             B.N      ??OS_InitRdyList_0
   1354          
   1355              OSPrioCur     = 0u;
   \                     ??OS_InitRdyList_1:
   \   0000001E   0x....             LDR.N    R2,??DataTable20_7
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x7013             STRB     R3,[R2, #+0]
   1356              OSPrioHighRdy = 0u;
   \   00000024   0x....             LDR.N    R2,??DataTable20_4
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x7013             STRB     R3,[R2, #+0]
   1357          
   1358              OSTCBHighRdy  = (OS_TCB *)0;
   \   0000002A   0x....             LDR.N    R2,??DataTable20_6
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x6013             STR      R3,[R2, #+0]
   1359              OSTCBCur      = (OS_TCB *)0;
   \   00000030   0x....             LDR.N    R2,??DataTable20_2
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x6013             STR      R3,[R2, #+0]
   1360          }
   \   00000036   0x4770             BX       LR               ;; return
   1361          
   1362          /*$PAGE*/
   1363          /*
   1364          *********************************************************************************************************
   1365          *                                             INITIALIZATION
   1366          *                                         CREATING THE IDLE TASK
   1367          *
   1368          * Description: This function creates the Idle Task.
   1369          *
   1370          * Arguments  : none
   1371          *
   1372          * Returns    : none
   1373          *********************************************************************************************************
   1374          */
   1375          

   \                                 In section .text, align 2, keep-with-next
   1376          static  void  OS_InitTaskIdle (void)
   1377          {
   \                     OS_InitTaskIdle:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1378          #if OS_TASK_NAME_EN > 0u
   1379              INT8U  err;
   1380          #endif
   1381          
   1382          
   1383          #if OS_TASK_CREATE_EXT_EN > 0u
   1384              #if OS_STK_GROWTH == 1u
   1385              (void)OSTaskCreateExt(OS_TaskIdle,
   1386                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1387                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
   1388                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1389                                    OS_TASK_IDLE_ID,
   1390                                    &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
   1391                                    OS_TASK_IDLE_STK_SIZE,
   1392                                    (void *)0,                                 /* No TCB extension                     */
   1393                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   \   00000004   0x2003             MOVS     R0,#+3
   \   00000006   0x9004             STR      R0,[SP, #+16]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0xF44F 0x7080      MOV      R0,#+256
   \   00000010   0x9002             STR      R0,[SP, #+8]
   \   00000012   0x....             LDR.N    R0,??DataTable20_20
   \   00000014   0x9001             STR      R0,[SP, #+4]
   \   00000016   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x231F             MOVS     R3,#+31
   \   0000001E   0x....             LDR.N    R2,??DataTable20_21
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x.... 0x....      ADR.W    R0,OS_TaskIdle
   \   00000026   0x.... 0x....      BL       OSTaskCreateExt
   1394              #else
   1395              (void)OSTaskCreateExt(OS_TaskIdle,
   1396                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1397                                    &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
   1398                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1399                                    OS_TASK_IDLE_ID,
   1400                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
   1401                                    OS_TASK_IDLE_STK_SIZE,
   1402                                    (void *)0,                                 /* No TCB extension                     */
   1403                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1404              #endif
   1405          #else
   1406              #if OS_STK_GROWTH == 1u
   1407              (void)OSTaskCreate(OS_TaskIdle,
   1408                                 (void *)0,
   1409                                 &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
   1410                                 OS_TASK_IDLE_PRIO);
   1411              #else
   1412              (void)OSTaskCreate(OS_TaskIdle,
   1413                                 (void *)0,
   1414                                 &OSTaskIdleStk[0],
   1415                                 OS_TASK_IDLE_PRIO);
   1416              #endif
   1417          #endif
   1418          
   1419          #if OS_TASK_NAME_EN > 0u
   1420              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
   1421          #endif
   1422          }
   \   0000002A   0xB005             ADD      SP,SP,#+20
   \   0000002C   0xBD00             POP      {PC}             ;; return
   1423          /*$PAGE*/
   1424          /*
   1425          *********************************************************************************************************
   1426          *                                             INITIALIZATION
   1427          *                                      CREATING THE STATISTIC TASK
   1428          *
   1429          * Description: This function creates the Statistic Task.
   1430          *
   1431          * Arguments  : none
   1432          *
   1433          * Returns    : none
   1434          *********************************************************************************************************
   1435          */
   1436          
   1437          #if OS_TASK_STAT_EN > 0u
   1438          static  void  OS_InitTaskStat (void)
   1439          {
   1440          #if OS_TASK_NAME_EN > 0u
   1441              INT8U  err;
   1442          #endif
   1443          
   1444          
   1445          #if OS_TASK_CREATE_EXT_EN > 0u
   1446              #if OS_STK_GROWTH == 1u
   1447              (void)OSTaskCreateExt(OS_TaskStat,
   1448                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1449                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
   1450                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1451                                    OS_TASK_STAT_ID,
   1452                                    &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
   1453                                    OS_TASK_STAT_STK_SIZE,
   1454                                    (void *)0,                                   /* No TCB extension               */
   1455                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1456              #else
   1457              (void)OSTaskCreateExt(OS_TaskStat,
   1458                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1459                                    &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
   1460                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1461                                    OS_TASK_STAT_ID,
   1462                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
   1463                                    OS_TASK_STAT_STK_SIZE,
   1464                                    (void *)0,                                   /* No TCB extension               */
   1465                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1466              #endif
   1467          #else
   1468              #if OS_STK_GROWTH == 1u
   1469              (void)OSTaskCreate(OS_TaskStat,
   1470                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1471                                 &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
   1472                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1473              #else
   1474              (void)OSTaskCreate(OS_TaskStat,
   1475                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1476                                 &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
   1477                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1478              #endif
   1479          #endif
   1480          
   1481          #if OS_TASK_NAME_EN > 0u
   1482              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
   1483          #endif
   1484          }
   1485          #endif
   1486          /*$PAGE*/
   1487          /*
   1488          *********************************************************************************************************
   1489          *                                             INITIALIZATION
   1490          *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
   1491          *
   1492          * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
   1493          *
   1494          * Arguments  : none
   1495          *
   1496          * Returns    : none
   1497          *********************************************************************************************************
   1498          */
   1499          

   \                                 In section .text, align 2, keep-with-next
   1500          static  void  OS_InitTCBList (void)
   1501          {
   \                     OS_InitTCBList:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1502              INT8U    i;
   1503              OS_TCB  *ptcb1;
   1504              OS_TCB  *ptcb2;
   1505          
   1506          
   1507              OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
   \   00000002   0xF44F 0x61A8      MOV      R1,#+1344
   \   00000006   0x....             LDR.N    R0,??DataTable20_22
   \   00000008   0x.... 0x....      BL       OS_MemClr
   1508              OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x....             LDR.N    R0,??DataTable20_5
   \   00000010   0x.... 0x....      BL       OS_MemClr
   1509              ptcb1 = &OSTCBTbl[0];
   \   00000014   0x....             LDR.N    R0,??DataTable20_22
   \   00000016   0x0004             MOVS     R4,R0
   1510              ptcb2 = &OSTCBTbl[1];
   \   00000018   0x....             LDR.N    R0,??DataTable20_23
   \   0000001A   0x0005             MOVS     R5,R0
   1511              for (i = 0u; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); i++) {/* Init. list of free TCBs            */
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0006             MOVS     R6,R0
   \                     ??OS_InitTCBList_0:
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0x2E0F             CMP      R6,#+15
   \   00000024   0xD204             BCS.N    ??OS_InitTCBList_1
   1512                  ptcb1->OSTCBNext = ptcb2;
   \   00000026   0x6165             STR      R5,[R4, #+20]
   1513          #if OS_TASK_NAME_EN > 0u
   1514                  ptcb1->OSTCBTaskName = (INT8U *)"?";                     /* Unknown name                       */
   1515          #endif
   1516                  ptcb1++;
   \   00000028   0x3454             ADDS     R4,R4,#+84
   1517                  ptcb2++;
   \   0000002A   0x3554             ADDS     R5,R5,#+84
   1518              }
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   \   0000002E   0xE7F7             B.N      ??OS_InitTCBList_0
   1519              ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
   \                     ??OS_InitTCBList_1:
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6160             STR      R0,[R4, #+20]
   1520          #if OS_TASK_NAME_EN > 0u
   1521              ptcb1->OSTCBTaskName    = (INT8U *)"?";                      /* Unknown name                       */
   1522          #endif
   1523              OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
   \   00000034   0x....             LDR.N    R0,??DataTable20_11
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6001             STR      R1,[R0, #+0]
   1524              OSTCBFreeList           = &OSTCBTbl[0];
   \   0000003A   0x....             LDR.N    R0,??DataTable20_24
   \   0000003C   0x....             LDR.N    R1,??DataTable20_22
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   1525          }
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
   1526          /*$PAGE*/
   1527          /*
   1528          *********************************************************************************************************
   1529          *                                        CLEAR A SECTION OF MEMORY
   1530          *
   1531          * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
   1532          *
   1533          * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
   1534          *
   1535          *              size     is the number of bytes to clear.
   1536          *
   1537          * Returns    : none
   1538          *
   1539          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1540          *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
   1541          *                 of the uses of this function gets close to this limit.
   1542          *              3) The clear is done one byte at a time since this will work on any processor irrespective
   1543          *                 of the alignment of the destination.
   1544          *********************************************************************************************************
   1545          */
   1546          

   \                                 In section .text, align 2, keep-with-next
   1547          void  OS_MemClr (INT8U  *pdest,
   1548                           INT16U  size)
   1549          {
   1550              while (size > 0u) {
   \                     OS_MemClr:
   \                     ??OS_MemClr_0:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??OS_MemClr_1
   1551                  *pdest++ = (INT8U)0;
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x7002             STRB     R2,[R0, #+0]
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   1552                  size--;
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
   \   0000000E   0xE7F7             B.N      ??OS_MemClr_0
   1553              }
   1554          }
   \                     ??OS_MemClr_1:
   \   00000010   0x4770             BX       LR               ;; return
   1555          /*$PAGE*/
   1556          /*
   1557          *********************************************************************************************************
   1558          *                                        COPY A BLOCK OF MEMORY
   1559          *
   1560          * Description: This function is called by other uC/OS-II services to copy a block of memory from one
   1561          *              location to another.
   1562          *
   1563          * Arguments  : pdest    is a pointer to the 'destination' memory block
   1564          *
   1565          *              psrc     is a pointer to the 'source'      memory block
   1566          *
   1567          *              size     is the number of bytes to copy.
   1568          *
   1569          * Returns    : none
   1570          *
   1571          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
   1572          *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
   1573          *                 is not a situation that will happen.
   1574          *              2) Note that we can only copy up to 64K bytes of RAM
   1575          *              3) The copy is done one byte at a time since this will work on any processor irrespective
   1576          *                 of the alignment of the source and destination.
   1577          *********************************************************************************************************
   1578          */
   1579          

   \                                 In section .text, align 2, keep-with-next
   1580          void  OS_MemCopy (INT8U  *pdest,
   1581                            INT8U  *psrc,
   1582                            INT16U  size)
   1583          {
   1584              while (size > 0u) {
   \                     OS_MemCopy:
   \                     ??OS_MemCopy_0:
   \   00000000   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD005             BEQ.N    ??OS_MemCopy_1
   1585                  *pdest++ = *psrc++;
   \   00000006   0x780B             LDRB     R3,[R1, #+0]
   \   00000008   0x7003             STRB     R3,[R0, #+0]
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   1586                  size--;
   \   0000000E   0x1E52             SUBS     R2,R2,#+1
   \   00000010   0xE7F6             B.N      ??OS_MemCopy_0
   1587              }
   1588          }
   \                     ??OS_MemCopy_1:
   \   00000012   0x4770             BX       LR               ;; return
   1589          /*$PAGE*/
   1590          /*
   1591          *********************************************************************************************************
   1592          *                                              SCHEDULER
   1593          *
   1594          * Description: This function is called by other uC/OS-II services to determine whether a new, high
   1595          *              priority task has been made ready to run.  This function is invoked by TASK level code
   1596          *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
   1597          *
   1598          * Arguments  : none
   1599          *
   1600          * Returns    : none
   1601          *
   1602          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1603          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
   1604          *********************************************************************************************************
   1605          */
   1606          

   \                                 In section .text, align 2, keep-with-next
   1607          void  OS_Sched (void)
   1608          {
   \                     OS_Sched:
   \   00000000   0xB510             PUSH     {R4,LR}
   1609          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
   1610              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2400             MOVS     R4,#+0
   1611          #endif
   1612          
   1613          
   1614          
   1615              OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000008   0x0004             MOVS     R4,R0
   1616              if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
   \   0000000A   0x....             LDR.N    R0,??DataTable20
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD120             BNE.N    ??OS_Sched_0
   1617                  if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
   \   00000012   0x....             LDR.N    R0,??DataTable20_1
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD11C             BNE.N    ??OS_Sched_0
   1618                      OS_SchedNew();
   \   0000001A   0x.... 0x....      BL       OS_SchedNew
   1619                      OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
   \   0000001E   0x....             LDR.N    R0,??DataTable20_4
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x....             LDR.N    R1,??DataTable20_5
   \   00000024   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000028   0x....             LDR.N    R1,??DataTable20_6
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1620                      if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
   \   0000002C   0x....             LDR.N    R0,??DataTable20_4
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x....             LDR.N    R1,??DataTable20_7
   \   00000032   0x7809             LDRB     R1,[R1, #+0]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD00D             BEQ.N    ??OS_Sched_0
   1621          #if OS_TASK_PROFILE_EN > 0u
   1622                          OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
   \   00000038   0x....             LDR.N    R0,??DataTable20_6
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x....             LDR.N    R1,??DataTable20_6
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x63C8             STR      R0,[R1, #+60]
   1623          #endif
   1624                          OSCtxSwCtr++;                          /* Increment context switch counter             */
   \   00000046   0x....             LDR.N    R0,??DataTable20_8
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x....             LDR.N    R1,??DataTable20_8
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1625                          OS_TASK_SW();                          /* Perform a context switch                     */
   \   00000050   0x.... 0x....      BL       OSCtxSw
   1626                      }
   1627                  }
   1628              }
   1629              OS_EXIT_CRITICAL();
   \                     ??OS_Sched_0:
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
   1630          }
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
   1631          
   1632          
   1633          /*
   1634          *********************************************************************************************************
   1635          *                              FIND HIGHEST PRIORITY TASK READY TO RUN
   1636          *
   1637          * Description: This function is called by other uC/OS-II services to determine the highest priority task
   1638          *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
   1639          *
   1640          * Arguments  : none
   1641          *
   1642          * Returns    : none
   1643          *
   1644          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1645          *              2) Interrupts are assumed to be disabled when this function is called.
   1646          *********************************************************************************************************
   1647          */
   1648          

   \                                 In section .text, align 2, keep-with-next
   1649          static  void  OS_SchedNew (void)
   1650          {
   1651          #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
   1652              INT8U   y;
   1653          
   1654          
   1655              y             = OSUnMapTbl[OSRdyGrp];
   \                     OS_SchedNew:
   \   00000000   0x....             LDR.N    R1,??DataTable20_12
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x....             LDR.N    R2,??DataTable20_14
   \   00000006   0x5C89             LDRB     R1,[R1, R2]
   \   00000008   0x0008             MOVS     R0,R1
   1656              OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x....             LDR.N    R1,??DataTable20_13
   \   00000010   0x5C41             LDRB     R1,[R0, R1]
   \   00000012   0x....             LDR.N    R2,??DataTable20_14
   \   00000014   0x5C89             LDRB     R1,[R1, R2]
   \   00000016   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \   0000001A   0x....             LDR.N    R2,??DataTable20_4
   \   0000001C   0x7011             STRB     R1,[R2, #+0]
   1657          #else                                            /* We support up to 256 tasks                         */
   1658              INT8U   y;
   1659              INT16U *ptbl;
   1660          
   1661          
   1662              if ((OSRdyGrp & 0xFFu) != 0u) {
   1663                  y = OSUnMapTbl[OSRdyGrp & 0xFFu];
   1664              } else {
   1665                  y = OSUnMapTbl[(OSRdyGrp >> 8u) & 0xFFu] + 8u;
   1666              }
   1667              ptbl = &OSRdyTbl[y];
   1668              if ((*ptbl & 0xFFu) != 0u) {
   1669                  OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
   1670              } else {
   1671                  OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl >> 8u) & 0xFFu] + 8u);
   1672              }
   1673          #endif
   1674          }
   \   0000001E   0x4770             BX       LR               ;; return
   1675          
   1676          /*$PAGE*/
   1677          /*
   1678          *********************************************************************************************************
   1679          *                                DETERMINE THE LENGTH OF AN ASCII STRING
   1680          *
   1681          * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
   1682          *              (excluding the NUL character).
   1683          *
   1684          * Arguments  : psrc     is a pointer to the string for which we need to know the size.
   1685          *
   1686          * Returns    : The size of the string (excluding the NUL terminating character)
   1687          *
   1688          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1689          *              2) The string to check must be less than 255 characters long.
   1690          *********************************************************************************************************
   1691          */
   1692          
   1693          #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   1694          INT8U  OS_StrLen (INT8U *psrc)
   1695          {
   \                     OS_StrLen:
   \   00000000   0x0001             MOVS     R1,R0
   1696              INT8U  len;
   1697          
   1698          
   1699              len = 0u;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x0010             MOVS     R0,R2
   1700              while (*psrc != OS_ASCII_NUL) {
   \                     ??OS_StrLen_0:
   \   00000006   0x780A             LDRB     R2,[R1, #+0]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD002             BEQ.N    ??OS_StrLen_1
   1701                  psrc++;
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   1702                  len++;
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0xE7F9             B.N      ??OS_StrLen_0
   1703              }
   1704              return (len);
   \                     ??OS_StrLen_1:
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1705          }
   1706          #endif
   1707          /*$PAGE*/
   1708          /*
   1709          *********************************************************************************************************
   1710          *                                              IDLE TASK
   1711          *
   1712          * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
   1713          *              executes because they are ALL waiting for event(s) to occur.
   1714          *
   1715          * Arguments  : none
   1716          *
   1717          * Returns    : none
   1718          *
   1719          * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
   1720          *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
   1721          *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
   1722          *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
   1723          *                 interrupts.
   1724          *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
   1725          *                 power.
   1726          *********************************************************************************************************
   1727          */
   1728          

   \                                 In section .text, align 4, keep-with-next
   1729          void  OS_TaskIdle (void *p_arg)
   1730          {
   \                     OS_TaskIdle:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1731          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1732              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2500             MOVS     R5,#+0
   1733          #endif
   1734          
   1735          
   1736          
   1737              (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
   1738              for (;;) {
   1739                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskIdle_0:
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   1740                  OSIdleCtr++;
   \   0000000C   0x....             LDR.N    R0,??DataTable20_19
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable20_19
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1741                  OS_EXIT_CRITICAL();
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       OS_CPU_SR_Restore
   1742                  OSTaskIdleHook();                        /* Call user definable HOOK                           */
   \   0000001C   0x.... 0x....      BL       OSTaskIdleHook
   \   00000020   0xE7F1             B.N      ??OS_TaskIdle_0
   1743              }
   1744          }
   1745          /*$PAGE*/
   1746          /*
   1747          *********************************************************************************************************
   1748          *                                            STATISTICS TASK
   1749          *
   1750          * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
   1751          *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
   1752          *              CPU usage is determined by:
   1753          *
   1754          *                                          OSIdleCtr
   1755          *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
   1756          *                                         OSIdleCtrMax
   1757          *
   1758          * Arguments  : parg     this pointer is not used at this time.
   1759          *
   1760          * Returns    : none
   1761          *
   1762          * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
   1763          *                 next higher priority, OS_TASK_IDLE_PRIO-1.
   1764          *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
   1765          *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
   1766          *                 maximum value for the idle counter.
   1767          *********************************************************************************************************
   1768          */
   1769          
   1770          #if OS_TASK_STAT_EN > 0u
   1771          void  OS_TaskStat (void *p_arg)
   1772          {
   1773          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1774              OS_CPU_SR  cpu_sr = 0u;
   1775          #endif
   1776          
   1777          
   1778          
   1779              (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
   1780              while (OSStatRdy == OS_FALSE) {
   1781                  OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
   1782              }
   1783              OSIdleCtrMax /= 100L;
   1784              if (OSIdleCtrMax == 0L) {
   1785                  OSCPUUsage = 0u;
   1786          #if OS_TASK_SUSPEND_EN > 0u
   1787                  (void)OSTaskSuspend(OS_PRIO_SELF);
   1788          #else
   1789                  for (;;) {
   1790                      OSTimeDly(OS_TICKS_PER_SEC);
   1791                  }
   1792          #endif
   1793              }
   1794              for (;;) {
   1795                  OS_ENTER_CRITICAL();
   1796                  OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
   1797                  OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
   1798                  OS_EXIT_CRITICAL();
   1799                  OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
   1800                  OSTaskStatHook();                        /* Invoke user definable hook                         */
   1801          #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
   1802                  OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
   1803          #endif
   1804                  OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
   1805              }
   1806          }
   1807          #endif
   1808          /*$PAGE*/
   1809          /*
   1810          *********************************************************************************************************
   1811          *                                      CHECK ALL TASK STACKS
   1812          *
   1813          * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
   1814          *
   1815          * Arguments  : none
   1816          *
   1817          * Returns    : none
   1818          *********************************************************************************************************
   1819          */
   1820          
   1821          #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
   1822          void  OS_TaskStatStkChk (void)
   1823          {
   1824              OS_TCB      *ptcb;
   1825              OS_STK_DATA  stk_data;
   1826              INT8U        err;
   1827              INT8U        prio;
   1828          
   1829          
   1830              for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
   1831                  err = OSTaskStkChk(prio, &stk_data);
   1832                  if (err == OS_ERR_NONE) {
   1833                      ptcb = OSTCBPrioTbl[prio];
   1834                      if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
   1835                          if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
   1836          #if OS_TASK_PROFILE_EN > 0u
   1837                              #if OS_STK_GROWTH == 1u
   1838                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
   1839                              #else
   1840                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
   1841                              #endif
   1842                              ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
   1843          #endif
   1844                          }
   1845                      }
   1846                  }
   1847              }
   1848          }
   1849          #endif
   1850          /*$PAGE*/
   1851          /*
   1852          *********************************************************************************************************
   1853          *                                            INITIALIZE TCB
   1854          *
   1855          * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
   1856          *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
   1857          *
   1858          * Arguments  : prio          is the priority of the task being created
   1859          *
   1860          *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
   1861          *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
   1862          *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
   1863          *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
   1864          *                            specific.
   1865          *
   1866          *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
   1867          *                            'OSTaskCreate()'.
   1868          *
   1869          *              id            is the task's ID (0..65535)
   1870          *
   1871          *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
   1872          *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
   1873          *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
   1874          *                            units are established by the #define constant OS_STK which is CPU
   1875          *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
   1876          *
   1877          *              pext          is a pointer to a user supplied memory area that is used to extend the task
   1878          *                            control block.  This allows you to store the contents of floating-point
   1879          *                            registers, MMU registers or anything else you could find useful during a
   1880          *                            context switch.  You can even assign a name to each task and store this name
   1881          *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
   1882          *
   1883          *              opt           options as passed to 'OSTaskCreateExt()' or,
   1884          *                            0 if called from 'OSTaskCreate()'.
   1885          *
   1886          * Returns    : OS_ERR_NONE         if the call was successful
   1887          *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
   1888          *                                  be created.
   1889          *
   1890          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1891          *********************************************************************************************************
   1892          */
   1893          

   \                                 In section .text, align 2, keep-with-next
   1894          INT8U  OS_TCBInit (INT8U    prio,
   1895                             OS_STK  *ptos,
   1896                             OS_STK  *pbos,
   1897                             INT16U   id,
   1898                             INT32U   stk_size,
   1899                             void    *pext,
   1900                             INT16U   opt)
   1901          {
   \                     OS_TCBInit:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x001E             MOVS     R6,R3
   \   00000008   0x9F0C             LDR      R7,[SP, #+48]
   \   0000000A   0xF8DD 0x8034      LDR      R8,[SP, #+52]
   \   0000000E   0x9C0E             LDR      R4,[SP, #+56]
   1902              OS_TCB    *ptcb;
   1903          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
   1904              OS_CPU_SR  cpu_sr = 0u;
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
   1905          #endif
   1906          #if OS_TASK_REG_TBL_SIZE > 0u
   1907              INT8U      i;
   1908          #endif
   1909          
   1910          
   1911              OS_ENTER_CRITICAL();
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000018   0x4682             MOV      R10,R0
   1912              ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
   \   0000001A   0x....             LDR.N    R0,??DataTable20_24
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x4681             MOV      R9,R0
   1913              if (ptcb != (OS_TCB *)0) {
   \   00000020   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000024   0xF000 0x809D      BEQ.W    ??OS_TCBInit_0
   1914                  OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
   \   00000028   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \   0000002C   0x....             LDR.N    R1,??DataTable20_24
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   1915                  OS_EXIT_CRITICAL();
   \   00000030   0x4650             MOV      R0,R10
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Restore
   1916                  ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
   \   00000036   0x9801             LDR      R0,[SP, #+4]
   \   00000038   0xF8C9 0x0000      STR      R0,[R9, #+0]
   1917                  ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
   \   0000003C   0xF889 0x5036      STRB     R5,[R9, #+54]
   1918                  ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF889 0x0034      STRB     R0,[R9, #+52]
   1919                  ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF889 0x0035      STRB     R0,[R9, #+53]
   1920                  ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF8C9 0x0030      STR      R0,[R9, #+48]
   1921          
   1922          #if OS_TASK_CREATE_EXT_EN > 0u
   1923                  ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
   \   00000052   0xF8C9 0x8004      STR      R8,[R9, #+4]
   1924                  ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
   \   00000056   0xF8C9 0x700C      STR      R7,[R9, #+12]
   1925                  ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
   \   0000005A   0x9802             LDR      R0,[SP, #+8]
   \   0000005C   0xF8C9 0x0008      STR      R0,[R9, #+8]
   1926                  ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
   \   00000060   0xF8A9 0x4010      STRH     R4,[R9, #+16]
   1927                  ptcb->OSTCBId            = id;                     /* Store task ID                            */
   \   00000064   0xF8A9 0x6012      STRH     R6,[R9, #+18]
   1928          #else
   1929                  pext                     = pext;                   /* Prevent compiler warning if not used     */
   1930                  stk_size                 = stk_size;
   1931                  pbos                     = pbos;
   1932                  opt                      = opt;
   1933                  id                       = id;
   1934          #endif
   1935          
   1936          #if OS_TASK_DEL_EN > 0u
   1937                  ptcb->OSTCBDelReq        = OS_ERR_NONE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF889 0x003B      STRB     R0,[R9, #+59]
   1938          #endif
   1939          
   1940          #if OS_LOWEST_PRIO <= 63u
   1941                  ptcb->OSTCBY             = (INT8U)(prio >> 3u);           /* Pre-compute X, Y, BitX and BitY   */
   \   0000006E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000070   0x08E8             LSRS     R0,R5,#+3
   \   00000072   0xF889 0x0038      STRB     R0,[R9, #+56]
   1942                  ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
   \   00000076   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   0000007A   0xF889 0x0037      STRB     R0,[R9, #+55]
   1943                  ptcb->OSTCBBitY          = (INT8U)(1u << ptcb->OSTCBY);
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF899 0x1038      LDRB     R1,[R9, #+56]
   \   00000084   0x4088             LSLS     R0,R0,R1
   \   00000086   0xF889 0x003A      STRB     R0,[R9, #+58]
   1944                  ptcb->OSTCBBitX          = (INT8U)(1u << ptcb->OSTCBX);
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xF899 0x1037      LDRB     R1,[R9, #+55]
   \   00000090   0x4088             LSLS     R0,R0,R1
   \   00000092   0xF889 0x0039      STRB     R0,[R9, #+57]
   1945          #else
   1946                  ptcb->OSTCBY             = (INT8U)((prio >> 4u) & 0xFFu); /* Pre-compute X, Y, BitX and BitY   */
   1947                  ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
   1948                  ptcb->OSTCBBitY          = (INT16U)(1u << ptcb->OSTCBY);
   1949                  ptcb->OSTCBBitX          = (INT16U)(1u << ptcb->OSTCBX);
   1950          #endif
   1951          
   1952          #if (OS_EVENT_EN)
   1953                  ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF8C9 0x001C      STR      R0,[R9, #+28]
   1954          #if (OS_EVENT_MULTI_EN > 0u)
   1955                  ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF8C9 0x0020      STR      R0,[R9, #+32]
   1956          #endif
   1957          #endif
   1958          
   1959          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
   1960                  ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF8C9 0x0028      STR      R0,[R9, #+40]
   1961          #endif
   1962          
   1963          #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
   1964                  ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF8C9 0x0024      STR      R0,[R9, #+36]
   1965          #endif
   1966          
   1967          #if OS_TASK_PROFILE_EN > 0u
   1968                  ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF8C9 0x003C      STR      R0,[R9, #+60]
   1969                  ptcb->OSTCBCyclesStart = 0L;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF8C9 0x0044      STR      R0,[R9, #+68]
   1970                  ptcb->OSTCBCyclesTot   = 0L;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF8C9 0x0040      STR      R0,[R9, #+64]
   1971                  ptcb->OSTCBStkBase     = (OS_STK *)0;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF8C9 0x0048      STR      R0,[R9, #+72]
   1972                  ptcb->OSTCBStkUsed     = 0L;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF8C9 0x004C      STR      R0,[R9, #+76]
   1973          #endif
   1974          
   1975          #if OS_TASK_NAME_EN > 0u
   1976                  ptcb->OSTCBTaskName    = (INT8U *)"?";
   1977          #endif
   1978          
   1979          #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
   1980                  for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x4683             MOV      R11,R0
   \                     ??OS_TCBInit_1:
   \   000000D0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000D4   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000D8   0xD108             BNE.N    ??OS_TCBInit_2
   1981                      ptcb->OSTCBRegTbl[i] = 0u;
   \   000000DA   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000DE   0xEB19 0x008B      ADDS     R0,R9,R11, LSL #+2
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0x6501             STR      R1,[R0, #+80]
   1982                  }
   \   000000E6   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000000EA   0xE7F1             B.N      ??OS_TCBInit_1
   1983          #endif
   1984          
   1985                  OSTCBInitHook(ptcb);
   \                     ??OS_TCBInit_2:
   \   000000EC   0x4648             MOV      R0,R9
   \   000000EE   0x.... 0x....      BL       OSTCBInitHook
   1986          
   1987                  OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
   \   000000F2   0x4648             MOV      R0,R9
   \   000000F4   0x.... 0x....      BL       OSTaskCreateHook
   1988          
   1989                  OS_ENTER_CRITICAL();
   \   000000F8   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000000FC   0x4682             MOV      R10,R0
   1990                  OSTCBPrioTbl[prio] = ptcb;
   \   000000FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000100   0x....             LDR.N    R0,??DataTable20_5
   \   00000102   0xF840 0x9025      STR      R9,[R0, R5, LSL #+2]
   1991                  ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
   \   00000106   0x....             LDR.N    R0,??DataTable20_11
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0xF8C9 0x0014      STR      R0,[R9, #+20]
   1992                  ptcb->OSTCBPrev    = (OS_TCB *)0;
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xF8C9 0x0018      STR      R0,[R9, #+24]
   1993                  if (OSTCBList != (OS_TCB *)0) {
   \   00000114   0x....             LDR.N    R0,??DataTable20_11
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD003             BEQ.N    ??OS_TCBInit_3
   1994                      OSTCBList->OSTCBPrev = ptcb;
   \   0000011C   0x....             LDR.N    R0,??DataTable20_11
   \   0000011E   0x6800             LDR      R0,[R0, #+0]
   \   00000120   0xF8C0 0x9018      STR      R9,[R0, #+24]
   1995                  }
   1996                  OSTCBList               = ptcb;
   \                     ??OS_TCBInit_3:
   \   00000124   0x....             LDR.N    R0,??DataTable20_11
   \   00000126   0xF8C0 0x9000      STR      R9,[R0, #+0]
   1997                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
   \   0000012A   0x....             LDR.N    R0,??DataTable20_12
   \   0000012C   0x7800             LDRB     R0,[R0, #+0]
   \   0000012E   0xF899 0x103A      LDRB     R1,[R9, #+58]
   \   00000132   0x4308             ORRS     R0,R1,R0
   \   00000134   0x....             LDR.N    R1,??DataTable20_12
   \   00000136   0x7008             STRB     R0,[R1, #+0]
   1998                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000138   0xF899 0x0038      LDRB     R0,[R9, #+56]
   \   0000013C   0x....             LDR.N    R1,??DataTable20_13
   \   0000013E   0x5C40             LDRB     R0,[R0, R1]
   \   00000140   0xF899 0x1039      LDRB     R1,[R9, #+57]
   \   00000144   0x4308             ORRS     R0,R1,R0
   \   00000146   0xF899 0x1038      LDRB     R1,[R9, #+56]
   \   0000014A   0x....             LDR.N    R2,??DataTable20_13
   \   0000014C   0x5488             STRB     R0,[R1, R2]
   1999                  OSTaskCtr++;                                       /* Increment the #tasks counter             */
   \   0000014E   0x....             LDR.N    R0,??DataTable20_18
   \   00000150   0x7800             LDRB     R0,[R0, #+0]
   \   00000152   0x1C40             ADDS     R0,R0,#+1
   \   00000154   0x....             LDR.N    R1,??DataTable20_18
   \   00000156   0x7008             STRB     R0,[R1, #+0]
   2000                  OS_EXIT_CRITICAL();
   \   00000158   0x4650             MOV      R0,R10
   \   0000015A   0x.... 0x....      BL       OS_CPU_SR_Restore
   2001                  return (OS_ERR_NONE);
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0xE003             B.N      ??OS_TCBInit_4
   2002              }
   2003              OS_EXIT_CRITICAL();
   \                     ??OS_TCBInit_0:
   \   00000162   0x4650             MOV      R0,R10
   \   00000164   0x.... 0x....      BL       OS_CPU_SR_Restore
   2004              return (OS_ERR_TASK_NO_MORE_TCB);
   \   00000168   0x2042             MOVS     R0,#+66
   \                     ??OS_TCBInit_4:
   \   0000016A   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2005          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     OSPrioHighRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x........         DC32     OSTCBHighRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x........         DC32     OSCtxSwCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \   00000000   0x........         DC32     OSTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \   00000000   0x........         DC32     OSTickStepState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \   00000000   0x........         DC32     OSTCBList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_14:
   \   00000000   0x........         DC32     OSUnMapTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_15:
   \   00000000   0x........         DC32     OSEventTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_16:
   \   00000000   0x........         DC32     OSEventTbl+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_17:
   \   00000000   0x........         DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_18:
   \   00000000   0x........         DC32     OSTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_19:
   \   00000000   0x........         DC32     OSIdleCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_20:
   \   00000000   0x........         DC32     OSTaskIdleStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_21:
   \   00000000   0x........         DC32     OSTaskIdleStk+0x3FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_22:
   \   00000000   0x........         DC32     OSTCBTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_23:
   \   00000000   0x........         DC32     OSTCBTbl+0x54

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_24:
   \   00000000   0x........         DC32     OSTCBFreeList

   \                                 In section .rodata, align 2
   \   00000000   0x3F 0x00          DC8 "?"

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSEventNameGet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrLen
      24   OSEventNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      56   OSEventPendMulti
        56   -> OS_CPU_SR_Restore
        56   -> OS_CPU_SR_Save
        56   -> OS_EventTaskRemoveMulti
        56   -> OS_EventTaskWaitMulti
        56   -> OS_Sched
       8   OSInit
         8   -> OSInitHookBegin
         8   -> OSInitHookEnd
         8   -> OS_FlagInit
         8   -> OS_InitEventList
         8   -> OS_InitMisc
         8   -> OS_InitRdyList
         8   -> OS_InitTCBList
         8   -> OS_InitTaskIdle
         8   -> OS_MemInit
         8   -> OS_QInit
       0   OSIntEnter
       8   OSIntExit
         8   -> OSIntCtxSw
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> OS_SchedNew
       8   OSSchedLock
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
       8   OSSchedUnlock
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> OS_Sched
       8   OSStart
         8   -> OSStartHighRdy
         8   -> OS_SchedNew
      16   OSTimeTick
        16   -> OSTimeTickHook
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
       0   OSVersion
       0   OS_Dummy
      40   OS_EventTaskRdy
        40   -> OS_EventTaskRemove
        40   -> OS_EventTaskRemoveMulti
       4   OS_EventTaskRemove
      16   OS_EventTaskRemoveMulti
       0   OS_EventTaskWait
       8   OS_EventTaskWaitMulti
       0   OS_EventWaitListInit
      16   OS_InitEventList
        16   -> OS_MemClr
       0   OS_InitMisc
       0   OS_InitRdyList
      16   OS_InitTCBList
        16   -> OS_MemClr
      24   OS_InitTaskIdle
        24   -> OSTaskCreateExt
       0   OS_MemClr
       0   OS_MemCopy
       8   OS_Sched
         8   -> OSCtxSw
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> OS_SchedNew
       0   OS_SchedNew
       0   OS_StrLen
      48   OS_TCBInit
        48   -> OSTCBInitHook
        48   -> OSTaskCreateHook
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
      16   OS_TaskIdle
        16   -> OSTaskIdleHook
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_16
       4  ??DataTable20_17
       4  ??DataTable20_18
       4  ??DataTable20_19
       4  ??DataTable20_2
       4  ??DataTable20_20
       4  ??DataTable20_21
       4  ??DataTable20_22
       4  ??DataTable20_23
       4  ??DataTable20_24
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
       4  OSCtxSwCtr
       4  OSEventFreeList
      84  OSEventNameGet
      60  OSEventNameSet
     730  OSEventPendMulti
    1260  OSEventTbl
       4  OSFlagFreeList
     480  OSFlagTbl
       4  OSIdleCtr
      44  OSInit
      36  OSIntEnter
     148  OSIntExit
       1  OSIntNesting
       1  OSLockNesting
       4  OSMemFreeList
     480  OSMemTbl
       1  OSPrioCur
       1  OSPrioHighRdy
       4  OSQFreeList
     480  OSQTbl
       1  OSRdyGrp
       4  OSRdyTbl
       1  OSRunning
      62  OSSchedLock
     100  OSSchedUnlock
      66  OSStart
       4  OSTCBCur
       4  OSTCBFreeList
       4  OSTCBHighRdy
       4  OSTCBList
     128  OSTCBPrioTbl
    1344  OSTCBTbl
       1  OSTaskCtr
    1024  OSTaskIdleStk
       1  OSTickStepState
       4  OSTime
     246  OSTimeTick
     256  OSUnMapTbl
       6  OSVersion
       2  OS_Dummy
     186  OS_EventTaskRdy
      50  OS_EventTaskRemove
      76  OS_EventTaskRemoveMulti
     142  OS_EventTaskWait
     174  OS_EventTaskWaitMulti
      32  OS_EventWaitListInit
      78  OS_InitEventList
      44  OS_InitMisc
      56  OS_InitRdyList
      66  OS_InitTCBList
      46  OS_InitTaskIdle
      18  OS_MemClr
      20  OS_MemCopy
      92  OS_Sched
      32  OS_SchedNew
      22  OS_StrLen
     366  OS_TCBInit
      34  OS_TaskIdle

 
 5 252 bytes in section .bss
   258 bytes in section .rodata
 3 222 bytes in section .text
 
 3 222 bytes of CODE  memory
   258 bytes of CONST memory
 5 252 bytes of DATA  memory

Errors: none
Warnings: none
