###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:25 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_flag.c                                    #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_flag.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm #
#                    \RTU\´úÂë\RTU_1.2\project\iar\Debug\List\ -o             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\os_flag.lst                                #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\os_flag.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCOS-II\Source\os_flag.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                         EVENT FLAG  MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_FLAG.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.89
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
     29          /*
     30          *********************************************************************************************************
     31          *                                            LOCAL PROTOTYPES
     32          *********************************************************************************************************
     33          */
     34          
     35          static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
     36          static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy);
     37          
     38          /*$PAGE*/
     39          /*
     40          *********************************************************************************************************
     41          *                              CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
     42          *
     43          * Description: This function is called to check the status of a combination of bits to be set or cleared
     44          *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
     45          *              bits to be set/cleared.
     46          *
     47          *              This call does not block if the desired flags are not present.
     48          *
     49          * Arguments  : pgrp          is a pointer to the desired event flag group.
     50          *
     51          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
     52          *                            The bits you want are specified by setting the corresponding bits in
     53          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
     54          *                            'flags' would contain 0x03.
     55          *
     56          *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
     57          *                            to be set/cleared.
     58          *                            You can specify the following argument:
     59          *
     60          *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
     61          *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
     62          *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
     63          *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
     64          *
     65          *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
     66          *                                  the call.  Example, to wait for any flag in a group AND then clear
     67          *                                  the flags that are present, set 'wait_type' to:
     68          *
     69          *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
     70          *
     71          *              perr          is a pointer to an error code and can be:
     72          *                            OS_ERR_NONE               No error
     73          *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
     74          *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
     75          *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
     76          *                                                      group handle.
     77          *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
     78          *                                                      available.
     79          *
     80          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
     81          *              occurred.
     82          *
     83          * Called from: Task or ISR
     84          *
     85          * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
     86          *                 function NOW returns the flags that were ready INSTEAD of the current state of the
     87          *                 event flags.
     88          *********************************************************************************************************
     89          */
     90          
     91          #if OS_FLAG_ACCEPT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     92          OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
     93                                  OS_FLAGS      flags, 
     94                                  INT8U         wait_type, 
     95                                  INT8U        *perr)
     96          {
   \                     OSFlagAccept:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
     97              OS_FLAGS      flags_rdy;
     98              INT8U         result;
     99              BOOLEAN       consume;
    100          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    101              OS_CPU_SR     cpu_sr = 0u;
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    102          #endif
    103          
    104          
    105          
    106          #if OS_ARG_CHK_EN > 0u
    107              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    108                  return ((OS_FLAGS)0);
    109              }
    110              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    111                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    112                  return ((OS_FLAGS)0);
    113              }
    114          #endif
    115              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD003             BEQ.N    ??OSFlagAccept_0
    116                  *perr = OS_ERR_EVENT_TYPE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7038             STRB     R0,[R7, #+0]
    117                  return ((OS_FLAGS)0);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE087             B.N      ??OSFlagAccept_1
    118              }
    119              result = (INT8U)(wait_type & OS_FLAG_CONSUME);
   \                     ??OSFlagAccept_0:
   \   0000001E   0xF016 0x0080      ANDS     R0,R6,#0x80
   \   00000022   0x4681             MOV      R9,R0
    120              if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
   \   00000024   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000028   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002C   0xD004             BEQ.N    ??OSFlagAccept_2
    121                  wait_type &= ~OS_FLAG_CONSUME;
   \   0000002E   0xF016 0x067F      ANDS     R6,R6,#0x7F
    122                  consume    = OS_TRUE;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x4682             MOV      R10,R0
   \   00000036   0xE001             B.N      ??OSFlagAccept_3
    123              } else {
    124                  consume    = OS_FALSE;
   \                     ??OSFlagAccept_2:
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4682             MOV      R10,R0
    125              }
    126          /*$PAGE*/
    127              *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
   \                     ??OSFlagAccept_3:
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x7038             STRB     R0,[R7, #+0]
    128              OS_ENTER_CRITICAL();
   \   00000040   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000044   0x4683             MOV      R11,R0
    129              switch (wait_type) {
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD035             BEQ.N    ??OSFlagAccept_4
   \   0000004C   0x2E02             CMP      R6,#+2
   \   0000004E   0xD003             BEQ.N    ??OSFlagAccept_5
   \   00000050   0xD34B             BCC.N    ??OSFlagAccept_6
   \   00000052   0x2E03             CMP      R6,#+3
   \   00000054   0xD018             BEQ.N    ??OSFlagAccept_7
   \   00000056   0xE061             B.N      ??OSFlagAccept_8
    130                  case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
    131                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
   \                     ??OSFlagAccept_5:
   \   00000058   0x8920             LDRH     R0,[R4, #+8]
   \   0000005A   0x4028             ANDS     R0,R5,R0
   \   0000005C   0x4680             MOV      R8,R0
    132                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   0000005E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000062   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000064   0x45A8             CMP      R8,R5
   \   00000066   0xD109             BNE.N    ??OSFlagAccept_9
    133                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   00000068   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000006C   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000070   0xD106             BNE.N    ??OSFlagAccept_10
    134                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
   \   00000072   0x8920             LDRH     R0,[R4, #+8]
   \   00000074   0xEA30 0x0008      BICS     R0,R0,R8
   \   00000078   0x8120             STRH     R0,[R4, #+8]
   \   0000007A   0xE001             B.N      ??OSFlagAccept_10
    135                           }
    136                       } else {
    137                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_9:
   \   0000007C   0x2070             MOVS     R0,#+112
   \   0000007E   0x7038             STRB     R0,[R7, #+0]
    138                       }
    139                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_10:
   \   00000080   0x4658             MOV      R0,R11
   \   00000082   0x.... 0x....      BL       OS_CPU_SR_Restore
    140                       break;
   \   00000086   0xE050             B.N      ??OSFlagAccept_11
    141          
    142                  case OS_FLAG_WAIT_SET_ANY:
    143                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
   \                     ??OSFlagAccept_7:
   \   00000088   0x8920             LDRH     R0,[R4, #+8]
   \   0000008A   0x4028             ANDS     R0,R5,R0
   \   0000008C   0x4680             MOV      R8,R0
    144                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
   \   0000008E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000092   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000096   0xD009             BEQ.N    ??OSFlagAccept_12
    145                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   00000098   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000009C   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000A0   0xD106             BNE.N    ??OSFlagAccept_13
    146                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
   \   000000A2   0x8920             LDRH     R0,[R4, #+8]
   \   000000A4   0xEA30 0x0008      BICS     R0,R0,R8
   \   000000A8   0x8120             STRH     R0,[R4, #+8]
   \   000000AA   0xE001             B.N      ??OSFlagAccept_13
    147                           }
    148                       } else {
    149                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_12:
   \   000000AC   0x2070             MOVS     R0,#+112
   \   000000AE   0x7038             STRB     R0,[R7, #+0]
    150                       }
    151                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_13:
   \   000000B0   0x4658             MOV      R0,R11
   \   000000B2   0x.... 0x....      BL       OS_CPU_SR_Restore
    152                       break;
   \   000000B6   0xE038             B.N      ??OSFlagAccept_11
    153          
    154          #if OS_FLAG_WAIT_CLR_EN > 0u
    155                  case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
    156                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
   \                     ??OSFlagAccept_4:
   \   000000B8   0x8920             LDRH     R0,[R4, #+8]
   \   000000BA   0xEA35 0x0000      BICS     R0,R5,R0
   \   000000BE   0x4680             MOV      R8,R0
    157                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   000000C0   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000C4   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000C6   0x45A8             CMP      R8,R5
   \   000000C8   0xD109             BNE.N    ??OSFlagAccept_14
    158                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   000000CA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000CE   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000D2   0xD106             BNE.N    ??OSFlagAccept_15
    159                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
   \   000000D4   0x8920             LDRH     R0,[R4, #+8]
   \   000000D6   0xEA58 0x0000      ORRS     R0,R8,R0
   \   000000DA   0x8120             STRH     R0,[R4, #+8]
   \   000000DC   0xE001             B.N      ??OSFlagAccept_15
    160                           }
    161                       } else {
    162                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_14:
   \   000000DE   0x2070             MOVS     R0,#+112
   \   000000E0   0x7038             STRB     R0,[R7, #+0]
    163                       }
    164                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_15:
   \   000000E2   0x4658             MOV      R0,R11
   \   000000E4   0x.... 0x....      BL       OS_CPU_SR_Restore
    165                       break;
   \   000000E8   0xE01F             B.N      ??OSFlagAccept_11
    166          
    167                  case OS_FLAG_WAIT_CLR_ANY:
    168                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
   \                     ??OSFlagAccept_6:
   \   000000EA   0x8920             LDRH     R0,[R4, #+8]
   \   000000EC   0xEA35 0x0000      BICS     R0,R5,R0
   \   000000F0   0x4680             MOV      R8,R0
    169                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
   \   000000F2   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000F6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000FA   0xD009             BEQ.N    ??OSFlagAccept_16
    170                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   000000FC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000100   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000104   0xD106             BNE.N    ??OSFlagAccept_17
    171                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
   \   00000106   0x8920             LDRH     R0,[R4, #+8]
   \   00000108   0xEA58 0x0000      ORRS     R0,R8,R0
   \   0000010C   0x8120             STRH     R0,[R4, #+8]
   \   0000010E   0xE001             B.N      ??OSFlagAccept_17
    172                           }
    173                       } else {
    174                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_16:
   \   00000110   0x2070             MOVS     R0,#+112
   \   00000112   0x7038             STRB     R0,[R7, #+0]
    175                       }
    176                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_17:
   \   00000114   0x4658             MOV      R0,R11
   \   00000116   0x.... 0x....      BL       OS_CPU_SR_Restore
    177                       break;
   \   0000011A   0xE006             B.N      ??OSFlagAccept_11
    178          #endif
    179          
    180                  default:
    181                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_8:
   \   0000011C   0x4658             MOV      R0,R11
   \   0000011E   0x.... 0x....      BL       OS_CPU_SR_Restore
    182                       flags_rdy = (OS_FLAGS)0;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x4680             MOV      R8,R0
    183                       *perr     = OS_ERR_FLAG_WAIT_TYPE;
   \   00000126   0x206F             MOVS     R0,#+111
   \   00000128   0x7038             STRB     R0,[R7, #+0]
    184                       break;
    185              }
    186              return (flags_rdy);
   \                     ??OSFlagAccept_11:
   \   0000012A   0x4640             MOV      R0,R8
   \   0000012C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagAccept_1:
   \   0000012E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    187          }
    188          #endif
    189          
    190          /*$PAGE*/
    191          /*
    192          *********************************************************************************************************
    193          *                                           CREATE AN EVENT FLAG
    194          *
    195          * Description: This function is called to create an event flag group.
    196          *
    197          * Arguments  : flags         Contains the initial value to store in the event flag group.
    198          *
    199          *              perr          is a pointer to an error code which will be returned to your application:
    200          *                               OS_ERR_NONE               if the call was successful.
    201          *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
    202          *                                                         ISR.
    203          *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
    204          *
    205          * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
    206          *
    207          * Called from: Task ONLY
    208          *********************************************************************************************************
    209          */
    210          

   \                                 In section .text, align 2, keep-with-next
    211          OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags, 
    212                                      INT8U    *perr)
    213          {
   \                     OSFlagCreate:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    214              OS_FLAG_GRP *pgrp;
    215          #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
    216              OS_CPU_SR    cpu_sr = 0u;
   \   00000006   0x2700             MOVS     R7,#+0
    217          #endif
    218          
    219          
    220          
    221          #if OS_ARG_CHK_EN > 0u
    222              if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
    223                  return ((OS_FLAG_GRP *)0);
    224              }
    225          #endif
    226              if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSFlagCreate_0
    227                  *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
   \   00000012   0x2010             MOVS     R0,#+16
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    228                  return ((OS_FLAG_GRP *)0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE022             B.N      ??OSFlagCreate_1
    229              }
    230              OS_ENTER_CRITICAL();
   \                     ??OSFlagCreate_0:
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x0007             MOVS     R7,R0
    231              pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0006             MOVS     R6,R0
    232              if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD013             BEQ.N    ??OSFlagCreate_2
    233                                                              /* Adjust free list                                */
    234                  OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x6840             LDR      R0,[R0, #+4]
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   00000038   0x6008             STR      R0,[R1, #+0]
    235                  pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
   \   0000003A   0x2005             MOVS     R0,#+5
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
    236                  pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
   \   0000003E   0x8134             STRH     R4,[R6, #+8]
    237                  pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6070             STR      R0,[R6, #+4]
    238          #if OS_FLAG_NAME_EN > 0u
    239                  pgrp->OSFlagName     = (INT8U *)"?";
   \   00000044   0x....             ADR.N    R0,??DataTable3  ;; "\?"
   \   00000046   0x60F0             STR      R0,[R6, #+12]
    240          #endif
    241                  OS_EXIT_CRITICAL();
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    242                  *perr                = OS_ERR_NONE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x7028             STRB     R0,[R5, #+0]
   \   00000052   0xE004             B.N      ??OSFlagCreate_3
    243              } else {
    244                  OS_EXIT_CRITICAL();
   \                     ??OSFlagCreate_2:
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
    245                  *perr                = OS_ERR_FLAG_GRP_DEPLETED;
   \   0000005A   0x2072             MOVS     R0,#+114
   \   0000005C   0x7028             STRB     R0,[R5, #+0]
    246              }
    247              return (pgrp);                                  /* Return pointer to event flag group              */
   \                     ??OSFlagCreate_3:
   \   0000005E   0x0030             MOVS     R0,R6
   \                     ??OSFlagCreate_1:
   \   00000060   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    248          }
    249          
    250          /*$PAGE*/
    251          /*
    252          *********************************************************************************************************
    253          *                                     DELETE AN EVENT FLAG GROUP
    254          *
    255          * Description: This function deletes an event flag group and readies all tasks pending on the event flag
    256          *              group.
    257          *
    258          * Arguments  : pgrp          is a pointer to the desired event flag group.
    259          *
    260          *              opt           determines delete options as follows:
    261          *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
    262          *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
    263          *                                                    waiting.  In this case, all the tasks pending will be
    264          *                                                    readied.
    265          *
    266          *              perr          is a pointer to an error code that can contain one of the following values:
    267          *                            OS_ERR_NONE               The call was successful and the event flag group was
    268          *                                                      deleted
    269          *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
    270          *                                                      an ISR
    271          *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
    272          *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
    273          *                            OS_ERR_INVALID_OPT        An invalid option was specified
    274          *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
    275          *                                                      group.
    276          *
    277          * Returns    : pgrp          upon error
    278          *              (OS_EVENT *)0 if the event flag group was successfully deleted.
    279          *
    280          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    281          *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
    282          *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
    283          *                 time is directly proportional to the number of tasks waiting on the event flag group.
    284          *********************************************************************************************************
    285          */
    286          
    287          #if OS_FLAG_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    288          OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
    289                                   INT8U         opt, 
    290                                   INT8U        *perr)
    291          {
   \                     OSFlagDel:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    292              BOOLEAN       tasks_waiting;
    293              OS_FLAG_NODE *pnode;
    294              OS_FLAG_GRP  *pgrp_return;
    295          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    296              OS_CPU_SR     cpu_sr = 0u;
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
    297          #endif
    298          
    299          
    300          
    301          #if OS_ARG_CHK_EN > 0u
    302              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    303                  return (pgrp);
    304              }
    305              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    306                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    307                  return (pgrp);
    308              }
    309          #endif
    310              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSFlagDel_0
    311                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00000018   0x200F             MOVS     R0,#+15
   \   0000001A   0x7030             STRB     R0,[R6, #+0]
    312                  return (pgrp);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xE063             B.N      ??OSFlagDel_1
    313              }
    314              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
   \                     ??OSFlagDel_0:
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD003             BEQ.N    ??OSFlagDel_2
    315                  *perr = OS_ERR_EVENT_TYPE;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7030             STRB     R0,[R6, #+0]
    316                  return (pgrp);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xE05C             B.N      ??OSFlagDel_1
    317              }
    318              OS_ENTER_CRITICAL();
   \                     ??OSFlagDel_2:
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000032   0x4682             MOV      R10,R0
    319              if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
   \   00000034   0x6860             LDR      R0,[R4, #+4]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??OSFlagDel_3
    320                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x0007             MOVS     R7,R0
   \   0000003E   0xE001             B.N      ??OSFlagDel_4
    321              } else {
    322                  tasks_waiting = OS_FALSE;                          /* No                                       */
   \                     ??OSFlagDel_3:
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x0007             MOVS     R7,R0
    323              }
    324              switch (opt) {
   \                     ??OSFlagDel_4:
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD002             BEQ.N    ??OSFlagDel_5
   \   0000004A   0x2D01             CMP      R5,#+1
   \   0000004C   0xD01F             BEQ.N    ??OSFlagDel_6
   \   0000004E   0xE044             B.N      ??OSFlagDel_7
    325                  case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
    326                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSFlagDel_5:
   \   00000050   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000052   0x2F00             CMP      R7,#+0
   \   00000054   0xD114             BNE.N    ??OSFlagDel_8
    327          #if OS_FLAG_NAME_EN > 0u
    328                           pgrp->OSFlagName     = (INT8U *)"?";
   \   00000056   0x....             ADR.N    R0,??DataTable3  ;; "\?"
   \   00000058   0x60E0             STR      R0,[R4, #+12]
    329          #endif
    330                           pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7020             STRB     R0,[R4, #+0]
    331                           pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x6060             STR      R0,[R4, #+4]
    332                           pgrp->OSFlagFlags    = (OS_FLAGS)0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x8120             STRH     R0,[R4, #+8]
    333                           OSFlagFreeList       = pgrp;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000006E   0x6004             STR      R4,[R0, #+0]
    334                           OS_EXIT_CRITICAL();
   \   00000070   0x4650             MOV      R0,R10
   \   00000072   0x.... 0x....      BL       OS_CPU_SR_Restore
    335                           *perr                = OS_ERR_NONE;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x7030             STRB     R0,[R6, #+0]
    336                           pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x4681             MOV      R9,R0
   \   0000007E   0xE005             B.N      ??OSFlagDel_9
    337                       } else {
    338                           OS_EXIT_CRITICAL();
   \                     ??OSFlagDel_8:
   \   00000080   0x4650             MOV      R0,R10
   \   00000082   0x.... 0x....      BL       OS_CPU_SR_Restore
    339                           *perr                = OS_ERR_TASK_WAITING;
   \   00000086   0x2049             MOVS     R0,#+73
   \   00000088   0x7030             STRB     R0,[R6, #+0]
    340                           pgrp_return          = pgrp;
   \   0000008A   0x46A1             MOV      R9,R4
    341                       }
    342                       break;
   \                     ??OSFlagDel_9:
   \   0000008C   0xE02B             B.N      ??OSFlagDel_10
    343          
    344                  case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
    345                       pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \                     ??OSFlagDel_6:
   \   0000008E   0x6860             LDR      R0,[R4, #+4]
   \   00000090   0x4680             MOV      R8,R0
    346                       while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
   \                     ??OSFlagDel_11:
   \   00000092   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000096   0xD006             BEQ.N    ??OSFlagDel_12
    347                           (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0x.... 0x....      BL       OS_FlagTaskRdy
    348                           pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
   \   000000A0   0xF8D8 0x8000      LDR      R8,[R8, #+0]
   \   000000A4   0xE7F5             B.N      ??OSFlagDel_11
    349                       }
    350          #if OS_FLAG_NAME_EN > 0u
    351                       pgrp->OSFlagName     = (INT8U *)"?";
   \                     ??OSFlagDel_12:
   \   000000A6   0x....             ADR.N    R0,??DataTable3  ;; "\?"
   \   000000A8   0x60E0             STR      R0,[R4, #+12]
    352          #endif
    353                       pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x7020             STRB     R0,[R4, #+0]
    354                       pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x6060             STR      R0,[R4, #+4]
    355                       pgrp->OSFlagFlags    = (OS_FLAGS)0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x8120             STRH     R0,[R4, #+8]
    356                       OSFlagFreeList       = pgrp;
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000000BE   0x6004             STR      R4,[R0, #+0]
    357                       OS_EXIT_CRITICAL();
   \   000000C0   0x4650             MOV      R0,R10
   \   000000C2   0x.... 0x....      BL       OS_CPU_SR_Restore
    358                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   000000C6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000C8   0x2F01             CMP      R7,#+1
   \   000000CA   0xD101             BNE.N    ??OSFlagDel_13
    359                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   000000CC   0x.... 0x....      BL       OS_Sched
    360                       }
    361                       *perr = OS_ERR_NONE;
   \                     ??OSFlagDel_13:
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x7030             STRB     R0,[R6, #+0]
    362                       pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x4681             MOV      R9,R0
    363                       break;
   \   000000D8   0xE005             B.N      ??OSFlagDel_10
    364          
    365                  default:
    366                       OS_EXIT_CRITICAL();
   \                     ??OSFlagDel_7:
   \   000000DA   0x4650             MOV      R0,R10
   \   000000DC   0x.... 0x....      BL       OS_CPU_SR_Restore
    367                       *perr                = OS_ERR_INVALID_OPT;
   \   000000E0   0x2007             MOVS     R0,#+7
   \   000000E2   0x7030             STRB     R0,[R6, #+0]
    368                       pgrp_return          = pgrp;
   \   000000E4   0x46A1             MOV      R9,R4
    369                       break;
    370              }
    371              return (pgrp_return);
   \                     ??OSFlagDel_10:
   \   000000E6   0x4648             MOV      R0,R9
   \                     ??OSFlagDel_1:
   \   000000E8   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    372          }
    373          #endif
    374          /*$PAGE*/
    375          /*
    376          *********************************************************************************************************
    377          *                                 GET THE NAME OF AN EVENT FLAG GROUP
    378          *
    379          * Description: This function is used to obtain the name assigned to an event flag group
    380          *
    381          * Arguments  : pgrp      is a pointer to the event flag group.
    382          *
    383          *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
    384          *                        group.
    385          *
    386          *              perr      is a pointer to an error code that can contain one of the following values:
    387          *
    388          *                        OS_ERR_NONE                if the requested task is resumed
    389          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
    390          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    391          *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
    392          *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
    393          *
    394          * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
    395          *********************************************************************************************************
    396          */
    397          
    398          #if OS_FLAG_NAME_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    399          INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp, 
    400                                INT8U        **pname, 
    401                                INT8U         *perr)
    402          {
   \                     OSFlagNameGet:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    403              INT8U      len;
    404          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    405              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    406          #endif
    407          
    408          
    409          
    410          #if OS_ARG_CHK_EN > 0u
    411              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    412                  return (0u);
    413              }
    414              if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
    415                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    416                  return (0u);
    417              }
    418              if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
    419                  *perr = OS_ERR_PNAME_NULL;
    420                  return (0u);
    421              }
    422          #endif
    423              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSFlagNameGet_0
    424                  *perr = OS_ERR_NAME_GET_ISR;
   \   00000018   0x2011             MOVS     R0,#+17
   \   0000001A   0x7030             STRB     R0,[R6, #+0]
    425                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE019             B.N      ??OSFlagNameGet_1
    426              }
    427              OS_ENTER_CRITICAL();
   \                     ??OSFlagNameGet_0:
   \   00000020   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000024   0x4680             MOV      R8,R0
    428              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD006             BEQ.N    ??OSFlagNameGet_2
    429                  OS_EXIT_CRITICAL();
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Restore
    430                  *perr = OS_ERR_EVENT_TYPE;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7030             STRB     R0,[R6, #+0]
    431                  return (0u);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE00C             B.N      ??OSFlagNameGet_1
    432              }
    433              *pname = pgrp->OSFlagName;
   \                     ??OSFlagNameGet_2:
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x6028             STR      R0,[R5, #+0]
    434              len    = OS_StrLen(*pname);
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x.... 0x....      BL       OS_StrLen
   \   00000044   0x0007             MOVS     R7,R0
    435              OS_EXIT_CRITICAL();
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    436              *perr  = OS_ERR_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7030             STRB     R0,[R6, #+0]
    437              return (len);
   \   00000050   0x0038             MOVS     R0,R7
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSFlagNameGet_1:
   \   00000054   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    438          }
    439          #endif
    440          
    441          /*$PAGE*/
    442          /*
    443          *********************************************************************************************************
    444          *                                 ASSIGN A NAME TO AN EVENT FLAG GROUP
    445          *
    446          * Description: This function assigns a name to an event flag group.
    447          *
    448          * Arguments  : pgrp      is a pointer to the event flag group.
    449          *
    450          *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
    451          *                        group.
    452          *
    453          *              perr      is a pointer to an error code that can contain one of the following values:
    454          *
    455          *                        OS_ERR_NONE                if the requested task is resumed
    456          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
    457          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    458          *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
    459          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    460          *
    461          * Returns    : None
    462          *********************************************************************************************************
    463          */
    464          
    465          #if OS_FLAG_NAME_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    466          void  OSFlagNameSet (OS_FLAG_GRP  *pgrp, 
    467                               INT8U        *pname, 
    468                               INT8U        *perr)
    469          {
   \                     OSFlagNameSet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    470          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    471              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
    472          #endif
    473          
    474          
    475          
    476          #if OS_ARG_CHK_EN > 0u
    477              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    478                  return;
    479              }
    480              if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
    481                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    482                  return;
    483              }
    484              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    485                  *perr = OS_ERR_PNAME_NULL;
    486                  return;
    487              }
    488          #endif
    489              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??OSFlagNameSet_0
    490                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000014   0x2012             MOVS     R0,#+18
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    491                  return;
   \   00000018   0xE011             B.N      ??OSFlagNameSet_1
    492              }
    493              OS_ENTER_CRITICAL();
   \                     ??OSFlagNameSet_0:
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x0007             MOVS     R7,R0
    494              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD005             BEQ.N    ??OSFlagNameSet_2
    495                  OS_EXIT_CRITICAL();
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Restore
    496                  *perr = OS_ERR_EVENT_TYPE;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7030             STRB     R0,[R6, #+0]
    497                  return;
   \   00000030   0xE005             B.N      ??OSFlagNameSet_1
    498              }
    499              pgrp->OSFlagName = pname;
   \                     ??OSFlagNameSet_2:
   \   00000032   0x60E5             STR      R5,[R4, #+12]
    500              OS_EXIT_CRITICAL();
   \   00000034   0x0038             MOVS     R0,R7
   \   00000036   0x.... 0x....      BL       OS_CPU_SR_Restore
    501              *perr            = OS_ERR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
    502              return;
   \                     ??OSFlagNameSet_1:
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    503          }
    504          #endif
    505          
    506          /*$PAGE*/
    507          /*
    508          *********************************************************************************************************
    509          *                                        WAIT ON AN EVENT FLAG GROUP
    510          *
    511          * Description: This function is called to wait for a combination of bits to be set in an event flag
    512          *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
    513          *
    514          * Arguments  : pgrp          is a pointer to the desired event flag group.
    515          *
    516          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
    517          *                            The bits you want are specified by setting the corresponding bits in
    518          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
    519          *                            'flags' would contain 0x03.
    520          *
    521          *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
    522          *                            You can specify the following argument:
    523          *
    524          *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
    525          *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
    526          *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
    527          *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
    528          *
    529          *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
    530          *                                  the call.  Example, to wait for any flag in a group AND then clear
    531          *                                  the flags that are present, set 'wait_type' to:
    532          *
    533          *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
    534          *
    535          *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
    536          *                            desired bit combination.  If you specify 0, however, your task will wait
    537          *                            forever at the specified event flag group or, until a message arrives.
    538          *
    539          *              perr          is a pointer to an error code and can be:
    540          *                            OS_ERR_NONE               The desired bits have been set within the specified
    541          *                                                      'timeout'.
    542          *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
    543          *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
    544          *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
    545          *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
    546          *                                                      'timeout'.
    547          *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
    548          *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
    549          *
    550          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
    551          *              occurred.
    552          *
    553          * Called from: Task ONLY
    554          *
    555          * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
    556          *                 function NOW returns the flags that were ready INSTEAD of the current state of the
    557          *                 event flags.
    558          *********************************************************************************************************
    559          */
    560          

   \                                 In section .text, align 2, keep-with-next
    561          OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp, 
    562                                OS_FLAGS      flags, 
    563                                INT8U         wait_type, 
    564                                INT32U        timeout, 
    565                                INT8U        *perr)
    566          {
   \                     OSFlagPend:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x4692             MOV      R10,R2
   \   0000000C   0x001E             MOVS     R6,R3
   \   0000000E   0x9F10             LDR      R7,[SP, #+64]
    567              OS_FLAG_NODE  node;
    568              OS_FLAGS      flags_rdy;
    569              INT8U         result;
    570              INT8U         pend_stat;
    571              BOOLEAN       consume;
    572          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    573              OS_CPU_SR     cpu_sr = 0u;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    574          #endif
    575          
    576          
    577          
    578          #if OS_ARG_CHK_EN > 0u
    579              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    580                  return ((OS_FLAGS)0);
    581              }
    582              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    583                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    584                  return ((OS_FLAGS)0);
    585              }
    586          #endif
    587              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??OSFlagPend_0
    588                  *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x7038             STRB     R0,[R7, #+0]
    589                  return ((OS_FLAGS)0);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE145             B.N      ??OSFlagPend_1
    590              }
    591              if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
   \                     ??OSFlagPend_0:
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD003             BEQ.N    ??OSFlagPend_2
    592                  *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
   \   00000030   0x200D             MOVS     R0,#+13
   \   00000032   0x7038             STRB     R0,[R7, #+0]
    593                  return ((OS_FLAGS)0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE13C             B.N      ??OSFlagPend_1
    594              }
    595              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
   \                     ??OSFlagPend_2:
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x2805             CMP      R0,#+5
   \   0000003C   0xD003             BEQ.N    ??OSFlagPend_3
    596                  *perr = OS_ERR_EVENT_TYPE;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x7038             STRB     R0,[R7, #+0]
    597                  return ((OS_FLAGS)0);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE135             B.N      ??OSFlagPend_1
    598              }
    599              result = (INT8U)(wait_type & OS_FLAG_CONSUME);
   \                     ??OSFlagPend_3:
   \   00000046   0xF01A 0x0080      ANDS     R0,R10,#0x80
   \   0000004A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    600              if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
   \   0000004E   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD004             BEQ.N    ??OSFlagPend_4
    601                  wait_type &= ~(INT8U)OS_FLAG_CONSUME;
   \   00000056   0xF01A 0x0A7F      ANDS     R10,R10,#0x7F
    602                  consume    = OS_TRUE;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x4680             MOV      R8,R0
   \   0000005E   0xE001             B.N      ??OSFlagPend_5
    603              } else {
    604                  consume    = OS_FALSE;
   \                     ??OSFlagPend_4:
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x4680             MOV      R8,R0
    605              }
    606          /*$PAGE*/
    607              OS_ENTER_CRITICAL();
   \                     ??OSFlagPend_5:
   \   00000064   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000068   0x4681             MOV      R9,R0
    608              switch (wait_type) {
   \   0000006A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000006E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000072   0xD05E             BEQ.N    ??OSFlagPend_6
   \   00000074   0xF1BA 0x0F02      CMP      R10,#+2
   \   00000078   0xD005             BEQ.N    ??OSFlagPend_7
   \   0000007A   0xF0C0 0x8086      BCC.W    ??OSFlagPend_8
   \   0000007E   0xF1BA 0x0F03      CMP      R10,#+3
   \   00000082   0xD02B             BEQ.N    ??OSFlagPend_9
   \   00000084   0xE0AD             B.N      ??OSFlagPend_10
    609                  case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
    610                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
   \                     ??OSFlagPend_7:
   \   00000086   0x8920             LDRH     R0,[R4, #+8]
   \   00000088   0x4028             ANDS     R0,R5,R0
   \   0000008A   0x4683             MOV      R11,R0
    611                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   0000008C   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   00000090   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000092   0x45AB             CMP      R11,R5
   \   00000094   0xD115             BNE.N    ??OSFlagPend_11
    612                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   00000096   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009A   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000009E   0xD103             BNE.N    ??OSFlagPend_12
    613                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
   \   000000A0   0x8920             LDRH     R0,[R4, #+8]
   \   000000A2   0xEA30 0x000B      BICS     R0,R0,R11
   \   000000A6   0x8120             STRH     R0,[R4, #+8]
    614                           }
    615                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
   \                     ??OSFlagPend_12:
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0xF8A0 0xB02C      STRH     R11,[R0, #+44]
    616                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
   \   000000B2   0x4648             MOV      R0,R9
   \   000000B4   0x.... 0x....      BL       OS_CPU_SR_Restore
    617                           *perr                   = OS_ERR_NONE;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x7038             STRB     R0,[R7, #+0]
    618                           return (flags_rdy);
   \   000000BC   0x4658             MOV      R0,R11
   \   000000BE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C0   0xE0F7             B.N      ??OSFlagPend_1
    619                       } else {                                      /* Block task until events occur or timeout */
    620                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
   \                     ??OSFlagPend_11:
   \   000000C2   0x9600             STR      R6,[SP, #+0]
   \   000000C4   0x4653             MOV      R3,R10
   \   000000C6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000C8   0x002A             MOVS     R2,R5
   \   000000CA   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000CC   0xA902             ADD      R1,SP,#+8
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       OS_FlagBlock
    621                           OS_EXIT_CRITICAL();
   \   000000D4   0x4648             MOV      R0,R9
   \   000000D6   0x.... 0x....      BL       OS_CPU_SR_Restore
    622                       }
    623                       break;
   \   000000DA   0xE08C             B.N      ??OSFlagPend_13
    624          
    625                  case OS_FLAG_WAIT_SET_ANY:
    626                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
   \                     ??OSFlagPend_9:
   \   000000DC   0x8920             LDRH     R0,[R4, #+8]
   \   000000DE   0x4028             ANDS     R0,R5,R0
   \   000000E0   0x4683             MOV      R11,R0
    627                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
   \   000000E2   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   000000E6   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000EA   0xD015             BEQ.N    ??OSFlagPend_14
    628                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   000000EC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000F0   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000F4   0xD103             BNE.N    ??OSFlagPend_15
    629                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
   \   000000F6   0x8920             LDRH     R0,[R4, #+8]
   \   000000F8   0xEA30 0x000B      BICS     R0,R0,R11
   \   000000FC   0x8120             STRH     R0,[R4, #+8]
    630                           }
    631                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
   \                     ??OSFlagPend_15:
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0xF8A0 0xB02C      STRH     R11,[R0, #+44]
    632                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
   \   00000108   0x4648             MOV      R0,R9
   \   0000010A   0x.... 0x....      BL       OS_CPU_SR_Restore
    633                           *perr                   = OS_ERR_NONE;
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x7038             STRB     R0,[R7, #+0]
    634                           return (flags_rdy);
   \   00000112   0x4658             MOV      R0,R11
   \   00000114   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000116   0xE0CC             B.N      ??OSFlagPend_1
    635                       } else {                                      /* Block task until events occur or timeout */
    636                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
   \                     ??OSFlagPend_14:
   \   00000118   0x9600             STR      R6,[SP, #+0]
   \   0000011A   0x4653             MOV      R3,R10
   \   0000011C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000011E   0x002A             MOVS     R2,R5
   \   00000120   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000122   0xA902             ADD      R1,SP,#+8
   \   00000124   0x0020             MOVS     R0,R4
   \   00000126   0x.... 0x....      BL       OS_FlagBlock
    637                           OS_EXIT_CRITICAL();
   \   0000012A   0x4648             MOV      R0,R9
   \   0000012C   0x.... 0x....      BL       OS_CPU_SR_Restore
    638                       }
    639                       break;
   \   00000130   0xE061             B.N      ??OSFlagPend_13
    640          
    641          #if OS_FLAG_WAIT_CLR_EN > 0u
    642                  case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
    643                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
   \                     ??OSFlagPend_6:
   \   00000132   0x8920             LDRH     R0,[R4, #+8]
   \   00000134   0xEA35 0x0000      BICS     R0,R5,R0
   \   00000138   0x4683             MOV      R11,R0
    644                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   0000013A   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   0000013E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000140   0x45AB             CMP      R11,R5
   \   00000142   0xD115             BNE.N    ??OSFlagPend_16
    645                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   00000144   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000148   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000014C   0xD103             BNE.N    ??OSFlagPend_17
    646                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
   \   0000014E   0x8920             LDRH     R0,[R4, #+8]
   \   00000150   0xEA5B 0x0000      ORRS     R0,R11,R0
   \   00000154   0x8120             STRH     R0,[R4, #+8]
    647                           }
    648                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
   \                     ??OSFlagPend_17:
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   0000015A   0x6800             LDR      R0,[R0, #+0]
   \   0000015C   0xF8A0 0xB02C      STRH     R11,[R0, #+44]
    649                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
   \   00000160   0x4648             MOV      R0,R9
   \   00000162   0x.... 0x....      BL       OS_CPU_SR_Restore
    650                           *perr                   = OS_ERR_NONE;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0x7038             STRB     R0,[R7, #+0]
    651                           return (flags_rdy);
   \   0000016A   0x4658             MOV      R0,R11
   \   0000016C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000016E   0xE0A0             B.N      ??OSFlagPend_1
    652                       } else {                                      /* Block task until events occur or timeout */
    653                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
   \                     ??OSFlagPend_16:
   \   00000170   0x9600             STR      R6,[SP, #+0]
   \   00000172   0x4653             MOV      R3,R10
   \   00000174   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000176   0x002A             MOVS     R2,R5
   \   00000178   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000017A   0xA902             ADD      R1,SP,#+8
   \   0000017C   0x0020             MOVS     R0,R4
   \   0000017E   0x.... 0x....      BL       OS_FlagBlock
    654                           OS_EXIT_CRITICAL();
   \   00000182   0x4648             MOV      R0,R9
   \   00000184   0x.... 0x....      BL       OS_CPU_SR_Restore
    655                       }
    656                       break;
   \   00000188   0xE035             B.N      ??OSFlagPend_13
    657          
    658                  case OS_FLAG_WAIT_CLR_ANY:
    659                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
   \                     ??OSFlagPend_8:
   \   0000018A   0x8920             LDRH     R0,[R4, #+8]
   \   0000018C   0xEA35 0x0000      BICS     R0,R5,R0
   \   00000190   0x4683             MOV      R11,R0
    660                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
   \   00000192   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   00000196   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000019A   0xD015             BEQ.N    ??OSFlagPend_18
    661                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   0000019C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001A0   0xF1B8 0x0F01      CMP      R8,#+1
   \   000001A4   0xD103             BNE.N    ??OSFlagPend_19
    662                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
   \   000001A6   0x8920             LDRH     R0,[R4, #+8]
   \   000001A8   0xEA5B 0x0000      ORRS     R0,R11,R0
   \   000001AC   0x8120             STRH     R0,[R4, #+8]
    663                           }
    664                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
   \                     ??OSFlagPend_19:
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   000001B2   0x6800             LDR      R0,[R0, #+0]
   \   000001B4   0xF8A0 0xB02C      STRH     R11,[R0, #+44]
    665                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
   \   000001B8   0x4648             MOV      R0,R9
   \   000001BA   0x.... 0x....      BL       OS_CPU_SR_Restore
    666                           *perr                   = OS_ERR_NONE;
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0x7038             STRB     R0,[R7, #+0]
    667                           return (flags_rdy);
   \   000001C2   0x4658             MOV      R0,R11
   \   000001C4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001C6   0xE074             B.N      ??OSFlagPend_1
    668                       } else {                                      /* Block task until events occur or timeout */
    669                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
   \                     ??OSFlagPend_18:
   \   000001C8   0x9600             STR      R6,[SP, #+0]
   \   000001CA   0x4653             MOV      R3,R10
   \   000001CC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001CE   0x002A             MOVS     R2,R5
   \   000001D0   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000001D2   0xA902             ADD      R1,SP,#+8
   \   000001D4   0x0020             MOVS     R0,R4
   \   000001D6   0x.... 0x....      BL       OS_FlagBlock
    670                           OS_EXIT_CRITICAL();
   \   000001DA   0x4648             MOV      R0,R9
   \   000001DC   0x.... 0x....      BL       OS_CPU_SR_Restore
    671                       }
    672                       break;
   \   000001E0   0xE009             B.N      ??OSFlagPend_13
    673          #endif
    674          
    675                  default:
    676                       OS_EXIT_CRITICAL();
   \                     ??OSFlagPend_10:
   \   000001E2   0x4648             MOV      R0,R9
   \   000001E4   0x.... 0x....      BL       OS_CPU_SR_Restore
    677                       flags_rdy = (OS_FLAGS)0;
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x4683             MOV      R11,R0
    678                       *perr      = OS_ERR_FLAG_WAIT_TYPE;
   \   000001EC   0x206F             MOVS     R0,#+111
   \   000001EE   0x7038             STRB     R0,[R7, #+0]
    679                       return (flags_rdy);
   \   000001F0   0x4658             MOV      R0,R11
   \   000001F2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001F4   0xE05D             B.N      ??OSFlagPend_1
    680              }
    681          /*$PAGE*/
    682              OS_Sched();                                            /* Find next HPT ready to run               */
   \                     ??OSFlagPend_13:
   \   000001F6   0x.... 0x....      BL       OS_Sched
    683              OS_ENTER_CRITICAL();
   \   000001FA   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000001FE   0x4681             MOV      R9,R0
    684              if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000204   0x6800             LDR      R0,[R0, #+0]
   \   00000206   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   0000020A   0x2800             CMP      R0,#+0
   \   0000020C   0xD026             BEQ.N    ??OSFlagPend_20
    685                  pend_stat                = OSTCBCur->OSTCBStatPend;
   \   0000020E   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000212   0x6800             LDR      R0,[R0, #+0]
   \   00000214   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000218   0xF88D 0x0004      STRB     R0,[SP, #+4]
    686                  OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   0000021C   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000220   0x6800             LDR      R0,[R0, #+0]
   \   00000222   0x2100             MOVS     R1,#+0
   \   00000224   0xF880 0x1035      STRB     R1,[R0, #+53]
    687                  OS_FlagUnlink(&node);
   \   00000228   0xA802             ADD      R0,SP,#+8
   \   0000022A   0x.... 0x....      BL       OS_FlagUnlink
    688                  OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
   \   0000022E   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000232   0x6800             LDR      R0,[R0, #+0]
   \   00000234   0x2100             MOVS     R1,#+0
   \   00000236   0xF880 0x1034      STRB     R1,[R0, #+52]
    689                  OS_EXIT_CRITICAL();
   \   0000023A   0x4648             MOV      R0,R9
   \   0000023C   0x.... 0x....      BL       OS_CPU_SR_Restore
    690                  flags_rdy                = (OS_FLAGS)0;
   \   00000240   0x2000             MOVS     R0,#+0
   \   00000242   0x4683             MOV      R11,R0
    691                  switch (pend_stat) {
   \   00000244   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000248   0x2802             CMP      R0,#+2
   \   0000024A   0xD102             BNE.N    ??OSFlagPend_21
    692                      case OS_STAT_PEND_ABORT:
    693                           *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
   \   0000024C   0x200E             MOVS     R0,#+14
   \   0000024E   0x7038             STRB     R0,[R7, #+0]
    694                           break;
   \   00000250   0xE001             B.N      ??OSFlagPend_22
    695          
    696                      case OS_STAT_PEND_TO:
    697                      default:
    698                           *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
   \                     ??OSFlagPend_21:
   \   00000252   0x200A             MOVS     R0,#+10
   \   00000254   0x7038             STRB     R0,[R7, #+0]
    699                           break;
    700                  }
    701                  return (flags_rdy);
   \                     ??OSFlagPend_22:
   \   00000256   0x4658             MOV      R0,R11
   \   00000258   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000025A   0xE02A             B.N      ??OSFlagPend_1
    702              }
    703              flags_rdy = OSTCBCur->OSTCBFlagsRdy;
   \                     ??OSFlagPend_20:
   \   0000025C   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000260   0x6800             LDR      R0,[R0, #+0]
   \   00000262   0x8D80             LDRH     R0,[R0, #+44]
   \   00000264   0x4683             MOV      R11,R0
    704              if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
   \   00000266   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000026A   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000026E   0xD119             BNE.N    ??OSFlagPend_23
    705                  switch (wait_type) {
   \   00000270   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000274   0x4650             MOV      R0,R10
   \   00000276   0x2800             CMP      R0,#+0
   \   00000278   0x2801             CMP      R0,#+1
   \   0000027A   0xD907             BLS.N    ??OSFlagPend_24
   \   0000027C   0x1E80             SUBS     R0,R0,#+2
   \   0000027E   0x2801             CMP      R0,#+1
   \   00000280   0xD809             BHI.N    ??OSFlagPend_25
    706                      case OS_FLAG_WAIT_SET_ALL:
    707                      case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
    708                           pgrp->OSFlagFlags &= ~flags_rdy;
   \                     ??OSFlagPend_26:
   \   00000282   0x8920             LDRH     R0,[R4, #+8]
   \   00000284   0xEA30 0x000B      BICS     R0,R0,R11
   \   00000288   0x8120             STRH     R0,[R4, #+8]
    709                           break;
   \   0000028A   0xE00B             B.N      ??OSFlagPend_23
    710          
    711          #if OS_FLAG_WAIT_CLR_EN > 0u
    712                      case OS_FLAG_WAIT_CLR_ALL:
    713                      case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
    714                           pgrp->OSFlagFlags |=  flags_rdy;
   \                     ??OSFlagPend_24:
   \   0000028C   0x8920             LDRH     R0,[R4, #+8]
   \   0000028E   0xEA5B 0x0000      ORRS     R0,R11,R0
   \   00000292   0x8120             STRH     R0,[R4, #+8]
    715                           break;
   \   00000294   0xE006             B.N      ??OSFlagPend_23
    716          #endif
    717                      default:
    718                           OS_EXIT_CRITICAL();
   \                     ??OSFlagPend_25:
   \   00000296   0x4648             MOV      R0,R9
   \   00000298   0x.... 0x....      BL       OS_CPU_SR_Restore
    719                           *perr = OS_ERR_FLAG_WAIT_TYPE;
   \   0000029C   0x206F             MOVS     R0,#+111
   \   0000029E   0x7038             STRB     R0,[R7, #+0]
    720                           return ((OS_FLAGS)0);
   \   000002A0   0x2000             MOVS     R0,#+0
   \   000002A2   0xE006             B.N      ??OSFlagPend_1
    721                  }
    722              }
    723              OS_EXIT_CRITICAL();
   \                     ??OSFlagPend_23:
   \   000002A4   0x4648             MOV      R0,R9
   \   000002A6   0x.... 0x....      BL       OS_CPU_SR_Restore
    724              *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
   \   000002AA   0x2000             MOVS     R0,#+0
   \   000002AC   0x7038             STRB     R0,[R7, #+0]
    725              return (flags_rdy);
   \   000002AE   0x4658             MOV      R0,R11
   \   000002B0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagPend_1:
   \   000002B2   0xB007             ADD      SP,SP,#+28
   \   000002B4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    726          }
    727          /*$PAGE*/
    728          /*
    729          *********************************************************************************************************
    730          *                               GET FLAGS WHO CAUSED TASK TO BECOME READY
    731          *
    732          * Description: This function is called to obtain the flags that caused the task to become ready to run.
    733          *              In other words, this function allows you to tell "Who done it!".
    734          *
    735          * Arguments  : None
    736          *
    737          * Returns    : The flags that caused the task to be ready.
    738          *
    739          * Called from: Task ONLY
    740          *********************************************************************************************************
    741          */
    742          

   \                                 In section .text, align 2, keep-with-next
    743          OS_FLAGS  OSFlagPendGetFlagsRdy (void)
    744          {
   \                     OSFlagPendGetFlagsRdy:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    745              OS_FLAGS      flags;
    746          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    747              OS_CPU_SR     cpu_sr = 0u;
   \   00000002   0x2500             MOVS     R5,#+0
    748          #endif
    749          
    750          
    751          
    752              OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000008   0x0005             MOVS     R5,R0
    753              flags = OSTCBCur->OSTCBFlagsRdy;
   \   0000000A   0x....             LDR.N    R0,??DataTable8_4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x8D80             LDRH     R0,[R0, #+44]
   \   00000010   0x0004             MOVS     R4,R0
    754              OS_EXIT_CRITICAL();
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Restore
    755              return (flags);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    756          }
    757          
    758          /*$PAGE*/
    759          /*
    760          *********************************************************************************************************
    761          *                                         POST EVENT FLAG BIT(S)
    762          *
    763          * Description: This function is called to set or clear some bits in an event flag group.  The bits to
    764          *              set or clear are specified by a 'bit mask'.
    765          *
    766          * Arguments  : pgrp          is a pointer to the desired event flag group.
    767          *
    768          *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
    769          *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
    770          *                            and 5 you would set 'flags' to:
    771          *
    772          *                                0x31     (note, bit 0 is least significant bit)
    773          *
    774          *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
    775          *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
    776          *                            4 and 5 you would specify 'flags' as:
    777          *
    778          *                                0x31     (note, bit 0 is least significant bit)
    779          *
    780          *              opt           indicates whether the flags will be:
    781          *                                set     (OS_FLAG_SET) or
    782          *                                cleared (OS_FLAG_CLR)
    783          *
    784          *              perr          is a pointer to an error code and can be:
    785          *                            OS_ERR_NONE                The call was successfull
    786          *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
    787          *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
    788          *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
    789          *
    790          * Returns    : the new value of the event flags bits that are still set.
    791          *
    792          * Called From: Task or ISR
    793          *
    794          * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
    795          *                 flag group.
    796          *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
    797          *                 the event flag group.
    798          *********************************************************************************************************
    799          */

   \                                 In section .text, align 2, keep-with-next
    800          OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp, 
    801                                OS_FLAGS      flags, 
    802                                INT8U         opt, 
    803                                INT8U        *perr)
    804          {
   \                     OSFlagPost:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x001D             MOVS     R5,R3
    805              OS_FLAG_NODE *pnode;
    806              BOOLEAN       sched;
    807              OS_FLAGS      flags_cur;
    808              OS_FLAGS      flags_rdy;
    809              BOOLEAN       rdy;
    810          #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
    811              OS_CPU_SR     cpu_sr = 0u;
   \   00000008   0xF05F 0x0B00      MOVS     R11,#+0
    812          #endif
    813          
    814          
    815          
    816          #if OS_ARG_CHK_EN > 0u
    817              if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
    818                  return ((OS_FLAGS)0);
    819              }
    820              if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
    821                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    822                  return ((OS_FLAGS)0);
    823              }
    824          #endif
    825              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2805             CMP      R0,#+5
   \   00000010   0xD003             BEQ.N    ??OSFlagPost_0
    826                  *perr = OS_ERR_EVENT_TYPE;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    827                  return ((OS_FLAGS)0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE0A6             B.N      ??OSFlagPost_1
    828              }
    829          /*$PAGE*/
    830              OS_ENTER_CRITICAL();
   \                     ??OSFlagPost_0:
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x4683             MOV      R11,R0
    831              switch (opt) {
   \   00000020   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD002             BEQ.N    ??OSFlagPost_2
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD006             BEQ.N    ??OSFlagPost_3
   \   0000002C   0xE00B             B.N      ??OSFlagPost_4
    832                  case OS_FLAG_CLR:
    833                       pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
   \                     ??OSFlagPost_2:
   \   0000002E   0x8920             LDRH     R0,[R4, #+8]
   \   00000030   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000034   0x4388             BICS     R0,R0,R1
   \   00000036   0x8120             STRH     R0,[R4, #+8]
    834                       break;
   \   00000038   0xE00C             B.N      ??OSFlagPost_5
    835          
    836                  case OS_FLAG_SET:
    837                       pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
   \                     ??OSFlagPost_3:
   \   0000003A   0x8920             LDRH     R0,[R4, #+8]
   \   0000003C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000040   0x4308             ORRS     R0,R1,R0
   \   00000042   0x8120             STRH     R0,[R4, #+8]
    838                       break;
   \   00000044   0xE006             B.N      ??OSFlagPost_5
    839          
    840                  default:
    841                       OS_EXIT_CRITICAL();                     /* INVALID option                                 */
   \                     ??OSFlagPost_4:
   \   00000046   0x4658             MOV      R0,R11
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    842                       *perr = OS_ERR_FLAG_INVALID_OPT;
   \   0000004C   0x2071             MOVS     R0,#+113
   \   0000004E   0x7028             STRB     R0,[R5, #+0]
    843                       return ((OS_FLAGS)0);
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE089             B.N      ??OSFlagPost_1
    844              }
    845              sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
   \                     ??OSFlagPost_5:
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x0007             MOVS     R7,R0
    846              pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \   00000058   0x6860             LDR      R0,[R4, #+4]
   \   0000005A   0x0006             MOVS     R6,R0
    847              while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
   \                     ??OSFlagPost_6:
   \   0000005C   0x2E00             CMP      R6,#+0
   \   0000005E   0xD06F             BEQ.N    ??OSFlagPost_7
    848                  switch (pnode->OSFlagNodeWaitType) {
   \   00000060   0x7CB0             LDRB     R0,[R6, #+18]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD033             BEQ.N    ??OSFlagPost_8
   \   00000066   0x2802             CMP      R0,#+2
   \   00000068   0xD003             BEQ.N    ??OSFlagPost_9
   \   0000006A   0xD348             BCC.N    ??OSFlagPost_10
   \   0000006C   0x2803             CMP      R0,#+3
   \   0000006E   0xD017             BEQ.N    ??OSFlagPost_11
   \   00000070   0xE05D             B.N      ??OSFlagPost_12
    849                      case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
    850                           flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
   \                     ??OSFlagPost_9:
   \   00000072   0x8920             LDRH     R0,[R4, #+8]
   \   00000074   0x8A31             LDRH     R1,[R6, #+16]
   \   00000076   0x4008             ANDS     R0,R1,R0
   \   00000078   0x4681             MOV      R9,R0
    851                           if (flags_rdy == pnode->OSFlagNodeFlags) {
   \   0000007A   0x8A30             LDRH     R0,[R6, #+16]
   \   0000007C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000080   0x4581             CMP      R9,R0
   \   00000082   0xD10C             BNE.N    ??OSFlagPost_13
    852                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
   \   00000084   0x4649             MOV      R1,R9
   \   00000086   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000088   0x0030             MOVS     R0,R6
   \   0000008A   0x.... 0x....      BL       OS_FlagTaskRdy
   \   0000008E   0x4682             MOV      R10,R0
    853                               if (rdy == OS_TRUE) {
   \   00000090   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000094   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000098   0xD101             BNE.N    ??OSFlagPost_13
    854                                   sched = OS_TRUE;                     /* When done we will reschedule          */
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x0007             MOVS     R7,R0
    855                               }
    856                           }
    857                           break;
   \                     ??OSFlagPost_13:
   \   0000009E   0xE04D             B.N      ??OSFlagPost_14
    858          
    859                      case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
    860                           flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
   \                     ??OSFlagPost_11:
   \   000000A0   0x8920             LDRH     R0,[R4, #+8]
   \   000000A2   0x8A31             LDRH     R1,[R6, #+16]
   \   000000A4   0x4008             ANDS     R0,R1,R0
   \   000000A6   0x4681             MOV      R9,R0
    861                           if (flags_rdy != (OS_FLAGS)0) {
   \   000000A8   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000AC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000B0   0xD00C             BEQ.N    ??OSFlagPost_15
    862                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
   \   000000B2   0x4649             MOV      R1,R9
   \   000000B4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000B6   0x0030             MOVS     R0,R6
   \   000000B8   0x.... 0x....      BL       OS_FlagTaskRdy
   \   000000BC   0x4682             MOV      R10,R0
    863                               if (rdy == OS_TRUE) {
   \   000000BE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000C2   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000C6   0xD101             BNE.N    ??OSFlagPost_15
    864                                   sched = OS_TRUE;                     /* When done we will reschedule          */
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0x0007             MOVS     R7,R0
    865                               }
    866                           }
    867                           break;
   \                     ??OSFlagPost_15:
   \   000000CC   0xE036             B.N      ??OSFlagPost_14
    868          
    869          #if OS_FLAG_WAIT_CLR_EN > 0u
    870                      case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
    871                           flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
   \                     ??OSFlagPost_8:
   \   000000CE   0x8920             LDRH     R0,[R4, #+8]
   \   000000D0   0x8A31             LDRH     R1,[R6, #+16]
   \   000000D2   0xEA31 0x0000      BICS     R0,R1,R0
   \   000000D6   0x4681             MOV      R9,R0
    872                           if (flags_rdy == pnode->OSFlagNodeFlags) {
   \   000000D8   0x8A30             LDRH     R0,[R6, #+16]
   \   000000DA   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000DE   0x4581             CMP      R9,R0
   \   000000E0   0xD10C             BNE.N    ??OSFlagPost_16
    873                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
   \   000000E2   0x4649             MOV      R1,R9
   \   000000E4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000E6   0x0030             MOVS     R0,R6
   \   000000E8   0x.... 0x....      BL       OS_FlagTaskRdy
   \   000000EC   0x4682             MOV      R10,R0
    874                               if (rdy == OS_TRUE) {
   \   000000EE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000F2   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000F6   0xD101             BNE.N    ??OSFlagPost_16
    875                                   sched = OS_TRUE;                     /* When done we will reschedule          */
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0x0007             MOVS     R7,R0
    876                               }
    877                           }
    878                           break;
   \                     ??OSFlagPost_16:
   \   000000FC   0xE01E             B.N      ??OSFlagPost_14
    879          
    880                      case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
    881                           flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
   \                     ??OSFlagPost_10:
   \   000000FE   0x8920             LDRH     R0,[R4, #+8]
   \   00000100   0x8A31             LDRH     R1,[R6, #+16]
   \   00000102   0xEA31 0x0000      BICS     R0,R1,R0
   \   00000106   0x4681             MOV      R9,R0
    882                           if (flags_rdy != (OS_FLAGS)0) {
   \   00000108   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000010C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000110   0xD00C             BEQ.N    ??OSFlagPost_17
    883                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
   \   00000112   0x4649             MOV      R1,R9
   \   00000114   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000116   0x0030             MOVS     R0,R6
   \   00000118   0x.... 0x....      BL       OS_FlagTaskRdy
   \   0000011C   0x4682             MOV      R10,R0
    884                               if (rdy == OS_TRUE) {
   \   0000011E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000122   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000126   0xD101             BNE.N    ??OSFlagPost_17
    885                                   sched = OS_TRUE;                     /* When done we will reschedule          */
   \   00000128   0x2001             MOVS     R0,#+1
   \   0000012A   0x0007             MOVS     R7,R0
    886                               }
    887                           }
    888                           break;
   \                     ??OSFlagPost_17:
   \   0000012C   0xE006             B.N      ??OSFlagPost_14
    889          #endif
    890                      default:
    891                           OS_EXIT_CRITICAL();
   \                     ??OSFlagPost_12:
   \   0000012E   0x4658             MOV      R0,R11
   \   00000130   0x.... 0x....      BL       OS_CPU_SR_Restore
    892                           *perr = OS_ERR_FLAG_WAIT_TYPE;
   \   00000134   0x206F             MOVS     R0,#+111
   \   00000136   0x7028             STRB     R0,[R5, #+0]
    893                           return ((OS_FLAGS)0);
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xE015             B.N      ??OSFlagPost_1
    894                  }
    895                  pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
   \                     ??OSFlagPost_14:
   \   0000013C   0x6836             LDR      R6,[R6, #+0]
   \   0000013E   0xE78D             B.N      ??OSFlagPost_6
    896              }
    897              OS_EXIT_CRITICAL();
   \                     ??OSFlagPost_7:
   \   00000140   0x4658             MOV      R0,R11
   \   00000142   0x.... 0x....      BL       OS_CPU_SR_Restore
    898              if (sched == OS_TRUE) {
   \   00000146   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000148   0x2F01             CMP      R7,#+1
   \   0000014A   0xD101             BNE.N    ??OSFlagPost_18
    899                  OS_Sched();
   \   0000014C   0x.... 0x....      BL       OS_Sched
    900              }
    901              OS_ENTER_CRITICAL();
   \                     ??OSFlagPost_18:
   \   00000150   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000154   0x4683             MOV      R11,R0
    902              flags_cur = pgrp->OSFlagFlags;
   \   00000156   0x8920             LDRH     R0,[R4, #+8]
   \   00000158   0x4680             MOV      R8,R0
    903              OS_EXIT_CRITICAL();
   \   0000015A   0x4658             MOV      R0,R11
   \   0000015C   0x.... 0x....      BL       OS_CPU_SR_Restore
    904              *perr     = OS_ERR_NONE;
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x7028             STRB     R0,[R5, #+0]
    905              return (flags_cur);
   \   00000164   0x4640             MOV      R0,R8
   \   00000166   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagPost_1:
   \   00000168   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    906          }
    907          /*$PAGE*/
    908          /*
    909          *********************************************************************************************************
    910          *                                           QUERY EVENT FLAG
    911          *
    912          * Description: This function is used to check the value of the event flag group.
    913          *
    914          * Arguments  : pgrp         is a pointer to the desired event flag group.
    915          *
    916          *              perr          is a pointer to an error code returned to the called:
    917          *                            OS_ERR_NONE                The call was successfull
    918          *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
    919          *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
    920          *
    921          * Returns    : The current value of the event flag group.
    922          *
    923          * Called From: Task or ISR
    924          *********************************************************************************************************
    925          */
    926          
    927          #if OS_FLAG_QUERY_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    928          OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp, 
    929                                 INT8U        *perr)
    930          {
   \                     OSFlagQuery:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    931              OS_FLAGS   flags;
    932          #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
    933              OS_CPU_SR  cpu_sr = 0u;
   \   00000006   0x2700             MOVS     R7,#+0
    934          #endif
    935          
    936          
    937          
    938          #if OS_ARG_CHK_EN > 0u
    939              if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
    940                  return ((OS_FLAGS)0);
    941              }
    942              if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
    943                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    944                  return ((OS_FLAGS)0);
    945              }
    946          #endif
    947              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2805             CMP      R0,#+5
   \   0000000C   0xD003             BEQ.N    ??OSFlagQuery_0
    948                  *perr = OS_ERR_EVENT_TYPE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7028             STRB     R0,[R5, #+0]
    949                  return ((OS_FLAGS)0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE00B             B.N      ??OSFlagQuery_1
    950              }
    951              OS_ENTER_CRITICAL();
   \                     ??OSFlagQuery_0:
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001A   0x0007             MOVS     R7,R0
    952              flags = pgrp->OSFlagFlags;
   \   0000001C   0x8920             LDRH     R0,[R4, #+8]
   \   0000001E   0x0006             MOVS     R6,R0
    953              OS_EXIT_CRITICAL();
   \   00000020   0x0038             MOVS     R0,R7
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Restore
    954              *perr = OS_ERR_NONE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7028             STRB     R0,[R5, #+0]
    955              return (flags);                               /* Return the current value of the event flags       */
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagQuery_1:
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    956          }
    957          #endif
    958          
    959          /*$PAGE*/
    960          /*
    961          *********************************************************************************************************
    962          *                         SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
    963          *
    964          * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
    965          *              event flag bit(s) are set.
    966          *
    967          * Arguments  : pgrp          is a pointer to the desired event flag group.
    968          *
    969          *              pnode         is a pointer to a structure which contains data about the task waiting for
    970          *                            event flag bit(s) to be set.
    971          *
    972          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
    973          *                            The bits you want are specified by setting the corresponding bits in
    974          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
    975          *                            'flags' would contain 0x03.
    976          *
    977          *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
    978          *                            to be set/cleared.
    979          *                            You can specify the following argument:
    980          *
    981          *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
    982          *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
    983          *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
    984          *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
    985          *
    986          *              timeout       is the desired amount of time that the task will wait for the event flag
    987          *                            bit(s) to be set.
    988          *
    989          * Returns    : none
    990          *
    991          * Called by  : OSFlagPend()  OS_FLAG.C
    992          *
    993          * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
    994          *********************************************************************************************************
    995          */
    996          

   \                                 In section .text, align 2, keep-with-next
    997          static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp, 
    998                                      OS_FLAG_NODE *pnode, 
    999                                      OS_FLAGS      flags, 
   1000                                      INT8U         wait_type, 
   1001                                      INT32U        timeout)
   1002          {
   \                     OS_FlagBlock:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9C04             LDR      R4,[SP, #+16]
   1003              OS_FLAG_NODE  *pnode_next;
   1004              INT8U          y;
   1005          
   1006          
   1007              OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
   \   00000004   0x....             LDR.N    R7,??DataTable8_4
   \   00000006   0x683F             LDR      R7,[R7, #+0]
   \   00000008   0xF897 0x7034      LDRB     R7,[R7, #+52]
   \   0000000C   0xF057 0x0720      ORRS     R7,R7,#0x20
   \   00000010   0x.... 0x....      LDR.W    R12,??DataTable8_4
   \   00000014   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000018   0xF88C 0x7034      STRB     R7,[R12, #+52]
   1008              OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
   \   0000001C   0x....             LDR.N    R7,??DataTable8_4
   \   0000001E   0x683F             LDR      R7,[R7, #+0]
   \   00000020   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000024   0xF887 0xC035      STRB     R12,[R7, #+53]
   1009              OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
   \   00000028   0x....             LDR.N    R7,??DataTable8_4
   \   0000002A   0x683F             LDR      R7,[R7, #+0]
   \   0000002C   0x633C             STR      R4,[R7, #+48]
   1010          #if OS_TASK_DEL_EN > 0u
   1011              OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
   \   0000002E   0x....             LDR.N    R7,??DataTable8_4
   \   00000030   0x683F             LDR      R7,[R7, #+0]
   \   00000032   0x62B9             STR      R1,[R7, #+40]
   1012          #endif
   1013              pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
   \   00000034   0x820A             STRH     R2,[R1, #+16]
   1014              pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
   \   00000036   0x748B             STRB     R3,[R1, #+18]
   1015              pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
   \   00000038   0x....             LDR.N    R7,??DataTable8_4
   \   0000003A   0x683F             LDR      R7,[R7, #+0]
   \   0000003C   0x608F             STR      R7,[R1, #+8]
   1016              pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
   \   0000003E   0x6847             LDR      R7,[R0, #+4]
   \   00000040   0x600F             STR      R7,[R1, #+0]
   1017              pnode->OSFlagNodePrev     = (void *)0;
   \   00000042   0x2700             MOVS     R7,#+0
   \   00000044   0x604F             STR      R7,[R1, #+4]
   1018              pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
   \   00000046   0x60C8             STR      R0,[R1, #+12]
   1019              pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \   00000048   0x6847             LDR      R7,[R0, #+4]
   \   0000004A   0x003D             MOVS     R5,R7
   1020              if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD000             BEQ.N    ??OS_FlagBlock_0
   1021                  pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
   \   00000050   0x6069             STR      R1,[R5, #+4]
   1022              }
   1023              pgrp->OSFlagWaitList = (void *)pnode;
   \                     ??OS_FlagBlock_0:
   \   00000052   0x6041             STR      R1,[R0, #+4]
   1024          
   1025              y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
   \   00000054   0x....             LDR.N    R7,??DataTable8_4
   \   00000056   0x683F             LDR      R7,[R7, #+0]
   \   00000058   0xF897 0x7038      LDRB     R7,[R7, #+56]
   \   0000005C   0x003E             MOVS     R6,R7
   1026              OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x....             LDR.N    R7,??DataTable8_5
   \   00000062   0x5DF7             LDRB     R7,[R6, R7]
   \   00000064   0x.... 0x....      LDR.W    R12,??DataTable8_4
   \   00000068   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   0000006C   0xF89C 0xC039      LDRB     R12,[R12, #+57]
   \   00000070   0xEA37 0x070C      BICS     R7,R7,R12
   \   00000074   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000076   0x.... 0x....      LDR.W    R12,??DataTable8_5
   \   0000007A   0xF806 0x700C      STRB     R7,[R6, R12]
   1027              if (OSRdyTbl[y] == 0x00) {
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x....             LDR.N    R7,??DataTable8_5
   \   00000082   0x5DF7             LDRB     R7,[R6, R7]
   \   00000084   0x2F00             CMP      R7,#+0
   \   00000086   0xD10D             BNE.N    ??OS_FlagBlock_1
   1028                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
   \   00000088   0x....             LDR.N    R7,??DataTable8_6
   \   0000008A   0x783F             LDRB     R7,[R7, #+0]
   \   0000008C   0x.... 0x....      LDR.W    R12,??DataTable8_4
   \   00000090   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000094   0xF89C 0xC03A      LDRB     R12,[R12, #+58]
   \   00000098   0xEA37 0x070C      BICS     R7,R7,R12
   \   0000009C   0x.... 0x....      LDR.W    R12,??DataTable8_6
   \   000000A0   0xF88C 0x7000      STRB     R7,[R12, #+0]
   1029              }
   1030          }
   \                     ??OS_FlagBlock_1:
   \   000000A4   0xBCF0             POP      {R4-R7}
   \   000000A6   0x4770             BX       LR               ;; return
   1031          
   1032          /*$PAGE*/
   1033          /*
   1034          *********************************************************************************************************
   1035          *                                    INITIALIZE THE EVENT FLAG MODULE
   1036          *
   1037          * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
   1038          *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
   1039          *
   1040          * Arguments  : none
   1041          *
   1042          * Returns    : none
   1043          *
   1044          * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
   1045          *********************************************************************************************************
   1046          */
   1047          

   \                                 In section .text, align 2, keep-with-next
   1048          void  OS_FlagInit (void)
   1049          {
   \                     OS_FlagInit:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1050          #if OS_MAX_FLAGS == 1u
   1051              OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
   1052              OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   1053              OSFlagFreeList->OSFlagWaitList = (void *)0;
   1054              OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
   1055          #if OS_FLAG_NAME_EN > 0u
   1056              OSFlagFreeList->OSFlagName     = (INT8U *)"?";
   1057          #endif
   1058          #endif
   1059          
   1060          #if OS_MAX_FLAGS >= 2u
   1061              INT16U       i;
   1062              OS_FLAG_GRP *pgrp1;
   1063              OS_FLAG_GRP *pgrp2;
   1064          
   1065          
   1066              OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
   \   00000002   0xF44F 0x71F0      MOV      R1,#+480
   \   00000006   0x....             LDR.N    R0,??DataTable8_7
   \   00000008   0x.... 0x....      BL       OS_MemClr
   1067              pgrp1 = &OSFlagTbl[0];
   \   0000000C   0x....             LDR.N    R0,??DataTable8_7
   \   0000000E   0x0004             MOVS     R4,R0
   1068              pgrp2 = &OSFlagTbl[1];
   \   00000010   0x....             LDR.N    R0,??DataTable8_8
   \   00000012   0x0005             MOVS     R5,R0
   1069              for (i = 0u; i < (OS_MAX_FLAGS - 1u); i++) {                    /* Init. list of free EVENT FLAGS  */
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0006             MOVS     R6,R0
   \                     ??OS_FlagInit_0:
   \   00000018   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001A   0x2E1D             CMP      R6,#+29
   \   0000001C   0xD208             BCS.N    ??OS_FlagInit_1
   1070                  pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7020             STRB     R0,[R4, #+0]
   1071                  pgrp1->OSFlagWaitList = (void *)pgrp2;
   \   00000022   0x6065             STR      R5,[R4, #+4]
   1072          #if OS_FLAG_NAME_EN > 0u
   1073                  pgrp1->OSFlagName     = (INT8U *)"?";                       /* Unknown name                    */
   \   00000024   0x....             ADR.N    R0,??DataTable8  ;; "\?"
   \   00000026   0x60E0             STR      R0,[R4, #+12]
   1074          #endif
   1075                  pgrp1++;
   \   00000028   0x3410             ADDS     R4,R4,#+16
   1076                  pgrp2++;
   \   0000002A   0x3510             ADDS     R5,R5,#+16
   1077              }
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   \   0000002E   0xE7F3             B.N      ??OS_FlagInit_0
   1078              pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \                     ??OS_FlagInit_1:
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x7020             STRB     R0,[R4, #+0]
   1079              pgrp1->OSFlagWaitList = (void *)0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6060             STR      R0,[R4, #+4]
   1080          #if OS_FLAG_NAME_EN > 0u
   1081              pgrp1->OSFlagName     = (INT8U *)"?";                           /* Unknown name                    */
   \   00000038   0x....             ADR.N    R0,??DataTable8  ;; "\?"
   \   0000003A   0x60E0             STR      R0,[R4, #+12]
   1082          #endif
   1083              OSFlagFreeList        = &OSFlagTbl[0];
   \   0000003C   0x....             LDR.N    R0,??DataTable8_2
   \   0000003E   0x....             LDR.N    R1,??DataTable8_7
   \   00000040   0x6001             STR      R1,[R0, #+0]
   1084          #endif
   1085          }
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
   1086          
   1087          /*$PAGE*/
   1088          /*
   1089          *********************************************************************************************************
   1090          *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
   1091          *
   1092          * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
   1093          *              desired event flag bits have been set.
   1094          *
   1095          * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
   1096          *                            event flag bit(s) to be set.
   1097          *
   1098          *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
   1099          *                            ready-to-run.
   1100          *
   1101          * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
   1102          *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
   1103          *
   1104          * Called by  : OSFlagsPost() OS_FLAG.C
   1105          *
   1106          * Note(s)    : 1) This function assumes that interrupts are disabled.
   1107          *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
   1108          *********************************************************************************************************
   1109          */
   1110          

   \                                 In section .text, align 2, keep-with-next
   1111          static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, 
   1112                                           OS_FLAGS      flags_rdy)
   1113          {
   \                     OS_FlagTaskRdy:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1114              OS_TCB   *ptcb;
   1115              BOOLEAN   sched;
   1116          
   1117          
   1118              ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x0006             MOVS     R6,R0
   1119              ptcb->OSTCBDly       = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x6330             STR      R0,[R6, #+48]
   1120              ptcb->OSTCBFlagsRdy  = flags_rdy;
   \   0000000E   0x85B5             STRH     R5,[R6, #+44]
   1121              ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
   \   00000010   0xF896 0x0034      LDRB     R0,[R6, #+52]
   \   00000014   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000018   0xF886 0x0034      STRB     R0,[R6, #+52]
   1122              ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF886 0x0035      STRB     R0,[R6, #+53]
   1123              if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
   \   00000022   0xF896 0x0034      LDRB     R0,[R6, #+52]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD114             BNE.N    ??OS_FlagTaskRdy_0
   1124                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
   \   0000002A   0x....             LDR.N    R0,??DataTable8_6
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xF896 0x103A      LDRB     R1,[R6, #+58]
   \   00000032   0x4308             ORRS     R0,R1,R0
   \   00000034   0x....             LDR.N    R1,??DataTable8_6
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   1125                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000038   0xF896 0x0038      LDRB     R0,[R6, #+56]
   \   0000003C   0x....             LDR.N    R1,??DataTable8_5
   \   0000003E   0x5C40             LDRB     R0,[R0, R1]
   \   00000040   0xF896 0x1039      LDRB     R1,[R6, #+57]
   \   00000044   0x4308             ORRS     R0,R1,R0
   \   00000046   0xF896 0x1038      LDRB     R1,[R6, #+56]
   \   0000004A   0x....             LDR.N    R2,??DataTable8_5
   \   0000004C   0x5488             STRB     R0,[R1, R2]
   1126                  sched                   = OS_TRUE;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x0007             MOVS     R7,R0
   \   00000052   0xE001             B.N      ??OS_FlagTaskRdy_1
   1127              } else {
   1128                  sched                   = OS_FALSE;
   \                     ??OS_FlagTaskRdy_0:
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x0007             MOVS     R7,R0
   1129              }
   1130              OS_FlagUnlink(pnode);
   \                     ??OS_FlagTaskRdy_1:
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       OS_FlagUnlink
   1131              return (sched);
   \   0000005E   0x0038             MOVS     R0,R7
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1132          }
   1133          
   1134          /*$PAGE*/
   1135          /*
   1136          *********************************************************************************************************
   1137          *                                  UNLINK EVENT FLAG NODE FROM WAITING LIST
   1138          *
   1139          * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
   1140          *              list of tasks waiting for the event flag.
   1141          *
   1142          * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
   1143          *                            event flag bit(s) to be set.
   1144          *
   1145          * Returns    : none
   1146          *
   1147          * Called by  : OS_FlagTaskRdy() OS_FLAG.C
   1148          *              OSFlagPend()     OS_FLAG.C
   1149          *              OSTaskDel()      OS_TASK.C
   1150          *
   1151          * Note(s)    : 1) This function assumes that interrupts are disabled.
   1152          *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
   1153          *********************************************************************************************************
   1154          */
   1155          

   \                                 In section .text, align 2, keep-with-next
   1156          void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
   1157          {
   \                     OS_FlagUnlink:
   \   00000000   0xB430             PUSH     {R4,R5}
   1158          #if OS_TASK_DEL_EN > 0u
   1159              OS_TCB       *ptcb;
   1160          #endif
   1161              OS_FLAG_GRP  *pgrp;
   1162              OS_FLAG_NODE *pnode_prev;
   1163              OS_FLAG_NODE *pnode_next;
   1164          
   1165          
   1166              pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
   \   00000002   0x6845             LDR      R5,[R0, #+4]
   \   00000004   0x002B             MOVS     R3,R5
   1167              pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
   \   00000006   0x6805             LDR      R5,[R0, #+0]
   \   00000008   0x002C             MOVS     R4,R5
   1168              if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD107             BNE.N    ??OS_FlagUnlink_0
   1169                  pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
   \   0000000E   0x68C5             LDR      R5,[R0, #+12]
   \   00000010   0x002A             MOVS     R2,R5
   1170                  pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
   \   00000012   0x6054             STR      R4,[R2, #+4]
   1171                  if (pnode_next != (OS_FLAG_NODE *)0) {
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD006             BEQ.N    ??OS_FlagUnlink_1
   1172                      pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
   \   00000018   0x2500             MOVS     R5,#+0
   \   0000001A   0x6065             STR      R5,[R4, #+4]
   \   0000001C   0xE003             B.N      ??OS_FlagUnlink_1
   1173                  }
   1174              } else {                                                    /* No,  A node somewhere in the list   */
   1175                  pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
   \                     ??OS_FlagUnlink_0:
   \   0000001E   0x601C             STR      R4,[R3, #+0]
   1176                  if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD000             BEQ.N    ??OS_FlagUnlink_1
   1177                      pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
   \   00000024   0x6063             STR      R3,[R4, #+4]
   1178                  }
   1179              }
   1180          #if OS_TASK_DEL_EN > 0u
   1181              ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
   \                     ??OS_FlagUnlink_1:
   \   00000026   0x6885             LDR      R5,[R0, #+8]
   \   00000028   0x0029             MOVS     R1,R5
   1182              ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0x628D             STR      R5,[R1, #+40]
   1183          #endif
   1184          }
   \   0000002E   0xBC30             POP      {R4,R5}
   \   00000030   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     OSFlagFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     OSFlagTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     OSFlagTbl+0x10

   \                                 In section .rodata, align 2
   \   00000000   0x3F 0x00          DC8 "?"
   1185          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   OSFlagAccept
        40   -> OS_CPU_SR_Restore
        40   -> OS_CPU_SR_Save
      24   OSFlagCreate
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      32   OSFlagDel
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> OS_FlagTaskRdy
        32   -> OS_Sched
      24   OSFlagNameGet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrLen
      24   OSFlagNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      64   OSFlagPend
        64   -> OS_CPU_SR_Restore
        64   -> OS_CPU_SR_Save
        64   -> OS_FlagBlock
        64   -> OS_FlagUnlink
        64   -> OS_Sched
      16   OSFlagPendGetFlagsRdy
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      48   OSFlagPost
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
        48   -> OS_FlagTaskRdy
        48   -> OS_Sched
      24   OSFlagQuery
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      16   OS_FlagBlock
      16   OS_FlagInit
        16   -> OS_MemClr
      24   OS_FlagTaskRdy
        24   -> OS_FlagUnlink
       8   OS_FlagUnlink


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
       4  ??DataTable3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
     306  OSFlagAccept
      98  OSFlagCreate
     236  OSFlagDel
      88  OSFlagNameGet
      64  OSFlagNameSet
     696  OSFlagPend
      30  OSFlagPendGetFlagsRdy
     364  OSFlagPost
      48  OSFlagQuery
     168  OS_FlagBlock
      68  OS_FlagInit
     100  OS_FlagTaskRdy
      50  OS_FlagUnlink

 
     2 bytes in section .rodata
 2 356 bytes in section .text
 
 2 356 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none
