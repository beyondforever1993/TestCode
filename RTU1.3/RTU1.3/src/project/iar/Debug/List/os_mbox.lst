###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:43 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_mbox.c                                    #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_mbox.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm #
#                    \RTU\´úÂë\RTU_1.2\project\iar\Debug\List\ -o             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\os_mbox.lst                                #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\os_mbox.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCOS-II\Source\os_mbox.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                       MESSAGE MAILBOX MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_MBOX.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.89
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          #if OS_MBOX_EN > 0u
     29          /*
     30          *********************************************************************************************************
     31          *                                     ACCEPT MESSAGE FROM MAILBOX
     32          *
     33          * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
     34          *              OSMboxAccept() does not suspend the calling task if a message is not available.
     35          *
     36          * Arguments  : pevent        is a pointer to the event control block
     37          *
     38          * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
     39          *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
     40          *              == (void *)0  if the mailbox is empty or,
     41          *                            if 'pevent' is a NULL pointer or,
     42          *                            if you didn't pass the proper event pointer.
     43          *********************************************************************************************************
     44          */
     45          
     46          #if OS_MBOX_ACCEPT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     47          void  *OSMboxAccept (OS_EVENT *pevent)
     48          {
   \                     OSMboxAccept:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     49              void      *pmsg;
     50          #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
     51              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
     52          #endif
     53          
     54          
     55          
     56          #if OS_ARG_CHK_EN > 0u
     57              if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
     58                  return ((void *)0);
     59              }
     60          #endif
     61              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD001             BEQ.N    ??OSMboxAccept_0
     62                  return ((void *)0);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00A             B.N      ??OSMboxAccept_1
     63              }
     64              OS_ENTER_CRITICAL();
   \                     ??OSMboxAccept_0:
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000014   0x0006             MOVS     R6,R0
     65              pmsg               = pevent->OSEventPtr;
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x0005             MOVS     R5,R0
     66              pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6060             STR      R0,[R4, #+4]
     67              OS_EXIT_CRITICAL();
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0x.... 0x....      BL       OS_CPU_SR_Restore
     68              return (pmsg);                                        /* Return the message received (or NULL)     */
   \   00000024   0x0028             MOVS     R0,R5
   \                     ??OSMboxAccept_1:
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
     69          }
     70          #endif
     71          /*$PAGE*/
     72          /*
     73          *********************************************************************************************************
     74          *                                        CREATE A MESSAGE MAILBOX
     75          *
     76          * Description: This function creates a message mailbox if free event control blocks are available.
     77          *
     78          * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
     79          *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
     80          *                            will be considered empty.
     81          *
     82          * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
     83          *                                created mailbox
     84          *              == (OS_EVENT *)0  if no event control blocks were available
     85          *********************************************************************************************************
     86          */
     87          

   \                                 In section .text, align 2, keep-with-next
     88          OS_EVENT  *OSMboxCreate (void *pmsg)
     89          {
   \                     OSMboxCreate:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     90              OS_EVENT  *pevent;
     91          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
     92              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
     93          #endif
     94          
     95          
     96          
     97              if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
   \   00000006   0x....             LDR.N    R0,??DataTable2_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??OSMboxCreate_0
     98                  return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE01E             B.N      ??OSMboxCreate_1
     99              }
    100              OS_ENTER_CRITICAL();
   \                     ??OSMboxCreate_0:
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000016   0x0006             MOVS     R6,R0
    101              pevent = OSEventFreeList;                    /* Get next free event control block                  */
   \   00000018   0x....             LDR.N    R0,??DataTable2_2
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x0005             MOVS     R5,R0
    102              if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
   \   0000001E   0x....             LDR.N    R0,??DataTable2_2
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD004             BEQ.N    ??OSMboxCreate_2
    103                  OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
   \   00000026   0x....             LDR.N    R0,??DataTable2_2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x....             LDR.N    R1,??DataTable2_2
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    104              }
    105              OS_EXIT_CRITICAL();
   \                     ??OSMboxCreate_2:
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Restore
    106              if (pevent != (OS_EVENT *)0) {
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD009             BEQ.N    ??OSMboxCreate_3
    107                  pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7028             STRB     R0,[R5, #+0]
    108                  pevent->OSEventCnt     = 0u;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x8128             STRH     R0,[R5, #+8]
    109                  pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
   \   00000042   0x606C             STR      R4,[R5, #+4]
    110          #if OS_EVENT_NAME_EN > 0u
    111                  pevent->OSEventName    = (INT8U *)"?";
   \   00000044   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   00000046   0x6128             STR      R0,[R5, #+16]
    112          #endif
    113                  OS_EventWaitListInit(pevent);
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       OS_EventWaitListInit
    114              }
    115              return (pevent);                             /* Return pointer to event control block              */
   \                     ??OSMboxCreate_3:
   \   0000004E   0x0028             MOVS     R0,R5
   \                     ??OSMboxCreate_1:
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    116          }
    117          /*$PAGE*/
    118          /*
    119          *********************************************************************************************************
    120          *                                         DELETE A MAIBOX
    121          *
    122          * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
    123          *
    124          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    125          *                            mailbox.
    126          *
    127          *              opt           determines delete options as follows:
    128          *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
    129          *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
    130          *                                                    In this case, all the tasks pending will be readied.
    131          *
    132          *              perr          is a pointer to an error code that can contain one of the following values:
    133          *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
    134          *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
    135          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    136          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
    137          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
    138          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    139          *
    140          * Returns    : pevent        upon error
    141          *              (OS_EVENT *)0 if the mailbox was successfully deleted.
    142          *
    143          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    144          *                 the mailbox MUST check the return code of OSMboxPend().
    145          *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
    146          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
    147          *                 time is directly proportional to the number of tasks waiting on the mailbox.
    148          *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
    149          *                 applications where the mailbox is used for mutual exclusion because the resource(s)
    150          *                 will no longer be guarded by the mailbox.
    151          *********************************************************************************************************
    152          */
    153          
    154          #if OS_MBOX_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    155          OS_EVENT  *OSMboxDel (OS_EVENT  *pevent, 
    156                                INT8U      opt, 
    157                                INT8U     *perr)
    158          {
   \                     OSMboxDel:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    159              BOOLEAN    tasks_waiting;
    160              OS_EVENT  *pevent_return;
    161          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    162              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    163          #endif
    164          
    165          
    166          
    167          #if OS_ARG_CHK_EN > 0u
    168              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    169                  return (pevent);
    170              }
    171              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    172                  *perr = OS_ERR_PEVENT_NULL;
    173                  return (pevent);
    174              }
    175          #endif
    176              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \   0000000E   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD003             BEQ.N    ??OSMboxDel_0
    177                  *perr = OS_ERR_EVENT_TYPE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7028             STRB     R0,[R5, #+0]
    178                  return (pevent);
   \   0000001A   0x4648             MOV      R0,R9
   \   0000001C   0xE06A             B.N      ??OSMboxDel_1
    179              }
    180              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??OSMboxDel_0:
   \   0000001E   0x....             LDR.N    R0,??DataTable2_1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD003             BEQ.N    ??OSMboxDel_2
    181                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00000026   0x200F             MOVS     R0,#+15
   \   00000028   0x7028             STRB     R0,[R5, #+0]
    182                  return (pevent);
   \   0000002A   0x4648             MOV      R0,R9
   \   0000002C   0xE062             B.N      ??OSMboxDel_1
    183              }
    184              OS_ENTER_CRITICAL();
   \                     ??OSMboxDel_2:
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000032   0x4680             MOV      R8,R0
    185              if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
   \   00000034   0xF899 0x000A      LDRB     R0,[R9, #+10]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD002             BEQ.N    ??OSMboxDel_3
    186                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x0006             MOVS     R6,R0
   \   00000040   0xE001             B.N      ??OSMboxDel_4
    187              } else {
    188                  tasks_waiting = OS_FALSE;                          /* No                                       */
   \                     ??OSMboxDel_3:
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0006             MOVS     R6,R0
    189              }
    190              switch (opt) {
   \                     ??OSMboxDel_4:
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD002             BEQ.N    ??OSMboxDel_5
   \   0000004C   0x2C01             CMP      R4,#+1
   \   0000004E   0xD022             BEQ.N    ??OSMboxDel_6
   \   00000050   0xE049             B.N      ??OSMboxDel_7
    191                  case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
    192                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSMboxDel_5:
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD117             BNE.N    ??OSMboxDel_8
    193          #if OS_EVENT_NAME_EN > 0u
    194                           pevent->OSEventName = (INT8U *)"?";
   \   00000058   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   0000005A   0xF8C9 0x0010      STR      R0,[R9, #+16]
    195          #endif
    196                           pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF889 0x0000      STRB     R0,[R9, #+0]
    197                           pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
   \   00000064   0x....             LDR.N    R0,??DataTable2_2
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF8C9 0x0004      STR      R0,[R9, #+4]
    198                           pevent->OSEventCnt  = 0u;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF8A9 0x0008      STRH     R0,[R9, #+8]
    199                           OSEventFreeList     = pevent;             /* Get next free event control block        */
   \   00000072   0x....             LDR.N    R0,??DataTable2_2
   \   00000074   0xF8C0 0x9000      STR      R9,[R0, #+0]
    200                           OS_EXIT_CRITICAL();
   \   00000078   0x4640             MOV      R0,R8
   \   0000007A   0x.... 0x....      BL       OS_CPU_SR_Restore
    201                           *perr               = OS_ERR_NONE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x7028             STRB     R0,[R5, #+0]
    202                           pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x0007             MOVS     R7,R0
   \   00000086   0xE005             B.N      ??OSMboxDel_9
    203                       } else {
    204                           OS_EXIT_CRITICAL();
   \                     ??OSMboxDel_8:
   \   00000088   0x4640             MOV      R0,R8
   \   0000008A   0x.... 0x....      BL       OS_CPU_SR_Restore
    205                           *perr               = OS_ERR_TASK_WAITING;
   \   0000008E   0x2049             MOVS     R0,#+73
   \   00000090   0x7028             STRB     R0,[R5, #+0]
    206                           pevent_return       = pevent;
   \   00000092   0x464F             MOV      R7,R9
    207                       }
    208                       break;
   \                     ??OSMboxDel_9:
   \   00000094   0xE02D             B.N      ??OSMboxDel_10
    209          
    210                  case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
    211                       while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
   \                     ??OSMboxDel_6:
   \   00000096   0xF899 0x000A      LDRB     R0,[R9, #+10]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD006             BEQ.N    ??OSMboxDel_11
    212                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \   0000009E   0x2300             MOVS     R3,#+0
   \   000000A0   0x2202             MOVS     R2,#+2
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0x.... 0x....      BL       OS_EventTaskRdy
   \   000000AA   0xE7F4             B.N      ??OSMboxDel_6
    213                       }
    214          #if OS_EVENT_NAME_EN > 0u
    215                       pevent->OSEventName    = (INT8U *)"?";
   \                     ??OSMboxDel_11:
   \   000000AC   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   000000AE   0xF8C9 0x0010      STR      R0,[R9, #+16]
    216          #endif
    217                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF889 0x0000      STRB     R0,[R9, #+0]
    218                       pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
   \   000000B8   0x....             LDR.N    R0,??DataTable2_2
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF8C9 0x0004      STR      R0,[R9, #+4]
    219                       pevent->OSEventCnt     = 0u;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF8A9 0x0008      STRH     R0,[R9, #+8]
    220                       OSEventFreeList        = pevent;              /* Get next free event control block        */
   \   000000C6   0x....             LDR.N    R0,??DataTable2_2
   \   000000C8   0xF8C0 0x9000      STR      R9,[R0, #+0]
    221                       OS_EXIT_CRITICAL();
   \   000000CC   0x4640             MOV      R0,R8
   \   000000CE   0x.... 0x....      BL       OS_CPU_SR_Restore
    222                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   000000D2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D4   0x2E01             CMP      R6,#+1
   \   000000D6   0xD101             BNE.N    ??OSMboxDel_12
    223                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   000000D8   0x.... 0x....      BL       OS_Sched
    224                       }
    225                       *perr         = OS_ERR_NONE;
   \                     ??OSMboxDel_12:
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x7028             STRB     R0,[R5, #+0]
    226                       pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x0007             MOVS     R7,R0
    227                       break;
   \   000000E4   0xE005             B.N      ??OSMboxDel_10
    228          
    229                  default:
    230                       OS_EXIT_CRITICAL();
   \                     ??OSMboxDel_7:
   \   000000E6   0x4640             MOV      R0,R8
   \   000000E8   0x.... 0x....      BL       OS_CPU_SR_Restore
    231                       *perr         = OS_ERR_INVALID_OPT;
   \   000000EC   0x2007             MOVS     R0,#+7
   \   000000EE   0x7028             STRB     R0,[R5, #+0]
    232                       pevent_return = pevent;
   \   000000F0   0x464F             MOV      R7,R9
    233                       break;
    234              }
    235              return (pevent_return);
   \                     ??OSMboxDel_10:
   \   000000F2   0x0038             MOVS     R0,R7
   \                     ??OSMboxDel_1:
   \   000000F4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    236          }
    237          #endif
    238          
    239          /*$PAGE*/
    240          /*
    241          *********************************************************************************************************
    242          *                                      PEND ON MAILBOX FOR A MESSAGE
    243          *
    244          * Description: This function waits for a message to be sent to a mailbox
    245          *
    246          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    247          *
    248          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    249          *                            wait for a message to arrive at the mailbox up to the amount of time
    250          *                            specified by this argument.  If you specify 0, however, your task will wait
    251          *                            forever at the specified mailbox or, until a message arrives.
    252          *
    253          *              perr          is a pointer to where an error message will be deposited.  Possible error
    254          *                            messages are:
    255          *
    256          *                            OS_ERR_NONE         The call was successful and your task received a
    257          *                                                message.
    258          *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
    259          *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
    260          *                            OS_ERR_EVENT_TYPE   Invalid event type
    261          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    262          *                                                would lead to a suspension.
    263          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    264          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
    265          *
    266          * Returns    : != (void *)0  is a pointer to the message received
    267          *              == (void *)0  if no message was received or,
    268          *                            if 'pevent' is a NULL pointer or,
    269          *                            if you didn't pass the proper pointer to the event control block.
    270          *********************************************************************************************************
    271          */
    272          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    273          void  *OSMboxPend (OS_EVENT  *pevent, 
    274                             INT32U     timeout, 
    275                             INT8U     *perr)
    276          {
   \                     OSMboxPend:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    277              void      *pmsg;
    278          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    279              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    280          #endif
    281          
    282          
    283          
    284          #if OS_ARG_CHK_EN > 0u
    285              if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
    286                  return ((void *)0);
    287              }
    288              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    289                  *perr = OS_ERR_PEVENT_NULL;
    290                  return ((void *)0);
    291              }
    292          #endif
    293              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ.N    ??OSMboxPend_0
    294                  *perr = OS_ERR_EVENT_TYPE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    295                  return ((void *)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE074             B.N      ??OSMboxPend_1
    296              }
    297              if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
   \                     ??OSMboxPend_0:
   \   0000001C   0x....             LDR.N    R0,??DataTable2_1
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD003             BEQ.N    ??OSMboxPend_2
    298                  *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x7030             STRB     R0,[R6, #+0]
    299                  return ((void *)0);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE06C             B.N      ??OSMboxPend_1
    300              }
    301              if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
   \                     ??OSMboxPend_2:
   \   0000002C   0x....             LDR.N    R0,??DataTable2_3
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD003             BEQ.N    ??OSMboxPend_3
    302                  *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
   \   00000034   0x200D             MOVS     R0,#+13
   \   00000036   0x7030             STRB     R0,[R6, #+0]
    303                  return ((void *)0);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE064             B.N      ??OSMboxPend_1
    304              }
    305              OS_ENTER_CRITICAL();
   \                     ??OSMboxPend_3:
   \   0000003C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000040   0x4680             MOV      R8,R0
    306              pmsg = pevent->OSEventPtr;
   \   00000042   0x6860             LDR      R0,[R4, #+4]
   \   00000044   0x0007             MOVS     R7,R0
    307              if (pmsg != (void *)0) {                          /* See if there is already a message             */
   \   00000046   0x2F00             CMP      R7,#+0
   \   00000048   0xD008             BEQ.N    ??OSMboxPend_4
    308                  pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6060             STR      R0,[R4, #+4]
    309                  OS_EXIT_CRITICAL();
   \   0000004E   0x4640             MOV      R0,R8
   \   00000050   0x.... 0x....      BL       OS_CPU_SR_Restore
    310                  *perr = OS_ERR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x7030             STRB     R0,[R6, #+0]
    311                  return (pmsg);                                /* Return the message received (or NULL)         */
   \   00000058   0x0038             MOVS     R0,R7
   \   0000005A   0xE054             B.N      ??OSMboxPend_1
    312              }
    313              OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
   \                     ??OSMboxPend_4:
   \   0000005C   0x....             LDR.N    R0,??DataTable2_4
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000064   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000068   0x....             LDR.N    R1,??DataTable2_4
   \   0000006A   0x6809             LDR      R1,[R1, #+0]
   \   0000006C   0xF881 0x0034      STRB     R0,[R1, #+52]
    314              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00000070   0x....             LDR.N    R0,??DataTable2_4
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0xF880 0x1035      STRB     R1,[R0, #+53]
    315              OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
   \   0000007A   0x....             LDR.N    R0,??DataTable2_4
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x6305             STR      R5,[R0, #+48]
    316              OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       OS_EventTaskWait
    317              OS_EXIT_CRITICAL();
   \   00000086   0x4640             MOV      R0,R8
   \   00000088   0x.... 0x....      BL       OS_CPU_SR_Restore
    318              OS_Sched();                                       /* Find next highest priority task ready to run  */
   \   0000008C   0x.... 0x....      BL       OS_Sched
    319              OS_ENTER_CRITICAL();
   \   00000090   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000094   0x4680             MOV      R8,R0
    320              switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
   \   00000096   0x....             LDR.N    R0,??DataTable2_4
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD002             BEQ.N    ??OSMboxPend_5
   \   000000A2   0x2802             CMP      R0,#+2
   \   000000A4   0xD007             BEQ.N    ??OSMboxPend_6
   \   000000A6   0xE00B             B.N      ??OSMboxPend_7
    321                  case OS_STAT_PEND_OK:
    322                       pmsg =  OSTCBCur->OSTCBMsg;
   \                     ??OSMboxPend_5:
   \   000000A8   0x....             LDR.N    R0,??DataTable2_4
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x6A40             LDR      R0,[R0, #+36]
   \   000000AE   0x0007             MOVS     R7,R0
    323                      *perr =  OS_ERR_NONE;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x7030             STRB     R0,[R6, #+0]
    324                       break;
   \   000000B4   0xE00D             B.N      ??OSMboxPend_8
    325          
    326                  case OS_STAT_PEND_ABORT:
    327                       pmsg = (void *)0;
   \                     ??OSMboxPend_6:
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x0007             MOVS     R7,R0
    328                      *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
   \   000000BA   0x200E             MOVS     R0,#+14
   \   000000BC   0x7030             STRB     R0,[R6, #+0]
    329                       break;
   \   000000BE   0xE008             B.N      ??OSMboxPend_8
    330          
    331                  case OS_STAT_PEND_TO:
    332                  default:
    333                       OS_EventTaskRemove(OSTCBCur, pevent);
   \                     ??OSMboxPend_7:
   \   000000C0   0x0021             MOVS     R1,R4
   \   000000C2   0x....             LDR.N    R0,??DataTable2_4
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x.... 0x....      BL       OS_EventTaskRemove
    334                       pmsg = (void *)0;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x0007             MOVS     R7,R0
    335                      *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
   \   000000CE   0x200A             MOVS     R0,#+10
   \   000000D0   0x7030             STRB     R0,[R6, #+0]
    336                       break;
    337              }
    338              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
   \                     ??OSMboxPend_8:
   \   000000D2   0x....             LDR.N    R0,??DataTable2_4
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0xF880 0x1034      STRB     R1,[R0, #+52]
    339              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
   \   000000DC   0x....             LDR.N    R0,??DataTable2_4
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0xF880 0x1035      STRB     R1,[R0, #+53]
    340              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
   \   000000E6   0x....             LDR.N    R0,??DataTable2_4
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0x2100             MOVS     R1,#+0
   \   000000EC   0x61C1             STR      R1,[R0, #+28]
    341          #if (OS_EVENT_MULTI_EN > 0u)
    342              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   000000EE   0x....             LDR.N    R0,??DataTable2_4
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0x2100             MOVS     R1,#+0
   \   000000F4   0x6201             STR      R1,[R0, #+32]
    343          #endif
    344              OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
   \   000000F6   0x....             LDR.N    R0,??DataTable2_4
   \   000000F8   0x6800             LDR      R0,[R0, #+0]
   \   000000FA   0x2100             MOVS     R1,#+0
   \   000000FC   0x6241             STR      R1,[R0, #+36]
    345              OS_EXIT_CRITICAL();
   \   000000FE   0x4640             MOV      R0,R8
   \   00000100   0x.... 0x....      BL       OS_CPU_SR_Restore
    346              return (pmsg);                                    /* Return received message                       */
   \   00000104   0x0038             MOVS     R0,R7
   \                     ??OSMboxPend_1:
   \   00000106   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    347          }
    348          /*$PAGE*/
    349          /*
    350          *********************************************************************************************************
    351          *                                      ABORT WAITING ON A MESSAGE MAILBOX
    352          *
    353          * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function 
    354          *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
    355          *              the mailbox via OSMboxPost() or OSMboxPostOpt().
    356          *
    357          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
    358          *
    359          *              opt           determines the type of ABORT performed:
    360          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
    361          *                                                     mailbox
    362          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
    363          *                                                     mailbox
    364          *
    365          *              perr          is a pointer to where an error message will be deposited.  Possible error
    366          *                            messages are:
    367          *
    368          *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
    369          *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
    370          *                                                and informed of the aborted wait; check return value 
    371          *                                                for the number of tasks whose wait on the mailbox 
    372          *                                                was aborted.
    373          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
    374          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    375          *
    376          * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
    377          *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
    378          *********************************************************************************************************
    379          */
    380          
    381          #if OS_MBOX_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    382          INT8U  OSMboxPendAbort (OS_EVENT  *pevent, 
    383                                  INT8U      opt, 
    384                                  INT8U     *perr)
    385          {
   \                     OSMboxPendAbort:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    386              INT8U      nbr_tasks;
    387          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    388              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    389          #endif
    390          
    391          
    392          
    393          #if OS_ARG_CHK_EN > 0u
    394              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    395                  return (0u);
    396              }
    397              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    398                  *perr = OS_ERR_PEVENT_NULL;
    399                  return (0u);
    400              }
    401          #endif
    402              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ.N    ??OSMboxPendAbort_0
    403                  *perr = OS_ERR_EVENT_TYPE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    404                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE02D             B.N      ??OSMboxPendAbort_1
    405              }
    406              OS_ENTER_CRITICAL();
   \                     ??OSMboxPendAbort_0:
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000020   0x4680             MOV      R8,R0
    407              if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
   \   00000022   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD021             BEQ.N    ??OSMboxPendAbort_2
    408                  nbr_tasks = 0u;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x0007             MOVS     R7,R0
    409                  switch (opt) {
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD10B             BNE.N    ??OSMboxPendAbort_3
    410                      case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
    411                           while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
   \                     ??OSMboxPendAbort_4:
   \   00000032   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD007             BEQ.N    ??OSMboxPendAbort_5
    412                               (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
   \   00000038   0x2302             MOVS     R3,#+2
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       OS_EventTaskRdy
    413                               nbr_tasks++;
   \   00000044   0x1C7F             ADDS     R7,R7,#+1
   \   00000046   0xE7F4             B.N      ??OSMboxPendAbort_4
    414                           }
    415                           break;
   \                     ??OSMboxPendAbort_5:
   \   00000048   0xE006             B.N      ??OSMboxPendAbort_6
    416                       
    417                      case OS_PEND_OPT_NONE:
    418                      default:                                       /* No,  ready HPT       waiting on mailbox  */
    419                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
   \                     ??OSMboxPendAbort_3:
   \   0000004A   0x2302             MOVS     R3,#+2
   \   0000004C   0x2202             MOVS     R2,#+2
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       OS_EventTaskRdy
    420                           nbr_tasks++;
   \   00000056   0x1C7F             ADDS     R7,R7,#+1
    421                           break;
    422                  }
    423                  OS_EXIT_CRITICAL();
   \                     ??OSMboxPendAbort_6:
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x.... 0x....      BL       OS_CPU_SR_Restore
    424                  OS_Sched();                                        /* Find HPT ready to run                    */
   \   0000005E   0x.... 0x....      BL       OS_Sched
    425                  *perr = OS_ERR_PEND_ABORT;
   \   00000062   0x200E             MOVS     R0,#+14
   \   00000064   0x7030             STRB     R0,[R6, #+0]
    426                  return (nbr_tasks);
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE005             B.N      ??OSMboxPendAbort_1
    427              }
    428              OS_EXIT_CRITICAL();
   \                     ??OSMboxPendAbort_2:
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       OS_CPU_SR_Restore
    429              *perr = OS_ERR_NONE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x7030             STRB     R0,[R6, #+0]
    430              return (0u);                                           /* No tasks waiting on mailbox              */
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??OSMboxPendAbort_1:
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    431          }
    432          #endif
    433          
    434          /*$PAGE*/
    435          /*
    436          *********************************************************************************************************
    437          *                                       POST MESSAGE TO A MAILBOX
    438          *
    439          * Description: This function sends a message to a mailbox
    440          *
    441          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    442          *
    443          *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
    444          *
    445          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    446          *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
    447          *                                   message at a time and thus, the message MUST be consumed before you
    448          *                                   are allowed to send another one.
    449          *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
    450          *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
    451          *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
    452          *
    453          * Note(s)    : 1) HPT means Highest Priority Task
    454          *********************************************************************************************************
    455          */
    456          
    457          #if OS_MBOX_POST_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    458          INT8U  OSMboxPost (OS_EVENT  *pevent, 
    459                             void      *pmsg)
    460          {
   \                     OSMboxPost:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    461          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    462              OS_CPU_SR  cpu_sr = 0u;
   \   00000006   0x2600             MOVS     R6,#+0
    463          #endif
    464          
    465          
    466          
    467          #if OS_ARG_CHK_EN > 0u
    468              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    469                  return (OS_ERR_PEVENT_NULL);
    470              }
    471              if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
    472                  return (OS_ERR_POST_NULL_PTR);
    473              }
    474          #endif
    475              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD001             BEQ.N    ??OSMboxPost_0
    476                  return (OS_ERR_EVENT_TYPE);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE020             B.N      ??OSMboxPost_1
    477              }
    478              OS_ENTER_CRITICAL();
   \                     ??OSMboxPost_0:
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000016   0x0006             MOVS     R6,R0
    479              if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
   \   00000018   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD00D             BEQ.N    ??OSMboxPost_2
    480                                                                /* Ready HPT waiting on event                    */
    481                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2202             MOVS     R2,#+2
   \   00000022   0x0029             MOVS     R1,R5
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       OS_EventTaskRdy
   \   0000002A   0x0007             MOVS     R7,R0
    482                  OS_EXIT_CRITICAL();
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Restore
    483                  OS_Sched();                                   /* Find highest priority task ready to run       */
   \   00000032   0x.... 0x....      BL       OS_Sched
    484                  return (OS_ERR_NONE);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE00C             B.N      ??OSMboxPost_1
    485              }
    486              if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
   \                     ??OSMboxPost_2:
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD004             BEQ.N    ??OSMboxPost_3
    487                  OS_EXIT_CRITICAL();
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0x.... 0x....      BL       OS_CPU_SR_Restore
    488                  return (OS_ERR_MBOX_FULL);
   \   00000046   0x2014             MOVS     R0,#+20
   \   00000048   0xE004             B.N      ??OSMboxPost_1
    489              }
    490              pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
   \                     ??OSMboxPost_3:
   \   0000004A   0x6065             STR      R5,[R4, #+4]
    491              OS_EXIT_CRITICAL();
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0x.... 0x....      BL       OS_CPU_SR_Restore
    492              return (OS_ERR_NONE);
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??OSMboxPost_1:
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    493          }
    494          #endif
    495          
    496          /*$PAGE*/
    497          /*
    498          *********************************************************************************************************
    499          *                                       POST MESSAGE TO A MAILBOX
    500          *
    501          * Description: This function sends a message to a mailbox
    502          *
    503          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    504          *
    505          *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
    506          *
    507          *              opt           determines the type of POST performed:
    508          *                            OS_POST_OPT_NONE         POST to a single waiting task
    509          *                                                     (Identical to OSMboxPost())
    510          *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
    511          *
    512          *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
    513          *
    514          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    515          *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
    516          *                                   message at a time and thus, the message MUST be consumed before you
    517          *                                   are allowed to send another one.
    518          *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
    519          *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
    520          *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
    521          *
    522          * Note(s)    : 1) HPT means Highest Priority Task
    523          *
    524          * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
    525          *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
    526          *********************************************************************************************************
    527          */
    528          
    529          #if OS_MBOX_POST_OPT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    530          INT8U  OSMboxPostOpt (OS_EVENT  *pevent, 
    531                                void      *pmsg, 
    532                                INT8U      opt)
    533          {
   \                     OSMboxPostOpt:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    534          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    535              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
    536          #endif
    537          
    538          
    539          
    540          #if OS_ARG_CHK_EN > 0u
    541              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    542                  return (OS_ERR_PEVENT_NULL);
    543              }
    544              if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
    545                  return (OS_ERR_POST_NULL_PTR);
    546              }
    547          #endif
    548              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD001             BEQ.N    ??OSMboxPostOpt_0
    549                  return (OS_ERR_EVENT_TYPE);
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE02D             B.N      ??OSMboxPostOpt_1
    550              }
    551              OS_ENTER_CRITICAL();
   \                     ??OSMboxPostOpt_0:
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000018   0x0007             MOVS     R7,R0
    552              if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
   \   0000001A   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD01A             BEQ.N    ??OSMboxPostOpt_2
    553                  if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
   \   00000020   0x07F0             LSLS     R0,R6,#+31
   \   00000022   0xD509             BPL.N    ??OSMboxPostOpt_3
    554                      while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
   \                     ??OSMboxPostOpt_4:
   \   00000024   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD00C             BEQ.N    ??OSMboxPostOpt_5
    555                          (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0x0029             MOVS     R1,R5
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       OS_EventTaskRdy
   \   00000036   0xE7F5             B.N      ??OSMboxPostOpt_4
    556                      }
    557                  } else {                                      /* No,  Post to HPT waiting on mbox              */
    558                      (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \                     ??OSMboxPostOpt_3:
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0x0029             MOVS     R1,R5
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       OS_EventTaskRdy
    559                  }
    560                  OS_EXIT_CRITICAL();
   \                     ??OSMboxPostOpt_5:
   \   00000044   0x0038             MOVS     R0,R7
   \   00000046   0x.... 0x....      BL       OS_CPU_SR_Restore
    561                  if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
   \   0000004A   0x0770             LSLS     R0,R6,#+29
   \   0000004C   0xD401             BMI.N    ??OSMboxPostOpt_6
    562                      OS_Sched();                               /* Find HPT ready to run                         */
   \   0000004E   0x.... 0x....      BL       OS_Sched
    563                  }
    564                  return (OS_ERR_NONE);
   \                     ??OSMboxPostOpt_6:
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE00C             B.N      ??OSMboxPostOpt_1
    565              }
    566              if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
   \                     ??OSMboxPostOpt_2:
   \   00000056   0x6860             LDR      R0,[R4, #+4]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD004             BEQ.N    ??OSMboxPostOpt_7
    567                  OS_EXIT_CRITICAL();
   \   0000005C   0x0038             MOVS     R0,R7
   \   0000005E   0x.... 0x....      BL       OS_CPU_SR_Restore
    568                  return (OS_ERR_MBOX_FULL);
   \   00000062   0x2014             MOVS     R0,#+20
   \   00000064   0xE004             B.N      ??OSMboxPostOpt_1
    569              }
    570              pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
   \                     ??OSMboxPostOpt_7:
   \   00000066   0x6065             STR      R5,[R4, #+4]
    571              OS_EXIT_CRITICAL();
   \   00000068   0x0038             MOVS     R0,R7
   \   0000006A   0x.... 0x....      BL       OS_CPU_SR_Restore
    572              return (OS_ERR_NONE);
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??OSMboxPostOpt_1:
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    573          }
    574          #endif
    575          
    576          /*$PAGE*/
    577          /*
    578          *********************************************************************************************************
    579          *                                        QUERY A MESSAGE MAILBOX
    580          *
    581          * Description: This function obtains information about a message mailbox.
    582          *
    583          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    584          *
    585          *              p_mbox_data   is a pointer to a structure that will contain information about the message
    586          *                            mailbox.
    587          *
    588          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
    589          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
    590          *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
    591          *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
    592          *********************************************************************************************************
    593          */
    594          
    595          #if OS_MBOX_QUERY_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    596          INT8U  OSMboxQuery (OS_EVENT      *pevent, 
    597                              OS_MBOX_DATA  *p_mbox_data)
    598          {
   \                     OSMboxQuery:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    599              INT8U      i;
    600          #if OS_LOWEST_PRIO <= 63u
    601              INT8U     *psrc;
    602              INT8U     *pdest;
    603          #else
    604              INT16U    *psrc;
    605              INT16U    *pdest;
    606          #endif
    607          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    608              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0xF05F 0x0900      MOVS     R9,#+0
    609          #endif
    610          
    611          
    612          
    613          #if OS_ARG_CHK_EN > 0u
    614              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    615                  return (OS_ERR_PEVENT_NULL);
    616              }
    617              if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
    618                  return (OS_ERR_PDATA_NULL);
    619              }
    620          #endif
    621              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD001             BEQ.N    ??OSMboxQuery_0
    622                  return (OS_ERR_EVENT_TYPE);
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE01C             B.N      ??OSMboxQuery_1
    623              }
    624              OS_ENTER_CRITICAL();
   \                     ??OSMboxQuery_0:
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001A   0x4681             MOV      R9,R0
    625              p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
   \   0000001C   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000001E   0x7228             STRB     R0,[R5, #+8]
    626              psrc                    = &pevent->OSEventTbl[0];
   \   00000020   0xF204 0x000B      ADDW     R0,R4,#+11
   \   00000024   0x0007             MOVS     R7,R0
    627              pdest                   = &p_mbox_data->OSEventTbl[0];
   \   00000026   0x1D28             ADDS     R0,R5,#+4
   \   00000028   0x4680             MOV      R8,R0
    628              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x0006             MOVS     R6,R0
   \                     ??OSMboxQuery_2:
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E04             CMP      R6,#+4
   \   00000032   0xD207             BCS.N    ??OSMboxQuery_3
    629                  *pdest++ = *psrc++;
   \   00000034   0x7838             LDRB     R0,[R7, #+0]
   \   00000036   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   0000003A   0x1C7F             ADDS     R7,R7,#+1
   \   0000003C   0xF118 0x0801      ADDS     R8,R8,#+1
    630              }
   \   00000040   0x1C76             ADDS     R6,R6,#+1
   \   00000042   0xE7F4             B.N      ??OSMboxQuery_2
    631              p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
   \                     ??OSMboxQuery_3:
   \   00000044   0x6860             LDR      R0,[R4, #+4]
   \   00000046   0x6028             STR      R0,[R5, #+0]
    632              OS_EXIT_CRITICAL();
   \   00000048   0x4648             MOV      R0,R9
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    633              return (OS_ERR_NONE);
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??OSMboxQuery_1:
   \   00000050   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    634          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .rodata, align 2
   \   00000000   0x3F 0x00          DC8 "?"
    635          #endif                                                     /* OS_MBOX_QUERY_EN                         */
    636          #endif                                                     /* OS_MBOX_EN                               */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OSMboxAccept
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      16   OSMboxCreate
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_EventWaitListInit
      32   OSMboxDel
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> OS_EventTaskRdy
        32   -> OS_Sched
      24   OSMboxPend
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRemove
        24   -> OS_EventTaskWait
        24   -> OS_Sched
      24   OSMboxPendAbort
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      24   OSMboxPost
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      24   OSMboxPostOpt
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      32   OSMboxQuery
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
      40  OSMboxAccept
      82  OSMboxCreate
     248  OSMboxDel
     266  OSMboxPend
     124  OSMboxPendAbort
      86  OSMboxPost
     114  OSMboxPostOpt
      84  OSMboxQuery

 
     2 bytes in section .rodata
 1 064 bytes in section .text
 
 1 064 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none
