###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:21 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_q.c                                       #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_q.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm\RT #
#                    U\´úÂë\RTU_1.2\project\iar\Debug\List\ -o                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\os_q.lst                                   #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\os_q.o                                      #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCOS-II\Source\os_q.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                        MESSAGE QUEUE MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_Q.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.89
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
     29          /*
     30          *********************************************************************************************************
     31          *                                      ACCEPT MESSAGE FROM QUEUE
     32          *
     33          * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
     34          *              OSQAccept() does not suspend the calling task if a message is not available.
     35          *
     36          * Arguments  : pevent        is a pointer to the event control block
     37          *
     38          *              perr          is a pointer to where an error message will be deposited.  Possible error
     39          *                            messages are:
     40          *
     41          *                            OS_ERR_NONE         The call was successful and your task received a
     42          *                                                message.
     43          *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
     44          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
     45          *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
     46          *
     47          * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
     48          *                            from the so the next time OSQAccept() is called, the queue will contain
     49          *                            one less entry.
     50          *              == (void *)0  if you received a NULL pointer message
     51          *                            if the queue is empty or,
     52          *                            if 'pevent' is a NULL pointer or,
     53          *                            if you passed an invalid event type
     54          *
     55          * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
     56          *              'perr' has been added to the API to tell you about the outcome of the call.
     57          *********************************************************************************************************
     58          */
     59          
     60          #if OS_Q_ACCEPT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     61          void  *OSQAccept (OS_EVENT  *pevent, 
     62                            INT8U     *perr)
     63          {
   \                     OSQAccept:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     64              void      *pmsg;
     65              OS_Q      *pq;
     66          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
     67              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
     68          #endif
     69          
     70          
     71          
     72          #if OS_ARG_CHK_EN > 0u
     73              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
     74                  return ((void *)0);
     75              }
     76              if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
     77                  *perr = OS_ERR_PEVENT_NULL;
     78                  return ((void *)0);
     79              }
     80          #endif
     81              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD003             BEQ.N    ??OSQAccept_0
     82                  *perr = OS_ERR_EVENT_TYPE;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7028             STRB     R0,[R5, #+0]
     83                  return ((void *)0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE020             B.N      ??OSQAccept_1
     84              }
     85              OS_ENTER_CRITICAL();
   \                     ??OSQAccept_0:
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x4680             MOV      R8,R0
     86              pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
   \   00000020   0x6860             LDR      R0,[R4, #+4]
   \   00000022   0x0007             MOVS     R7,R0
     87              if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
   \   00000024   0x8AF8             LDRH     R0,[R7, #+22]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD010             BEQ.N    ??OSQAccept_2
     88                  pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
   \   0000002A   0x6938             LDR      R0,[R7, #+16]
   \   0000002C   0x1D01             ADDS     R1,R0,#+4
   \   0000002E   0x6139             STR      R1,[R7, #+16]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0006             MOVS     R6,R0
     89                  pq->OSQEntries--;                        /* Update the number of entries in the queue          */
   \   00000034   0x8AF8             LDRH     R0,[R7, #+22]
   \   00000036   0x1E40             SUBS     R0,R0,#+1
   \   00000038   0x82F8             STRH     R0,[R7, #+22]
     90                  if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
   \   0000003A   0x6938             LDR      R0,[R7, #+16]
   \   0000003C   0x68B9             LDR      R1,[R7, #+8]
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD101             BNE.N    ??OSQAccept_3
     91                      pq->OSQOut = pq->OSQStart;
   \   00000042   0x6878             LDR      R0,[R7, #+4]
   \   00000044   0x6138             STR      R0,[R7, #+16]
     92                  }
     93                  *perr = OS_ERR_NONE;
   \                     ??OSQAccept_3:
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x7028             STRB     R0,[R5, #+0]
   \   0000004A   0xE003             B.N      ??OSQAccept_4
     94              } else {
     95                  *perr = OS_ERR_Q_EMPTY;
   \                     ??OSQAccept_2:
   \   0000004C   0x201F             MOVS     R0,#+31
   \   0000004E   0x7028             STRB     R0,[R5, #+0]
     96                  pmsg  = (void *)0;                       /* Queue is empty                                     */
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x0006             MOVS     R6,R0
     97              }
     98              OS_EXIT_CRITICAL();
   \                     ??OSQAccept_4:
   \   00000054   0x4640             MOV      R0,R8
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
     99              return (pmsg);                               /* Return message received (or NULL)                  */
   \   0000005A   0x0030             MOVS     R0,R6
   \                     ??OSQAccept_1:
   \   0000005C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    100          }
    101          #endif
    102          /*$PAGE*/
    103          /*
    104          *********************************************************************************************************
    105          *                                        CREATE A MESSAGE QUEUE
    106          *
    107          * Description: This function creates a message queue if free event control blocks are available.
    108          *
    109          * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
    110          *                            storage area MUST be declared as an array of pointers to 'void' as follows
    111          *
    112          *                            void *MessageStorage[size]
    113          *
    114          *              size          is the number of elements in the storage area
    115          *
    116          * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
    117          *                                created queue
    118          *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
    119          *********************************************************************************************************
    120          */
    121          

   \                                 In section .text, align 2, keep-with-next
    122          OS_EVENT  *OSQCreate (void    **start,
    123                                INT16U    size)
    124          {
   \                     OSQCreate:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    125              OS_EVENT  *pevent;
    126              OS_Q      *pq;
    127          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    128              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
    129          #endif
    130          
    131          
    132          
    133              if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable3
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??OSQCreate_0
    134                  return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE04C             B.N      ??OSQCreate_1
    135              }
    136              OS_ENTER_CRITICAL();
   \                     ??OSQCreate_0:
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x4680             MOV      R8,R0
    137              pevent = OSEventFreeList;                    /* Get next free event control block                  */
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0006             MOVS     R6,R0
    138              if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD006             BEQ.N    ??OSQCreate_2
    139                  OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x6840             LDR      R0,[R0, #+4]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable3_1
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    140              }
    141              OS_EXIT_CRITICAL();
   \                     ??OSQCreate_2:
   \   00000040   0x4640             MOV      R0,R8
   \   00000042   0x.... 0x....      BL       OS_CPU_SR_Restore
    142              if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
   \   00000046   0x2E00             CMP      R6,#+0
   \   00000048   0xD033             BEQ.N    ??OSQCreate_3
    143                  OS_ENTER_CRITICAL();
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000004E   0x4680             MOV      R8,R0
    144                  pq = OSQFreeList;                        /* Get a free queue control block                     */
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x0007             MOVS     R7,R0
    145                  if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
   \   00000058   0x2F00             CMP      R7,#+0
   \   0000005A   0xD01E             BEQ.N    ??OSQCreate_4
    146                      OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable3_2
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0x6001             STR      R1,[R0, #+0]
    147                      OS_EXIT_CRITICAL();
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       OS_CPU_SR_Restore
    148                      pq->OSQStart           = start;               /*      Initialize the queue                 */
   \   00000070   0x607C             STR      R4,[R7, #+4]
    149                      pq->OSQEnd             = &start[size];
   \   00000072   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000074   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000078   0x60B8             STR      R0,[R7, #+8]
    150                      pq->OSQIn              = start;
   \   0000007A   0x60FC             STR      R4,[R7, #+12]
    151                      pq->OSQOut             = start;
   \   0000007C   0x613C             STR      R4,[R7, #+16]
    152                      pq->OSQSize            = size;
   \   0000007E   0x82BD             STRH     R5,[R7, #+20]
    153                      pq->OSQEntries         = 0u;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x82F8             STRH     R0,[R7, #+22]
    154                      pevent->OSEventType    = OS_EVENT_TYPE_Q;
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x7030             STRB     R0,[R6, #+0]
    155                      pevent->OSEventCnt     = 0u;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x8130             STRH     R0,[R6, #+8]
    156                      pevent->OSEventPtr     = pq;
   \   0000008C   0x6077             STR      R7,[R6, #+4]
    157          #if OS_EVENT_NAME_EN > 0u
    158                      pevent->OSEventName    = (INT8U *)"?";
   \   0000008E   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   00000090   0x6130             STR      R0,[R6, #+16]
    159          #endif
    160                      OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
   \   00000092   0x0030             MOVS     R0,R6
   \   00000094   0x.... 0x....      BL       OS_EventWaitListInit
   \   00000098   0xE00B             B.N      ??OSQCreate_3
    161                  } else {
    162                      pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
   \                     ??OSQCreate_4:
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x6070             STR      R0,[R6, #+4]
    163                      OSEventFreeList    = pevent;
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   000000A6   0x6006             STR      R6,[R0, #+0]
    164                      OS_EXIT_CRITICAL();
   \   000000A8   0x4640             MOV      R0,R8
   \   000000AA   0x.... 0x....      BL       OS_CPU_SR_Restore
    165                      pevent = (OS_EVENT *)0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x0006             MOVS     R6,R0
    166                  }
    167              }
    168              return (pevent);
   \                     ??OSQCreate_3:
   \   000000B2   0x0030             MOVS     R0,R6
   \                     ??OSQCreate_1:
   \   000000B4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    169          }
    170          /*$PAGE*/
    171          /*
    172          *********************************************************************************************************
    173          *                                        DELETE A MESSAGE QUEUE
    174          *
    175          * Description: This function deletes a message queue and readies all tasks pending on the queue.
    176          *
    177          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    178          *                            queue.
    179          *
    180          *              opt           determines delete options as follows:
    181          *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
    182          *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
    183          *                                                    In this case, all the tasks pending will be readied.
    184          *
    185          *              perr          is a pointer to an error code that can contain one of the following values:
    186          *                            OS_ERR_NONE             The call was successful and the queue was deleted
    187          *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
    188          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    189          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
    190          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
    191          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    192          *
    193          * Returns    : pevent        upon error
    194          *              (OS_EVENT *)0 if the queue was successfully deleted.
    195          *
    196          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    197          *                 the queue MUST check the return code of OSQPend().
    198          *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
    199          *                 they check 'pevent' to see that it's a NULL pointer.
    200          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
    201          *                 time is directly proportional to the number of tasks waiting on the queue.
    202          *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
    203          *                 applications where the queue is used for mutual exclusion because the resource(s)
    204          *                 will no longer be guarded by the queue.
    205          *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
    206          *                 type call) then your application MUST release the memory storage by call the counterpart
    207          *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
    208          *                 then, the storage can be reused.
    209          *********************************************************************************************************
    210          */
    211          
    212          #if OS_Q_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    213          OS_EVENT  *OSQDel (OS_EVENT  *pevent, 
    214                             INT8U      opt, 
    215                             INT8U     *perr)
    216          {
   \                     OSQDel:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    217              BOOLEAN    tasks_waiting;
    218              OS_EVENT  *pevent_return;
    219              OS_Q      *pq;
    220          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    221              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
    222          #endif
    223          
    224          
    225          
    226          #if OS_ARG_CHK_EN > 0u
    227              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    228                  return (pevent);
    229              }
    230              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    231                  *perr = OS_ERR_PEVENT_NULL;
    232                  return (pevent);
    233              }
    234          #endif
    235              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD003             BEQ.N    ??OSQDel_0
    236                  *perr = OS_ERR_EVENT_TYPE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    237                  return (pevent);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xE079             B.N      ??OSQDel_1
    238              }
    239              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??OSQDel_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable3
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD003             BEQ.N    ??OSQDel_2
    240                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00000026   0x200F             MOVS     R0,#+15
   \   00000028   0x7030             STRB     R0,[R6, #+0]
    241                  return (pevent);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xE070             B.N      ??OSQDel_1
    242              }
    243              OS_ENTER_CRITICAL();
   \                     ??OSQDel_2:
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000032   0x4682             MOV      R10,R0
    244              if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
   \   00000034   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??OSQDel_3
    245                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x0007             MOVS     R7,R0
   \   0000003E   0xE001             B.N      ??OSQDel_4
    246              } else {
    247                  tasks_waiting = OS_FALSE;                          /* No                                       */
   \                     ??OSQDel_3:
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x0007             MOVS     R7,R0
    248              }
    249              switch (opt) {
   \                     ??OSQDel_4:
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD002             BEQ.N    ??OSQDel_5
   \   0000004A   0x2D01             CMP      R5,#+1
   \   0000004C   0xD02A             BEQ.N    ??OSQDel_6
   \   0000004E   0xE058             B.N      ??OSQDel_7
    250                  case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
    251                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSQDel_5:
   \   00000050   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000052   0x2F00             CMP      R7,#+0
   \   00000054   0xD11F             BNE.N    ??OSQDel_8
    252          #if OS_EVENT_NAME_EN > 0u
    253                           pevent->OSEventName    = (INT8U *)"?";
   \   00000056   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   00000058   0x6120             STR      R0,[R4, #+16]
    254          #endif
    255                           pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
   \   0000005A   0x6860             LDR      R0,[R4, #+4]
   \   0000005C   0x4681             MOV      R9,R0
    256                           pq->OSQPtr             = OSQFreeList;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF8C9 0x0000      STR      R0,[R9, #+0]
    257                           OSQFreeList            = pq;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   0000006C   0xF8C0 0x9000      STR      R9,[R0, #+0]
    258                           pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x7020             STRB     R0,[R4, #+0]
    259                           pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x6060             STR      R0,[R4, #+4]
    260                           pevent->OSEventCnt     = 0u;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x8120             STRH     R0,[R4, #+8]
    261                           OSEventFreeList        = pevent;          /* Get next free event control block        */
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   00000084   0x6004             STR      R4,[R0, #+0]
    262                           OS_EXIT_CRITICAL();
   \   00000086   0x4650             MOV      R0,R10
   \   00000088   0x.... 0x....      BL       OS_CPU_SR_Restore
    263                           *perr                  = OS_ERR_NONE;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x7030             STRB     R0,[R6, #+0]
    264                           pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x4680             MOV      R8,R0
   \   00000094   0xE005             B.N      ??OSQDel_9
    265                       } else {
    266                           OS_EXIT_CRITICAL();
   \                     ??OSQDel_8:
   \   00000096   0x4650             MOV      R0,R10
   \   00000098   0x.... 0x....      BL       OS_CPU_SR_Restore
    267                           *perr                  = OS_ERR_TASK_WAITING;
   \   0000009C   0x2049             MOVS     R0,#+73
   \   0000009E   0x7030             STRB     R0,[R6, #+0]
    268                           pevent_return          = pevent;
   \   000000A0   0x46A0             MOV      R8,R4
    269                       }
    270                       break;
   \                     ??OSQDel_9:
   \   000000A2   0xE034             B.N      ??OSQDel_10
    271          
    272                  case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
    273                       while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
   \                     ??OSQDel_6:
   \   000000A4   0x7AA0             LDRB     R0,[R4, #+10]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD006             BEQ.N    ??OSQDel_11
    274                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
   \   000000AA   0x2300             MOVS     R3,#+0
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       OS_EventTaskRdy
   \   000000B6   0xE7F5             B.N      ??OSQDel_6
    275                       }
    276          #if OS_EVENT_NAME_EN > 0u
    277                       pevent->OSEventName    = (INT8U *)"?";
   \                     ??OSQDel_11:
   \   000000B8   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   000000BA   0x6120             STR      R0,[R4, #+16]
    278          #endif
    279                       pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
   \   000000BC   0x6860             LDR      R0,[R4, #+4]
   \   000000BE   0x4681             MOV      R9,R0
    280                       pq->OSQPtr             = OSQFreeList;
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0xF8C9 0x0000      STR      R0,[R9, #+0]
    281                       OSQFreeList            = pq;
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   000000CE   0xF8C0 0x9000      STR      R9,[R0, #+0]
    282                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x7020             STRB     R0,[R4, #+0]
    283                       pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x6060             STR      R0,[R4, #+4]
    284                       pevent->OSEventCnt     = 0u;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x8120             STRH     R0,[R4, #+8]
    285                       OSEventFreeList        = pevent;              /* Get next free event control block        */
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   000000E6   0x6004             STR      R4,[R0, #+0]
    286                       OS_EXIT_CRITICAL();
   \   000000E8   0x4650             MOV      R0,R10
   \   000000EA   0x.... 0x....      BL       OS_CPU_SR_Restore
    287                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   000000EE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F0   0x2F01             CMP      R7,#+1
   \   000000F2   0xD101             BNE.N    ??OSQDel_12
    288                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   000000F4   0x.... 0x....      BL       OS_Sched
    289                       }
    290                       *perr                  = OS_ERR_NONE;
   \                     ??OSQDel_12:
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x7030             STRB     R0,[R6, #+0]
    291                       pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x4680             MOV      R8,R0
    292                       break;
   \   00000100   0xE005             B.N      ??OSQDel_10
    293          
    294                  default:
    295                       OS_EXIT_CRITICAL();
   \                     ??OSQDel_7:
   \   00000102   0x4650             MOV      R0,R10
   \   00000104   0x.... 0x....      BL       OS_CPU_SR_Restore
    296                       *perr                  = OS_ERR_INVALID_OPT;
   \   00000108   0x2007             MOVS     R0,#+7
   \   0000010A   0x7030             STRB     R0,[R6, #+0]
    297                       pevent_return          = pevent;
   \   0000010C   0x46A0             MOV      R8,R4
    298                       break;
    299              }
    300              return (pevent_return);
   \                     ??OSQDel_10:
   \   0000010E   0x4640             MOV      R0,R8
   \                     ??OSQDel_1:
   \   00000110   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    301          }
    302          #endif
    303          
    304          /*$PAGE*/
    305          /*
    306          *********************************************************************************************************
    307          *                                             FLUSH QUEUE
    308          *
    309          * Description : This function is used to flush the contents of the message queue.
    310          *
    311          * Arguments   : none
    312          *
    313          * Returns     : OS_ERR_NONE         upon success
    314          *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
    315          *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    316          *
    317          * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
    318          *               the references to what the queue entries are pointing to and thus, you could cause
    319          *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
    320          *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
    321          *********************************************************************************************************
    322          */
    323          
    324          #if OS_Q_FLUSH_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    325          INT8U  OSQFlush (OS_EVENT *pevent)
    326          {
   \                     OSQFlush:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    327              OS_Q      *pq;
    328          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    329              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
    330          #endif
    331          
    332          
    333          
    334          #if OS_ARG_CHK_EN > 0u
    335              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    336                  return (OS_ERR_PEVENT_NULL);
    337              }
    338              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
    339                  return (OS_ERR_EVENT_TYPE);
    340              }
    341          #endif
    342              OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
    343              pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x0005             MOVS     R5,R0
    344              pq->OSQIn      = pq->OSQStart;
   \   00000010   0x6868             LDR      R0,[R5, #+4]
   \   00000012   0x60E8             STR      R0,[R5, #+12]
    345              pq->OSQOut     = pq->OSQStart;
   \   00000014   0x6868             LDR      R0,[R5, #+4]
   \   00000016   0x6128             STR      R0,[R5, #+16]
    346              pq->OSQEntries = 0u;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x82E8             STRH     R0,[R5, #+22]
    347              OS_EXIT_CRITICAL();
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Restore
    348              return (OS_ERR_NONE);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    349          }
    350          #endif
    351          
    352          /*$PAGE*/
    353          /*
    354          *********************************************************************************************************
    355          *                                     PEND ON A QUEUE FOR A MESSAGE
    356          *
    357          * Description: This function waits for a message to be sent to a queue
    358          *
    359          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    360          *
    361          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    362          *                            wait for a message to arrive at the queue up to the amount of time
    363          *                            specified by this argument.  If you specify 0, however, your task will wait
    364          *                            forever at the specified queue or, until a message arrives.
    365          *
    366          *              perr          is a pointer to where an error message will be deposited.  Possible error
    367          *                            messages are:
    368          *
    369          *                            OS_ERR_NONE         The call was successful and your task received a
    370          *                                                message.
    371          *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
    372          *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
    373          *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
    374          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    375          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    376          *                                                would lead to a suspension.
    377          *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
    378          *
    379          * Returns    : != (void *)0  is a pointer to the message received
    380          *              == (void *)0  if you received a NULL pointer message or,
    381          *                            if no message was received or,
    382          *                            if 'pevent' is a NULL pointer or,
    383          *                            if you didn't pass a pointer to a queue.
    384          *
    385          * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
    386          *********************************************************************************************************
    387          */
    388          

   \                                 In section .text, align 2, keep-with-next
    389          void  *OSQPend (OS_EVENT  *pevent, 
    390                          INT32U     timeout, 
    391                          INT8U     *perr)
    392          {
   \                     OSQPend:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    393              void      *pmsg;
    394              OS_Q      *pq;
    395          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    396              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
    397          #endif
    398          
    399          
    400          
    401          #if OS_ARG_CHK_EN > 0u
    402              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    403                  return ((void *)0);
    404              }
    405              if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
    406                  *perr = OS_ERR_PEVENT_NULL;
    407                  return ((void *)0);
    408              }
    409          #endif
    410              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD003             BEQ.N    ??OSQPend_0
    411                  *perr = OS_ERR_EVENT_TYPE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    412                  return ((void *)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE090             B.N      ??OSQPend_1
    413              }
    414              if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
   \                     ??OSQPend_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable3
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD003             BEQ.N    ??OSQPend_2
    415                  *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x7030             STRB     R0,[R6, #+0]
    416                  return ((void *)0);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE087             B.N      ??OSQPend_1
    417              }
    418              if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
   \                     ??OSQPend_2:
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD003             BEQ.N    ??OSQPend_3
    419                  *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
   \   00000038   0x200D             MOVS     R0,#+13
   \   0000003A   0x7030             STRB     R0,[R6, #+0]
    420                  return ((void *)0);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE07E             B.N      ??OSQPend_1
    421              }
    422              OS_ENTER_CRITICAL();
   \                     ??OSQPend_3:
   \   00000040   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000044   0x4681             MOV      R9,R0
    423              pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0x4680             MOV      R8,R0
    424              if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
   \   0000004A   0xF8B8 0x0016      LDRH     R0,[R8, #+22]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD01C             BEQ.N    ??OSQPend_4
    425                  pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
   \   00000052   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   00000056   0x1D01             ADDS     R1,R0,#+4
   \   00000058   0xF8C8 0x1010      STR      R1,[R8, #+16]
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x0007             MOVS     R7,R0
    426                  pq->OSQEntries--;                        /* Update the number of entries in the queue          */
   \   00000060   0xF8B8 0x0016      LDRH     R0,[R8, #+22]
   \   00000064   0x1E40             SUBS     R0,R0,#+1
   \   00000066   0xF8A8 0x0016      STRH     R0,[R8, #+22]
    427                  if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
   \   0000006A   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   0000006E   0xF8D8 0x1008      LDR      R1,[R8, #+8]
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xD103             BNE.N    ??OSQPend_5
    428                      pq->OSQOut = pq->OSQStart;
   \   00000076   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000007A   0xF8C8 0x0010      STR      R0,[R8, #+16]
    429                  }
    430                  OS_EXIT_CRITICAL();
   \                     ??OSQPend_5:
   \   0000007E   0x4648             MOV      R0,R9
   \   00000080   0x.... 0x....      BL       OS_CPU_SR_Restore
    431                  *perr = OS_ERR_NONE;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x7030             STRB     R0,[R6, #+0]
    432                  return (pmsg);                           /* Return message received                            */
   \   00000088   0x0038             MOVS     R0,R7
   \   0000008A   0xE058             B.N      ??OSQPend_1
    433              }
    434              OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
   \                     ??OSQPend_4:
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable3_4
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000096   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable3_4
   \   0000009E   0x6809             LDR      R1,[R1, #+0]
   \   000000A0   0xF881 0x0034      STRB     R0,[R1, #+52]
    435              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable3_4
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0xF880 0x1035      STRB     R1,[R0, #+53]
    436              OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable3_4
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x6305             STR      R5,[R0, #+48]
    437              OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       OS_EventTaskWait
    438              OS_EXIT_CRITICAL();
   \   000000BE   0x4648             MOV      R0,R9
   \   000000C0   0x.... 0x....      BL       OS_CPU_SR_Restore
    439              OS_Sched();                                  /* Find next highest priority task ready to run       */
   \   000000C4   0x.... 0x....      BL       OS_Sched
    440              OS_ENTER_CRITICAL();
   \   000000C8   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000000CC   0x4681             MOV      R9,R0
    441              switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
   \   000000CE   0x....             LDR.N    R0,??DataTable3_4
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD002             BEQ.N    ??OSQPend_6
   \   000000DA   0x2802             CMP      R0,#+2
   \   000000DC   0xD007             BEQ.N    ??OSQPend_7
   \   000000DE   0xE00B             B.N      ??OSQPend_8
    442                  case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
    443                       pmsg =  OSTCBCur->OSTCBMsg;
   \                     ??OSQPend_6:
   \   000000E0   0x....             LDR.N    R0,??DataTable3_4
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0x6A40             LDR      R0,[R0, #+36]
   \   000000E6   0x0007             MOVS     R7,R0
    444                      *perr =  OS_ERR_NONE;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x7030             STRB     R0,[R6, #+0]
    445                       break;
   \   000000EC   0xE00D             B.N      ??OSQPend_9
    446          
    447                  case OS_STAT_PEND_ABORT:
    448                       pmsg = (void *)0;
   \                     ??OSQPend_7:
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x0007             MOVS     R7,R0
    449                      *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
   \   000000F2   0x200E             MOVS     R0,#+14
   \   000000F4   0x7030             STRB     R0,[R6, #+0]
    450                       break;
   \   000000F6   0xE008             B.N      ??OSQPend_9
    451          
    452                  case OS_STAT_PEND_TO:
    453                  default:
    454                       OS_EventTaskRemove(OSTCBCur, pevent);
   \                     ??OSQPend_8:
   \   000000F8   0x0021             MOVS     R1,R4
   \   000000FA   0x....             LDR.N    R0,??DataTable3_4
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x.... 0x....      BL       OS_EventTaskRemove
    455                       pmsg = (void *)0;
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x0007             MOVS     R7,R0
    456                      *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
   \   00000106   0x200A             MOVS     R0,#+10
   \   00000108   0x7030             STRB     R0,[R6, #+0]
    457                       break;
    458              }
    459              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
   \                     ??OSQPend_9:
   \   0000010A   0x....             LDR.N    R0,??DataTable3_4
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0x2100             MOVS     R1,#+0
   \   00000110   0xF880 0x1034      STRB     R1,[R0, #+52]
    460              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
   \   00000114   0x....             LDR.N    R0,??DataTable3_4
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0x2100             MOVS     R1,#+0
   \   0000011A   0xF880 0x1035      STRB     R1,[R0, #+53]
    461              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
   \   0000011E   0x....             LDR.N    R0,??DataTable3_4
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x2100             MOVS     R1,#+0
   \   00000124   0x61C1             STR      R1,[R0, #+28]
    462          #if (OS_EVENT_MULTI_EN > 0u)
    463              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   00000126   0x....             LDR.N    R0,??DataTable3_4
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0x2100             MOVS     R1,#+0
   \   0000012C   0x6201             STR      R1,[R0, #+32]
    464          #endif
    465              OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
   \   0000012E   0x....             LDR.N    R0,??DataTable3_4
   \   00000130   0x6800             LDR      R0,[R0, #+0]
   \   00000132   0x2100             MOVS     R1,#+0
   \   00000134   0x6241             STR      R1,[R0, #+36]
    466              OS_EXIT_CRITICAL();
   \   00000136   0x4648             MOV      R0,R9
   \   00000138   0x.... 0x....      BL       OS_CPU_SR_Restore
    467              return (pmsg);                                    /* Return received message                       */
   \   0000013C   0x0038             MOVS     R0,R7
   \                     ??OSQPend_1:
   \   0000013E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    468          }
    469          /*$PAGE*/
    470          /*
    471          *********************************************************************************************************
    472          *                                      ABORT WAITING ON A MESSAGE QUEUE
    473          *
    474          * Description: This function aborts & readies any tasks currently waiting on a queue.  This function 
    475          *              should be used to fault-abort the wait on the queue, rather than to normally signal
    476          *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
    477          *
    478          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
    479          *
    480          *              opt           determines the type of ABORT performed:
    481          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
    482          *                                                     queue
    483          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
    484          *                                                     queue
    485          *
    486          *              perr          is a pointer to where an error message will be deposited.  Possible error
    487          *                            messages are:
    488          *
    489          *                            OS_ERR_NONE         No tasks were     waiting on the queue.
    490          *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
    491          *                                                and informed of the aborted wait; check return value 
    492          *                                                for the number of tasks whose wait on the queue 
    493          *                                                was aborted.
    494          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
    495          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    496          *
    497          * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
    498          *              >  0          if one or more tasks waiting on the queue are now readied and informed.
    499          *********************************************************************************************************
    500          */
    501          
    502          #if OS_Q_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    503          INT8U  OSQPendAbort (OS_EVENT  *pevent, 
    504                               INT8U      opt, 
    505                               INT8U     *perr)
    506          {
   \                     OSQPendAbort:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    507              INT8U      nbr_tasks;
    508          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    509              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    510          #endif
    511          
    512          
    513          
    514          #if OS_ARG_CHK_EN > 0u
    515              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    516                  return (0u);
    517              }
    518              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    519                  *perr = OS_ERR_PEVENT_NULL;
    520                  return (0u);
    521              }
    522          #endif
    523              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD003             BEQ.N    ??OSQPendAbort_0
    524                  *perr = OS_ERR_EVENT_TYPE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    525                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE02D             B.N      ??OSQPendAbort_1
    526              }
    527              OS_ENTER_CRITICAL();
   \                     ??OSQPendAbort_0:
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000020   0x4680             MOV      R8,R0
    528              if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
   \   00000022   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD021             BEQ.N    ??OSQPendAbort_2
    529                  nbr_tasks = 0u;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x0007             MOVS     R7,R0
    530                  switch (opt) {
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD10B             BNE.N    ??OSQPendAbort_3
    531                      case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
    532                           while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
   \                     ??OSQPendAbort_4:
   \   00000032   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD007             BEQ.N    ??OSQPendAbort_5
    533                               (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
   \   00000038   0x2302             MOVS     R3,#+2
   \   0000003A   0x2204             MOVS     R2,#+4
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       OS_EventTaskRdy
    534                               nbr_tasks++;
   \   00000044   0x1C7F             ADDS     R7,R7,#+1
   \   00000046   0xE7F4             B.N      ??OSQPendAbort_4
    535                           }
    536                           break;
   \                     ??OSQPendAbort_5:
   \   00000048   0xE006             B.N      ??OSQPendAbort_6
    537                         
    538                      case OS_PEND_OPT_NONE:
    539                      default:                                       /* No,  ready HPT       waiting on queue    */
    540                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
   \                     ??OSQPendAbort_3:
   \   0000004A   0x2302             MOVS     R3,#+2
   \   0000004C   0x2204             MOVS     R2,#+4
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       OS_EventTaskRdy
    541                           nbr_tasks++;
   \   00000056   0x1C7F             ADDS     R7,R7,#+1
    542                           break;
    543                  }
    544                  OS_EXIT_CRITICAL();
   \                     ??OSQPendAbort_6:
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x.... 0x....      BL       OS_CPU_SR_Restore
    545                  OS_Sched();                                        /* Find HPT ready to run                    */
   \   0000005E   0x.... 0x....      BL       OS_Sched
    546                  *perr = OS_ERR_PEND_ABORT;
   \   00000062   0x200E             MOVS     R0,#+14
   \   00000064   0x7030             STRB     R0,[R6, #+0]
    547                  return (nbr_tasks);
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE005             B.N      ??OSQPendAbort_1
    548              }
    549              OS_EXIT_CRITICAL();
   \                     ??OSQPendAbort_2:
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       OS_CPU_SR_Restore
    550              *perr = OS_ERR_NONE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x7030             STRB     R0,[R6, #+0]
    551              return (0u);                                           /* No tasks waiting on queue                */
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??OSQPendAbort_1:
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    552          }
    553          #endif
    554          
    555          /*$PAGE*/
    556          /*
    557          *********************************************************************************************************
    558          *                                        POST MESSAGE TO A QUEUE
    559          *
    560          * Description: This function sends a message to a queue
    561          *
    562          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    563          *
    564          *              pmsg          is a pointer to the message to send.
    565          *
    566          * Returns    : OS_ERR_NONE           The call was successful and the message was sent
    567          *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
    568          *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
    569          *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
    570          *
    571          * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
    572          *********************************************************************************************************
    573          */
    574          
    575          #if OS_Q_POST_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    576          INT8U  OSQPost (OS_EVENT  *pevent, 
    577                          void      *pmsg)
    578          {
   \                     OSQPost:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    579              OS_Q      *pq;
    580          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
    581              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
    582          #endif
    583          
    584          
    585          
    586          #if OS_ARG_CHK_EN > 0u
    587              if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
    588                  return (OS_ERR_PEVENT_NULL);
    589              }
    590          #endif
    591              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD001             BEQ.N    ??OSQPost_0
    592                  return (OS_ERR_EVENT_TYPE);
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE02F             B.N      ??OSQPost_1
    593              }
    594              OS_ENTER_CRITICAL();
   \                     ??OSQPost_0:
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000018   0x0007             MOVS     R7,R0
    595              if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
   \   0000001A   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD00D             BEQ.N    ??OSQPost_2
    596                                                                 /* Ready highest priority task waiting on event */
    597                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       OS_EventTaskRdy
   \   0000002C   0x4680             MOV      R8,R0
    598                  OS_EXIT_CRITICAL();
   \   0000002E   0x0038             MOVS     R0,R7
   \   00000030   0x.... 0x....      BL       OS_CPU_SR_Restore
    599                  OS_Sched();                                    /* Find highest priority task ready to run      */
   \   00000034   0x.... 0x....      BL       OS_Sched
    600                  return (OS_ERR_NONE);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE01B             B.N      ??OSQPost_1
    601              }
    602              pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
   \                     ??OSQPost_2:
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0x0006             MOVS     R6,R0
    603              if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
   \   00000040   0x8AF0             LDRH     R0,[R6, #+22]
   \   00000042   0x8AB1             LDRH     R1,[R6, #+20]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD304             BCC.N    ??OSQPost_3
    604                  OS_EXIT_CRITICAL();
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    605                  return (OS_ERR_Q_FULL);
   \   0000004E   0x201E             MOVS     R0,#+30
   \   00000050   0xE010             B.N      ??OSQPost_1
    606              }
    607              *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
   \                     ??OSQPost_3:
   \   00000052   0x68F0             LDR      R0,[R6, #+12]
   \   00000054   0x1D01             ADDS     R1,R0,#+4
   \   00000056   0x60F1             STR      R1,[R6, #+12]
   \   00000058   0x6005             STR      R5,[R0, #+0]
    608              pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
   \   0000005A   0x8AF0             LDRH     R0,[R6, #+22]
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \   0000005E   0x82F0             STRH     R0,[R6, #+22]
    609              if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
   \   00000060   0x68F0             LDR      R0,[R6, #+12]
   \   00000062   0x68B1             LDR      R1,[R6, #+8]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD101             BNE.N    ??OSQPost_4
    610                  pq->OSQIn = pq->OSQStart;
   \   00000068   0x6870             LDR      R0,[R6, #+4]
   \   0000006A   0x60F0             STR      R0,[R6, #+12]
    611              }
    612              OS_EXIT_CRITICAL();
   \                     ??OSQPost_4:
   \   0000006C   0x0038             MOVS     R0,R7
   \   0000006E   0x.... 0x....      BL       OS_CPU_SR_Restore
    613              return (OS_ERR_NONE);
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??OSQPost_1:
   \   00000074   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    614          }
    615          #endif
    616          /*$PAGE*/
    617          /*
    618          *********************************************************************************************************
    619          *                                   POST MESSAGE TO THE FRONT OF A QUEUE
    620          *
    621          * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
    622          *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
    623          *              'priority' messages.
    624          *
    625          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    626          *
    627          *              pmsg          is a pointer to the message to send.
    628          *
    629          * Returns    : OS_ERR_NONE           The call was successful and the message was sent
    630          *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
    631          *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
    632          *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
    633          *
    634          * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
    635          *********************************************************************************************************
    636          */
    637          
    638          #if OS_Q_POST_FRONT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    639          INT8U  OSQPostFront (OS_EVENT  *pevent, 
    640                               void      *pmsg)
    641          {
   \                     OSQPostFront:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    642              OS_Q      *pq;
    643          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    644              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
    645          #endif
    646          
    647          
    648          
    649          #if OS_ARG_CHK_EN > 0u
    650              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    651                  return (OS_ERR_PEVENT_NULL);
    652              }
    653          #endif
    654              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD001             BEQ.N    ??OSQPostFront_0
    655                  return (OS_ERR_EVENT_TYPE);
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE030             B.N      ??OSQPostFront_1
    656              }
    657              OS_ENTER_CRITICAL();
   \                     ??OSQPostFront_0:
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000018   0x0007             MOVS     R7,R0
    658              if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
   \   0000001A   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD00D             BEQ.N    ??OSQPostFront_2
    659                                                                /* Ready highest priority task waiting on event  */
    660                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       OS_EventTaskRdy
   \   0000002C   0x4680             MOV      R8,R0
    661                  OS_EXIT_CRITICAL();
   \   0000002E   0x0038             MOVS     R0,R7
   \   00000030   0x.... 0x....      BL       OS_CPU_SR_Restore
    662                  OS_Sched();                                   /* Find highest priority task ready to run       */
   \   00000034   0x.... 0x....      BL       OS_Sched
    663                  return (OS_ERR_NONE);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE01C             B.N      ??OSQPostFront_1
    664              }
    665              pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
   \                     ??OSQPostFront_2:
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0x0006             MOVS     R6,R0
    666              if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
   \   00000040   0x8AF0             LDRH     R0,[R6, #+22]
   \   00000042   0x8AB1             LDRH     R1,[R6, #+20]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD304             BCC.N    ??OSQPostFront_3
    667                  OS_EXIT_CRITICAL();
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    668                  return (OS_ERR_Q_FULL);
   \   0000004E   0x201E             MOVS     R0,#+30
   \   00000050   0xE011             B.N      ??OSQPostFront_1
    669              }
    670              if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
   \                     ??OSQPostFront_3:
   \   00000052   0x6930             LDR      R0,[R6, #+16]
   \   00000054   0x6871             LDR      R1,[R6, #+4]
   \   00000056   0x4288             CMP      R0,R1
   \   00000058   0xD101             BNE.N    ??OSQPostFront_4
    671                  pq->OSQOut = pq->OSQEnd;
   \   0000005A   0x68B0             LDR      R0,[R6, #+8]
   \   0000005C   0x6130             STR      R0,[R6, #+16]
    672              }
    673              pq->OSQOut--;
   \                     ??OSQPostFront_4:
   \   0000005E   0x6930             LDR      R0,[R6, #+16]
   \   00000060   0x1F00             SUBS     R0,R0,#+4
   \   00000062   0x6130             STR      R0,[R6, #+16]
    674              *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
   \   00000064   0x6930             LDR      R0,[R6, #+16]
   \   00000066   0x6005             STR      R5,[R0, #+0]
    675              pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
   \   00000068   0x8AF0             LDRH     R0,[R6, #+22]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \   0000006C   0x82F0             STRH     R0,[R6, #+22]
    676              OS_EXIT_CRITICAL();
   \   0000006E   0x0038             MOVS     R0,R7
   \   00000070   0x.... 0x....      BL       OS_CPU_SR_Restore
    677              return (OS_ERR_NONE);
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??OSQPostFront_1:
   \   00000076   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    678          }
    679          #endif
    680          /*$PAGE*/
    681          /*
    682          *********************************************************************************************************
    683          *                                        POST MESSAGE TO A QUEUE
    684          *
    685          * Description: This function sends a message to a queue.  This call has been added to reduce code size
    686          *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
    687          *              capability to broadcast a message to ALL tasks waiting on the message queue.
    688          *
    689          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    690          *
    691          *              pmsg          is a pointer to the message to send.
    692          *
    693          *              opt           determines the type of POST performed:
    694          *                            OS_POST_OPT_NONE         POST to a single waiting task
    695          *                                                     (Identical to OSQPost())
    696          *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
    697          *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
    698          *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
    699          *
    700          * Returns    : OS_ERR_NONE           The call was successful and the message was sent
    701          *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
    702          *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
    703          *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
    704          *
    705          * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
    706          *              interrupt disable time is proportional to the number of tasks waiting on the queue.
    707          *********************************************************************************************************
    708          */
    709          
    710          #if OS_Q_POST_OPT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    711          INT8U  OSQPostOpt (OS_EVENT  *pevent, 
    712                             void      *pmsg, 
    713                             INT8U      opt)
    714          {
   \                     OSQPostOpt:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    715              OS_Q      *pq;
    716          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    717              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    718          #endif
    719          
    720          
    721          
    722          #if OS_ARG_CHK_EN > 0u
    723              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    724                  return (OS_ERR_PEVENT_NULL);
    725              }
    726          #endif
    727              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD001             BEQ.N    ??OSQPostOpt_0
    728                  return (OS_ERR_EVENT_TYPE);
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE04A             B.N      ??OSQPostOpt_1
    729              }
    730              OS_ENTER_CRITICAL();
   \                     ??OSQPostOpt_0:
   \   00000018   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001C   0x4680             MOV      R8,R0
    731              if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
   \   0000001E   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD01A             BEQ.N    ??OSQPostOpt_2
    732                  if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
   \   00000024   0x07F0             LSLS     R0,R6,#+31
   \   00000026   0xD509             BPL.N    ??OSQPostOpt_3
    733                      while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
   \                     ??OSQPostOpt_4:
   \   00000028   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00C             BEQ.N    ??OSQPostOpt_5
    734                          (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       OS_EventTaskRdy
   \   0000003A   0xE7F5             B.N      ??OSQPostOpt_4
    735                      }
    736                  } else {                                      /* No,  Post to HPT waiting on queue             */
    737                      (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \                     ??OSQPostOpt_3:
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x2204             MOVS     R2,#+4
   \   00000040   0x0029             MOVS     R1,R5
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       OS_EventTaskRdy
    738                  }
    739                  OS_EXIT_CRITICAL();
   \                     ??OSQPostOpt_5:
   \   00000048   0x4640             MOV      R0,R8
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    740                  if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {	  /* See if scheduler needs to be invoked          */
   \   0000004E   0x0770             LSLS     R0,R6,#+29
   \   00000050   0xD401             BMI.N    ??OSQPostOpt_6
    741                      OS_Sched();                               /* Find highest priority task ready to run       */
   \   00000052   0x.... 0x....      BL       OS_Sched
    742                  }
    743                  return (OS_ERR_NONE);
   \                     ??OSQPostOpt_6:
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE029             B.N      ??OSQPostOpt_1
    744              }
    745              pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
   \                     ??OSQPostOpt_2:
   \   0000005A   0x6860             LDR      R0,[R4, #+4]
   \   0000005C   0x0007             MOVS     R7,R0
    746              if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
   \   0000005E   0x8AF8             LDRH     R0,[R7, #+22]
   \   00000060   0x8AB9             LDRH     R1,[R7, #+20]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD304             BCC.N    ??OSQPostOpt_7
    747                  OS_EXIT_CRITICAL();
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0x.... 0x....      BL       OS_CPU_SR_Restore
    748                  return (OS_ERR_Q_FULL);
   \   0000006C   0x201E             MOVS     R0,#+30
   \   0000006E   0xE01E             B.N      ??OSQPostOpt_1
    749              }
    750              if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
   \                     ??OSQPostOpt_7:
   \   00000070   0x07B0             LSLS     R0,R6,#+30
   \   00000072   0xD50B             BPL.N    ??OSQPostOpt_8
    751                  if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
   \   00000074   0x6938             LDR      R0,[R7, #+16]
   \   00000076   0x6879             LDR      R1,[R7, #+4]
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD101             BNE.N    ??OSQPostOpt_9
    752                      pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
   \   0000007C   0x68B8             LDR      R0,[R7, #+8]
   \   0000007E   0x6138             STR      R0,[R7, #+16]
    753                  }
    754                  pq->OSQOut--;
   \                     ??OSQPostOpt_9:
   \   00000080   0x6938             LDR      R0,[R7, #+16]
   \   00000082   0x1F00             SUBS     R0,R0,#+4
   \   00000084   0x6138             STR      R0,[R7, #+16]
    755                  *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
   \   00000086   0x6938             LDR      R0,[R7, #+16]
   \   00000088   0x6005             STR      R5,[R0, #+0]
   \   0000008A   0xE009             B.N      ??OSQPostOpt_10
    756              } else {                                          /* No,  Post as FIFO                             */
    757                  *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
   \                     ??OSQPostOpt_8:
   \   0000008C   0x68F8             LDR      R0,[R7, #+12]
   \   0000008E   0x1D01             ADDS     R1,R0,#+4
   \   00000090   0x60F9             STR      R1,[R7, #+12]
   \   00000092   0x6005             STR      R5,[R0, #+0]
    758                  if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
   \   00000094   0x68F8             LDR      R0,[R7, #+12]
   \   00000096   0x68B9             LDR      R1,[R7, #+8]
   \   00000098   0x4288             CMP      R0,R1
   \   0000009A   0xD101             BNE.N    ??OSQPostOpt_10
    759                      pq->OSQIn = pq->OSQStart;
   \   0000009C   0x6878             LDR      R0,[R7, #+4]
   \   0000009E   0x60F8             STR      R0,[R7, #+12]
    760                  }
    761              }
    762              pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
   \                     ??OSQPostOpt_10:
   \   000000A0   0x8AF8             LDRH     R0,[R7, #+22]
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \   000000A4   0x82F8             STRH     R0,[R7, #+22]
    763              OS_EXIT_CRITICAL();
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0x.... 0x....      BL       OS_CPU_SR_Restore
    764              return (OS_ERR_NONE);
   \   000000AC   0x2000             MOVS     R0,#+0
   \                     ??OSQPostOpt_1:
   \   000000AE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    765          }
    766          #endif
    767          /*$PAGE*/
    768          /*
    769          *********************************************************************************************************
    770          *                                        QUERY A MESSAGE QUEUE
    771          *
    772          * Description: This function obtains information about a message queue.
    773          *
    774          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    775          *
    776          *              p_q_data      is a pointer to a structure that will contain information about the message
    777          *                            queue.
    778          *
    779          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
    780          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
    781          *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
    782          *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
    783          *********************************************************************************************************
    784          */
    785          
    786          #if OS_Q_QUERY_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    787          INT8U  OSQQuery (OS_EVENT  *pevent, 
    788                           OS_Q_DATA *p_q_data)
    789          {
   \                     OSQQuery:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    790              OS_Q      *pq;
    791              INT8U      i;
    792          #if OS_LOWEST_PRIO <= 63u
    793              INT8U     *psrc;
    794              INT8U     *pdest;
    795          #else
    796              INT16U    *psrc;
    797              INT16U    *pdest;
    798          #endif
    799          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
    800              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0xF05F 0x0A00      MOVS     R10,#+0
    801          #endif
    802          
    803          
    804          
    805          #if OS_ARG_CHK_EN > 0u
    806              if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
    807                  return (OS_ERR_PEVENT_NULL);
    808              }
    809              if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
    810                  return (OS_ERR_PDATA_NULL);
    811              }
    812          #endif
    813              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD001             BEQ.N    ??OSQQuery_0
    814                  return (OS_ERR_EVENT_TYPE);
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE02C             B.N      ??OSQQuery_1
    815              }
    816              OS_ENTER_CRITICAL();
   \                     ??OSQQuery_0:
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001A   0x4682             MOV      R10,R0
    817              p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
   \   0000001C   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000001E   0x7328             STRB     R0,[R5, #+12]
    818              psrc                 = &pevent->OSEventTbl[0];
   \   00000020   0xF204 0x000B      ADDW     R0,R4,#+11
   \   00000024   0x4680             MOV      R8,R0
    819              pdest                = &p_q_data->OSEventTbl[0];
   \   00000026   0xF115 0x0008      ADDS     R0,R5,#+8
   \   0000002A   0x4681             MOV      R9,R0
    820              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x0007             MOVS     R7,R0
   \                     ??OSQQuery_2:
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0x2F04             CMP      R7,#+4
   \   00000034   0xD209             BCS.N    ??OSQQuery_3
    821                  *pdest++ = *psrc++;
   \   00000036   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000003A   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   0000003E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000042   0xF119 0x0901      ADDS     R9,R9,#+1
    822              }
   \   00000046   0x1C7F             ADDS     R7,R7,#+1
   \   00000048   0xE7F2             B.N      ??OSQQuery_2
    823              pq = (OS_Q *)pevent->OSEventPtr;
   \                     ??OSQQuery_3:
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0x0006             MOVS     R6,R0
    824              if (pq->OSQEntries > 0u) {
   \   0000004E   0x8AF0             LDRH     R0,[R6, #+22]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD003             BEQ.N    ??OSQQuery_4
    825                  p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
   \   00000054   0x6930             LDR      R0,[R6, #+16]
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x6028             STR      R0,[R5, #+0]
   \   0000005A   0xE001             B.N      ??OSQQuery_5
    826              } else {
    827                  p_q_data->OSMsg = (void *)0;
   \                     ??OSQQuery_4:
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6028             STR      R0,[R5, #+0]
    828              }
    829              p_q_data->OSNMsgs = pq->OSQEntries;
   \                     ??OSQQuery_5:
   \   00000060   0x8AF0             LDRH     R0,[R6, #+22]
   \   00000062   0x80A8             STRH     R0,[R5, #+4]
    830              p_q_data->OSQSize = pq->OSQSize;
   \   00000064   0x8AB0             LDRH     R0,[R6, #+20]
   \   00000066   0x80E8             STRH     R0,[R5, #+6]
    831              OS_EXIT_CRITICAL();
   \   00000068   0x4650             MOV      R0,R10
   \   0000006A   0x.... 0x....      BL       OS_CPU_SR_Restore
    832              return (OS_ERR_NONE);
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??OSQQuery_1:
   \   00000070   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    833          }
    834          #endif                                                 /* OS_Q_QUERY_EN                                */
    835          
    836          /*$PAGE*/
    837          /*
    838          *********************************************************************************************************
    839          *                                      QUEUE MODULE INITIALIZATION
    840          *
    841          * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
    842          *               application MUST NOT call this function.
    843          *
    844          * Arguments   :  none
    845          *
    846          * Returns     : none
    847          *
    848          * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
    849          *********************************************************************************************************
    850          */
    851          

   \                                 In section .text, align 2, keep-with-next
    852          void  OS_QInit (void)
    853          {
   \                     OS_QInit:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    854          #if OS_MAX_QS == 1u
    855              OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
    856              OSQFreeList->OSQPtr = (OS_Q *)0;
    857          #endif
    858          
    859          #if OS_MAX_QS >= 2u
    860              INT16U  i;
    861              OS_Q   *pq1;
    862              OS_Q   *pq2;
    863          
    864          
    865          
    866              OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
   \   00000002   0xF44F 0x71F0      MOV      R1,#+480
   \   00000006   0x....             LDR.N    R0,??DataTable3_5
   \   00000008   0x.... 0x....      BL       OS_MemClr
    867              pq1 = &OSQTbl[0];
   \   0000000C   0x....             LDR.N    R0,??DataTable3_5
   \   0000000E   0x0004             MOVS     R4,R0
    868              pq2 = &OSQTbl[1];
   \   00000010   0x....             LDR.N    R0,??DataTable3_6
   \   00000012   0x0005             MOVS     R5,R0
    869              for (i = 0u; i < (OS_MAX_QS - 1u); i++) {        /* Init. list of free QUEUE control blocks        */
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0006             MOVS     R6,R0
   \                     ??OS_QInit_0:
   \   00000018   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001A   0x2E13             CMP      R6,#+19
   \   0000001C   0xD204             BCS.N    ??OS_QInit_1
    870                  pq1->OSQPtr = pq2;
   \   0000001E   0x6025             STR      R5,[R4, #+0]
    871                  pq1++;
   \   00000020   0x3418             ADDS     R4,R4,#+24
    872                  pq2++;
   \   00000022   0x3518             ADDS     R5,R5,#+24
    873              }
   \   00000024   0x1C76             ADDS     R6,R6,#+1
   \   00000026   0xE7F7             B.N      ??OS_QInit_0
    874              pq1->OSQPtr = (OS_Q *)0;
   \                     ??OS_QInit_1:
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6020             STR      R0,[R4, #+0]
    875              OSQFreeList = &OSQTbl[0];
   \   0000002C   0x....             LDR.N    R0,??DataTable3_2
   \   0000002E   0x....             LDR.N    R1,??DataTable3_5
   \   00000030   0x6001             STR      R1,[R0, #+0]
    876          #endif
    877          }
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     OSQFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     OSQTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     OSQTbl+0x18

   \                                 In section .rodata, align 2
   \   00000000   0x3F 0x00          DC8 "?"
    878          #endif                                               /* OS_Q_EN                                        */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSQAccept
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      24   OSQCreate
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventWaitListInit
      32   OSQDel
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> OS_EventTaskRdy
        32   -> OS_Sched
      16   OSQFlush
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      32   OSQPend
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> OS_EventTaskRemove
        32   -> OS_EventTaskWait
        32   -> OS_Sched
      24   OSQPendAbort
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      24   OSQPost
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      24   OSQPostFront
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      24   OSQPostOpt
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      32   OSQQuery
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
      16   OS_QInit
        16   -> OS_MemClr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
       4  ??DataTable2
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
      96  OSQAccept
     184  OSQCreate
     276  OSQDel
      38  OSQFlush
     322  OSQPend
     124  OSQPendAbort
     120  OSQPost
     122  OSQPostFront
     178  OSQPostOpt
     116  OSQQuery
      52  OS_QInit

 
     2 bytes in section .rodata
 1 660 bytes in section .text
 
 1 660 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none
