###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:21 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_task.c                                    #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_task.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm #
#                    \RTU\´úÂë\RTU_1.2\project\iar\Debug\List\ -o             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\os_task.lst                                #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\os_task.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCOS-II\Source\os_task.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                            TASK MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_TASK.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.89
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          /*$PAGE*/
     29          /*
     30          *********************************************************************************************************
     31          *                                        CHANGE PRIORITY OF A TASK
     32          *
     33          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
     34          *              priority MUST be available.
     35          *
     36          * Arguments  : oldp     is the old priority
     37          *
     38          *              newp     is the new priority
     39          *
     40          * Returns    : OS_ERR_NONE            is the call was successful
     41          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
     42          *                                     (i.e. >= OS_LOWEST_PRIO)
     43          *              OS_ERR_PRIO_EXIST      if the new priority already exist.
     44          *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
     45          *                                     not exist.
     46          *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
     47          *********************************************************************************************************
     48          */
     49          
     50          #if OS_TASK_CHANGE_PRIO_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     51          INT8U  OSTaskChangePrio (INT8U  oldprio,
     52                                   INT8U  newprio)
     53          {
   \                     OSTaskChangePrio:
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x000C             MOVS     R4,R1
     54          #if (OS_EVENT_EN)
     55              OS_EVENT  *pevent;
     56          #if (OS_EVENT_MULTI_EN > 0u)
     57              OS_EVENT **pevents;
     58          #endif
     59          #endif
     60              OS_TCB    *ptcb;
     61              INT8U      y_new;
     62              INT8U      x_new;
     63              INT8U      y_old;
     64          #if OS_LOWEST_PRIO <= 63u
     65              INT8U      bity_new;
     66              INT8U      bitx_new;
     67              INT8U      bity_old;
     68              INT8U      bitx_old;
     69          #else
     70              INT16U     bity_new;
     71              INT16U     bitx_new;
     72              INT16U     bity_old;
     73              INT16U     bitx_old;
     74          #endif
     75          #if OS_CRITICAL_METHOD == 3u
     76              OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   \   00000008   0xF05F 0x0B00      MOVS     R11,#+0
     77          #endif
     78          
     79          
     80          /*$PAGE*/
     81          #if OS_ARG_CHK_EN > 0u
     82              if (oldprio >= OS_LOWEST_PRIO) {
     83                  if (oldprio != OS_PRIO_SELF) {
     84                      return (OS_ERR_PRIO_INVALID);
     85                  }
     86              }
     87              if (newprio >= OS_LOWEST_PRIO) {
     88                  return (OS_ERR_PRIO_INVALID);
     89              }
     90          #endif
     91              OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000010   0x4683             MOV      R11,R0
     92              if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000018   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ.N    ??OSTaskChangePrio_0
     93                  OS_EXIT_CRITICAL();
   \   00000020   0x4658             MOV      R0,R11
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Restore
     94                  return (OS_ERR_PRIO_EXIST);
   \   00000026   0x2028             MOVS     R0,#+40
   \   00000028   0xE109             B.N      ??OSTaskChangePrio_1
     95              }
     96              if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
   \                     ??OSTaskChangePrio_0:
   \   0000002A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000002E   0x28FF             CMP      R0,#+255
   \   00000030   0xD106             BNE.N    ??OSTaskChangePrio_2
     97                  oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000003C   0xF88D 0x0008      STRB     R0,[SP, #+8]
     98              }
     99              ptcb = OSTCBPrioTbl[oldprio];
   \                     ??OSTaskChangePrio_2:
   \   00000040   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000048   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000004C   0x0007             MOVS     R7,R0
    100              if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD104             BNE.N    ??OSTaskChangePrio_3
    101                  OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
   \   00000052   0x4658             MOV      R0,R11
   \   00000054   0x.... 0x....      BL       OS_CPU_SR_Restore
    102                  return (OS_ERR_PRIO);
   \   00000058   0x2029             MOVS     R0,#+41
   \   0000005A   0xE0F0             B.N      ??OSTaskChangePrio_1
    103              }
    104              if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
   \                     ??OSTaskChangePrio_3:
   \   0000005C   0x2F01             CMP      R7,#+1
   \   0000005E   0xD104             BNE.N    ??OSTaskChangePrio_4
    105                  OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
   \   00000060   0x4658             MOV      R0,R11
   \   00000062   0x.... 0x....      BL       OS_CPU_SR_Restore
    106                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000066   0x2043             MOVS     R0,#+67
   \   00000068   0xE0E9             B.N      ??OSTaskChangePrio_1
    107              }
    108          #if OS_LOWEST_PRIO <= 63u
    109              y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
   \                     ??OSTaskChangePrio_4:
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0x08E0             LSRS     R0,R4,#+3
   \   0000006E   0x4680             MOV      R8,R0
    110              x_new                 = (INT8U)(newprio & 0x07);
   \   00000070   0xF014 0x0007      ANDS     R0,R4,#0x7
   \   00000074   0xF88D 0x0003      STRB     R0,[SP, #+3]
    111              bity_new              = (INT8U)(1u << y_new);
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0xFA10 0xF008      LSLS     R0,R0,R8
   \   0000007E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    112              bitx_new              = (INT8U)(1u << x_new);
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000088   0x4088             LSLS     R0,R0,R1
   \   0000008A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    113          #else
    114              y_new                 = (INT8U)((newprio >> 4) & 0x0F);
    115              x_new                 = (INT8U)( newprio & 0x0F);
    116              bity_new              = (INT16U)(1u << y_new);
    117              bitx_new              = (INT16U)(1u << x_new);
    118          #endif
    119          
    120              OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
   \   0000008E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000096   0x2200             MOVS     R2,#+0
   \   00000098   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    121              OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable10
   \   000000A2   0xF840 0x7024      STR      R7,[R0, R4, LSL #+2]
    122              y_old                 =  ptcb->OSTCBY;
   \   000000A6   0xF897 0x0038      LDRB     R0,[R7, #+56]
   \   000000AA   0x4681             MOV      R9,R0
    123              bity_old              =  ptcb->OSTCBBitY;
   \   000000AC   0xF897 0x003A      LDRB     R0,[R7, #+58]
   \   000000B0   0xF88D 0x0002      STRB     R0,[SP, #+2]
    124              bitx_old              =  ptcb->OSTCBBitX;
   \   000000B4   0xF897 0x0039      LDRB     R0,[R7, #+57]
   \   000000B8   0x4682             MOV      R10,R0
    125              if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
   \   000000BA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000C2   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   000000C6   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000CA   0xEA10 0x0F0A      TST      R0,R10
   \   000000CE   0xD036             BEQ.N    ??OSTaskChangePrio_5
    126                   OSRdyTbl[y_old] &= ~bitx_old;
   \   000000D0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000D8   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   000000DC   0xEA30 0x000A      BICS     R0,R0,R10
   \   000000E0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000E8   0xF809 0x0001      STRB     R0,[R9, R1]
    127                   if (OSRdyTbl[y_old] == 0u) {
   \   000000EC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000F4   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD108             BNE.N    ??OSTaskChangePrio_6
    128                       OSRdyGrp &= ~bity_old;
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000100   0x7800             LDRB     R0,[R0, #+0]
   \   00000102   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000106   0x4388             BICS     R0,R0,R1
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   0000010C   0x7008             STRB     R0,[R1, #+0]
    129                   }
    130                   OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
   \                     ??OSTaskChangePrio_6:
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000112   0x7800             LDRB     R0,[R0, #+0]
   \   00000114   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000118   0x4308             ORRS     R0,R1,R0
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   0000011E   0x7008             STRB     R0,[R1, #+0]
    131                   OSRdyTbl[y_new] |= bitx_new;
   \   00000120   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000128   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000012C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000130   0x4308             ORRS     R0,R1,R0
   \   00000132   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000013A   0xF808 0x0001      STRB     R0,[R8, R1]
    132              }
    133          
    134          #if (OS_EVENT_EN)
    135              pevent = ptcb->OSTCBEventPtr;
   \                     ??OSTaskChangePrio_5:
   \   0000013E   0x69F8             LDR      R0,[R7, #+28]
   \   00000140   0x0005             MOVS     R5,R0
    136              if (pevent != (OS_EVENT *)0) {
   \   00000142   0x2D00             CMP      R5,#+0
   \   00000144   0xD029             BEQ.N    ??OSTaskChangePrio_7
    137                  pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
   \   00000146   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000014A   0xEB19 0x0005      ADDS     R0,R9,R5
   \   0000014E   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000150   0xEA30 0x000A      BICS     R0,R0,R10
   \   00000154   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000158   0xEB19 0x0105      ADDS     R1,R9,R5
   \   0000015C   0x72C8             STRB     R0,[R1, #+11]
    138                  if (pevent->OSEventTbl[y_old] == 0u) {
   \   0000015E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000162   0xEB19 0x0005      ADDS     R0,R9,R5
   \   00000166   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000168   0x2800             CMP      R0,#+0
   \   0000016A   0xD104             BNE.N    ??OSTaskChangePrio_8
    139                      pevent->OSEventGrp    &= ~bity_old;
   \   0000016C   0x7AA8             LDRB     R0,[R5, #+10]
   \   0000016E   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000172   0x4388             BICS     R0,R0,R1
   \   00000174   0x72A8             STRB     R0,[R5, #+10]
    140                  }
    141                  pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
   \                     ??OSTaskChangePrio_8:
   \   00000176   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000178   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   0000017C   0x4308             ORRS     R0,R1,R0
   \   0000017E   0x72A8             STRB     R0,[R5, #+10]
    142                  pevent->OSEventTbl[y_new] |= bitx_new;
   \   00000180   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000184   0xEB18 0x0005      ADDS     R0,R8,R5
   \   00000188   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000018A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000018E   0x4308             ORRS     R0,R1,R0
   \   00000190   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000194   0xEB18 0x0105      ADDS     R1,R8,R5
   \   00000198   0x72C8             STRB     R0,[R1, #+11]
    143              }
    144          #if (OS_EVENT_MULTI_EN > 0u)
    145              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
   \                     ??OSTaskChangePrio_7:
   \   0000019A   0x6A38             LDR      R0,[R7, #+32]
   \   0000019C   0x2800             CMP      R0,#+0
   \   0000019E   0xD033             BEQ.N    ??OSTaskChangePrio_9
    146                  pevents =  ptcb->OSTCBEventMultiPtr;
   \   000001A0   0x6A38             LDR      R0,[R7, #+32]
   \   000001A2   0x0006             MOVS     R6,R0
    147                  pevent  = *pevents;
   \   000001A4   0x6830             LDR      R0,[R6, #+0]
   \   000001A6   0x0005             MOVS     R5,R0
    148                  while (pevent != (OS_EVENT *)0) {
   \                     ??OSTaskChangePrio_10:
   \   000001A8   0x2D00             CMP      R5,#+0
   \   000001AA   0xD02D             BEQ.N    ??OSTaskChangePrio_9
    149                      pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
   \   000001AC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001B0   0xEB19 0x0005      ADDS     R0,R9,R5
   \   000001B4   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001B6   0xEA30 0x000A      BICS     R0,R0,R10
   \   000001BA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001BE   0xEB19 0x0105      ADDS     R1,R9,R5
   \   000001C2   0x72C8             STRB     R0,[R1, #+11]
    150                      if (pevent->OSEventTbl[y_old] == 0u) {
   \   000001C4   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001C8   0xEB19 0x0005      ADDS     R0,R9,R5
   \   000001CC   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001CE   0x2800             CMP      R0,#+0
   \   000001D0   0xD104             BNE.N    ??OSTaskChangePrio_11
    151                          pevent->OSEventGrp    &= ~bity_old;
   \   000001D2   0x7AA8             LDRB     R0,[R5, #+10]
   \   000001D4   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   000001D8   0x4388             BICS     R0,R0,R1
   \   000001DA   0x72A8             STRB     R0,[R5, #+10]
    152                      }
    153                      pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
   \                     ??OSTaskChangePrio_11:
   \   000001DC   0x7AA8             LDRB     R0,[R5, #+10]
   \   000001DE   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   000001E2   0x4308             ORRS     R0,R1,R0
   \   000001E4   0x72A8             STRB     R0,[R5, #+10]
    154                      pevent->OSEventTbl[y_new] |= bitx_new;
   \   000001E6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001EA   0xEB18 0x0005      ADDS     R0,R8,R5
   \   000001EE   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001F0   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000001F4   0x4308             ORRS     R0,R1,R0
   \   000001F6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001FA   0xEB18 0x0105      ADDS     R1,R8,R5
   \   000001FE   0x72C8             STRB     R0,[R1, #+11]
    155                      pevents++;
   \   00000200   0x1D36             ADDS     R6,R6,#+4
    156                      pevent                     = *pevents;
   \   00000202   0x6830             LDR      R0,[R6, #+0]
   \   00000204   0x0005             MOVS     R5,R0
   \   00000206   0xE7CF             B.N      ??OSTaskChangePrio_10
    157                  }
    158              }
    159          #endif
    160          #endif
    161          
    162              ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
   \                     ??OSTaskChangePrio_9:
   \   00000208   0xF887 0x4036      STRB     R4,[R7, #+54]
    163              ptcb->OSTCBY    = y_new;
   \   0000020C   0xF887 0x8038      STRB     R8,[R7, #+56]
    164              ptcb->OSTCBX    = x_new;
   \   00000210   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000214   0xF887 0x0037      STRB     R0,[R7, #+55]
    165              ptcb->OSTCBBitY = bity_new;
   \   00000218   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000021C   0xF887 0x003A      STRB     R0,[R7, #+58]
    166              ptcb->OSTCBBitX = bitx_new;
   \   00000220   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000224   0xF887 0x0039      STRB     R0,[R7, #+57]
    167              OS_EXIT_CRITICAL();
   \   00000228   0x4658             MOV      R0,R11
   \   0000022A   0x.... 0x....      BL       OS_CPU_SR_Restore
    168              if (OSRunning == OS_TRUE) {
   \   0000022E   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000232   0x7800             LDRB     R0,[R0, #+0]
   \   00000234   0x2801             CMP      R0,#+1
   \   00000236   0xD101             BNE.N    ??OSTaskChangePrio_12
    169                  OS_Sched();                                         /* Find new highest priority task          */
   \   00000238   0x.... 0x....      BL       OS_Sched
    170              }
    171              return (OS_ERR_NONE);
   \                     ??OSTaskChangePrio_12:
   \   0000023C   0x2000             MOVS     R0,#+0
   \                     ??OSTaskChangePrio_1:
   \   0000023E   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    172          }
    173          #endif
    174          /*$PAGE*/
    175          /*
    176          *********************************************************************************************************
    177          *                                            CREATE A TASK
    178          *
    179          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
    180          *              be created prior to the start of multitasking or by a running task.  A task cannot be
    181          *              created by an ISR.
    182          *
    183          * Arguments  : task     is a pointer to the task's code
    184          *
    185          *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
    186          *                       the task when the task first executes.  Where the task is concerned it thinks
    187          *                       it was invoked and passed the argument 'p_arg' as follows:
    188          *
    189          *                           void Task (void *p_arg)
    190          *                           {
    191          *                               for (;;) {
    192          *                                   Task code;
    193          *                               }
    194          *                           }
    195          *
    196          *              ptos     is a pointer to the task's top of stack.  If the configuration constant
    197          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    198          *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
    199          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
    200          *                       lowest memory location of the stack and the stack will grow with increasing
    201          *                       memory locations.
    202          *
    203          *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
    204          *                       lower the number, the higher the priority.
    205          *
    206          * Returns    : OS_ERR_NONE             if the function was successful.
    207          *              OS_PRIO_EXIT            if the task priority already exist
    208          *                                      (each task MUST have a unique priority).
    209          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    210          *                                      (i.e. >= OS_LOWEST_PRIO)
    211          *              OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
    212          *********************************************************************************************************
    213          */
    214          
    215          #if OS_TASK_CREATE_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    216          INT8U  OSTaskCreate (void   (*task)(void *p_arg),
    217                               void    *p_arg,
    218                               OS_STK  *ptos,
    219                               INT8U    prio)
    220          {
   \                     OSTaskCreate:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    221              OS_STK    *psp;
    222              INT8U      err;
    223          #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
    224              OS_CPU_SR  cpu_sr = 0u;
   \   0000000E   0xF05F 0x0A00      MOVS     R10,#+0
    225          #endif
    226          
    227          
    228          
    229          #if OS_ARG_CHK_EN > 0u
    230              if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
    231                  return (OS_ERR_PRIO_INVALID);
    232              }
    233          #endif
    234              OS_ENTER_CRITICAL();
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000016   0x4682             MOV      R10,R0
    235              if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD004             BEQ.N    ??OSTaskCreate_0
    236                  OS_EXIT_CRITICAL();
   \   00000022   0x4650             MOV      R0,R10
   \   00000024   0x.... 0x....      BL       OS_CPU_SR_Restore
    237                  return (OS_ERR_TASK_CREATE_ISR);
   \   00000028   0x203C             MOVS     R0,#+60
   \   0000002A   0xE044             B.N      ??OSTaskCreate_1
    238              }
    239              if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
   \                     ??OSTaskCreate_0:
   \   0000002C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000032   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD139             BNE.N    ??OSTaskCreate_2
    240                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
   \   0000003A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0xF840 0x1027      STR      R1,[R0, R7, LSL #+2]
    241                                                       /* ... the same thing until task is created.              */
    242                  OS_EXIT_CRITICAL();
   \   00000046   0x4650             MOV      R0,R10
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    243                  psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
   \   0000004C   0x2300             MOVS     R3,#+0
   \   0000004E   0x0032             MOVS     R2,R6
   \   00000050   0x0029             MOVS     R1,R5
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       OSTaskStkInit
   \   00000058   0x4680             MOV      R8,R0
    244                  err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x9002             STR      R0,[SP, #+8]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x9001             STR      R0,[SP, #+4]
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x2300             MOVS     R3,#+0
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x4641             MOV      R1,R8
   \   0000006C   0x0038             MOVS     R0,R7
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x.... 0x....      BL       OS_TCBInit
   \   00000074   0x4681             MOV      R9,R0
    245                  if (err == OS_ERR_NONE) {
   \   00000076   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000007A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000007E   0xD107             BNE.N    ??OSTaskCreate_3
    246                      if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD10E             BNE.N    ??OSTaskCreate_4
    247                          OS_Sched();
   \   0000008A   0x.... 0x....      BL       OS_Sched
   \   0000008E   0xE00B             B.N      ??OSTaskCreate_4
    248                      }
    249                  } else {
    250                      OS_ENTER_CRITICAL();
   \                     ??OSTaskCreate_3:
   \   00000090   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000094   0x4682             MOV      R10,R0
    251                      OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
   \   00000096   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0xF840 0x1027      STR      R1,[R0, R7, LSL #+2]
    252                      OS_EXIT_CRITICAL();
   \   000000A2   0x4650             MOV      R0,R10
   \   000000A4   0x.... 0x....      BL       OS_CPU_SR_Restore
    253                  }
    254                  return (err);
   \                     ??OSTaskCreate_4:
   \   000000A8   0x4648             MOV      R0,R9
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xE003             B.N      ??OSTaskCreate_1
    255              }
    256              OS_EXIT_CRITICAL();
   \                     ??OSTaskCreate_2:
   \   000000AE   0x4650             MOV      R0,R10
   \   000000B0   0x.... 0x....      BL       OS_CPU_SR_Restore
    257              return (OS_ERR_PRIO_EXIST);
   \   000000B4   0x2028             MOVS     R0,#+40
   \                     ??OSTaskCreate_1:
   \   000000B6   0xB004             ADD      SP,SP,#+16
   \   000000B8   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    258          }
    259          #endif
    260          /*$PAGE*/
    261          /*
    262          *********************************************************************************************************
    263          *                                     CREATE A TASK (Extended Version)
    264          *
    265          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
    266          *              be created prior to the start of multitasking or by a running task.  A task cannot be
    267          *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
    268          *              additional information about a task to be specified.
    269          *
    270          * Arguments  : task      is a pointer to the task's code
    271          *
    272          *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
    273          *                        the task when the task first executes.  Where the task is concerned it thinks
    274          *                        it was invoked and passed the argument 'p_arg' as follows:
    275          *
    276          *                            void Task (void *p_arg)
    277          *                            {
    278          *                                for (;;) {
    279          *                                    Task code;
    280          *                                }
    281          *                            }
    282          *
    283          *              ptos      is a pointer to the task's top of stack.  If the configuration constant
    284          *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    285          *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
    286          *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
    287          *                        lowest memory location of the stack and the stack will grow with increasing
    288          *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
    289          *
    290          *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
    291          *                        lower the number, the higher the priority.
    292          *
    293          *              id        is the task's ID (0..65535)
    294          *
    295          *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
    296          *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    297          *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
    298          *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
    299          *                        HIGHEST memory location of the stack and the stack will grow with increasing
    300          *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
    301          *
    302          *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
    303          *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
    304          *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
    305          *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
    306          *                        available on the stack.
    307          *
    308          *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
    309          *                        For example, this user memory can hold the contents of floating-point registers
    310          *                        during a context switch, the time each task takes to execute, the number of times
    311          *                        the task has been switched-in, etc.
    312          *
    313          *              opt       contains additional information (or options) about the behavior of the task.  The
    314          *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
    315          *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
    316          *
    317          *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
    318          *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
    319          *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
    320          *                                                 during a context switch.
    321          *
    322          * Returns    : OS_ERR_NONE             if the function was successful.
    323          *              OS_PRIO_EXIT            if the task priority already exist
    324          *                                      (each task MUST have a unique priority).
    325          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    326          *                                      (i.e. > OS_LOWEST_PRIO)
    327          *              OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
    328          *********************************************************************************************************
    329          */
    330          /*$PAGE*/
    331          #if OS_TASK_CREATE_EXT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    332          INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
    333                                  void    *p_arg,
    334                                  OS_STK  *ptos,
    335                                  INT8U    prio,
    336                                  INT16U   id,
    337                                  OS_STK  *pbos,
    338                                  INT32U   stk_size,
    339                                  void    *pext,
    340                                  INT16U   opt)
    341          {
   \                     OSTaskCreateExt:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x001E             MOVS     R6,R3
   \   00000008   0x9C10             LDR      R4,[SP, #+64]
   \   0000000A   0x9F11             LDR      R7,[SP, #+68]
   \   0000000C   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \   00000010   0xF8DD 0x904C      LDR      R9,[SP, #+76]
   \   00000014   0x9D14             LDR      R5,[SP, #+80]
    342              OS_STK    *psp;
    343              INT8U      err;
    344          #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
    345              OS_CPU_SR  cpu_sr = 0u;
   \   00000016   0xF05F 0x0B00      MOVS     R11,#+0
    346          #endif
    347          
    348          
    349          
    350          #if OS_ARG_CHK_EN > 0u
    351              if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
    352                  return (OS_ERR_PRIO_INVALID);
    353              }
    354          #endif
    355              OS_ENTER_CRITICAL();
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x4683             MOV      R11,R0
    356              if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD004             BEQ.N    ??OSTaskCreateExt_0
    357                  OS_EXIT_CRITICAL();
   \   0000002A   0x4658             MOV      R0,R11
   \   0000002C   0x.... 0x....      BL       OS_CPU_SR_Restore
    358                  return (OS_ERR_TASK_CREATE_ISR);
   \   00000030   0x203C             MOVS     R0,#+60
   \   00000032   0xE046             B.N      ??OSTaskCreateExt_1
    359              }
    360              if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
   \                     ??OSTaskCreateExt_0:
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000003A   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD13B             BNE.N    ??OSTaskCreateExt_2
    361                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0xF840 0x1026      STR      R1,[R0, R6, LSL #+2]
    362                                                       /* ... the same thing until task is created.              */
    363                  OS_EXIT_CRITICAL();
   \   0000004E   0x4658             MOV      R0,R11
   \   00000050   0x.... 0x....      BL       OS_CPU_SR_Restore
    364          
    365          #if (OS_TASK_STAT_STK_CHK_EN > 0u)
    366                  OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
    367          #endif
    368          
    369                  psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
   \   00000054   0x002B             MOVS     R3,R5
   \   00000056   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000058   0x9A06             LDR      R2,[SP, #+24]
   \   0000005A   0x9905             LDR      R1,[SP, #+20]
   \   0000005C   0x9804             LDR      R0,[SP, #+16]
   \   0000005E   0x.... 0x....      BL       OSTaskStkInit
   \   00000062   0x9003             STR      R0,[SP, #+12]
    370                  err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
   \   00000064   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000066   0x9502             STR      R5,[SP, #+8]
   \   00000068   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   0000006C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000070   0x0023             MOVS     R3,R4
   \   00000072   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000074   0x003A             MOVS     R2,R7
   \   00000076   0x9903             LDR      R1,[SP, #+12]
   \   00000078   0x0030             MOVS     R0,R6
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x.... 0x....      BL       OS_TCBInit
   \   00000080   0x4682             MOV      R10,R0
    371                  if (err == OS_ERR_NONE) {
   \   00000082   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000086   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000008A   0xD107             BNE.N    ??OSTaskCreateExt_3
    372                      if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD10E             BNE.N    ??OSTaskCreateExt_4
    373                          OS_Sched();
   \   00000096   0x.... 0x....      BL       OS_Sched
   \   0000009A   0xE00B             B.N      ??OSTaskCreateExt_4
    374                      }
    375                  } else {
    376                      OS_ENTER_CRITICAL();
   \                     ??OSTaskCreateExt_3:
   \   0000009C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000000A0   0x4683             MOV      R11,R0
    377                      OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
   \   000000A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable10
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0xF840 0x1026      STR      R1,[R0, R6, LSL #+2]
    378                      OS_EXIT_CRITICAL();
   \   000000AE   0x4658             MOV      R0,R11
   \   000000B0   0x.... 0x....      BL       OS_CPU_SR_Restore
    379                  }
    380                  return (err);
   \                     ??OSTaskCreateExt_4:
   \   000000B4   0x4650             MOV      R0,R10
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0xE003             B.N      ??OSTaskCreateExt_1
    381              }
    382              OS_EXIT_CRITICAL();
   \                     ??OSTaskCreateExt_2:
   \   000000BA   0x4658             MOV      R0,R11
   \   000000BC   0x.... 0x....      BL       OS_CPU_SR_Restore
    383              return (OS_ERR_PRIO_EXIST);
   \   000000C0   0x2028             MOVS     R0,#+40
   \                     ??OSTaskCreateExt_1:
   \   000000C2   0xB007             ADD      SP,SP,#+28
   \   000000C4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    384          }
    385          #endif
    386          /*$PAGE*/
    387          /*
    388          *********************************************************************************************************
    389          *                                            DELETE A TASK
    390          *
    391          * Description: This function allows you to delete a task.  The calling task can delete itself by
    392          *              its own priority number.  The deleted task is returned to the dormant state and can be
    393          *              re-activated by creating the deleted task again.
    394          *
    395          * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitely delete
    396          *                      the current task without knowing its priority level by setting 'prio' to
    397          *                      OS_PRIO_SELF.
    398          *
    399          * Returns    : OS_ERR_NONE             if the call is successful
    400          *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
    401          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    402          *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    403          *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
    404          *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
    405          *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
    406          *
    407          * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
    408          *                    a) by making it not ready
    409          *                    b) by removing it from any wait lists
    410          *                    c) by preventing OSTimeTick() from making the task ready to run.
    411          *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
    412          *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
    413          *                 the next instruction following the enable interrupt instruction is ignored.
    414          *              3) An ISR cannot delete a task.
    415          *              4) The lock nesting counter is incremented because, for a brief instant, if the current
    416          *                 task is being deleted, the current task would not be able to be rescheduled because it
    417          *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
    418          *                 from being schedule.  This means that an ISR would return to the current task which is
    419          *                 being deleted.  The rest of the deletion would thus be able to be completed.
    420          *********************************************************************************************************
    421          */
    422          
    423          #if OS_TASK_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    424          INT8U  OSTaskDel (INT8U prio)
    425          {
   \                     OSTaskDel:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    426          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
    427              OS_FLAG_NODE *pnode;
    428          #endif
    429              OS_TCB       *ptcb;
    430          #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
    431              OS_CPU_SR     cpu_sr = 0u;
   \   00000004   0x2700             MOVS     R7,#+0
    432          #endif
    433          
    434          
    435          
    436              if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??OSTaskDel_0
    437                  return (OS_ERR_TASK_DEL_ISR);
   \   00000010   0x2040             MOVS     R0,#+64
   \   00000012   0xE0A7             B.N      ??OSTaskDel_1
    438              }
    439              if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
   \                     ??OSTaskDel_0:
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C1F             CMP      R4,#+31
   \   00000018   0xD101             BNE.N    ??OSTaskDel_2
    440                  return (OS_ERR_TASK_DEL_IDLE);
   \   0000001A   0x203E             MOVS     R0,#+62
   \   0000001C   0xE0A2             B.N      ??OSTaskDel_1
    441              }
    442          #if OS_ARG_CHK_EN > 0u
    443              if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
    444                  if (prio != OS_PRIO_SELF) {
    445                      return (OS_ERR_PRIO_INVALID);
    446                  }
    447              }
    448          #endif
    449          
    450          /*$PAGE*/
    451              OS_ENTER_CRITICAL();
   \                     ??OSTaskDel_2:
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000022   0x0007             MOVS     R7,R0
    452              if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2CFF             CMP      R4,#+255
   \   00000028   0xD105             BNE.N    ??OSTaskDel_3
    453                  prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   00000034   0x0004             MOVS     R4,R0
    454              }
    455              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskDel_3:
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000003C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000040   0x0006             MOVS     R6,R0
    456              if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD104             BNE.N    ??OSTaskDel_4
    457                  OS_EXIT_CRITICAL();
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    458                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000004C   0x2043             MOVS     R0,#+67
   \   0000004E   0xE089             B.N      ??OSTaskDel_1
    459              }
    460              if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
   \                     ??OSTaskDel_4:
   \   00000050   0x2E01             CMP      R6,#+1
   \   00000052   0xD104             BNE.N    ??OSTaskDel_5
    461                  OS_EXIT_CRITICAL();
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
    462                  return (OS_ERR_TASK_DEL);
   \   0000005A   0x203D             MOVS     R0,#+61
   \   0000005C   0xE082             B.N      ??OSTaskDel_1
    463              }
    464          
    465              OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
   \                     ??OSTaskDel_5:
   \   0000005E   0xF896 0x0038      LDRB     R0,[R6, #+56]
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000066   0x5C40             LDRB     R0,[R0, R1]
   \   00000068   0xF896 0x1039      LDRB     R1,[R6, #+57]
   \   0000006C   0x4388             BICS     R0,R0,R1
   \   0000006E   0xF896 0x1038      LDRB     R1,[R6, #+56]
   \   00000072   0x.... 0x....      LDR.W    R2,??DataTable10_2
   \   00000076   0x5488             STRB     R0,[R1, R2]
    466              if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
   \   00000078   0xF896 0x0038      LDRB     R0,[R6, #+56]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000080   0x5C40             LDRB     R0,[R0, R1]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD108             BNE.N    ??OSTaskDel_6
    467                  OSRdyGrp           &= ~ptcb->OSTCBBitY;
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0xF896 0x103A      LDRB     R1,[R6, #+58]
   \   00000090   0x4388             BICS     R0,R0,R1
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000096   0x7008             STRB     R0,[R1, #+0]
    468              }
    469          
    470          #if (OS_EVENT_EN)
    471              if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
   \                     ??OSTaskDel_6:
   \   00000098   0x69F0             LDR      R0,[R6, #+28]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD003             BEQ.N    ??OSTaskDel_7
    472                  OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
   \   0000009E   0x69F1             LDR      R1,[R6, #+28]
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0x.... 0x....      BL       OS_EventTaskRemove
    473              }
    474          #if (OS_EVENT_MULTI_EN > 0u)
    475              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
   \                     ??OSTaskDel_7:
   \   000000A6   0x6A30             LDR      R0,[R6, #+32]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD003             BEQ.N    ??OSTaskDel_8
    476                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \   000000AC   0x6A31             LDR      R1,[R6, #+32]
   \   000000AE   0x0030             MOVS     R0,R6
   \   000000B0   0x.... 0x....      BL       OS_EventTaskRemoveMulti
    477              }
    478          #endif
    479          #endif
    480          
    481          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
    482              pnode = ptcb->OSTCBFlagNode;
   \                     ??OSTaskDel_8:
   \   000000B4   0x6AB0             LDR      R0,[R6, #+40]
   \   000000B6   0x0005             MOVS     R5,R0
    483              if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
   \   000000B8   0x2D00             CMP      R5,#+0
   \   000000BA   0xD002             BEQ.N    ??OSTaskDel_9
    484                  OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
   \   000000BC   0x0028             MOVS     R0,R5
   \   000000BE   0x.... 0x....      BL       OS_FlagUnlink
    485              }
    486          #endif
    487          
    488              ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
   \                     ??OSTaskDel_9:
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x6330             STR      R0,[R6, #+48]
    489              ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF886 0x0034      STRB     R0,[R6, #+52]
    490              ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xF886 0x0035      STRB     R0,[R6, #+53]
    491              if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   000000D6   0x7800             LDRB     R0,[R0, #+0]
   \   000000D8   0x28FF             CMP      R0,#+255
   \   000000DA   0xD006             BEQ.N    ??OSTaskDel_10
    492                  OSLockNesting++;
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0x1C40             ADDS     R0,R0,#+1
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable10_6
   \   000000E8   0x7008             STRB     R0,[R1, #+0]
    493              }
    494              OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
   \                     ??OSTaskDel_10:
   \   000000EA   0x0038             MOVS     R0,R7
   \   000000EC   0x.... 0x....      BL       OS_CPU_SR_Restore
    495              OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
   \   000000F0   0x.... 0x....      BL       OS_Dummy
    496              OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
   \   000000F4   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000000F8   0x0007             MOVS     R7,R0
    497              if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
   \   000000FA   0x....             LDR.N    R0,??DataTable10_6
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD004             BEQ.N    ??OSTaskDel_11
    498                  OSLockNesting--;
   \   00000102   0x....             LDR.N    R0,??DataTable10_6
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x1E40             SUBS     R0,R0,#+1
   \   00000108   0x....             LDR.N    R1,??DataTable10_6
   \   0000010A   0x7008             STRB     R0,[R1, #+0]
    499              }
    500              OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
   \                     ??OSTaskDel_11:
   \   0000010C   0x0030             MOVS     R0,R6
   \   0000010E   0x.... 0x....      BL       OSTaskDelHook
    501              OSTaskCtr--;                                        /* One less task being managed                 */
   \   00000112   0x....             LDR.N    R0,??DataTable10_7
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x1E40             SUBS     R0,R0,#+1
   \   00000118   0x....             LDR.N    R1,??DataTable10_7
   \   0000011A   0x7008             STRB     R0,[R1, #+0]
    502              OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
   \   0000011C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011E   0x....             LDR.N    R0,??DataTable10
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
    503              if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
   \   00000126   0x69B0             LDR      R0,[R6, #+24]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD106             BNE.N    ??OSTaskDel_12
    504                  ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
   \   0000012C   0x6970             LDR      R0,[R6, #+20]
   \   0000012E   0x2100             MOVS     R1,#+0
   \   00000130   0x6181             STR      R1,[R0, #+24]
    505                  OSTCBList                  = ptcb->OSTCBNext;
   \   00000132   0x6970             LDR      R0,[R6, #+20]
   \   00000134   0x....             LDR.N    R1,??DataTable10_8
   \   00000136   0x6008             STR      R0,[R1, #+0]
   \   00000138   0xE005             B.N      ??OSTaskDel_13
    506              } else {
    507                  ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
   \                     ??OSTaskDel_12:
   \   0000013A   0x69B0             LDR      R0,[R6, #+24]
   \   0000013C   0x6971             LDR      R1,[R6, #+20]
   \   0000013E   0x6141             STR      R1,[R0, #+20]
    508                  ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
   \   00000140   0x6970             LDR      R0,[R6, #+20]
   \   00000142   0x69B1             LDR      R1,[R6, #+24]
   \   00000144   0x6181             STR      R1,[R0, #+24]
    509              }
    510              ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
   \                     ??OSTaskDel_13:
   \   00000146   0x....             LDR.N    R0,??DataTable10_9
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0x6170             STR      R0,[R6, #+20]
    511              OSTCBFreeList       = ptcb;
   \   0000014C   0x....             LDR.N    R0,??DataTable10_9
   \   0000014E   0x6006             STR      R6,[R0, #+0]
    512          #if OS_TASK_NAME_EN > 0u
    513              ptcb->OSTCBTaskName = (INT8U *)"?";
    514          #endif
    515              OS_EXIT_CRITICAL();
   \   00000150   0x0038             MOVS     R0,R7
   \   00000152   0x.... 0x....      BL       OS_CPU_SR_Restore
    516              if (OSRunning == OS_TRUE) {
   \   00000156   0x....             LDR.N    R0,??DataTable10_4
   \   00000158   0x7800             LDRB     R0,[R0, #+0]
   \   0000015A   0x2801             CMP      R0,#+1
   \   0000015C   0xD101             BNE.N    ??OSTaskDel_14
    517                  OS_Sched();                                     /* Find new highest priority task              */
   \   0000015E   0x.... 0x....      BL       OS_Sched
    518              }
    519              return (OS_ERR_NONE);
   \                     ??OSTaskDel_14:
   \   00000162   0x2000             MOVS     R0,#+0
   \                     ??OSTaskDel_1:
   \   00000164   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    520          }
    521          #endif
    522          /*$PAGE*/
    523          /*
    524          *********************************************************************************************************
    525          *                                    REQUEST THAT A TASK DELETE ITSELF
    526          *
    527          * Description: This function is used to:
    528          *                   a) notify a task to delete itself.
    529          *                   b) to see if a task requested that the current task delete itself.
    530          *              This function is a little tricky to understand.  Basically, you have a task that needs
    531          *              to be deleted however, this task has resources that it has allocated (memory buffers,
    532          *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
    533          *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
    534          *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
    535          *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
    536          *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
    537          *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
    538          *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
    539          *              this:
    540          *
    541          *                   void Task(void *p_arg)
    542          *                   {
    543          *                       .
    544          *                       .
    545          *                       while (1) {
    546          *                           OSTimeDly(1);
    547          *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
    548          *                               Release any owned resources;
    549          *                               De-allocate any dynamic memory;
    550          *                               OSTaskDel(OS_PRIO_SELF);
    551          *                           }
    552          *                       }
    553          *                   }
    554          *
    555          * Arguments  : prio    is the priority of the task to request the delete from
    556          *
    557          * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
    558          *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
    559          *                                     the request has been executed.
    560          *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
    561          *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
    562          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
    563          *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    564          *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
    565          *                                     deleted.
    566          *********************************************************************************************************
    567          */
    568          /*$PAGE*/
    569          #if OS_TASK_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    570          INT8U  OSTaskDelReq (INT8U prio)
    571          {
   \                     OSTaskDelReq:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    572              INT8U      stat;
    573              OS_TCB    *ptcb;
    574          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    575              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
    576          #endif
    577          
    578          
    579          
    580              if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C1F             CMP      R4,#+31
   \   0000000A   0xD101             BNE.N    ??OSTaskDelReq_0
    581                  return (OS_ERR_TASK_DEL_IDLE);
   \   0000000C   0x203E             MOVS     R0,#+62
   \   0000000E   0xE02D             B.N      ??OSTaskDelReq_1
    582              }
    583          #if OS_ARG_CHK_EN > 0u
    584              if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
    585                  if (prio != OS_PRIO_SELF) {
    586                      return (OS_ERR_PRIO_INVALID);
    587                  }
    588              }
    589          #endif
    590              if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
   \                     ??OSTaskDelReq_0:
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2CFF             CMP      R4,#+255
   \   00000014   0xD10D             BNE.N    ??OSTaskDelReq_2
    591                  OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001A   0x0006             MOVS     R6,R0
    592                  stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
   \   0000001C   0x....             LDR.N    R0,??DataTable10_1
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   00000024   0x0007             MOVS     R7,R0
    593                  OS_EXIT_CRITICAL();
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Restore
    594                  return (stat);
   \   0000002C   0x0038             MOVS     R0,R7
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0xE01C             B.N      ??OSTaskDelReq_1
    595              }
    596              OS_ENTER_CRITICAL();
   \                     ??OSTaskDelReq_2:
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000036   0x0006             MOVS     R6,R0
    597              ptcb = OSTCBPrioTbl[prio];
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x....             LDR.N    R0,??DataTable10
   \   0000003C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000040   0x0005             MOVS     R5,R0
    598              if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD104             BNE.N    ??OSTaskDelReq_3
    599                  OS_EXIT_CRITICAL();
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    600                  return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
   \   0000004C   0x2043             MOVS     R0,#+67
   \   0000004E   0xE00D             B.N      ??OSTaskDelReq_1
    601              }
    602              if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
   \                     ??OSTaskDelReq_3:
   \   00000050   0x2D01             CMP      R5,#+1
   \   00000052   0xD104             BNE.N    ??OSTaskDelReq_4
    603                  OS_EXIT_CRITICAL();
   \   00000054   0x0030             MOVS     R0,R6
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
    604                  return (OS_ERR_TASK_DEL);
   \   0000005A   0x203D             MOVS     R0,#+61
   \   0000005C   0xE006             B.N      ??OSTaskDelReq_1
    605              }
    606              ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
   \                     ??OSTaskDelReq_4:
   \   0000005E   0x203F             MOVS     R0,#+63
   \   00000060   0xF885 0x003B      STRB     R0,[R5, #+59]
    607              OS_EXIT_CRITICAL();
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0x.... 0x....      BL       OS_CPU_SR_Restore
    608              return (OS_ERR_NONE);
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??OSTaskDelReq_1:
   \   0000006C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    609          }
    610          #endif
    611          /*$PAGE*/
    612          /*
    613          *********************************************************************************************************
    614          *                                        GET THE NAME OF A TASK
    615          *
    616          * Description: This function is called to obtain the name of a task.
    617          *
    618          * Arguments  : prio      is the priority of the task that you want to obtain the name from.
    619          *
    620          *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
    621          *
    622          *              perr      is a pointer to an error code that can contain one of the following values:
    623          *
    624          *                        OS_ERR_NONE                if the requested task is resumed
    625          *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
    626          *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
    627          *                                                   A higher value than the idle task or not OS_PRIO_SELF.
    628          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    629          *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
    630          *
    631          *
    632          * Returns    : The length of the string or 0 if the task does not exist.
    633          *********************************************************************************************************
    634          */
    635          
    636          #if OS_TASK_NAME_EN > 0u
    637          INT8U  OSTaskNameGet (INT8U    prio,
    638                                INT8U  **pname,
    639                                INT8U   *perr)
    640          {
    641              OS_TCB    *ptcb;
    642              INT8U      len;
    643          #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
    644              OS_CPU_SR  cpu_sr = 0u;
    645          #endif
    646          
    647          
    648          
    649          #if OS_ARG_CHK_EN > 0u
    650              if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
    651                  return (0u);
    652              }
    653              if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
    654                  if (prio != OS_PRIO_SELF) {
    655                      *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
    656                      return (0u);
    657                  }
    658              }
    659              if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
    660                  *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
    661                  return (0u);
    662              }
    663          #endif
    664              if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
    665                  *perr = OS_ERR_NAME_GET_ISR;
    666                  return (0u);
    667              }
    668              OS_ENTER_CRITICAL();
    669              if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
    670                  prio = OSTCBCur->OSTCBPrio;
    671              }
    672              ptcb = OSTCBPrioTbl[prio];
    673              if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
    674                  OS_EXIT_CRITICAL();                              /* No                                         */
    675                  *perr = OS_ERR_TASK_NOT_EXIST;
    676                  return (0u);
    677              }
    678              if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
    679                  OS_EXIT_CRITICAL();                              /* Yes                                        */
    680                  *perr = OS_ERR_TASK_NOT_EXIST;
    681                  return (0u);
    682              }
    683              *pname = ptcb->OSTCBTaskName;
    684              len    = OS_StrLen(*pname);
    685              OS_EXIT_CRITICAL();
    686              *perr  = OS_ERR_NONE;
    687              return (len);
    688          }
    689          #endif
    690          
    691          /*$PAGE*/
    692          /*
    693          *********************************************************************************************************
    694          *                                        ASSIGN A NAME TO A TASK
    695          *
    696          * Description: This function is used to set the name of a task.
    697          *
    698          * Arguments  : prio      is the priority of the task that you want the assign a name to.
    699          *
    700          *              pname     is a pointer to an ASCII string that contains the name of the task.
    701          *
    702          *              perr       is a pointer to an error code that can contain one of the following values:
    703          *
    704          *                        OS_ERR_NONE                if the requested task is resumed
    705          *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
    706          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    707          *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
    708          *                                                   A higher value than the idle task or not OS_PRIO_SELF.
    709          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    710          *
    711          * Returns    : None
    712          *********************************************************************************************************
    713          */
    714          #if OS_TASK_NAME_EN > 0u
    715          void  OSTaskNameSet (INT8U   prio,
    716                               INT8U  *pname,
    717                               INT8U  *perr)
    718          {
    719              OS_TCB    *ptcb;
    720          #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
    721              OS_CPU_SR  cpu_sr = 0u;
    722          #endif
    723          
    724          
    725          
    726          #if OS_ARG_CHK_EN > 0u
    727              if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
    728                  return;
    729              }
    730              if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
    731                  if (prio != OS_PRIO_SELF) {
    732                      *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
    733                      return;
    734                  }
    735              }
    736              if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
    737                  *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
    738                  return;
    739              }
    740          #endif
    741              if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
    742                  *perr = OS_ERR_NAME_SET_ISR;
    743                  return;
    744              }
    745              OS_ENTER_CRITICAL();
    746              if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
    747                  prio = OSTCBCur->OSTCBPrio;
    748              }
    749              ptcb = OSTCBPrioTbl[prio];
    750              if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
    751                  OS_EXIT_CRITICAL();                          /* No                                             */
    752                  *perr = OS_ERR_TASK_NOT_EXIST;
    753                  return;
    754              }
    755              if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
    756                  OS_EXIT_CRITICAL();                          /* Yes                                            */
    757                  *perr = OS_ERR_TASK_NOT_EXIST;
    758                  return;
    759              }
    760              ptcb->OSTCBTaskName = pname;
    761              OS_EXIT_CRITICAL();
    762              *perr               = OS_ERR_NONE;
    763          }
    764          #endif
    765          
    766          /*$PAGE*/
    767          /*
    768          *********************************************************************************************************
    769          *                                        RESUME A SUSPENDED TASK
    770          *
    771          * Description: This function is called to resume a previously suspended task.  This is the only call that
    772          *              will remove an explicit task suspension.
    773          *
    774          * Arguments  : prio     is the priority of the task to resume.
    775          *
    776          * Returns    : OS_ERR_NONE                if the requested task is resumed
    777          *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
    778          *                                         (i.e. >= OS_LOWEST_PRIO)
    779          *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
    780          *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
    781          *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
    782          *********************************************************************************************************
    783          */
    784          
    785          #if OS_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    786          INT8U  OSTaskResume (INT8U prio)
    787          {
   \                     OSTaskResume:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    788              OS_TCB    *ptcb;
    789          #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
    790              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
    791          #endif
    792          
    793          
    794          
    795          #if OS_ARG_CHK_EN > 0u
    796              if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
    797                  return (OS_ERR_PRIO_INVALID);
    798              }
    799          #endif
    800              OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
    801              ptcb = OSTCBPrioTbl[prio];
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x....             LDR.N    R0,??DataTable10
   \   00000010   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000014   0x0005             MOVS     R5,R0
    802              if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD104             BNE.N    ??OSTaskResume_0
    803                  OS_EXIT_CRITICAL();
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Restore
    804                  return (OS_ERR_TASK_RESUME_PRIO);
   \   00000020   0x2046             MOVS     R0,#+70
   \   00000022   0xE040             B.N      ??OSTaskResume_1
    805              }
    806              if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
   \                     ??OSTaskResume_0:
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD104             BNE.N    ??OSTaskResume_2
    807                  OS_EXIT_CRITICAL();
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       OS_CPU_SR_Restore
    808                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000002E   0x2043             MOVS     R0,#+67
   \   00000030   0xE039             B.N      ??OSTaskResume_1
    809              }
    810              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
   \                     ??OSTaskResume_2:
   \   00000032   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000036   0x0700             LSLS     R0,R0,#+28
   \   00000038   0xD531             BPL.N    ??OSTaskResume_3
    811                  ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
   \   0000003A   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000003E   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000042   0xF885 0x0034      STRB     R0,[R5, #+52]
    812                  if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
   \   00000046   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD122             BNE.N    ??OSTaskResume_4
    813                      if (ptcb->OSTCBDly == 0u) {
   \   0000004E   0x6B28             LDR      R0,[R5, #+48]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD11B             BNE.N    ??OSTaskResume_5
    814                          OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
   \   00000054   0x....             LDR.N    R0,??DataTable10_3
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0xF895 0x103A      LDRB     R1,[R5, #+58]
   \   0000005C   0x4308             ORRS     R0,R1,R0
   \   0000005E   0x....             LDR.N    R1,??DataTable10_3
   \   00000060   0x7008             STRB     R0,[R1, #+0]
    815                          OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000062   0xF895 0x0038      LDRB     R0,[R5, #+56]
   \   00000066   0x....             LDR.N    R1,??DataTable10_2
   \   00000068   0x5C40             LDRB     R0,[R0, R1]
   \   0000006A   0xF895 0x1039      LDRB     R1,[R5, #+57]
   \   0000006E   0x4308             ORRS     R0,R1,R0
   \   00000070   0xF895 0x1038      LDRB     R1,[R5, #+56]
   \   00000074   0x....             LDR.N    R2,??DataTable10_2
   \   00000076   0x5488             STRB     R0,[R1, R2]
    816                          OS_EXIT_CRITICAL();
   \   00000078   0x0030             MOVS     R0,R6
   \   0000007A   0x.... 0x....      BL       OS_CPU_SR_Restore
    817                          if (OSRunning == OS_TRUE) {
   \   0000007E   0x....             LDR.N    R0,??DataTable10_4
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD109             BNE.N    ??OSTaskResume_6
    818                              OS_Sched();                               /* Find new highest priority task        */
   \   00000086   0x.... 0x....      BL       OS_Sched
   \   0000008A   0xE006             B.N      ??OSTaskResume_6
    819                          }
    820                      } else {
    821                          OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_5:
   \   0000008C   0x0030             MOVS     R0,R6
   \   0000008E   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000092   0xE002             B.N      ??OSTaskResume_6
    822                      }
    823                  } else {                                              /* Must be pending on event              */
    824                      OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_4:
   \   00000094   0x0030             MOVS     R0,R6
   \   00000096   0x.... 0x....      BL       OS_CPU_SR_Restore
    825                  }
    826                  return (OS_ERR_NONE);
   \                     ??OSTaskResume_6:
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE003             B.N      ??OSTaskResume_1
    827              }
    828              OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_3:
   \   0000009E   0x0030             MOVS     R0,R6
   \   000000A0   0x.... 0x....      BL       OS_CPU_SR_Restore
    829              return (OS_ERR_TASK_NOT_SUSPENDED);
   \   000000A4   0x2044             MOVS     R0,#+68
   \                     ??OSTaskResume_1:
   \   000000A6   0xBD70             POP      {R4-R6,PC}       ;; return
    830          }
    831          #endif
    832          /*$PAGE*/
    833          /*
    834          *********************************************************************************************************
    835          *                                             STACK CHECKING
    836          *
    837          * Description: This function is called to check the amount of free memory left on the specified task's
    838          *              stack.
    839          *
    840          * Arguments  : prio          is the task priority
    841          *
    842          *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
    843          *
    844          * Returns    : OS_ERR_NONE            upon success
    845          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
    846          *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    847          *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
    848          *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
    849          *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
    850          *********************************************************************************************************
    851          */
    852          #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
    853          INT8U  OSTaskStkChk (INT8U         prio,
    854                               OS_STK_DATA  *p_stk_data)
    855          {
    856              OS_TCB    *ptcb;
    857              OS_STK    *pchk;
    858              INT32U     nfree;
    859              INT32U     size;
    860          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
    861              OS_CPU_SR  cpu_sr = 0u;
    862          #endif
    863          
    864          
    865          
    866          #if OS_ARG_CHK_EN > 0u
    867              if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
    868                  if (prio != OS_PRIO_SELF) {
    869                      return (OS_ERR_PRIO_INVALID);
    870                  }
    871              }
    872              if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
    873                  return (OS_ERR_PDATA_NULL);
    874              }
    875          #endif
    876              p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
    877              p_stk_data->OSUsed = 0u;
    878              OS_ENTER_CRITICAL();
    879              if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
    880                  prio = OSTCBCur->OSTCBPrio;
    881              }
    882              ptcb = OSTCBPrioTbl[prio];
    883              if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
    884                  OS_EXIT_CRITICAL();
    885                  return (OS_ERR_TASK_NOT_EXIST);
    886              }
    887              if (ptcb == OS_TCB_RESERVED) {
    888                  OS_EXIT_CRITICAL();
    889                  return (OS_ERR_TASK_NOT_EXIST);
    890              }
    891              if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
    892                  OS_EXIT_CRITICAL();
    893                  return (OS_ERR_TASK_OPT);
    894              }
    895              nfree = 0u;
    896              size  = ptcb->OSTCBStkSize;
    897              pchk  = ptcb->OSTCBStkBottom;
    898              OS_EXIT_CRITICAL();
    899          #if OS_STK_GROWTH == 1u
    900              while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
    901                  nfree++;
    902              }
    903          #else
    904              while (*pchk-- == (OS_STK)0) {
    905                  nfree++;
    906              }
    907          #endif
    908              p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
    909              p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
    910              return (OS_ERR_NONE);
    911          }
    912          #endif
    913          /*$PAGE*/
    914          /*
    915          *********************************************************************************************************
    916          *                                            SUSPEND A TASK
    917          *
    918          * Description: This function is called to suspend a task.  The task can be the calling task if the
    919          *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
    920          *
    921          * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
    922          *                       calling task will suspend itself and rescheduling will occur.
    923          *
    924          * Returns    : OS_ERR_NONE               if the requested task is suspended
    925          *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
    926          *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
    927          *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    928          *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
    929          *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
    930          *
    931          * Note       : You should use this function with great care.  If you suspend a task that is waiting for
    932          *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
    933          *              running when the event arrives.
    934          *********************************************************************************************************
    935          */
    936          
    937          #if OS_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    938          INT8U  OSTaskSuspend (INT8U prio)
    939          {
   \                     OSTaskSuspend:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    940              BOOLEAN    self;
    941              OS_TCB    *ptcb;
    942              INT8U      y;
    943          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    944              OS_CPU_SR  cpu_sr = 0u;
   \   00000006   0xF05F 0x0800      MOVS     R8,#+0
    945          #endif
    946          
    947          
    948          
    949          #if OS_ARG_CHK_EN > 0u
    950              if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
    951                  return (OS_ERR_TASK_SUSPEND_IDLE);
    952              }
    953              if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
    954                  if (prio != OS_PRIO_SELF) {
    955                      return (OS_ERR_PRIO_INVALID);
    956                  }
    957              }
    958          #endif
    959              OS_ENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000E   0x4680             MOV      R8,R0
    960              if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2CFF             CMP      R4,#+255
   \   00000014   0xD107             BNE.N    ??OSTaskSuspend_0
    961                  prio = OSTCBCur->OSTCBPrio;
   \   00000016   0x....             LDR.N    R0,??DataTable10_1
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000001E   0x0004             MOVS     R4,R0
    962                  self = OS_TRUE;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x0005             MOVS     R5,R0
   \   00000024   0xE00B             B.N      ??OSTaskSuspend_1
    963              } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
   \                     ??OSTaskSuspend_0:
   \   00000026   0x....             LDR.N    R0,??DataTable10_1
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD102             BNE.N    ??OSTaskSuspend_2
    964                  self = OS_TRUE;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x0005             MOVS     R5,R0
   \   00000038   0xE001             B.N      ??OSTaskSuspend_1
    965              } else {
    966                  self = OS_FALSE;                                        /* No suspending another task          */
   \                     ??OSTaskSuspend_2:
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x0005             MOVS     R5,R0
    967              }
    968              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskSuspend_1:
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x....             LDR.N    R0,??DataTable10
   \   00000042   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000046   0x0006             MOVS     R6,R0
    969              if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD104             BNE.N    ??OSTaskSuspend_3
    970                  OS_EXIT_CRITICAL();
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       OS_CPU_SR_Restore
    971                  return (OS_ERR_TASK_SUSPEND_PRIO);
   \   00000052   0x2048             MOVS     R0,#+72
   \   00000054   0xE02D             B.N      ??OSTaskSuspend_4
    972              }
    973              if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
   \                     ??OSTaskSuspend_3:
   \   00000056   0x2E01             CMP      R6,#+1
   \   00000058   0xD104             BNE.N    ??OSTaskSuspend_5
    974                  OS_EXIT_CRITICAL();
   \   0000005A   0x4640             MOV      R0,R8
   \   0000005C   0x.... 0x....      BL       OS_CPU_SR_Restore
    975                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000060   0x2043             MOVS     R0,#+67
   \   00000062   0xE026             B.N      ??OSTaskSuspend_4
    976              }
    977              y            = ptcb->OSTCBY;
   \                     ??OSTaskSuspend_5:
   \   00000064   0xF896 0x0038      LDRB     R0,[R6, #+56]
   \   00000068   0x0007             MOVS     R7,R0
    978              OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
   \   0000006A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006C   0x....             LDR.N    R0,??DataTable10_2
   \   0000006E   0x5C38             LDRB     R0,[R7, R0]
   \   00000070   0xF896 0x1039      LDRB     R1,[R6, #+57]
   \   00000074   0x4388             BICS     R0,R0,R1
   \   00000076   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000078   0x....             LDR.N    R1,??DataTable10_2
   \   0000007A   0x5478             STRB     R0,[R7, R1]
    979              if (OSRdyTbl[y] == 0u) {
   \   0000007C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007E   0x....             LDR.N    R0,??DataTable10_2
   \   00000080   0x5C38             LDRB     R0,[R7, R0]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD106             BNE.N    ??OSTaskSuspend_6
    980                  OSRdyGrp &= ~ptcb->OSTCBBitY;
   \   00000086   0x....             LDR.N    R0,??DataTable10_3
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0xF896 0x103A      LDRB     R1,[R6, #+58]
   \   0000008E   0x4388             BICS     R0,R0,R1
   \   00000090   0x....             LDR.N    R1,??DataTable10_3
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    981              }
    982              ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
   \                     ??OSTaskSuspend_6:
   \   00000094   0xF896 0x0034      LDRB     R0,[R6, #+52]
   \   00000098   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000009C   0xF886 0x0034      STRB     R0,[R6, #+52]
    983              OS_EXIT_CRITICAL();
   \   000000A0   0x4640             MOV      R0,R8
   \   000000A2   0x.... 0x....      BL       OS_CPU_SR_Restore
    984              if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x2D01             CMP      R5,#+1
   \   000000AA   0xD101             BNE.N    ??OSTaskSuspend_7
    985                  OS_Sched();                                             /* Find new highest priority task      */
   \   000000AC   0x.... 0x....      BL       OS_Sched
    986              }
    987              return (OS_ERR_NONE);
   \                     ??OSTaskSuspend_7:
   \   000000B0   0x2000             MOVS     R0,#+0
   \                     ??OSTaskSuspend_4:
   \   000000B2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    988          }
    989          #endif
    990          /*$PAGE*/
    991          /*
    992          *********************************************************************************************************
    993          *                                            QUERY A TASK
    994          *
    995          * Description: This function is called to obtain a copy of the desired task's TCB.
    996          *
    997          * Arguments  : prio         is the priority of the task to obtain information from.
    998          *
    999          *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
   1000          *
   1001          * Returns    : OS_ERR_NONE            if the requested task is suspended
   1002          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
   1003          *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
   1004          *              OS_ERR_PRIO            if the desired task has not been created
   1005          *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
   1006          *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
   1007          *********************************************************************************************************
   1008          */
   1009          
   1010          #if OS_TASK_QUERY_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1011          INT8U  OSTaskQuery (INT8U    prio,
   1012                              OS_TCB  *p_task_data)
   1013          {
   \                     OSTaskQuery:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1014              OS_TCB    *ptcb;
   1015          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1016              OS_CPU_SR  cpu_sr = 0u;
   \   00000006   0x2700             MOVS     R7,#+0
   1017          #endif
   1018          
   1019          
   1020          
   1021          #if OS_ARG_CHK_EN > 0u
   1022              if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
   1023                  if (prio != OS_PRIO_SELF) {
   1024                      return (OS_ERR_PRIO_INVALID);
   1025                  }
   1026              }
   1027              if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
   1028                  return (OS_ERR_PDATA_NULL);
   1029              }
   1030          #endif
   1031              OS_ENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000C   0x0007             MOVS     R7,R0
   1032              if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2CFF             CMP      R4,#+255
   \   00000012   0xD104             BNE.N    ??OSTaskQuery_0
   1033                  prio = OSTCBCur->OSTCBPrio;
   \   00000014   0x....             LDR.N    R0,??DataTable10_1
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000001C   0x0004             MOVS     R4,R0
   1034              }
   1035              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskQuery_0:
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x....             LDR.N    R0,??DataTable10
   \   00000022   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000026   0x0006             MOVS     R6,R0
   1036              if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD104             BNE.N    ??OSTaskQuery_1
   1037                  OS_EXIT_CRITICAL();
   \   0000002C   0x0038             MOVS     R0,R7
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Restore
   1038                  return (OS_ERR_PRIO);
   \   00000032   0x2029             MOVS     R0,#+41
   \   00000034   0xE00F             B.N      ??OSTaskQuery_2
   1039              }
   1040              if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
   \                     ??OSTaskQuery_1:
   \   00000036   0x2E01             CMP      R6,#+1
   \   00000038   0xD104             BNE.N    ??OSTaskQuery_3
   1041                  OS_EXIT_CRITICAL();
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       OS_CPU_SR_Restore
   1042                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000040   0x2043             MOVS     R0,#+67
   \   00000042   0xE008             B.N      ??OSTaskQuery_2
   1043              }
   1044                                                           /* Copy TCB into user storage area                    */
   1045              OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
   \                     ??OSTaskQuery_3:
   \   00000044   0x2254             MOVS     R2,#+84
   \   00000046   0x0031             MOVS     R1,R6
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       OS_MemCopy
   1046              OS_EXIT_CRITICAL();
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0x.... 0x....      BL       OS_CPU_SR_Restore
   1047              return (OS_ERR_NONE);
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??OSTaskQuery_2:
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1048          }
   1049          #endif
   1050          /*$PAGE*/
   1051          /*
   1052          *********************************************************************************************************
   1053          *                                 GET THE CURRENT VALUE OF A TASK REGISTER
   1054          *
   1055          * Description: This function is called to obtain the current value of a task register.  Task registers
   1056          *              are application specific and can be used to store task specific values such as 'error
   1057          *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
   1058          *
   1059          * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
   1060          *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
   1061          *
   1062          *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
   1063          *                        than OS_TASK_REG_TBL_SIZE
   1064          *
   1065          *              perr      is a pointer to a variable that will hold an error code related to this call.
   1066          *
   1067          *                        OS_ERR_NONE            if the call was successful
   1068          *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
   1069          *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
   1070          *
   1071          * Returns    : The current value of the task's register or 0 if an error is detected.
   1072          *
   1073          * Note(s)    : The maximum number of task variables is 254
   1074          *********************************************************************************************************
   1075          */
   1076          
   1077          #if OS_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1078          INT32U  OSTaskRegGet (INT8U   prio,
   1079                                INT8U   id,
   1080                                INT8U  *perr)
   1081          {
   \                     OSTaskRegGet:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1082          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1083              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0x2700             MOVS     R7,#+0
   1084          #endif
   1085              INT32U     value;
   1086              OS_TCB    *ptcb;
   1087          
   1088          
   1089          #if OS_ARG_CHK_EN > 0u
   1090              if (prio >= OS_LOWEST_PRIO) {
   1091                  if (prio != OS_PRIO_SELF) {
   1092                      *perr = OS_ERR_PRIO_INVALID;
   1093                      return (0u);
   1094                  }
   1095              }
   1096              if (id >= OS_TASK_REG_TBL_SIZE) {
   1097                  *perr = OS_ERR_ID_INVALID;
   1098                  return (0u);
   1099              }
   1100          #endif
   1101              OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000010   0x0007             MOVS     R7,R0
   1102              if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2CFF             CMP      R4,#+255
   \   00000016   0xD103             BNE.N    ??OSTaskRegGet_0
   1103                  ptcb = OSTCBCur;
   \   00000018   0x....             LDR.N    R0,??DataTable10_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x4681             MOV      R9,R0
   \   0000001E   0xE004             B.N      ??OSTaskRegGet_1
   1104              } else {
   1105                  ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskRegGet_0:
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x....             LDR.N    R0,??DataTable10
   \   00000024   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000028   0x4681             MOV      R9,R0
   1106              }
   1107              value = ptcb->OSTCBRegTbl[id];
   \                     ??OSTaskRegGet_1:
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0xEB19 0x0085      ADDS     R0,R9,R5, LSL #+2
   \   00000030   0x6D00             LDR      R0,[R0, #+80]
   \   00000032   0x4680             MOV      R8,R0
   1108              OS_EXIT_CRITICAL();
   \   00000034   0x0038             MOVS     R0,R7
   \   00000036   0x.... 0x....      BL       OS_CPU_SR_Restore
   1109              *perr = OS_ERR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
   1110              return (value);
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1111          }
   1112          #endif
   1113          
   1114          /*$PAGE*/
   1115          /*
   1116          *********************************************************************************************************
   1117          *                                 SET THE CURRENT VALUE OF A TASK VARIABLE
   1118          *
   1119          * Description: This function is called to change the current value of a task register.  Task registers
   1120          *              are application specific and can be used to store task specific values such as 'error
   1121          *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
   1122          *
   1123          * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
   1124          *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
   1125          *
   1126          *              var_id    is the 'id' of the desired task register.  Note that the 'id' must be less
   1127          *                        than OS_TASK_REG_TBL_SIZE
   1128          *
   1129          *              value     is the desired value for the task register.
   1130          *
   1131          *              perr      is a pointer to a variable that will hold an error code related to this call.
   1132          *
   1133          *                        OS_ERR_NONE            if the call was successful
   1134          *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
   1135          *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
   1136          *
   1137          * Returns    : The current value of the task's variable or 0 if an error is detected.
   1138          *
   1139          * Note(s)    : The maximum number of task variables is 254
   1140          *********************************************************************************************************
   1141          */
   1142          
   1143          #if OS_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1144          void  OSTaskRegSet (INT8U    prio,
   1145                              INT8U    id,
   1146                              INT32U   value,
   1147                              INT8U   *perr)
   1148          {
   \                     OSTaskRegSet:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1149          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1150              OS_CPU_SR  cpu_sr = 0u;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1151          #endif
   1152              OS_TCB    *ptcb;
   1153          
   1154          
   1155          #if OS_ARG_CHK_EN > 0u
   1156              if (prio >= OS_LOWEST_PRIO) {
   1157                  if (prio != OS_PRIO_SELF) {
   1158                      *perr = OS_ERR_PRIO_INVALID;
   1159                      return;
   1160                  }
   1161              }
   1162              if (id >= OS_TASK_REG_TBL_SIZE) {
   1163                  *perr = OS_ERR_ID_INVALID;
   1164                  return;
   1165              }
   1166          #endif
   1167              OS_ENTER_CRITICAL();
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000014   0x4680             MOV      R8,R0
   1168              if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2CFF             CMP      R4,#+255
   \   0000001A   0xD103             BNE.N    ??OSTaskRegSet_0
   1169                  ptcb = OSTCBCur;
   \   0000001C   0x....             LDR.N    R0,??DataTable10_1
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4681             MOV      R9,R0
   \   00000022   0xE004             B.N      ??OSTaskRegSet_1
   1170              } else {
   1171                  ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskRegSet_0:
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x....             LDR.N    R0,??DataTable10
   \   00000028   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000002C   0x4681             MOV      R9,R0
   1172              }
   1173              ptcb->OSTCBRegTbl[id] = value;
   \                     ??OSTaskRegSet_1:
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0xEB19 0x0085      ADDS     R0,R9,R5, LSL #+2
   \   00000034   0x6506             STR      R6,[R0, #+80]
   1174              OS_EXIT_CRITICAL();
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Restore
   1175              *perr                 = OS_ERR_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x7038             STRB     R0,[R7, #+0]
   1176          }
   \   00000040   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1177          #endif
   1178          
   1179          /*$PAGE*/
   1180          /*
   1181          *********************************************************************************************************
   1182          *                                              CATCH ACCIDENTAL TASK RETURN
   1183          *
   1184          * Description: This function is called if a task accidentally returns without deleting itself.  In other
   1185          *              words, a task should either be an infinite loop or delete itself if it's done.
   1186          *
   1187          * Arguments  : none
   1188          *
   1189          * Returns    : none
   1190          *
   1191          * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
   1192          *********************************************************************************************************
   1193          */
   1194          

   \                                 In section .text, align 2, keep-with-next
   1195          void  OS_TaskReturn (void)
   1196          {
   \                     OS_TaskReturn:
   \   00000000   0xB580             PUSH     {R7,LR}
   1197              OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
   \   00000002   0x....             LDR.N    R0,??DataTable10_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       OSTaskReturnHook
   1198          
   1199          #if OS_TASK_DEL_EN > 0u
   1200              (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x.... 0x....      BL       OSTaskDel
   1201          #else
   1202              for (;;) {
   1203                  OSTimeDly(OS_TICKS_PER_SEC);
   1204              }
   1205          #endif
   1206          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     OSTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     OSTCBList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     OSTCBFreeList
   1207          
   1208          /*$PAGE*/
   1209          /*
   1210          *********************************************************************************************************
   1211          *                                        CLEAR TASK STACK
   1212          *
   1213          * Description: This function is used to clear the stack of a task (i.e. write all zeros)
   1214          *
   1215          * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
   1216          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
   1217          *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
   1218          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
   1219          *                       highest memory location of the stack and the stack will grow with increasing
   1220          *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
   1221          *
   1222          *              size     is the number of 'stack elements' to clear.
   1223          *
   1224          *              opt      contains additional information (or options) about the behavior of the task.  The
   1225          *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
   1226          *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
   1227          *
   1228          * Returns    : none
   1229          *********************************************************************************************************
   1230          */
   1231          #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
   1232          void  OS_TaskStkClr (OS_STK  *pbos,
   1233                               INT32U   size,
   1234                               INT16U   opt)
   1235          {
   1236              if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
   1237                  if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
   1238          #if OS_STK_GROWTH == 1u
   1239                      while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
   1240                          size--;
   1241                          *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
   1242                      }
   1243          #else
   1244                      while (size > 0u) {                        /* Stack grows from LOW to HIGH memory          */
   1245                          size--;
   1246                          *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
   1247                      }
   1248          #endif
   1249                  }
   1250              }
   1251          }
   1252          
   1253          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   OSTaskChangePrio
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
        48   -> OS_Sched
      48   OSTaskCreate
        48   -> OSTaskStkInit
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
        48   -> OS_Sched
        48   -> OS_TCBInit
      64   OSTaskCreateExt
        64   -> OSTaskStkInit
        64   -> OS_CPU_SR_Restore
        64   -> OS_CPU_SR_Save
        64   -> OS_Sched
        64   -> OS_TCBInit
      24   OSTaskDel
        24   -> OSTaskDelHook
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_Dummy
        24   -> OS_EventTaskRemove
        24   -> OS_EventTaskRemoveMulti
        24   -> OS_FlagUnlink
        24   -> OS_Sched
      24   OSTaskDelReq
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      24   OSTaskQuery
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_MemCopy
      32   OSTaskRegGet
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
      32   OSTaskRegSet
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
      16   OSTaskResume
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_Sched
      24   OSTaskSuspend
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_Sched
       8   OS_TaskReturn
         8   -> OSTaskDel
         8   -> OSTaskReturnHook


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
     578  OSTaskChangePrio
     188  OSTaskCreate
     200  OSTaskCreateExt
     358  OSTaskDel
     110  OSTaskDelReq
      88  OSTaskQuery
      68  OSTaskRegGet
      68  OSTaskRegSet
     168  OSTaskResume
     182  OSTaskSuspend
      18  OS_TaskReturn

 
 2 066 bytes in section .text
 
 2 066 bytes of CODE memory

Errors: none
Warnings: none
