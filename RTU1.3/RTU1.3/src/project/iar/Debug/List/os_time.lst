###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      11/Mar/2017  15:34:15 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_time.c                                    #
#    Command line =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCO #
#                    S-II\Source\os_time.c -lCN D:\wangfan2\×ÀÃæ\receiverfirm #
#                    \RTU\´úÂë\RTU_1.2\project\iar\Debug\List\ -o             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2 #
#                    \project\iar\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\BSP\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\ADC\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´ #
#                    úÂë\RTU_1.2\project\iar\..\..\BSP\RTC\ -I                #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\TILT\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\ #
#                    ´úÂë\RTU_1.2\project\iar\..\..\BSP\RDLevel\ -I           #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\RS232\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU #
#                    \´úÂë\RTU_1.2\project\iar\..\..\BSP\OS-v2\ -I            #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\BSP\VibrationString\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\  #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\ucos2\uCOS-II\Source\ -I                     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-LIB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\ucos2\uC-CPU\ -I      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\source\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Drivers\include\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\app\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\uC-Probe\Target\Plugins\uCOS-I #
#                    I\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\pro #
#                    ject\iar\..\..\uC-Probe\Target\Demos\Intro\Workspaces\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Demos\Intro\Source\ -I       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\Source\   #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\uC-Probe\Target\Communication\Generic\RS-232 #
#                    \Source\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1 #
#                    .2\project\iar\..\..\uC-Probe\Target\Communication\Gener #
#                    ic\RS-232\Ports\NXP\LPC17xx\ -I                          #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\uC-Probe\Target\Communication\Generic\RS-232\OS #
#                    \uCOS-II\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_ #
#                    1.2\project\iar\..\..\cmsis\Core\CM3\CoreSupport\ -I     #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\ -I D:\wangfan2\×ÀÃæ\receiverfirm\R #
#                    TU\´úÂë\RTU_1.2\project\iar\..\..\HuaceApp\DEVICE_BT\    #
#                    -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\projec #
#                    t\iar\..\..\HuaceApp\DEVICE_COM\ -I                      #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPRS\ -I                        #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_GPS\ -I                         #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\DEVICE_RADIO\ -I                       #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\iap\ -I D:\wangfan2\×ÀÃæ\receiverfirm\ #
#                    RTU\´úÂë\RTU_1.2\project\iar\..\..\FatFs\ -I             #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\USB\ -I D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\ #
#                    RTU_1.2\project\iar\..\..\bsp\spi_flash\ -I              #
#                    D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\..\..\HuaceApp\LED\ -On --use_c++_inline              #
#    List file    =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\List\os_time.lst                                #
#    Object file  =  D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\project\i #
#                    ar\Debug\Obj\os_time.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\×ÀÃæ\receiverfirm\RTU\´úÂë\RTU_1.2\ucos2\uCOS-II\Source\os_time.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             TIME MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_TIME.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.89
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                       DELAY TASK 'n' TICKS
     31          *
     32          * Description: This function is called to delay execution of the currently running task until the
     33          *              specified number of system ticks expires.  This, of course, directly equates to delaying
     34          *              the current task for some time to expire.  No delay will result If the specified delay is
     35          *              0.  If the specified delay is greater than 0 then, a context switch will result.
     36          *
     37          * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
     38          *                        Note that by specifying 0, the task will not be delayed.
     39          *
     40          * Returns    : none
     41          *********************************************************************************************************
     42          */
     43          

   \                                 In section .text, align 2, keep-with-next
     44          void  OSTimeDly (INT32U ticks)
     45          {
   \                     OSTimeDly:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     46              INT8U      y;
     47          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
     48              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
     49          #endif
     50          
     51          
     52          
     53              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   00000006   0x....             LDR.N    R0,??DataTable4
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD12A             BNE.N    ??OSTimeDly_0
     54                  return;
     55              }
     56              if (ticks > 0u) {                            /* 0 means no delay!                                  */
   \                     ??OSTimeDly_1:
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD028             BEQ.N    ??OSTimeDly_2
     57                  OS_ENTER_CRITICAL();
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000016   0x0006             MOVS     R6,R0
     58                  y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
   \   00000018   0x....             LDR.N    R0,??DataTable4_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF890 0x0038      LDRB     R0,[R0, #+56]
   \   00000020   0x0005             MOVS     R5,R0
     59                  OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x....             LDR.N    R0,??DataTable4_2
   \   00000026   0x5C28             LDRB     R0,[R5, R0]
   \   00000028   0x....             LDR.N    R1,??DataTable4_1
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0xF891 0x1039      LDRB     R1,[R1, #+57]
   \   00000030   0x4388             BICS     R0,R0,R1
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x....             LDR.N    R1,??DataTable4_2
   \   00000036   0x5468             STRB     R0,[R5, R1]
     60                  if (OSRdyTbl[y] == 0u) {
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x....             LDR.N    R0,??DataTable4_2
   \   0000003C   0x5C28             LDRB     R0,[R5, R0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD108             BNE.N    ??OSTimeDly_3
     61                      OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
   \   00000042   0x....             LDR.N    R0,??DataTable4_3
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x....             LDR.N    R1,??DataTable4_1
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0xF891 0x103A      LDRB     R1,[R1, #+58]
   \   0000004E   0x4388             BICS     R0,R0,R1
   \   00000050   0x....             LDR.N    R1,??DataTable4_3
   \   00000052   0x7008             STRB     R0,[R1, #+0]
     62                  }
     63                  OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
   \                     ??OSTimeDly_3:
   \   00000054   0x....             LDR.N    R0,??DataTable4_1
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x6304             STR      R4,[R0, #+48]
     64                  OS_EXIT_CRITICAL();
   \   0000005A   0x0030             MOVS     R0,R6
   \   0000005C   0x.... 0x....      BL       OS_CPU_SR_Restore
     65                  OS_Sched();                              /* Find next task to run!                             */
   \   00000060   0x.... 0x....      BL       OS_Sched
     66              }
     67          }
   \                     ??OSTimeDly_2:
   \                     ??OSTimeDly_0:
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
     68          /*$PAGE*/
     69          /*
     70          *********************************************************************************************************
     71          *                                     DELAY TASK FOR SPECIFIED TIME
     72          *
     73          * Description: This function is called to delay execution of the currently running task until some time
     74          *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
     75          *              MILLISECONDS instead of ticks.
     76          *
     77          * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
     78          *              minutes   specifies the number of minutes (max. 59)
     79          *              seconds   specifies the number of seconds (max. 59)
     80          *              ms        specifies the number of milliseconds (max. 999)
     81          *
     82          * Returns    : OS_ERR_NONE
     83          *              OS_ERR_TIME_INVALID_MINUTES
     84          *              OS_ERR_TIME_INVALID_SECONDS
     85          *              OS_ERR_TIME_INVALID_MS
     86          *              OS_ERR_TIME_ZERO_DLY
     87          *              OS_ERR_TIME_DLY_ISR
     88          *
     89          * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
     90          *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
     91          *              set to 0.  The actual delay is rounded to the nearest tick.
     92          *********************************************************************************************************
     93          */
     94          
     95          #if OS_TIME_DLY_HMSM_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     96          INT8U  OSTimeDlyHMSM (INT8U   hours,
     97                                INT8U   minutes,
     98                                INT8U   seconds,
     99                                INT16U  ms)
    100          {
   \                     OSTimeDlyHMSM:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    101              INT32U ticks;
    102          
    103          
    104              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   0000000C   0x....             LDR.N    R0,??DataTable4
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??OSTimeDlyHMSM_0
    105                  return (OS_ERR_TIME_DLY_ISR);
   \   00000014   0x2055             MOVS     R0,#+85
   \   00000016   0xE01A             B.N      ??OSTimeDlyHMSM_1
    106              }
    107          #if OS_ARG_CHK_EN > 0u
    108              if (hours == 0u) {
    109                  if (minutes == 0u) {
    110                      if (seconds == 0u) {
    111                          if (ms == 0u) {
    112                              return (OS_ERR_TIME_ZERO_DLY);
    113                          }
    114                      }
    115                  }
    116              }
    117              if (minutes > 59u) {
    118                  return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
    119              }
    120              if (seconds > 59u) {
    121                  return (OS_ERR_TIME_INVALID_SECONDS);
    122              }
    123              if (ms > 999u) {
    124                  return (OS_ERR_TIME_INVALID_MS);
    125              }
    126          #endif
    127                                                           /* Compute the total number of clock ticks required.. */
    128                                                           /* .. (rounded to the nearest tick)                   */
    129              ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
    130                    + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
   \                     ??OSTimeDlyHMSM_0:
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0xF44F 0x6061      MOV      R0,#+3600
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x213C             MOVS     R1,#+60
   \   00000022   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000026   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x1830             ADDS     R0,R6,R0
   \   0000002E   0x21C8             MOVS     R1,#+200
   \   00000030   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000032   0x1CBA             ADDS     R2,R7,#+2
   \   00000034   0x23C8             MOVS     R3,#+200
   \   00000036   0x435A             MULS     R2,R3,R2
   \   00000038   0xF44F 0x737A      MOV      R3,#+1000
   \   0000003C   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000040   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000044   0x4680             MOV      R8,R0
    131              OSTimeDly(ticks);
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0x.... 0x....      BL       OSTimeDly
    132              return (OS_ERR_NONE);
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??OSTimeDlyHMSM_1:
   \   0000004E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    133          }
    134          #endif
    135          /*$PAGE*/
    136          /*
    137          *********************************************************************************************************
    138          *                                         RESUME A DELAYED TASK
    139          *
    140          * Description: This function is used resume a task that has been delayed through a call to either
    141          *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
    142          *              task that is waiting for an event with timeout.  This would make the task look
    143          *              like a timeout occurred.
    144          *
    145          * Arguments  : prio                      specifies the priority of the task to resume
    146          *
    147          * Returns    : OS_ERR_NONE               Task has been resumed
    148          *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
    149          *                                        (i.e. >= OS_LOWEST_PRIO)
    150          *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
    151          *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
    152          *********************************************************************************************************
    153          */
    154          
    155          #if OS_TIME_DLY_RESUME_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    156          INT8U  OSTimeDlyResume (INT8U prio)
    157          {
   \                     OSTimeDlyResume:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    158              OS_TCB    *ptcb;
    159          #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
    160              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
    161          #endif
    162          
    163          
    164          
    165              if (prio >= OS_LOWEST_PRIO) {
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C1F             CMP      R4,#+31
   \   0000000A   0xD301             BCC.N    ??OSTimeDlyResume_0
    166                  return (OS_ERR_PRIO_INVALID);
   \   0000000C   0x202A             MOVS     R0,#+42
   \   0000000E   0xE051             B.N      ??OSTimeDlyResume_1
    167              }
    168              OS_ENTER_CRITICAL();
   \                     ??OSTimeDlyResume_0:
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000014   0x0006             MOVS     R6,R0
    169              ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x....             LDR.N    R0,??DataTable4_4
   \   0000001A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000001E   0x0005             MOVS     R5,R0
    170              if (ptcb == (OS_TCB *)0) {
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD104             BNE.N    ??OSTimeDlyResume_2
    171                  OS_EXIT_CRITICAL();
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0x.... 0x....      BL       OS_CPU_SR_Restore
    172                  return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
   \   0000002A   0x2043             MOVS     R0,#+67
   \   0000002C   0xE042             B.N      ??OSTimeDlyResume_1
    173              }
    174              if (ptcb == OS_TCB_RESERVED) {
   \                     ??OSTimeDlyResume_2:
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD104             BNE.N    ??OSTimeDlyResume_3
    175                  OS_EXIT_CRITICAL();
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x.... 0x....      BL       OS_CPU_SR_Restore
    176                  return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
   \   00000038   0x2043             MOVS     R0,#+67
   \   0000003A   0xE03B             B.N      ??OSTimeDlyResume_1
    177              }
    178              if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
   \                     ??OSTimeDlyResume_3:
   \   0000003C   0x6B28             LDR      R0,[R5, #+48]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD104             BNE.N    ??OSTimeDlyResume_4
    179                  OS_EXIT_CRITICAL();
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0x.... 0x....      BL       OS_CPU_SR_Restore
    180                  return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
   \   00000048   0x2050             MOVS     R0,#+80
   \   0000004A   0xE033             B.N      ??OSTimeDlyResume_1
    181              }
    182          
    183              ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
   \                     ??OSTimeDlyResume_4:
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6328             STR      R0,[R5, #+48]
    184              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
   \   00000050   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000054   0x2137             MOVS     R1,#+55
   \   00000056   0x4208             TST      R0,R1
   \   00000058   0xD009             BEQ.N    ??OSTimeDlyResume_5
    185                  ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
   \   0000005A   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000005E   0xF010 0x00C8      ANDS     R0,R0,#0xC8
   \   00000062   0xF885 0x0034      STRB     R0,[R5, #+52]
    186                  ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   0000006C   0xE002             B.N      ??OSTimeDlyResume_6
    187              } else {
    188                  ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
   \                     ??OSTimeDlyResume_5:
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF885 0x0035      STRB     R0,[R5, #+53]
    189              }
    190              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
   \                     ??OSTimeDlyResume_6:
   \   00000074   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000078   0x0700             LSLS     R0,R0,#+28
   \   0000007A   0xD417             BMI.N    ??OSTimeDlyResume_7
    191                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
   \   0000007C   0x....             LDR.N    R0,??DataTable4_3
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0xF895 0x103A      LDRB     R1,[R5, #+58]
   \   00000084   0x4308             ORRS     R0,R1,R0
   \   00000086   0x....             LDR.N    R1,??DataTable4_3
   \   00000088   0x7008             STRB     R0,[R1, #+0]
    192                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   0000008A   0xF895 0x0038      LDRB     R0,[R5, #+56]
   \   0000008E   0x....             LDR.N    R1,??DataTable4_2
   \   00000090   0x5C40             LDRB     R0,[R0, R1]
   \   00000092   0xF895 0x1039      LDRB     R1,[R5, #+57]
   \   00000096   0x4308             ORRS     R0,R1,R0
   \   00000098   0xF895 0x1038      LDRB     R1,[R5, #+56]
   \   0000009C   0x....             LDR.N    R2,??DataTable4_2
   \   0000009E   0x5488             STRB     R0,[R1, R2]
    193                  OS_EXIT_CRITICAL();
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0x.... 0x....      BL       OS_CPU_SR_Restore
    194                  OS_Sched();                                            /* See if this is new highest priority  */
   \   000000A6   0x.... 0x....      BL       OS_Sched
   \   000000AA   0xE002             B.N      ??OSTimeDlyResume_8
    195              } else {
    196                  OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
   \                     ??OSTimeDlyResume_7:
   \   000000AC   0x0030             MOVS     R0,R6
   \   000000AE   0x.... 0x....      BL       OS_CPU_SR_Restore
    197              }
    198              return (OS_ERR_NONE);
   \                     ??OSTimeDlyResume_8:
   \   000000B2   0x2000             MOVS     R0,#+0
   \                     ??OSTimeDlyResume_1:
   \   000000B4   0xBD70             POP      {R4-R6,PC}       ;; return
    199          }
    200          #endif
    201          /*$PAGE*/
    202          /*
    203          *********************************************************************************************************
    204          *                                         GET CURRENT SYSTEM TIME
    205          *
    206          * Description: This function is used by your application to obtain the current value of the 32-bit
    207          *              counter which keeps track of the number of clock ticks.
    208          *
    209          * Arguments  : none
    210          *
    211          * Returns    : The current value of OSTime
    212          *********************************************************************************************************
    213          */
    214          
    215          #if OS_TIME_GET_SET_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    216          INT32U  OSTimeGet (void)
    217          {
   \                     OSTimeGet:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    218              INT32U     ticks;
    219          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    220              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2500             MOVS     R5,#+0
    221          #endif
    222          
    223          
    224          
    225              OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000008   0x0005             MOVS     R5,R0
    226              ticks = OSTime;
   \   0000000A   0x....             LDR.N    R0,??DataTable4_5
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0004             MOVS     R4,R0
    227              OS_EXIT_CRITICAL();
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Restore
    228              return (ticks);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    229          }
    230          #endif
    231          
    232          /*
    233          *********************************************************************************************************
    234          *                                            SET SYSTEM CLOCK
    235          *
    236          * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
    237          *
    238          * Arguments  : ticks      specifies the new value that OSTime needs to take.
    239          *
    240          * Returns    : none
    241          *********************************************************************************************************
    242          */
    243          
    244          #if OS_TIME_GET_SET_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    245          void  OSTimeSet (INT32U ticks)
    246          {
   \                     OSTimeSet:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    247          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    248              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2500             MOVS     R5,#+0
    249          #endif
    250          
    251          
    252          
    253              OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
    254              OSTime = ticks;
   \   0000000C   0x....             LDR.N    R0,??DataTable4_5
   \   0000000E   0x6004             STR      R4,[R0, #+0]
    255              OS_EXIT_CRITICAL();
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Restore
    256          }
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     OSTime
    257          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OSTimeDly
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_Sched
      24   OSTimeDlyHMSM
        24   -> OSTimeDly
      16   OSTimeDlyResume
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_Sched
      16   OSTimeGet
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      16   OSTimeSet
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
     102  OSTimeDly
      82  OSTimeDlyHMSM
     182  OSTimeDlyResume
      26  OSTimeGet
      24  OSTimeSet

 
 440 bytes in section .text
 
 440 bytes of CODE memory

Errors: none
Warnings: none
