###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      05/Apr/2017  15:06:09 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\桌面\RTU_1.3\USB\scsi.c                      #
#    Command line =  D:\wangfan2\桌面\RTU_1.3\USB\scsi.c -lCN                 #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\List\ -o      #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\Obj\          #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\桌面\RTU_1.3\project\iar\ -I       #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\ -I       #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\ADC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\RTC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\TILT\ -I  #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\RDLevel\  #
#                    -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\RS232\ #
#                     -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\OS-v2 #
#                    \ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\Vibr #
#                    ationString\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\ #
#                    ..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\ -I     #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\ucos2\uCOS-II #
#                    \Source\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\u #
#                    cos2\uC-LIB\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\ #
#                    ..\ucos2\uC-CPU\ -I D:\wangfan2\桌面\RTU_1.3\project\iar #
#                    \..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I                #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\cmsis\Drivers #
#                    \source\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\c #
#                    msis\Drivers\include\ -I D:\wangfan2\桌面\RTU_1.3\projec #
#                    t\iar\..\..\app\ -I D:\wangfan2\桌面\RTU_1.3\project\iar #
#                    \..\..\uC-Probe\Target\Plugins\uCOS-II\ -I               #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Workspaces\ -I                            #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Source\ -I D:\wangfan2\桌面\RTU_1.3\proje #
#                    ct\iar\..\..\uC-Probe\Target\Communication\Generic\Sourc #
#                    e\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Prob #
#                    e\Target\Communication\Generic\RS-232\Source\ -I         #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\Ports\NXP\LPC17xx\ -I    #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\OS\uCOS-II\ -I           #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\cmsis\Core\CM #
#                    3\CoreSupport\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\. #
#                    .\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\ -I     #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp\ -I  #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp\DEVI #
#                    CE_BT\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\Hua #
#                    ceApp\DEVICE_COM\ -I D:\wangfan2\桌面\RTU_1.3\project\ia #
#                    r\..\..\HuaceApp\DEVICE_GPRS\ -I                         #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp\DEVI #
#                    CE_GPS\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\Hu #
#                    aceApp\DEVICE_RADIO\ -I D:\wangfan2\桌面\RTU_1.3\project #
#                    \iar\..\..\HuaceApp\iap\ -I                              #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\FatFs\ -I     #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\USB\ -I       #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\bsp\spi_flash #
#                    \ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp #
#                    \LED\ -On --use_c++_inline                               #
#    List file    =  D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\List\scsi.lst #
#    Object file  =  D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\Obj\scsi.o    #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\桌面\RTU_1.3\USB\scsi.c
      1          /*************************************************************************
      2           *
      3           *    Used with ICCARM and AARM.
      4           *
      5           *    (c) Copyright IAR Systems 2007
      6           *
      7           *    File name   : scsi.c
      8           *    Description : USB Mass storage device bulk-only transport and
      9           *                  SCSI SPC, SBC, MMC commands set
     10           *
     11           *    History :
     12           *    1. Date        : September 8, 2005
     13           *       Author      : Stanimir Bonev
     14           *       Description : Create
     15           *    2. Date        : January 27, 2006
     16           *       Author      : Stanimir Bonev
     17           *       Description : Modify
     18           *        Add Unit Start/Stop command implement
     19           *    3. Date        : October 23, 2007
     20           *       Author      : Stanimir Bonev
     21           *       Description : Modify
     22           *        Adapt for the USB framework 2
     23           *
     24           *    $Revision: 28532 $
     25           **************************************************************************/
     26          
     27          #define SCSI_GOBALS
     28          #include "scsi.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memset
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void EntrCritSection(void)
   \                     EntrCritSection:
   \   00000000   0x4805             LDR.N    R0,??EntrCritSection_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD100             BNE.N    ??EntrCritSection_1
   \   00000008   0xB672             CPSID i
   \                     ??EntrCritSection_1:
   \   0000000A   0x4803             LDR.N    R0,??EntrCritSection_0
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x4901             LDR.N    R1,??EntrCritSection_0
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0x4770             BX       LR               ;; return
   \   00000016   0xBF00             Nop      
   \                     ??EntrCritSection_0:
   \   00000018   0x........         DC32     CriticalSecCntr

   \                                 In section .text, align 4
   \   __interwork __softfp void ExtCritSection(void)
   \                     ExtCritSection:
   \   00000000   0x4804             LDR.N    R0,??ExtCritSection_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1E40             SUBS     R0,R0,#+1
   \   00000006   0x4903             LDR.N    R1,??ExtCritSection_0
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD100             BNE.N    ??ExtCritSection_1
   \   0000000E   0xB662             CPSIE i
   \                     ??ExtCritSection_1:
   \   00000010   0x4770             BX       LR               ;; return
   \   00000012   0xBF00             Nop      
   \                     ??ExtCritSection_0:
   \   00000014   0x........         DC32     CriticalSecCntr

   \                                 In section .bss, align 4
   \   __absolute pInt32U pScsiMessage[1]
   \                     pScsiMessage:
   \   00000000                      DS8 4
     29          
     30          #pragma data_alignment=4

   \                                 In section .rodata, align 4
     31          const Int8U LunMax = SCSI_LUN_NUMB-1;
   \                     LunMax:
   \   00000000   0x00               DC8 0
     32          

   \                                 In section .bss, align 4
     33          ScsiDrvObj  ScsiDrv [SCSI_LUN_NUMB];
   \                     ScsiDrv:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     34          Int32U      Lun = 0;
   \                     Lun:
   \   00000000                      DS8 4
     35          

   \                                 In section .bss, align 1
     36          volatile BotState_t  BotState;
   \                     BotState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     37          volatile BotStatus_t BotStatus;
   \                     BotStatus:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     38          volatile Boolean MSD_Configure;
   \                     MSD_Configure:
   \   00000000                      DS8 4
     39          
     40          /*************************************************************************
     41           * Function Name: ScsiInit
     42           * Parameters: none
     43           *
     44           * Return: none
     45           *
     46           * Description: Init SCSI
     47           *
     48           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     49          void ScsiInit (void)
     50          {
   \                     ScsiInit:
   \   00000000   0xB580             PUSH     {R7,LR}
     51            UsbClassBotInit();
   \   00000002   0x.... 0x....      BL       UsbClassBotInit
     52            // SCSI Drive Objects init
     53            for (Int32U i = 0; i < SCSI_LUN_NUMB; ++i)
   \   00000006   0x2000             MOVS     R0,#+0
   \                     ??ScsiInit_0:
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD11A             BNE.N    ??ScsiInit_1
     54            {
     55              ScsiDrv[i].Status = ScsiCommandNoKey;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000010   0xEB11 0x1100      ADDS     R1,R1,R0, LSL #+4
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x730A             STRB     R2,[R1, #+12]
     56              ScsiDrv[i].UnitSSStatus = UnitStarted;
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000001C   0xEB11 0x1100      ADDS     R1,R1,R0, LSL #+4
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x734A             STRB     R2,[R1, #+13]
     57              // Send init LUN message
     58              ScsiDrv[i].Message[0] = LunInitMsg;
   \   00000024   0x0101             LSLS     R1,R0,#+4
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable20
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x508B             STR      R3,[R1, R2]
     59              pScsiMessage[i] = ScsiDrv[i].Message;
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable20
   \   00000036   0xEB12 0x1200      ADDS     R2,R2,R0, LSL #+4
   \   0000003A   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
     60            }
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0xE7E2             B.N      ??ScsiInit_0
     61          }
   \                     ??ScsiInit_1:
   \   00000042   0xBD01             POP      {R0,PC}          ;; return
     62          
     63          /*************************************************************************
     64           * Function Name: UsbClassBotInit
     65           * Parameters: none
     66           *
     67           * Return: none
     68           *
     69           * Description: USB Bulk-only transport init
     70           *
     71           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     72          void UsbClassBotInit (void)
     73          {
   \                     UsbClassBotInit:
   \   00000000   0xB580             PUSH     {R7,LR}
     74            //BOT Init
     75            MSD_Configure = FALSE;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6001             STR      R1,[R0, #+0]
     76            BotState = BotWaitCbw;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7001             STRB     R1,[R0, #+0]
     77            Lun = 0;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6001             STR      R1,[R0, #+0]
     78            // Clear all flags
     79            BotStatus.Flags = 0;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x7001             STRB     R1,[R0, #+0]
     80          
     81            UsbClassBotConfigure(NULL);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       UsbClassBotConfigure
     82            UsbCoreInit();
   \   00000028   0x.... 0x....      BL       UsbCoreInit
     83          }
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
     84          
     85          /*************************************************************************
     86           * Function Name: UsbClassBotConfigure
     87           * Parameters:  pUsbDevCtrl_t pDev
     88           *
     89           * Return: none
     90           *
     91           * Description: USB Class storage configure
     92           *
     93           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     94          void UsbClassBotConfigure (pUsbDevCtrl_t pDev)
     95          {
   \                     UsbClassBotConfigure:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     96            if(pDev != NULL && pDev->Configuration)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD009             BEQ.N    ??UsbClassBotConfigure_0
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD006             BEQ.N    ??UsbClassBotConfigure_0
     97            {
     98              // Reset Interface
     99              UsbBotRstInterface();
   \   0000000E   0x.... 0x....      BL       UsbBotRstInterface
    100              MSD_Configure = TRUE;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x6001             STR      R1,[R0, #+0]
   \   0000001A   0xE003             B.N      ??UsbClassBotConfigure_1
    101            }
    102            else
    103            {
    104              MSD_Configure = FALSE;
   \                     ??UsbClassBotConfigure_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6001             STR      R1,[R0, #+0]
    105            }
    106          }
   \                     ??UsbClassBotConfigure_1:
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    107          
    108          /*************************************************************************
    109           * Function Name: IsUsbMSDConfigure
    110           * Parameters:  none
    111           *
    112           * Return: Boolean
    113           *
    114           * Description: Return configuration state
    115           *
    116           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    117          Boolean IsUsbMSDConfigure (void)
    118          {
    119            return(MSD_Configure);
   \                     IsUsbMSDConfigure:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    120          }
    121          
    122          /*************************************************************************
    123           * Function Name: UsbBotRstInterface
    124           * Parameters: none
    125           *
    126           * Return: none
    127           *
    128           * Description: USB Bulk-only transport interface reset
    129           *
    130           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    131          void UsbBotRstInterface (void)
    132          {
   \                     UsbBotRstInterface:
   \   00000000   0xB580             PUSH     {R7,LR}
    133            //BOT Init
    134            BotState = BotWaitCbw;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7001             STRB     R1,[R0, #+0]
    135            Lun = 0;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6001             STR      R1,[R0, #+0]
    136            // Clear all flags
    137            BotStatus.Flags = 0;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x7001             STRB     R1,[R0, #+0]
    138            USB_IO_Data(BulkOutEp,
    139                        (pInt8U)&Cbw,
    140                        sizeof(Cbw_t),
    141                        (void *)BotOutEP);
   \   0000001A   0x.... 0x....      ADR.W    R3,BotOutEP
   \   0000001E   0x221F             MOVS     R2,#+31
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable20_6
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x.... 0x....      BL       USB_IO_Data
    142            Csw.dCSWSignature = CswSignature;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable20_8  ;; 0x53425355
   \   00000032   0x6001             STR      R1,[R0, #+0]
    143          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
    144          
    145          /*************************************************************************
    146           * Function Name: BotInEpStall
    147           * Parameters:  none
    148           *
    149           * Return: none
    150           *
    151           * Description: Stall BOT In EP
    152           *
    153           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    154          void BotInEpStall (void)
    155          {
   \                     BotInEpStall:
   \   00000000   0xB580             PUSH     {R7,LR}
    156            USB_SetStallEP((USB_Endpoint_t)BulkInEp,TRUE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2005             MOVS     R0,#+5
   \   00000006   0x.... 0x....      BL       USB_SetStallEP
    157          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    158          
    159          /*************************************************************************
    160           * Function Name: BotOutEpStall
    161           * Parameters:  none
    162           *
    163           * Return: none
    164           *
    165           * Description: Stall BOT Out EP
    166           *
    167           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    168          void BotOutEpStall (void)
    169          {
   \                     BotOutEpStall:
   \   00000000   0xB580             PUSH     {R7,LR}
    170            USB_SetStallEP((USB_Endpoint_t)BulkOutEp,TRUE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       USB_SetStallEP
    171          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    172          
    173          /*************************************************************************
    174           * Function Name: UsbClassBotRequest
    175           * Parameters: pUsbSetupPacket_t pSetup
    176           *
    177           * Return: UsbCommStatus_t
    178           *
    179           * Description: Implement USB Class storage requests
    180           *
    181           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    182          UsbCommStatus_t UsbClassBotRequest (pUsbSetupPacket_t pSetup)
    183          {
   \                     UsbClassBotRequest:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    184            if (   pSetup->mRequestType.Recipient == UsbRecipientInterface
    185                && pSetup->wIndex.Word == MSD_INTERFACE_ID)
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD126             BNE.N    ??UsbClassBotRequest_0
   \   0000000E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD123             BNE.N    ??UsbClassBotRequest_0
    186            {
    187              switch (pSetup->bRequest)
   \   00000014   0x7860             LDRB     R0,[R4, #+1]
   \   00000016   0x28FE             CMP      R0,#+254
   \   00000018   0xD002             BEQ.N    ??UsbClassBotRequest_1
   \   0000001A   0x28FF             CMP      R0,#+255
   \   0000001C   0xD011             BEQ.N    ??UsbClassBotRequest_2
   \   0000001E   0xE01D             B.N      ??UsbClassBotRequest_0
    188              {
    189              case UsbBotInterfaceGetMaxLun: // return number of LUN
    190                if ((pSetup->wValue.Word  == 0) &&
    191                    (pSetup->wLength.Word == 1))
   \                     ??UsbClassBotRequest_1:
   \   00000020   0x8860             LDRH     R0,[R4, #+2]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD10C             BNE.N    ??UsbClassBotRequest_3
   \   00000026   0x88E0             LDRH     R0,[R4, #+6]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD109             BNE.N    ??UsbClassBotRequest_3
    192                {
    193                  USB_IO_Data( CTRL_ENP_IN,
    194                              (pInt8U)&LunMax,
    195                               1,
    196                              (void *)USB_StatusHandler);
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable20_9
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       USB_IO_Data
    197                  return(UsbPass);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE00E             B.N      ??UsbClassBotRequest_4
    198                }
    199                break;
   \                     ??UsbClassBotRequest_3:
   \   00000040   0xE00C             B.N      ??UsbClassBotRequest_0
    200              case MassStorageClassReqReset:  // reset BOT interface
    201                if ((pSetup->wValue.Word  == 0) &&
    202                    (pSetup->wLength.Word == 0))
   \                     ??UsbClassBotRequest_2:
   \   00000042   0x8860             LDRH     R0,[R4, #+2]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD109             BNE.N    ??UsbClassBotRequest_5
   \   00000048   0x88E0             LDRH     R0,[R4, #+6]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD106             BNE.N    ??UsbClassBotRequest_5
    203                {
    204                  UsbBotRstInterface();
   \   0000004E   0x.... 0x....      BL       UsbBotRstInterface
    205                  // Send AKN
    206                  USB_StatusHandler(CTRL_ENP_IN);
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x.... 0x....      BL       USB_StatusHandler
    207                  return(UsbPass);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE000             B.N      ??UsbClassBotRequest_4
    208                }
    209                break;
    210              }
    211            }
    212             return(UsbFault);
   \                     ??UsbClassBotRequest_5:
   \                     ??UsbClassBotRequest_0:
   \   0000005C   0x2001             MOVS     R0,#+1
   \                     ??UsbClassBotRequest_4:
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
    213          }
    214          
    215          /*************************************************************************
    216           * Function Name: BotOutEP
    217           * Parameters:  USB_Endpoint_t EP
    218           *
    219           * Return: none
    220           *
    221           * Description: USB BOT Out EP handler
    222           *
    223           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    224          void BotOutEP (USB_Endpoint_t EP)
    225          {
   \                     BotOutEP:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    226            assert(EP == BulkOutEp);
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C04             CMP      R4,#+4
   \   00000008   0xD008             BEQ.N    ??BotOutEP_0
   \   0000000A   0x22E2             MOVS     R2,#+226
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable20_11
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   00000014   0x.... 0x....      BL       __aeabi_assert
   \   00000018   0x.... 0x....      BL       __iar_EmptyStepPoint
    227            switch (BotState)
   \                     ??BotOutEP_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD002             BEQ.N    ??BotOutEP_1
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD00E             BEQ.N    ??BotOutEP_2
   \   0000002A   0xE032             B.N      ??BotOutEP_3
    228            {
    229            case BotWaitCbw:
    230              if(EpCnfg[BulkOutEp].Status == COMPLETE)
   \                     ??BotOutEP_1:
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable20_13
   \   00000030   0xF890 0x00A4      LDRB     R0,[R0, #+164]
   \   00000034   0x2803             CMP      R0,#+3
   \   00000036   0xD106             BNE.N    ??BotOutEP_4
    231              {
    232                BotStatus.Flags = 0;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x7001             STRB     R1,[R0, #+0]
    233                ScsiCommImpl();
   \   00000040   0x.... 0x....      BL       ScsiCommImpl
    234                return;
   \   00000044   0xE041             B.N      ??BotOutEP_5
    235              }
    236              break;
   \                     ??BotOutEP_4:
   \   00000046   0xE024             B.N      ??BotOutEP_3
    237            case BotEpDataOut:
    238              if(EpCnfg[BulkOutEp].Status == COMPLETE)
   \                     ??BotOutEP_2:
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable20_13
   \   0000004C   0xF890 0x00A4      LDRB     R0,[R0, #+164]
   \   00000050   0x2803             CMP      R0,#+3
   \   00000052   0xD116             BNE.N    ??BotOutEP_6
    239              {
    240                ScsiDrv[Lun].Message[0] = LunDataReadyMsg;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x0100             LSLS     R0,R0,#+4
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000060   0x220B             MOVS     R2,#+11
   \   00000062   0x5042             STR      R2,[R0, R1]
    241                pScsiMessage[Lun]       = ScsiDrv[Lun].Message;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000006E   0x.... 0x....      LDR.W    R2,??DataTable20_4
   \   00000072   0x6812             LDR      R2,[R2, #+0]
   \   00000074   0x.... 0x....      LDR.W    R3,??DataTable20
   \   00000078   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   0000007C   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    242                return;
   \   00000080   0xE023             B.N      ??BotOutEP_5
    243              }
    244              // Phase error
    245              BotStatus.PhaseError = TRUE;
   \                     ??BotOutEP_6:
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable20_5
   \   00000090   0x7008             STRB     R0,[R1, #+0]
    246              break;
    247            }
    248            ScsiDrv[Lun].Message[0] = LunResetReqMsg;
   \                     ??BotOutEP_3:
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x0100             LSLS     R0,R0,#+4
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000009E   0x2201             MOVS     R2,#+1
   \   000000A0   0x5042             STR      R2,[R0, R1]
    249            pScsiMessage[Lun]       = ScsiDrv[Lun].Message;
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000AC   0x.... 0x....      LDR.W    R2,??DataTable20_4
   \   000000B0   0x6812             LDR      R2,[R2, #+0]
   \   000000B2   0x.... 0x....      LDR.W    R3,??DataTable20
   \   000000B6   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   000000BA   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    250            BotOutEpStall();
   \   000000BE   0x.... 0x....      BL       BotOutEpStall
    251            BotInEpStall();
   \   000000C2   0x.... 0x....      BL       BotInEpStall
    252            // Something is wrong
    253            UsbBotRstInterface();
   \   000000C6   0x.... 0x....      BL       UsbBotRstInterface
    254          }
   \                     ??BotOutEP_5:
   \   000000CA   0xBD10             POP      {R4,PC}          ;; return
    255          
    256          /*************************************************************************
    257           * Function Name: BotInEP
    258           * Parameters:  USB_Endpoint_t EP
    259           *
    260           * Return: none
    261           *
    262           * Description: USB BOT In EP handler
    263           *
    264           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    265          void BotInEP (USB_Endpoint_t EP)
    266          {
   \                     BotInEP:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    267            assert(EP == BulkInEp);
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C05             CMP      R4,#+5
   \   00000008   0xD009             BEQ.N    ??BotInEP_0
   \   0000000A   0xF240 0x120B      MOVW     R2,#+267
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable20_11
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   00000016   0x.... 0x....      BL       __aeabi_assert
   \   0000001A   0x.... 0x....      BL       __iar_EmptyStepPoint
    268            switch (BotState)
   \                     ??BotInEP_0:
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD074             BEQ.N    ??BotInEP_1
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD002             BEQ.N    ??BotInEP_2
   \   0000002C   0x2803             CMP      R0,#+3
   \   0000002E   0xD06D             BEQ.N    ??BotInEP_3
   \   00000030   0xE070             B.N      ??BotInEP_4
    269            {
    270            case BotEpDataIn:
    271              if(EpCnfg[BulkInEp].Status == COMPLETE)
   \                     ??BotInEP_2:
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable20_13
   \   00000036   0xF890 0x00C8      LDRB     R0,[R0, #+200]
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xD13D             BNE.N    ??BotInEP_5
    272              {
    273                if(BotStatus.DataComplete)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD01E             BEQ.N    ??BotInEP_6
    274                {
    275                  if (Csw.dCSWDataResidue && !BotStatus.ShortPacket)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000052   0x6880             LDR      R0,[R0, #+8]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD016             BEQ.N    ??BotInEP_7
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD10E             BNE.N    ??BotInEP_7
    276                  {
    277                    // The host expect more data
    278                    BotStatus.ShortPacket = FALSE;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable20_5
   \   00000076   0x7008             STRB     R0,[R1, #+0]
    279                    USB_IO_Data(BulkInEp,NULL,0,NULL);
   \   00000078   0x2300             MOVS     R3,#+0
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x2005             MOVS     R0,#+5
   \   00000080   0x.... 0x....      BL       USB_IO_Data
   \   00000084   0xE001             B.N      ??BotInEP_8
    280                  }
    281                  else
    282                  {
    283                    BotSendStatus();
   \                     ??BotInEP_7:
   \   00000086   0x.... 0x....      BL       BotSendStatus
    284                  }
    285                  return;
   \                     ??BotInEP_8:
   \   0000008A   0xE05F             B.N      ??BotInEP_9
    286                }
    287                ScsiDrv[Lun].Message[0] = LunDataReadyMsg;
   \                     ??BotInEP_6:
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x0100             LSLS     R0,R0,#+4
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000098   0x220B             MOVS     R2,#+11
   \   0000009A   0x5042             STR      R2,[R0, R1]
    288                pScsiMessage[Lun]       = ScsiDrv[Lun].Message;
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable20_4
   \   000000AA   0x6812             LDR      R2,[R2, #+0]
   \   000000AC   0x.... 0x....      LDR.W    R3,??DataTable20
   \   000000B0   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   000000B4   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    289                return;
   \   000000B8   0xE048             B.N      ??BotInEP_9
    290              }
    291              BotStatus.PhaseError    =\
    292              BotStatus.BotStatus     = TRUE;
   \                     ??BotInEP_5:
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable20_5
   \   000000C8   0x7008             STRB     R0,[R1, #+0]
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   000000CE   0x7800             LDRB     R0,[R0, #+0]
   \   000000D0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable20_5
   \   000000D8   0x7008             STRB     R0,[R1, #+0]
    293              ScsiDrv[Lun].Message[0] = LunResetReqMsg;
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0x0100             LSLS     R0,R0,#+4
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000E6   0x2201             MOVS     R2,#+1
   \   000000E8   0x5042             STR      R2,[R0, R1]
    294              pScsiMessage[Lun]       = ScsiDrv[Lun].Message;
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000F4   0x.... 0x....      LDR.W    R2,??DataTable20_4
   \   000000F8   0x6812             LDR      R2,[R2, #+0]
   \   000000FA   0x.... 0x....      LDR.W    R3,??DataTable20
   \   000000FE   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   00000102   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    295              BotInEpStall();
   \   00000106   0x.... 0x....      BL       BotInEpStall
    296              return;
   \   0000010A   0xE01F             B.N      ??BotInEP_9
    297            case BotSendCsw:
    298              UsbBotRstInterface();
   \                     ??BotInEP_3:
   \   0000010C   0x.... 0x....      BL       UsbBotRstInterface
    299              return;
   \   00000110   0xE01C             B.N      ??BotInEP_9
    300            case BotWaitCbw:
    301              return;
   \                     ??BotInEP_1:
   \   00000112   0xE01B             B.N      ??BotInEP_9
    302            }
    303            ScsiDrv[Lun].Message[0] = LunResetReqMsg;
   \                     ??BotInEP_4:
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0x0100             LSLS     R0,R0,#+4
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000120   0x2201             MOVS     R2,#+1
   \   00000122   0x5042             STR      R2,[R0, R1]
    304            pScsiMessage[Lun]       = ScsiDrv[Lun].Message;
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000012E   0x.... 0x....      LDR.W    R2,??DataTable20_4
   \   00000132   0x6812             LDR      R2,[R2, #+0]
   \   00000134   0x.... 0x....      LDR.W    R3,??DataTable20
   \   00000138   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   0000013C   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    305            BotOutEpStall();
   \   00000140   0x.... 0x....      BL       BotOutEpStall
    306            BotInEpStall();
   \   00000144   0x.... 0x....      BL       BotInEpStall
    307            // Something is wrong
    308            UsbBotRstInterface();
   \   00000148   0x.... 0x....      BL       UsbBotRstInterface
    309            return;
   \                     ??BotInEP_9:
   \   0000014C   0xBD10             POP      {R4,PC}          ;; return
    310          }
    311          
    312          /*************************************************************************
    313           * Function Name: BotUnstallCallBack
    314           * Parameters: USB_Endpoint_t EP
    315           *
    316           * Return: none
    317           *
    318           * Description: Unstall callback function
    319           *
    320           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    321          void BotUnstallCallBack (USB_Endpoint_t EP)
    322          {
   \                     BotUnstallCallBack:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    323            if(EP == BulkOutEp)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C04             CMP      R4,#+4
   \   00000008   0xD10A             BNE.N    ??BotUnstallCallBack_0
    324            {
    325              if (!BotStatus.BotStatus)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD112             BNE.N    ??BotUnstallCallBack_1
    326              {
    327                UsbBotRstInterface();
   \   0000001A   0x.... 0x....      BL       UsbBotRstInterface
   \   0000001E   0xE00F             B.N      ??BotUnstallCallBack_1
    328              }
    329            }
    330            else if (EP == BulkInEp)
   \                     ??BotUnstallCallBack_0:
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2C05             CMP      R4,#+5
   \   00000024   0xD10C             BNE.N    ??BotUnstallCallBack_1
    331            {
    332              if (BotStatus.BotStatus)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD002             BEQ.N    ??BotUnstallCallBack_2
    333              {
    334                // Send a status after unstall the IN EP
    335                BotSendStatus();
   \   00000036   0x.... 0x....      BL       BotSendStatus
   \   0000003A   0xE001             B.N      ??BotUnstallCallBack_1
    336              }
    337              else
    338              {
    339                UsbBotRstInterface();
   \                     ??BotUnstallCallBack_2:
   \   0000003C   0x.... 0x....      BL       UsbBotRstInterface
    340              }
    341            }
    342          }
   \                     ??BotUnstallCallBack_1:
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    343          
    344          /*************************************************************************
    345           * Function Name: BotReceiveDataInit
    346           * Parameters: pInt8U pData, Int32U DataSize, Boolean DataComplete
    347           *
    348           * Return: BotToUserStatus_t
    349           *
    350           * Description: Init Receive
    351           *
    352           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    353          BotToUserStatus_t BotReceiveDataInit (pInt8U pData, Int32U DataSize, Boolean DataComplete)
    354          {
   \                     BotReceiveDataInit:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    355          #if __CORE__ < 7
    356          Int32U Save;
    357          #endif // __CORE__ < 7
    358            if (DataSize > Csw.dCSWDataResidue)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x42A8             CMP      R0,R5
   \   00000010   0xD201             BCS.N    ??BotReceiveDataInit_0
    359            {
    360              // When user tries to receive more data from that host expect
    361              return(BotError);
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE021             B.N      ??BotReceiveDataInit_1
    362            }
    363            else if (!DataComplete && (DataSize % BulkInEpMaxSize))
   \                     ??BotReceiveDataInit_0:
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD108             BNE.N    ??BotReceiveDataInit_2
   \   0000001A   0x2040             MOVS     R0,#+64
   \   0000001C   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   00000020   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD001             BEQ.N    ??BotReceiveDataInit_2
    364            {
    365              // when user tries to receive not alignment data to
    366              // the EP max size and DataComplete flag isn't set
    367              return(BotNotAlignment);
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0xE016             B.N      ??BotReceiveDataInit_1
    368            }
    369          #if __CORE__ < 7
    370            ENTR_CRT_SECTION(Save);
    371          #else
    372            ENTR_CRT_SECTION();
   \                     ??BotReceiveDataInit_2:
   \   0000002C   0x.... 0x....      BL       EntrCritSection
    373          #endif // __CORE__ < 7
    374            // Set BOT EP state
    375            BotState = BotEpDataOut;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x7001             STRB     R1,[R0, #+0]
    376            // Update DataResidue
    377            Csw.dCSWDataResidue -= DataSize;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   0000003C   0x6880             LDR      R0,[R0, #+8]
   \   0000003E   0x1B40             SUBS     R0,R0,R5
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   00000044   0x6088             STR      R0,[R1, #+8]
    378            // Init Transfer form BOT OUT EP
    379            USB_IO_Data(BulkOutEp,
    380                        pData,
    381                        DataSize,
    382                       (void*)BotOutEP);
   \   00000046   0x.... 0x....      LDR.W    R3,??DataTable20_15
   \   0000004A   0x002A             MOVS     R2,R5
   \   0000004C   0x0021             MOVS     R1,R4
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x.... 0x....      BL       USB_IO_Data
    383          
    384          #if __CORE__ < 7
    385            EXT_CRT_SECTION(Save);
    386          #else
    387            EXT_CRT_SECTION();
   \   00000054   0x.... 0x....      BL       ExtCritSection
    388          #endif // __CORE__ < 7
    389            return BotPass;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??BotReceiveDataInit_1:
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
    390          }
    391          
    392          /*************************************************************************
    393           * Function Name: BotSendDataInit
    394           * Parameters:  const pInt8U pData, Int32U DataSize, Boolean DataComplete
    395           *
    396           * Return: BotToUserStatus_t
    397           *
    398           * Description: Init Transmit
    399           *
    400           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    401          BotToUserStatus_t BotSendDataInit (const pInt8U pData, Int32U DataSize, Boolean DataComplete)
    402          {
   \                     BotSendDataInit:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    403          #if __CORE__ < 7
    404          Int32U Save;
    405          #endif // __CORE__ < 7
    406            if (DataSize > Csw.dCSWDataResidue)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x42A8             CMP      R0,R5
   \   00000010   0xD20B             BCS.N    ??BotSendDataInit_0
    407            {
    408              // When user tries to send more data from that host expect
    409              BotStatus.PhaseError = TRUE;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable20_5
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    410              DataSize = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0005             MOVS     R5,R0
    411              return BotError;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE032             B.N      ??BotSendDataInit_1
    412            }
    413            else if (DataSize % BulkInEpMaxSize)
   \                     ??BotSendDataInit_0:
   \   0000002A   0x2040             MOVS     R0,#+64
   \   0000002C   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   00000030   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD00B             BEQ.N    ??BotSendDataInit_2
    414            {
    415              BotStatus.ShortPacket = TRUE;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable20_5
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    416              if(!DataComplete)
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD101             BNE.N    ??BotSendDataInit_2
    417              {
    418                // Data size Alignment error
    419                return BotNotAlignment;
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0xE01F             B.N      ??BotSendDataInit_1
    420              }
    421            }
    422          #if __CORE__ < 7
    423            ENTR_CRT_SECTION(Save);
    424          #else
    425            ENTR_CRT_SECTION();
   \                     ??BotSendDataInit_2:
   \   00000050   0x.... 0x....      BL       EntrCritSection
    426          #endif // __CORE__ < 7
    427            // Set BOT EP state
    428            BotState = BotEpDataIn;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000058   0x2102             MOVS     R1,#+2
   \   0000005A   0x7001             STRB     R1,[R0, #+0]
    429            BotStatus.DataComplete = DataComplete;
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable20_5
   \   00000062   0x7809             LDRB     R1,[R1, #+0]
   \   00000064   0xF360 0x01C3      BFI      R1,R0,#+3,#+1
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
    430            // Update DataResidue
    431            Csw.dCSWDataResidue -= DataSize;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000072   0x6880             LDR      R0,[R0, #+8]
   \   00000074   0x1B40             SUBS     R0,R0,R5
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   0000007A   0x6088             STR      R0,[R1, #+8]
    432            // Init Transfer to BOT IN EP
    433            USB_IO_Data(BulkInEp,
    434                        pData,
    435                        DataSize,
    436                       (void*)BotInEP);
   \   0000007C   0x.... 0x....      LDR.W    R3,??DataTable20_16
   \   00000080   0x002A             MOVS     R2,R5
   \   00000082   0x0021             MOVS     R1,R4
   \   00000084   0x2005             MOVS     R0,#+5
   \   00000086   0x.... 0x....      BL       USB_IO_Data
    437          #if __CORE__ < 7
    438            EXT_CRT_SECTION(Save);
    439          #else
    440            EXT_CRT_SECTION();
   \   0000008A   0x.... 0x....      BL       ExtCritSection
    441          #endif // __CORE__ < 7
    442            return BotPass;
   \   0000008E   0x2000             MOVS     R0,#+0
   \                     ??BotSendDataInit_1:
   \   00000090   0xBD70             POP      {R4-R6,PC}       ;; return
    443          }
    444          
    445          /*************************************************************************
    446           * Function Name: BotSendStatus
    447           * Parameters:  Int32U DataSize, Int8U * pData, Boolean DataComplete
    448           *
    449           * Return: BotToUserStatus_t
    450           *
    451           * Description: Init Transmit of the CSW
    452           *
    453           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    454          void BotSendStatus (void)
    455          {
   \                     BotSendStatus:
   \   00000000   0xB580             PUSH     {R7,LR}
    456          #if __CORE__ < 7
    457          Int32U Save;
    458            ENTR_CRT_SECTION(Save);
    459          #else
    460            ENTR_CRT_SECTION();
   \   00000002   0x.... 0x....      BL       EntrCritSection
    461          #endif // __CORE__ < 7
    462            BotState = BotSendCsw;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000000A   0x2103             MOVS     R1,#+3
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    463            if(BotStatus.PhaseError)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD004             BEQ.N    ??BotSendStatus_0
    464            {
    465              Csw.bCSWStatus = CswPhaseError;
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x7301             STRB     R1,[R0, #+12]
   \   00000024   0xE010             B.N      ??BotSendStatus_1
    466            }
    467            else if (BotStatus.CmdFault)
   \                     ??BotSendStatus_0:
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD004             BEQ.N    ??BotSendStatus_2
    468            {
    469              Csw.bCSWStatus = CswFailed;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x7301             STRB     R1,[R0, #+12]
   \   0000003E   0xE003             B.N      ??BotSendStatus_1
    470            }
    471            else
    472            {
    473              Csw.bCSWStatus = CswPassed;
   \                     ??BotSendStatus_2:
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x7301             STRB     R1,[R0, #+12]
    474            }
    475            BotStatus.BotStatus = TRUE;
   \                     ??BotSendStatus_1:
   \   00000048   0x....             LDR.N    R0,??DataTable20_5
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000050   0x....             LDR.N    R1,??DataTable20_5
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    476            USB_IO_Data(BulkInEp,
    477                       (pInt8U)&Csw,
    478                        sizeof(Csw_t),
    479                       (void*)BotInEP);
   \   00000054   0x.... 0x....      LDR.W    R3,??DataTable20_16
   \   00000058   0x220D             MOVS     R2,#+13
   \   0000005A   0x....             LDR.N    R1,??DataTable20_7
   \   0000005C   0x2005             MOVS     R0,#+5
   \   0000005E   0x.... 0x....      BL       USB_IO_Data
    480          #if __CORE__ < 7
    481            EXT_CRT_SECTION(Save);
    482          #else
    483            EXT_CRT_SECTION();
   \   00000062   0x.... 0x....      BL       ExtCritSection
    484          #endif // __CORE__ < 7
    485          }
   \   00000066   0xBD01             POP      {R0,PC}          ;; return
    486          
    487          /*************************************************************************
    488           * Function Name: ScsiCommImpl
    489           * Parameters:  none
    490           *
    491           * Return: none
    492           *
    493           * Description: Scsi commands implement
    494           *
    495           *************************************************************************/

   \                                 In section .text, align 4
    496          inline
    497          void ScsiCommImpl (void)
    498          {
   \                     ScsiCommImpl:
   \   00000000   0xB580             PUSH     {R7,LR}
    499            if(ScsiCbwValid())
   \   00000002   0x.... 0x....      BL       ScsiCbwValid
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD058             BEQ.N    ??ScsiCommImpl_0
    500            {
    501              Csw.dCSWDataResidue = Cbw.dCBWDataTransferLength;
   \   0000000A   0x482F             LDR.N    R0,??ScsiCommImpl_1
   \   0000000C   0x492F             LDR.N    R1,??ScsiCommImpl_1+0x4
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0x6081             STR      R1,[R0, #+8]
    502              Csw.dCSWTag = Cbw.dCBWTag;
   \   00000012   0x482D             LDR.N    R0,??ScsiCommImpl_1
   \   00000014   0x492D             LDR.N    R1,??ScsiCommImpl_1+0x4
   \   00000016   0x6849             LDR      R1,[R1, #+4]
   \   00000018   0x6041             STR      R1,[R0, #+4]
    503              Lun = Cbw.bCBWLUN;
   \   0000001A   0x482C             LDR.N    R0,??ScsiCommImpl_1+0x4
   \   0000001C   0x7B40             LDRB     R0,[R0, #+13]
   \   0000001E   0x492C             LDR.N    R1,??ScsiCommImpl_1+0x8
   \   00000020   0x6008             STR      R0,[R1, #+0]
    504              switch (Cbw.CBWCB[0])
   \   00000022   0x482A             LDR.N    R0,??ScsiCommImpl_1+0x4
   \   00000024   0x7BC0             LDRB     R0,[R0, #+15]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD016             BEQ.N    ??ScsiCommImpl_2
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD017             BEQ.N    ??ScsiCommImpl_3
   \   0000002E   0x2812             CMP      R0,#+18
   \   00000030   0xD018             BEQ.N    ??ScsiCommImpl_4
   \   00000032   0x2815             CMP      R0,#+21
   \   00000034   0xD019             BEQ.N    ??ScsiCommImpl_5
   \   00000036   0x281A             CMP      R0,#+26
   \   00000038   0xD01A             BEQ.N    ??ScsiCommImpl_6
   \   0000003A   0x281B             CMP      R0,#+27
   \   0000003C   0xD01B             BEQ.N    ??ScsiCommImpl_7
   \   0000003E   0x281E             CMP      R0,#+30
   \   00000040   0xD01C             BEQ.N    ??ScsiCommImpl_8
   \   00000042   0x2823             CMP      R0,#+35
   \   00000044   0xD01D             BEQ.N    ??ScsiCommImpl_9
   \   00000046   0x2825             CMP      R0,#+37
   \   00000048   0xD01E             BEQ.N    ??ScsiCommImpl_10
   \   0000004A   0x2828             CMP      R0,#+40
   \   0000004C   0xD01F             BEQ.N    ??ScsiCommImpl_11
   \   0000004E   0x282A             CMP      R0,#+42
   \   00000050   0xD020             BEQ.N    ??ScsiCommImpl_12
   \   00000052   0x282F             CMP      R0,#+47
   \   00000054   0xD021             BEQ.N    ??ScsiCommImpl_13
   \   00000056   0xE023             B.N      ??ScsiCommImpl_14
    505              {
    506              case ScsiTestUnitReady:
    507                ScsiTestUnitReadyImp();
   \                     ??ScsiCommImpl_2:
   \   00000058   0x.... 0x....      BL       ScsiTestUnitReadyImp
    508                return;
   \   0000005C   0xE032             B.N      ??ScsiCommImpl_15
    509              case ScsiRequestSense:
    510                ScsiRequestSenseImp();
   \                     ??ScsiCommImpl_3:
   \   0000005E   0x.... 0x....      BL       ScsiRequestSenseImp
    511                return;
   \   00000062   0xE02F             B.N      ??ScsiCommImpl_15
    512              case ScsiInquiry:
    513                ScsiInquiryImp();
   \                     ??ScsiCommImpl_4:
   \   00000064   0x.... 0x....      BL       ScsiInquiryImp
    514                return;
   \   00000068   0xE02C             B.N      ??ScsiCommImpl_15
    515              case ScsiModeSelect6:
    516                ScsiModeSelect6Imp();
   \                     ??ScsiCommImpl_5:
   \   0000006A   0x.... 0x....      BL       ScsiModeSelect6Imp
    517                return;
   \   0000006E   0xE029             B.N      ??ScsiCommImpl_15
    518              case ScsiModeSense6:
    519                ScsiModeSense6Imp();
   \                     ??ScsiCommImpl_6:
   \   00000070   0x.... 0x....      BL       ScsiModeSense6Imp
    520                return;
   \   00000074   0xE026             B.N      ??ScsiCommImpl_15
    521              case ScsiMediaStartStop:
    522                ScsiMediaStartStopImp();
   \                     ??ScsiCommImpl_7:
   \   00000076   0x.... 0x....      BL       ScsiMediaStartStopImp
    523                return;
   \   0000007A   0xE023             B.N      ??ScsiCommImpl_15
    524              case ScsiMediaRemoval:
    525                ScsiMediaRemovalImp();
   \                     ??ScsiCommImpl_8:
   \   0000007C   0x.... 0x....      BL       ScsiMediaRemovalImp
    526                return;
   \   00000080   0xE020             B.N      ??ScsiCommImpl_15
    527              case ScsiReadFormatCapcity:
    528                ScsiReadFormatCapcityImp();
   \                     ??ScsiCommImpl_9:
   \   00000082   0x.... 0x....      BL       ScsiReadFormatCapcityImp
    529                return;
   \   00000086   0xE01D             B.N      ??ScsiCommImpl_15
    530              case ScsiReadCapacity10:
    531                ScsiReadCapacity10Imp();
   \                     ??ScsiCommImpl_10:
   \   00000088   0x.... 0x....      BL       ScsiReadCapacity10Imp
    532                return;
   \   0000008C   0xE01A             B.N      ??ScsiCommImpl_15
    533              case ScsiRead10:
    534                ScsiRead10Imp();
   \                     ??ScsiCommImpl_11:
   \   0000008E   0x.... 0x....      BL       ScsiRead10Imp
    535                return;
   \   00000092   0xE017             B.N      ??ScsiCommImpl_15
    536              case ScsiWrite10:
    537                ScsiWrite10Imp();
   \                     ??ScsiCommImpl_12:
   \   00000094   0x.... 0x....      BL       ScsiWrite10Imp
    538                return;
   \   00000098   0xE014             B.N      ??ScsiCommImpl_15
    539              case ScsiFerify10:
    540                ScsiVerify10Imp();
   \                     ??ScsiCommImpl_13:
   \   0000009A   0x.... 0x....      BL       ScsiVerify10Imp
    541                return;
   \   0000009E   0xE011             B.N      ??ScsiCommImpl_15
    542              default:
    543                ScsiCmdError(ScsiUnknowCommand,
    544                 (Cbw.bmCBWFlags.Dir == BotDataFormDevToHost)?ScsiStallIn:ScsiStallOut);
   \                     ??ScsiCommImpl_14:
   \   000000A0   0x480A             LDR.N    R0,??ScsiCommImpl_1+0x4
   \   000000A2   0x7B00             LDRB     R0,[R0, #+12]
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0x09C0             LSRS     R0,R0,#+7
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD001             BEQ.N    ??ScsiCommImpl_16
   \   000000AE   0x2101             MOVS     R1,#+1
   \   000000B0   0xE000             B.N      ??ScsiCommImpl_17
   \                     ??ScsiCommImpl_16:
   \   000000B2   0x2102             MOVS     R1,#+2
   \                     ??ScsiCommImpl_17:
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0x.... 0x....      BL       ScsiCmdError
    545              }
    546              return;
   \   000000BA   0xE003             B.N      ??ScsiCommImpl_15
    547            }
    548            // CBW Not valid or not meaningful
    549            BotInEpStall();
   \                     ??ScsiCommImpl_0:
   \   000000BC   0x.... 0x....      BL       BotInEpStall
    550            BotOutEpStall();
   \   000000C0   0x.... 0x....      BL       BotOutEpStall
    551          }
   \                     ??ScsiCommImpl_15:
   \   000000C4   0xBD01             POP      {R0,PC}          ;; return
   \   000000C6   0xBF00             Nop      
   \                     ??ScsiCommImpl_1:
   \   000000C8   0x........         DC32     Csw
   \   000000CC   0x........         DC32     Cbw
   \   000000D0   0x........         DC32     Lun
    552          
    553          /*************************************************************************
    554           * Function Name: ScsiCbwValid
    555           * Parameters:  none
    556           *
    557           * Return: Boolean
    558           *
    559           * Description: CBW valid and meaningful check
    560           *
    561           *************************************************************************/

   \                                 In section .text, align 4
    562          inline
    563          Boolean ScsiCbwValid(void)
    564          {
   \                     ScsiCbwValid:
   \   00000000   0xB081             SUB      SP,SP,#+4
    565          ScsiCmdField_t ScsiCmdField;
    566            if ((Cbw.dCBWSignature != CbwSignature) ||
    567                (Cbw.bCBWLUN >= SCSI_LUN_NUMB) ||
    568                BotStatus.BotStatus)
   \   00000002   0x4822             LDR.N    R0,??ScsiCbwValid_0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4922             LDR.N    R1,??ScsiCbwValid_0+0x4  ;; 0x43425355
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD10A             BNE.N    ??ScsiCbwValid_1
   \   0000000C   0x481F             LDR.N    R0,??ScsiCbwValid_0
   \   0000000E   0x7B40             LDRB     R0,[R0, #+13]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD106             BNE.N    ??ScsiCbwValid_1
   \   00000014   0x481F             LDR.N    R0,??ScsiCbwValid_0+0x8
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??ScsiCbwValid_2
    569            {
    570              return(FALSE);
   \                     ??ScsiCbwValid_1:
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE030             B.N      ??ScsiCbwValid_3
    571            }
    572            ScsiCmdField.Cmd = Cbw.CBWCB[0];
   \                     ??ScsiCbwValid_2:
   \   00000026   0x4819             LDR.N    R0,??ScsiCbwValid_0
   \   00000028   0x7BC0             LDRB     R0,[R0, #+15]
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    573            switch (ScsiCmdField.GroupCode)
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x0940             LSRS     R0,R0,#+5
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD008             BEQ.N    ??ScsiCbwValid_4
   \   0000003A   0x2802             CMP      R0,#+2
   \   0000003C   0xD00D             BEQ.N    ??ScsiCbwValid_5
   \   0000003E   0xD30C             BCC.N    ??ScsiCbwValid_5
   \   00000040   0x2804             CMP      R0,#+4
   \   00000042   0xD013             BEQ.N    ??ScsiCbwValid_6
   \   00000044   0xD310             BCC.N    ??ScsiCbwValid_7
   \   00000046   0x2805             CMP      R0,#+5
   \   00000048   0xD017             BEQ.N    ??ScsiCbwValid_8
   \   0000004A   0xE01C             B.N      ??ScsiCbwValid_9
    574            {
    575            case 0:
    576              if(Cbw.bCBWCBLength >= 6)
   \                     ??ScsiCbwValid_4:
   \   0000004C   0x480F             LDR.N    R0,??ScsiCbwValid_0
   \   0000004E   0x7B80             LDRB     R0,[R0, #+14]
   \   00000050   0x2806             CMP      R0,#+6
   \   00000052   0xDB01             BLT.N    ??ScsiCbwValid_10
    577                return(TRUE);
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xE017             B.N      ??ScsiCbwValid_3
    578              break;
   \                     ??ScsiCbwValid_10:
   \   00000058   0xE015             B.N      ??ScsiCbwValid_9
    579            case 1:
    580            case 2:
    581              if(Cbw.bCBWCBLength >= 10)
   \                     ??ScsiCbwValid_5:
   \   0000005A   0x480C             LDR.N    R0,??ScsiCbwValid_0
   \   0000005C   0x7B80             LDRB     R0,[R0, #+14]
   \   0000005E   0x280A             CMP      R0,#+10
   \   00000060   0xDB01             BLT.N    ??ScsiCbwValid_11
    582                return(TRUE);
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xE010             B.N      ??ScsiCbwValid_3
    583              break;
   \                     ??ScsiCbwValid_11:
   \   00000066   0xE00E             B.N      ??ScsiCbwValid_9
    584            case 3:
    585              return(TRUE);
   \                     ??ScsiCbwValid_7:
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xE00D             B.N      ??ScsiCbwValid_3
    586            case 4:
    587              if(Cbw.bCBWCBLength >= 16)
   \                     ??ScsiCbwValid_6:
   \   0000006C   0x4807             LDR.N    R0,??ScsiCbwValid_0
   \   0000006E   0x7B80             LDRB     R0,[R0, #+14]
   \   00000070   0x2810             CMP      R0,#+16
   \   00000072   0xDB01             BLT.N    ??ScsiCbwValid_12
    588                return(TRUE);
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE007             B.N      ??ScsiCbwValid_3
    589              break;
   \                     ??ScsiCbwValid_12:
   \   00000078   0xE005             B.N      ??ScsiCbwValid_9
    590            case 5:
    591              if(Cbw.bCBWCBLength >= 12)
   \                     ??ScsiCbwValid_8:
   \   0000007A   0x4804             LDR.N    R0,??ScsiCbwValid_0
   \   0000007C   0x7B80             LDRB     R0,[R0, #+14]
   \   0000007E   0x280C             CMP      R0,#+12
   \   00000080   0xDB01             BLT.N    ??ScsiCbwValid_9
    592                return(TRUE);
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xE000             B.N      ??ScsiCbwValid_3
    593            }
    594            return(FALSE);
   \                     ??ScsiCbwValid_9:
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??ScsiCbwValid_3:
   \   00000088   0xB001             ADD      SP,SP,#+4
   \   0000008A   0x4770             BX       LR               ;; return
   \                     ??ScsiCbwValid_0:
   \   0000008C   0x........         DC32     Cbw
   \   00000090   0x43425355         DC32     0x43425355
   \   00000094   0x........         DC32     BotStatus
    595          }
    596          
    597          /*************************************************************************
    598           * Function Name: ScsiTestUnitReadyImp
    599           * Parameters: none
    600           *
    601           * Return: none
    602           *
    603           * Description: TEST UNIT READY command implement
    604           *
    605           *************************************************************************/

   \                                 In section .text, align 4
    606          inline
    607          void ScsiTestUnitReadyImp (void)
    608          {
   \                     ScsiTestUnitReadyImp:
   \   00000000   0xB580             PUSH     {R7,LR}
    609            if(Cbw.dCBWDataTransferLength == 0)
   \   00000002   0x480D             LDR.N    R0,??ScsiTestUnitReadyImp_0
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD110             BNE.N    ??ScsiTestUnitReadyImp_1
    610            {
    611              ScsiDrv[Lun].Message[0] = LunTestUntilReadyReqMsg;
   \   0000000A   0x480C             LDR.N    R0,??ScsiTestUnitReadyImp_0+0x4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0100             LSLS     R0,R0,#+4
   \   00000010   0x490B             LDR.N    R1,??ScsiTestUnitReadyImp_0+0x8
   \   00000012   0x2203             MOVS     R2,#+3
   \   00000014   0x5042             STR      R2,[R0, R1]
    612              pScsiMessage[Lun] = ScsiDrv[Lun].Message;
   \   00000016   0x4809             LDR.N    R0,??ScsiTestUnitReadyImp_0+0x4
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x490A             LDR.N    R1,??ScsiTestUnitReadyImp_0+0xC
   \   0000001C   0x4A07             LDR.N    R2,??ScsiTestUnitReadyImp_0+0x4
   \   0000001E   0x6812             LDR      R2,[R2, #+0]
   \   00000020   0x4B07             LDR.N    R3,??ScsiTestUnitReadyImp_0+0x8
   \   00000022   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   00000026   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \   0000002A   0xE003             B.N      ??ScsiTestUnitReadyImp_2
    613            }
    614            else
    615            {
    616              ScsiCmdError(ScsiFatalError,0);
   \                     ??ScsiTestUnitReadyImp_1:
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x2007             MOVS     R0,#+7
   \   00000030   0x.... 0x....      BL       ScsiCmdError
    617            }
    618          }
   \                     ??ScsiTestUnitReadyImp_2:
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
   \   00000036   0xBF00             Nop      
   \                     ??ScsiTestUnitReadyImp_0:
   \   00000038   0x........         DC32     Cbw
   \   0000003C   0x........         DC32     Lun
   \   00000040   0x........         DC32     ScsiDrv
   \   00000044   0x........         DC32     pScsiMessage
    619          
    620          /*************************************************************************
    621           * Function Name: ScsiTestUntilReadyData
    622           * Parameters:  Int32U MediaReady
    623           *
    624           * Return: void
    625           *
    626           * Description: Prepare Test until ready data for sending
    627           *
    628           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    629          void ScsiTestUntilReadyData (Int32U MediaReady)
    630          {
   \                     ScsiTestUntilReadyData:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    631          
    632            if(ScsiDrv[Lun].UnitSSStatus == UnitEjected)
   \   00000004   0x....             LDR.N    R0,??DataTable20_4
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable20
   \   0000000A   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   0000000E   0x7B40             LDRB     R0,[R0, #+13]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD111             BNE.N    ??ScsiTestUntilReadyData_0
    633            {
    634              if(MediaReady != ScsiMediaChanged)
   \   00000014   0x2C05             CMP      R4,#+5
   \   00000016   0xD003             BEQ.N    ??ScsiTestUntilReadyData_1
    635              {
    636                ScsiCmdStatus(ScsiMediaNotPresent);
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x.... 0x....      BL       ScsiCmdStatus
   \   0000001E   0xE01E             B.N      ??ScsiTestUntilReadyData_2
    637              }
    638              else
    639              {
    640                ScsiDrv[Lun].UnitSSStatus = UnitStarted;
   \                     ??ScsiTestUntilReadyData_1:
   \   00000020   0x....             LDR.N    R0,??DataTable20_4
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x....             LDR.N    R1,??DataTable20
   \   00000026   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x7341             STRB     R1,[R0, #+13]
    641                ScsiCmdStatus((ScsiStatusCode_t)MediaReady);
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       ScsiCmdStatus
   \   00000036   0xE012             B.N      ??ScsiTestUntilReadyData_2
    642              }
    643            }
    644            else
    645            {
    646              if (   (ScsiMediaChanged == MediaReady)
    647                  || (ScsiCommandNoKey == MediaReady)
    648                 )
   \                     ??ScsiTestUntilReadyData_0:
   \   00000038   0x2C05             CMP      R4,#+5
   \   0000003A   0xD001             BEQ.N    ??ScsiTestUntilReadyData_3
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD104             BNE.N    ??ScsiTestUntilReadyData_4
    649              {
    650                ScsiCmdStatus((ScsiStatusCode_t)MediaReady);
   \                     ??ScsiTestUntilReadyData_3:
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x.... 0x....      BL       ScsiCmdStatus
   \   00000048   0xE009             B.N      ??ScsiTestUntilReadyData_2
    651              }
    652              else
    653              {
    654                ScsiCmdStatus(ScsiMediaNotPresent);
   \                     ??ScsiTestUntilReadyData_4:
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0x.... 0x....      BL       ScsiCmdStatus
    655                ScsiDrv[Lun].UnitSSStatus = UnitEjected;
   \   00000050   0x....             LDR.N    R0,??DataTable20_4
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x....             LDR.N    R1,??DataTable20
   \   00000056   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x7341             STRB     R1,[R0, #+13]
    656              }
    657            }
    658            BotSendStatus();
   \                     ??ScsiTestUntilReadyData_2:
   \   0000005E   0x.... 0x....      BL       BotSendStatus
    659          }
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    660          
    661          /*************************************************************************
    662           * Function Name: ScsiRequestSenseImp
    663           * Parameters:  none
    664           *
    665           * Return: Boolean
    666           *
    667           * Description: REQUEST SENSE command implement
    668           *
    669           *************************************************************************/

   \                                 In section .text, align 4
    670          inline
    671          void ScsiRequestSenseImp (void)
    672          {
   \                     ScsiRequestSenseImp:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    673          pSpc3RequestSense_t pRequestSense = (pSpc3RequestSense_t)Cbw.CBWCB;
   \   00000002   0x4C50             LDR.N    R4,??ScsiRequestSenseImp_0
    674          pSpc3RequestSenseResponse_t pRequestSenseResponse;
    675            if ((Cbw.bmCBWFlags.Dir == BotDataFormDevToHost) &&
    676                (Cbw.dCBWDataTransferLength >= pRequestSense->AllocationLenght))
   \   00000004   0x4850             LDR.N    R0,??ScsiRequestSenseImp_0+0x4
   \   00000006   0x7B00             LDRB     R0,[R0, #+12]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x09C0             LSRS     R0,R0,#+7
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF000 0x808C      BEQ.W    ??ScsiRequestSenseImp_1
   \   00000014   0x484C             LDR.N    R0,??ScsiRequestSenseImp_0+0x4
   \   00000016   0x6880             LDR      R0,[R0, #+8]
   \   00000018   0x7921             LDRB     R1,[R4, #+4]
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xF0C0 0x8086      BCC.W    ??ScsiRequestSenseImp_1
    677            {
    678              pRequestSenseResponse = (pSpc3RequestSenseResponse_t)&Cbw;
   \   00000020   0x4849             LDR.N    R0,??ScsiRequestSenseImp_0+0x4
   \   00000022   0x0005             MOVS     R5,R0
    679              // clear buffer
    680              memset(&Cbw,0,sizeof(Spc3RequestSenseResponse_t));
   \   00000024   0x2212             MOVS     R2,#+18
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x4847             LDR.N    R0,??ScsiRequestSenseImp_0+0x4
   \   0000002A   0x.... 0x....      BL       memset
    681              if ((pRequestSense->Control.Control == 0) && !pRequestSense->DESC)
   \   0000002E   0x7960             LDRB     R0,[R4, #+5]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD177             BNE.N    ??ScsiRequestSenseImp_2
   \   00000034   0x7860             LDRB     R0,[R4, #+1]
   \   00000036   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD172             BNE.N    ??ScsiRequestSenseImp_2
    682              {
    683                pRequestSenseResponse->ResponceCode = 0x70;
   \   0000003E   0x2070             MOVS     R0,#+112
   \   00000040   0x7829             LDRB     R1,[R5, #+0]
   \   00000042   0xF360 0x0106      BFI      R1,R0,#+0,#+7
   \   00000046   0x7029             STRB     R1,[R5, #+0]
    684                pRequestSenseResponse->Valid = TRUE;
   \   00000048   0x7828             LDRB     R0,[R5, #+0]
   \   0000004A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000004E   0x7028             STRB     R0,[R5, #+0]
    685                switch (ScsiDrv[Lun].Status)
   \   00000050   0x483E             LDR.N    R0,??ScsiRequestSenseImp_0+0x8
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x493E             LDR.N    R1,??ScsiRequestSenseImp_0+0xC
   \   00000056   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   0000005A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD009             BEQ.N    ??ScsiRequestSenseImp_3
   \   00000060   0xD344             BCC.N    ??ScsiRequestSenseImp_4
   \   00000062   0x2803             CMP      R0,#+3
   \   00000064   0xD01A             BEQ.N    ??ScsiRequestSenseImp_5
   \   00000066   0xD30F             BCC.N    ??ScsiRequestSenseImp_6
   \   00000068   0x2805             CMP      R0,#+5
   \   0000006A   0xD035             BEQ.N    ??ScsiRequestSenseImp_7
   \   0000006C   0xD320             BCC.N    ??ScsiRequestSenseImp_8
   \   0000006E   0x2806             CMP      R0,#+6
   \   00000070   0xD028             BEQ.N    ??ScsiRequestSenseImp_9
   \   00000072   0xE03B             B.N      ??ScsiRequestSenseImp_4
    686                {
    687                case ScsiMediamNotReady:
    688                  pRequestSenseResponse->Ascq = LogicalUnitNotReadyCauseNotReportable >> 8;
   \                     ??ScsiRequestSenseImp_3:
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x7368             STRB     R0,[R5, #+13]
    689                  pRequestSenseResponse->Asc  = LogicalUnitNotReadyCauseNotReportable;
   \   00000078   0x2004             MOVS     R0,#+4
   \   0000007A   0x7328             STRB     R0,[R5, #+12]
    690                  pRequestSenseResponse->SenseKey  = NotReady;
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0x78A9             LDRB     R1,[R5, #+2]
   \   00000080   0xF360 0x0103      BFI      R1,R0,#+0,#+4
   \   00000084   0x70A9             STRB     R1,[R5, #+2]
    691                  break;
   \   00000086   0xE039             B.N      ??ScsiRequestSenseImp_10
    692                case ScsiInvalidCbd:
    693                  pRequestSenseResponse->Ascq = InvalidFieldInCdb >> 8;
   \                     ??ScsiRequestSenseImp_6:
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x7368             STRB     R0,[R5, #+13]
    694                  pRequestSenseResponse->Asc  = InvalidFieldInCdb;
   \   0000008C   0x2024             MOVS     R0,#+36
   \   0000008E   0x7328             STRB     R0,[R5, #+12]
    695                  pRequestSenseResponse->SenseKey   = IllegalRequest;
   \   00000090   0x2005             MOVS     R0,#+5
   \   00000092   0x78A9             LDRB     R1,[R5, #+2]
   \   00000094   0xF360 0x0103      BFI      R1,R0,#+0,#+4
   \   00000098   0x70A9             STRB     R1,[R5, #+2]
    696                  break;
   \   0000009A   0xE02F             B.N      ??ScsiRequestSenseImp_10
    697                case ScsiUnknowCommand:
    698                  pRequestSenseResponse->Ascq = InvalidCommandOperationCode >> 8;
   \                     ??ScsiRequestSenseImp_5:
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x7368             STRB     R0,[R5, #+13]
    699                  pRequestSenseResponse->Asc  = InvalidCommandOperationCode;
   \   000000A0   0x2020             MOVS     R0,#+32
   \   000000A2   0x7328             STRB     R0,[R5, #+12]
    700                  pRequestSenseResponse->SenseKey   = IllegalRequest;
   \   000000A4   0x2005             MOVS     R0,#+5
   \   000000A6   0x78A9             LDRB     R1,[R5, #+2]
   \   000000A8   0xF360 0x0103      BFI      R1,R0,#+0,#+4
   \   000000AC   0x70A9             STRB     R1,[R5, #+2]
    701                  break;
   \   000000AE   0xE025             B.N      ??ScsiRequestSenseImp_10
    702                case ScsiMediaNotPresent:
    703                  pRequestSenseResponse->Ascq = MediumNotPresent >> 8;
   \                     ??ScsiRequestSenseImp_8:
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x7368             STRB     R0,[R5, #+13]
    704                  pRequestSenseResponse->Asc  = MediumNotPresent;
   \   000000B4   0x203A             MOVS     R0,#+58
   \   000000B6   0x7328             STRB     R0,[R5, #+12]
    705                  pRequestSenseResponse->SenseKey   = NotReady;
   \   000000B8   0x2002             MOVS     R0,#+2
   \   000000BA   0x78A9             LDRB     R1,[R5, #+2]
   \   000000BC   0xF360 0x0103      BFI      R1,R0,#+0,#+4
   \   000000C0   0x70A9             STRB     R1,[R5, #+2]
    706                  break;
   \   000000C2   0xE01B             B.N      ??ScsiRequestSenseImp_10
    707                case ScsiMiscompare:
    708                  pRequestSenseResponse->Ascq = MiscompareDuringVerifyOperation >> 8;
   \                     ??ScsiRequestSenseImp_9:
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x7368             STRB     R0,[R5, #+13]
    709                  pRequestSenseResponse->Asc  = MiscompareDuringVerifyOperation;
   \   000000C8   0x201D             MOVS     R0,#+29
   \   000000CA   0x7328             STRB     R0,[R5, #+12]
    710                  pRequestSenseResponse->SenseKey   = Miscompare;
   \   000000CC   0x200E             MOVS     R0,#+14
   \   000000CE   0x78A9             LDRB     R1,[R5, #+2]
   \   000000D0   0xF360 0x0103      BFI      R1,R0,#+0,#+4
   \   000000D4   0x70A9             STRB     R1,[R5, #+2]
    711                  break;
   \   000000D6   0xE011             B.N      ??ScsiRequestSenseImp_10
    712                case ScsiMediaChanged:
    713                  pRequestSenseResponse->Ascq = NotReadyToReadyChangeMediumMayHaveChanged >> 8;
   \                     ??ScsiRequestSenseImp_7:
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x7368             STRB     R0,[R5, #+13]
    714                  pRequestSenseResponse->Asc  = NotReadyToReadyChangeMediumMayHaveChanged;
   \   000000DC   0x2028             MOVS     R0,#+40
   \   000000DE   0x7328             STRB     R0,[R5, #+12]
    715                  pRequestSenseResponse->SenseKey   = UnitAttention;
   \   000000E0   0x2006             MOVS     R0,#+6
   \   000000E2   0x78A9             LDRB     R1,[R5, #+2]
   \   000000E4   0xF360 0x0103      BFI      R1,R0,#+0,#+4
   \   000000E8   0x70A9             STRB     R1,[R5, #+2]
    716                  break;
   \   000000EA   0xE007             B.N      ??ScsiRequestSenseImp_10
    717                default:
    718                  pRequestSenseResponse->Ascq = NoAdditionalSenseInformation >> 8;
   \                     ??ScsiRequestSenseImp_4:
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x7368             STRB     R0,[R5, #+13]
    719                  pRequestSenseResponse->Asc  = NoAdditionalSenseInformation;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x7328             STRB     R0,[R5, #+12]
    720                  pRequestSenseResponse->SenseKey   = NoSense;
   \   000000F4   0x78A8             LDRB     R0,[R5, #+2]
   \   000000F6   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   000000FA   0x70A8             STRB     R0,[R5, #+2]
    721                  break;
    722                }
    723                pRequestSenseResponse->AddSenseKeyLength = sizeof(Spc3RequestSenseResponse_t) - 8;
   \                     ??ScsiRequestSenseImp_10:
   \   000000FC   0x200A             MOVS     R0,#+10
   \   000000FE   0x71E8             STRB     R0,[R5, #+7]
    724                // Clear condition code info
    725                ScsiDrv[Lun].Status = ScsiCommandNoKey;
   \   00000100   0x4812             LDR.N    R0,??ScsiRequestSenseImp_0+0x8
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0x4912             LDR.N    R1,??ScsiRequestSenseImp_0+0xC
   \   00000106   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   0000010A   0x2100             MOVS     R1,#+0
   \   0000010C   0x7301             STRB     R1,[R0, #+12]
    726                // Send Status after data packet
    727                BotSendDataInit((Int8U *)pRequestSenseResponse,
    728                                MIN(pRequestSense->AllocationLenght,sizeof(Spc3RequestSenseResponse_t)),
    729                                TRUE);
   \   0000010E   0x7920             LDRB     R0,[R4, #+4]
   \   00000110   0x2812             CMP      R0,#+18
   \   00000112   0xD201             BCS.N    ??ScsiRequestSenseImp_11
   \   00000114   0x7921             LDRB     R1,[R4, #+4]
   \   00000116   0xE000             B.N      ??ScsiRequestSenseImp_12
   \                     ??ScsiRequestSenseImp_11:
   \   00000118   0x2112             MOVS     R1,#+18
   \                     ??ScsiRequestSenseImp_12:
   \   0000011A   0x2201             MOVS     R2,#+1
   \   0000011C   0x0028             MOVS     R0,R5
   \   0000011E   0x.... 0x....      BL       BotSendDataInit
    730                return;
   \   00000122   0xE00E             B.N      ??ScsiRequestSenseImp_13
    731              }
    732              else
    733              {
    734                ScsiCmdStatus(ScsiInvalidCbd);
   \                     ??ScsiRequestSenseImp_2:
   \   00000124   0x2002             MOVS     R0,#+2
   \   00000126   0x.... 0x....      BL       ScsiCmdStatus
   \   0000012A   0xE002             B.N      ??ScsiRequestSenseImp_14
    735              }
    736            }
    737            else
    738            {
    739              ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiRequestSenseImp_1:
   \   0000012C   0x2007             MOVS     R0,#+7
   \   0000012E   0x.... 0x....      BL       ScsiCmdStatus
    740            }
    741            BotStatus.BotStatus = TRUE;
   \                     ??ScsiRequestSenseImp_14:
   \   00000132   0x4808             LDR.N    R0,??ScsiRequestSenseImp_0+0x10
   \   00000134   0x7800             LDRB     R0,[R0, #+0]
   \   00000136   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000013A   0x4906             LDR.N    R1,??ScsiRequestSenseImp_0+0x10
   \   0000013C   0x7008             STRB     R0,[R1, #+0]
    742            BotInEpStall();
   \   0000013E   0x.... 0x....      BL       BotInEpStall
    743          }
   \                     ??ScsiRequestSenseImp_13:
   \   00000142   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??ScsiRequestSenseImp_0:
   \   00000144   0x........         DC32     Cbw+0xF
   \   00000148   0x........         DC32     Cbw
   \   0000014C   0x........         DC32     Lun
   \   00000150   0x........         DC32     ScsiDrv
   \   00000154   0x........         DC32     BotStatus
    744          
    745          /*************************************************************************
    746           * Function Name: ScsiModeSelect6Imp
    747           * Parameters:  none
    748           *
    749           * Return: none
    750           *
    751           * Description: MODE SELECT command implement
    752           *
    753           *************************************************************************/

   \                                 In section .text, align 4
    754          inline
    755          void ScsiModeSelect6Imp (void)
    756          {
   \                     ScsiModeSelect6Imp:
   \   00000000   0xB510             PUSH     {R4,LR}
    757          pSpc3ModeSelect6_t pModeSelect = (pSpc3ModeSelect6_t)Cbw.CBWCB;
   \   00000002   0x4C0D             LDR.N    R4,??ScsiModeSelect6Imp_0
    758            if ((Cbw.bmCBWFlags.Dir == BotDataFormHostToDev) &&
    759                (Cbw.dCBWDataTransferLength >= pModeSelect->ParameterListLenght))
   \   00000004   0x480D             LDR.N    R0,??ScsiModeSelect6Imp_0+0x4
   \   00000006   0x7B00             LDRB     R0,[R0, #+12]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x09C0             LSRS     R0,R0,#+7
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD108             BNE.N    ??ScsiModeSelect6Imp_1
   \   00000012   0x480A             LDR.N    R0,??ScsiModeSelect6Imp_0+0x4
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x7961             LDRB     R1,[R4, #+5]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD303             BCC.N    ??ScsiModeSelect6Imp_1
    760            {
    761              ScsiCmdStatus(ScsiInvalidCbd);
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      BL       ScsiCmdStatus
   \   00000022   0xE004             B.N      ??ScsiModeSelect6Imp_2
    762            }
    763            else
    764            {
    765              ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiModeSelect6Imp_1:
   \   00000024   0x2007             MOVS     R0,#+7
   \   00000026   0x.... 0x....      BL       ScsiCmdStatus
    766              BotInEpStall();
   \   0000002A   0x.... 0x....      BL       BotInEpStall
    767            }
    768            BotOutEpStall();
   \                     ??ScsiModeSelect6Imp_2:
   \   0000002E   0x.... 0x....      BL       BotOutEpStall
    769            BotSendStatus();
   \   00000032   0x.... 0x....      BL       BotSendStatus
    770          }
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   \                     ??ScsiModeSelect6Imp_0:
   \   00000038   0x........         DC32     Cbw+0xF
   \   0000003C   0x........         DC32     Cbw
    771          
    772          /*************************************************************************
    773           * Function Name: ScsiModeSense6Imp
    774           * Parameters:  none
    775           *
    776           * Return: none
    777           *
    778           * Description: MODE SENSE command implement
    779           *
    780           *************************************************************************/

   \                                 In section .text, align 4
    781          inline
    782          void ScsiModeSense6Imp (void)
    783          {
   \                     ScsiModeSense6Imp:
   \   00000000   0xB510             PUSH     {R4,LR}
    784          pSpc3ModeSense6_t pModeSense = (pSpc3ModeSense6_t)Cbw.CBWCB;
   \   00000002   0x4C1F             LDR.N    R4,??ScsiModeSense6Imp_0
    785            if ((Cbw.bmCBWFlags.Dir == BotDataFormDevToHost) &&
    786                (Cbw.dCBWDataTransferLength >= pModeSense->AllocationLenght))
   \   00000004   0x481F             LDR.N    R0,??ScsiModeSense6Imp_0+0x4
   \   00000006   0x7B00             LDRB     R0,[R0, #+12]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x09C0             LSRS     R0,R0,#+7
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD029             BEQ.N    ??ScsiModeSense6Imp_1
   \   00000012   0x481C             LDR.N    R0,??ScsiModeSense6Imp_0+0x4
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x7921             LDRB     R1,[R4, #+4]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD324             BCC.N    ??ScsiModeSense6Imp_1
    787            {
    788              if (   ( pModeSense->PC          == 0)
    789                  && ( pModeSense->SubPageCode == 0x00))
   \   0000001C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x0980             LSRS     R0,R0,#+6
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD11A             BNE.N    ??ScsiModeSense6Imp_2
   \   00000028   0x78E0             LDRB     R0,[R4, #+3]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD117             BNE.N    ??ScsiModeSense6Imp_2
    790              {
    791                // Clear condition code info
    792                ScsiDrv[Lun].Status = ScsiCommandNoKey;
   \   0000002E   0x4816             LDR.N    R0,??ScsiModeSense6Imp_0+0x8
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x4916             LDR.N    R1,??ScsiModeSense6Imp_0+0xC
   \   00000034   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x7301             STRB     R1,[R0, #+12]
    793                ScsiDrv[Lun].Message[0] = LunModeSense6ReqMsg;
   \   0000003C   0x4812             LDR.N    R0,??ScsiModeSense6Imp_0+0x8
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x0100             LSLS     R0,R0,#+4
   \   00000042   0x4912             LDR.N    R1,??ScsiModeSense6Imp_0+0xC
   \   00000044   0x2204             MOVS     R2,#+4
   \   00000046   0x5042             STR      R2,[R0, R1]
    794                pScsiMessage[Lun] = ScsiDrv[Lun].Message;
   \   00000048   0x480F             LDR.N    R0,??ScsiModeSense6Imp_0+0x8
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x4910             LDR.N    R1,??ScsiModeSense6Imp_0+0x10
   \   0000004E   0x4A0E             LDR.N    R2,??ScsiModeSense6Imp_0+0x8
   \   00000050   0x6812             LDR      R2,[R2, #+0]
   \   00000052   0x4B0E             LDR.N    R3,??ScsiModeSense6Imp_0+0xC
   \   00000054   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   00000058   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    795                return;
   \   0000005C   0xE00E             B.N      ??ScsiModeSense6Imp_3
    796              }
    797              else
    798              {
    799                ScsiCmdStatus(ScsiInvalidCbd);
   \                     ??ScsiModeSense6Imp_2:
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x.... 0x....      BL       ScsiCmdStatus
   \   00000064   0xE002             B.N      ??ScsiModeSense6Imp_4
    800              }
    801            }
    802            else
    803            {
    804              ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiModeSense6Imp_1:
   \   00000066   0x2007             MOVS     R0,#+7
   \   00000068   0x.... 0x....      BL       ScsiCmdStatus
    805            }
    806            BotStatus.BotStatus = TRUE;
   \                     ??ScsiModeSense6Imp_4:
   \   0000006C   0x4809             LDR.N    R0,??ScsiModeSense6Imp_0+0x14
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000074   0x4907             LDR.N    R1,??ScsiModeSense6Imp_0+0x14
   \   00000076   0x7008             STRB     R0,[R1, #+0]
    807            BotInEpStall();
   \   00000078   0x.... 0x....      BL       BotInEpStall
    808          }
   \                     ??ScsiModeSense6Imp_3:
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
   \   0000007E   0xBF00             Nop      
   \                     ??ScsiModeSense6Imp_0:
   \   00000080   0x........         DC32     Cbw+0xF
   \   00000084   0x........         DC32     Cbw
   \   00000088   0x........         DC32     Lun
   \   0000008C   0x........         DC32     ScsiDrv
   \   00000090   0x........         DC32     pScsiMessage
   \   00000094   0x........         DC32     BotStatus
    809          
    810          /*************************************************************************
    811           * Function Name: ScsiModeSenseData
    812           * Parameters:  Int32U WriteProtect
    813           *
    814           * Return: none
    815           *
    816           * Description: Prepare MODE SENSE data for sending
    817           *
    818           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    819          void ScsiModeSenseData (Int32U WriteProtect)
    820          {
   \                     ScsiModeSenseData:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    821          pSpc3ModeSense6Response_t pModeSense = (pSpc3ModeSense6Response_t)&Cbw;
   \   00000004   0x....             LDR.N    R5,??DataTable20_6
    822            // clear buffer
    823            memset(pModeSense,0,sizeof(Spc3ModeSense6Response_t));
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0x.... 0x....      BL       memset
    824            pModeSense->ModeDataLength = sizeof(Spc3ModeSense6Response_t)-1;
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0x7028             STRB     R0,[R5, #+0]
    825            pModeSense->WP = WriteProtect;
   \   00000014   0x78A8             LDRB     R0,[R5, #+2]
   \   00000016   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000001A   0xEA50 0x10C4      ORRS     R0,R0,R4, LSL #+7
   \   0000001E   0x70A8             STRB     R0,[R5, #+2]
    826            BotSendDataInit((Int8U *)pModeSense,
    827                            MIN(Csw.dCSWDataResidue,sizeof(Spc3ModeSense6Response_t)),
    828                            TRUE);
   \   00000020   0x....             LDR.N    R0,??DataTable20_7
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0x2804             CMP      R0,#+4
   \   00000026   0xD202             BCS.N    ??ScsiModeSenseData_0
   \   00000028   0x....             LDR.N    R0,??DataTable20_7
   \   0000002A   0x6881             LDR      R1,[R0, #+8]
   \   0000002C   0xE000             B.N      ??ScsiModeSenseData_1
   \                     ??ScsiModeSenseData_0:
   \   0000002E   0x2104             MOVS     R1,#+4
   \                     ??ScsiModeSenseData_1:
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       BotSendDataInit
    829          }
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    830          
    831          /*************************************************************************
    832           * Function Name: ScsiInquiryImp
    833           * Parameters:  none
    834           *
    835           * Return: none
    836           *
    837           * Description: INQUIRY command implement
    838           *
    839           *************************************************************************/

   \                                 In section .text, align 4
    840          inline
    841          void ScsiInquiryImp (void)
    842          {
   \                     ScsiInquiryImp:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    843          pSpc3Inquiry_t pInquiry = (pSpc3Inquiry_t)Cbw.CBWCB;
   \   00000002   0x4C1C             LDR.N    R4,??ScsiInquiryImp_0
    844          Int32U AllocationLenght =
    845            ((Int32U)pInquiry->AllocationLenght[0]<<8) + pInquiry->AllocationLenght[1];
   \   00000004   0x78E0             LDRB     R0,[R4, #+3]
   \   00000006   0x7921             LDRB     R1,[R4, #+4]
   \   00000008   0xEB11 0x2500      ADDS     R5,R1,R0, LSL #+8
    846            if ((Cbw.bmCBWFlags.Dir == BotDataFormDevToHost) &&
    847                (Cbw.dCBWDataTransferLength >= AllocationLenght))
   \   0000000C   0x481A             LDR.N    R0,??ScsiInquiryImp_0+0x4
   \   0000000E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x09C0             LSRS     R0,R0,#+7
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD020             BEQ.N    ??ScsiInquiryImp_1
   \   0000001A   0x4817             LDR.N    R0,??ScsiInquiryImp_0+0x4
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x42A8             CMP      R0,R5
   \   00000020   0xD31C             BCC.N    ??ScsiInquiryImp_1
    848            {
    849              if ((!pInquiry->EVPD) && (pInquiry->PageCode == 0))
   \   00000022   0x7860             LDRB     R0,[R4, #+1]
   \   00000024   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD113             BNE.N    ??ScsiInquiryImp_2
   \   0000002C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD110             BNE.N    ??ScsiInquiryImp_2
    850              {
    851                ScsiDrv[Lun].Message[0] = LunInquiryReqMsg;
   \   00000032   0x4812             LDR.N    R0,??ScsiInquiryImp_0+0x8
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x0100             LSLS     R0,R0,#+4
   \   00000038   0x4911             LDR.N    R1,??ScsiInquiryImp_0+0xC
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0x5042             STR      R2,[R0, R1]
    852                pScsiMessage[Lun] = ScsiDrv[Lun].Message;
   \   0000003E   0x480F             LDR.N    R0,??ScsiInquiryImp_0+0x8
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4910             LDR.N    R1,??ScsiInquiryImp_0+0x10
   \   00000044   0x4A0D             LDR.N    R2,??ScsiInquiryImp_0+0x8
   \   00000046   0x6812             LDR      R2,[R2, #+0]
   \   00000048   0x4B0D             LDR.N    R3,??ScsiInquiryImp_0+0xC
   \   0000004A   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   0000004E   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    853                return;
   \   00000052   0xE00E             B.N      ??ScsiInquiryImp_3
    854              }
    855              else
    856              {
    857                ScsiCmdStatus(ScsiInvalidCbd);
   \                     ??ScsiInquiryImp_2:
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x.... 0x....      BL       ScsiCmdStatus
   \   0000005A   0xE002             B.N      ??ScsiInquiryImp_4
    858              }
    859            }
    860            else
    861            {
    862             ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiInquiryImp_1:
   \   0000005C   0x2007             MOVS     R0,#+7
   \   0000005E   0x.... 0x....      BL       ScsiCmdStatus
    863            }
    864            BotStatus.BotStatus = TRUE;
   \                     ??ScsiInquiryImp_4:
   \   00000062   0x4809             LDR.N    R0,??ScsiInquiryImp_0+0x14
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000006A   0x4907             LDR.N    R1,??ScsiInquiryImp_0+0x14
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
    865            BotInEpStall();
   \   0000006E   0x.... 0x....      BL       BotInEpStall
    866          }
   \                     ??ScsiInquiryImp_3:
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??ScsiInquiryImp_0:
   \   00000074   0x........         DC32     Cbw+0xF
   \   00000078   0x........         DC32     Cbw
   \   0000007C   0x........         DC32     Lun
   \   00000080   0x........         DC32     ScsiDrv
   \   00000084   0x........         DC32     pScsiMessage
   \   00000088   0x........         DC32     BotStatus
    867          
    868          /*************************************************************************
    869           * Function Name: ScsiInquiryData
    870           * Parameters: const pInt8U pData, Int32U Size
    871           *
    872           * Return: none
    873           *
    874           * Description: Prepare INQUIRY data for sending
    875           *
    876           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    877          void ScsiInquiryData (const pInt8U pData, Int32U Size)
    878          {
   \                     ScsiInquiryData:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    879            BotSendDataInit(pData,MIN(Csw.dCSWDataResidue,Size),TRUE);
   \   00000006   0x....             LDR.N    R0,??DataTable20_7
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x42A8             CMP      R0,R5
   \   0000000C   0xD202             BCS.N    ??ScsiInquiryData_0
   \   0000000E   0x....             LDR.N    R0,??DataTable20_7
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0xE000             B.N      ??ScsiInquiryData_1
   \                     ??ScsiInquiryData_0:
   \   00000014   0x0029             MOVS     R1,R5
   \                     ??ScsiInquiryData_1:
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       BotSendDataInit
    880          }
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    881          
    882          /*************************************************************************
    883           * Function Name: ScsiMediaRemovalImp
    884           * Parameters:  none
    885           *
    886           * Return: none
    887           *
    888           * Description: PREVENT ALLOW MEDIUM REMOVAL command implement
    889           *
    890           *************************************************************************/

   \                                 In section .text, align 4
    891          inline
    892          void ScsiMediaRemovalImp(void)
    893          {
   \                     ScsiMediaRemovalImp:
   \   00000000   0xB510             PUSH     {R4,LR}
    894          pSpc3MediaRemoval_t pMediaRemoval = (pSpc3MediaRemoval_t)Cbw.CBWCB;
   \   00000002   0x4C10             LDR.N    R4,??ScsiMediaRemovalImp_0
    895            if (Cbw.dCBWDataTransferLength == 0)
   \   00000004   0x4810             LDR.N    R0,??ScsiMediaRemovalImp_0+0x4
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD115             BNE.N    ??ScsiMediaRemovalImp_1
    896            {
    897              if ((pMediaRemoval->Prevent == 0) || (pMediaRemoval->Prevent == 1))
   \   0000000C   0x7920             LDRB     R0,[R4, #+4]
   \   0000000E   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??ScsiMediaRemovalImp_2
   \   00000016   0x7920             LDRB     R0,[R4, #+4]
   \   00000018   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD105             BNE.N    ??ScsiMediaRemovalImp_3
    898              {
    899                // Clear condition code info
    900                ScsiCmdStatus(ScsiCommandNoKey);
   \                     ??ScsiMediaRemovalImp_2:
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       ScsiCmdStatus
    901                BotSendStatus();
   \   00000026   0x.... 0x....      BL       BotSendStatus
   \   0000002A   0xE004             B.N      ??ScsiMediaRemovalImp_4
    902              }
    903              else
    904              {
    905                ScsiCmdStatus(ScsiInvalidCbd);
   \                     ??ScsiMediaRemovalImp_3:
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x.... 0x....      BL       ScsiCmdStatus
    906                BotSendStatus();
   \   00000032   0x.... 0x....      BL       BotSendStatus
    907              }
    908              return;
   \                     ??ScsiMediaRemovalImp_4:
   \   00000036   0xE004             B.N      ??ScsiMediaRemovalImp_5
    909            }
    910            else
    911            {
    912              ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiMediaRemovalImp_1:
   \   00000038   0x2007             MOVS     R0,#+7
   \   0000003A   0x.... 0x....      BL       ScsiCmdStatus
    913            }
    914            UsbBotRstInterface();
   \   0000003E   0x.... 0x....      BL       UsbBotRstInterface
    915          }
   \                     ??ScsiMediaRemovalImp_5:
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   \                     ??ScsiMediaRemovalImp_0:
   \   00000044   0x........         DC32     Cbw+0xF
   \   00000048   0x........         DC32     Cbw
    916          
    917          /*************************************************************************
    918           * Function Name: ScsiReadCapacity10Imp
    919           * Parameters:  none
    920           *
    921           * Return: none
    922           *
    923           * Description: READ CAPACITY (10) command implement
    924           *
    925           *************************************************************************/

   \                                 In section .text, align 4
    926          inline
    927          void ScsiReadCapacity10Imp (void)
    928          {
   \                     ScsiReadCapacity10Imp:
   \   00000000   0xB580             PUSH     {R7,LR}
    929            if ((Cbw.bmCBWFlags.Dir == BotDataFormDevToHost) &&
    930                (Cbw.dCBWDataTransferLength >= sizeof(Sbc2ReadCapacity10Response_t)))
   \   00000002   0x4817             LDR.N    R0,??ScsiReadCapacity10Imp_0
   \   00000004   0x7B00             LDRB     R0,[R0, #+12]
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x09C0             LSRS     R0,R0,#+7
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD01B             BEQ.N    ??ScsiReadCapacity10Imp_1
   \   00000010   0x4813             LDR.N    R0,??ScsiReadCapacity10Imp_0
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x2808             CMP      R0,#+8
   \   00000016   0xD317             BCC.N    ??ScsiReadCapacity10Imp_1
    931            {
    932              ScsiDrv[Lun].Message[0] = LunReadCapacity10ReqMsg;
   \   00000018   0x4812             LDR.N    R0,??ScsiReadCapacity10Imp_0+0x4
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x0100             LSLS     R0,R0,#+4
   \   0000001E   0x4912             LDR.N    R1,??ScsiReadCapacity10Imp_0+0x8
   \   00000020   0x2205             MOVS     R2,#+5
   \   00000022   0x5042             STR      R2,[R0, R1]
    933              pScsiMessage[Lun] = ScsiDrv[Lun].Message;
   \   00000024   0x480F             LDR.N    R0,??ScsiReadCapacity10Imp_0+0x4
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4910             LDR.N    R1,??ScsiReadCapacity10Imp_0+0xC
   \   0000002A   0x4A0E             LDR.N    R2,??ScsiReadCapacity10Imp_0+0x4
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x4B0E             LDR.N    R3,??ScsiReadCapacity10Imp_0+0x8
   \   00000030   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   00000034   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    934              // Clear condition code info
    935              ScsiDrv[Lun].Status = ScsiCommandNoKey;
   \   00000038   0x480A             LDR.N    R0,??ScsiReadCapacity10Imp_0+0x4
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x490A             LDR.N    R1,??ScsiReadCapacity10Imp_0+0x8
   \   0000003E   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x7301             STRB     R1,[R0, #+12]
    936              return;
   \   00000046   0xE00A             B.N      ??ScsiReadCapacity10Imp_2
    937            }
    938            else
    939            {
    940              ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiReadCapacity10Imp_1:
   \   00000048   0x2007             MOVS     R0,#+7
   \   0000004A   0x.... 0x....      BL       ScsiCmdStatus
    941            }
    942            BotStatus.BotStatus = TRUE;
   \   0000004E   0x4808             LDR.N    R0,??ScsiReadCapacity10Imp_0+0x10
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000056   0x4906             LDR.N    R1,??ScsiReadCapacity10Imp_0+0x10
   \   00000058   0x7008             STRB     R0,[R1, #+0]
    943            BotInEpStall();
   \   0000005A   0x.... 0x....      BL       BotInEpStall
    944          }
   \                     ??ScsiReadCapacity10Imp_2:
   \   0000005E   0xBD01             POP      {R0,PC}          ;; return
   \                     ??ScsiReadCapacity10Imp_0:
   \   00000060   0x........         DC32     Cbw
   \   00000064   0x........         DC32     Lun
   \   00000068   0x........         DC32     ScsiDrv
   \   0000006C   0x........         DC32     pScsiMessage
   \   00000070   0x........         DC32     BotStatus
    945          
    946          /*************************************************************************
    947           * Function Name: ScsiReadCapacityData
    948           * Parameters:  Int32U LogBlockAdd, Int32U BlockSize
    949           *
    950           * Return: none
    951           *
    952           * Description: Prepare Read capacity data for sending
    953           *
    954           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    955          void ScsiReadCapacityData (Int32U LogBlockAdd, Int32U BlockSize)
    956          {
   \                     ScsiReadCapacityData:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    957          pSbc2ReadCapacity10Response_t pReadCapacity = (pSbc2ReadCapacity10Response_t)&Cbw;
   \   00000006   0x....             LDR.N    R6,??DataTable20_6
    958          
    959            // clear buffer
    960            memset(pReadCapacity,0,sizeof(Sbc2ReadCapacity10Response_t));
   \   00000008   0x2208             MOVS     R2,#+8
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0x.... 0x....      BL       memset
    961          
    962            pReadCapacity->LogicalBlockAddress[0] = (LogBlockAdd >> 24) & 0xFF;
   \   00000012   0x0E20             LSRS     R0,R4,#+24
   \   00000014   0x7030             STRB     R0,[R6, #+0]
    963            pReadCapacity->LogicalBlockAddress[1] = (LogBlockAdd >> 16) & 0xFF;
   \   00000016   0x0C20             LSRS     R0,R4,#+16
   \   00000018   0x7070             STRB     R0,[R6, #+1]
    964            pReadCapacity->LogicalBlockAddress[2] = (LogBlockAdd >> 8 ) & 0xFF;
   \   0000001A   0x0A20             LSRS     R0,R4,#+8
   \   0000001C   0x70B0             STRB     R0,[R6, #+2]
    965            pReadCapacity->LogicalBlockAddress[3] = (LogBlockAdd >> 0 ) & 0xFF;
   \   0000001E   0x70F4             STRB     R4,[R6, #+3]
    966          
    967            pReadCapacity->BlockLength[0]         = (BlockSize   >> 24) & 0xFF;
   \   00000020   0x0E28             LSRS     R0,R5,#+24
   \   00000022   0x7130             STRB     R0,[R6, #+4]
    968            pReadCapacity->BlockLength[1]         = (BlockSize   >> 16) & 0xFF;
   \   00000024   0x0C28             LSRS     R0,R5,#+16
   \   00000026   0x7170             STRB     R0,[R6, #+5]
    969            pReadCapacity->BlockLength[2]         = (BlockSize   >> 8 ) & 0xFF;
   \   00000028   0x0A28             LSRS     R0,R5,#+8
   \   0000002A   0x71B0             STRB     R0,[R6, #+6]
    970            pReadCapacity->BlockLength[3]         = (BlockSize   >> 0 ) & 0xFF;
   \   0000002C   0x71F5             STRB     R5,[R6, #+7]
    971          
    972            BotSendDataInit((Int8U *)pReadCapacity,
    973                            MIN(Csw.dCSWDataResidue,sizeof(Sbc2ReadCapacity10Response_t)),
    974                            TRUE);
   \   0000002E   0x....             LDR.N    R0,??DataTable20_7
   \   00000030   0x6880             LDR      R0,[R0, #+8]
   \   00000032   0x2808             CMP      R0,#+8
   \   00000034   0xD202             BCS.N    ??ScsiReadCapacityData_0
   \   00000036   0x....             LDR.N    R0,??DataTable20_7
   \   00000038   0x6881             LDR      R1,[R0, #+8]
   \   0000003A   0xE000             B.N      ??ScsiReadCapacityData_1
   \                     ??ScsiReadCapacityData_0:
   \   0000003C   0x2108             MOVS     R1,#+8
   \                     ??ScsiReadCapacityData_1:
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0x.... 0x....      BL       BotSendDataInit
    975          }
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    976          
    977          /*************************************************************************
    978           * Function Name: ScsiRead10Imp
    979           * Parameters:  none
    980           *
    981           * Return: none
    982           *
    983           * Description: READ (10) command implement
    984           *
    985           *************************************************************************/

   \                                 In section .text, align 4
    986          inline
    987          void ScsiRead10Imp (void)
    988          {
   \                     ScsiRead10Imp:
   \   00000000   0xB510             PUSH     {R4,LR}
    989          pSbc2Read10_t pRead = (pSbc2Read10_t)Cbw.CBWCB;
   \   00000002   0x4C2E             LDR.N    R4,??ScsiRead10Imp_0
    990            if (Cbw.bmCBWFlags.Dir == BotDataFormDevToHost)
   \   00000004   0x482E             LDR.N    R0,??ScsiRead10Imp_0+0x4
   \   00000006   0x7B00             LDRB     R0,[R0, #+12]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x09C0             LSRS     R0,R0,#+7
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD048             BEQ.N    ??ScsiRead10Imp_1
    991            {
    992              if(ScsiDrv[Lun].UnitSSStatus == UnitEjected)
   \   00000012   0x482C             LDR.N    R0,??ScsiRead10Imp_0+0x8
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x492C             LDR.N    R1,??ScsiRead10Imp_0+0xC
   \   00000018   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   0000001C   0x7B40             LDRB     R0,[R0, #+13]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD103             BNE.N    ??ScsiRead10Imp_2
    993              {
    994                ScsiCmdStatus(ScsiMediaNotPresent);
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0x.... 0x....      BL       ScsiCmdStatus
   \   00000028   0xE03F             B.N      ??ScsiRead10Imp_3
    995              }
    996              else
    997              {
    998                // Clear condition code info
    999                ScsiDrv[Lun].Status = ScsiCommandNoKey;
   \                     ??ScsiRead10Imp_2:
   \   0000002A   0x4826             LDR.N    R0,??ScsiRead10Imp_0+0x8
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x4926             LDR.N    R1,??ScsiRead10Imp_0+0xC
   \   00000030   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x7301             STRB     R1,[R0, #+12]
   1000                ScsiDrv[Lun].Message[2] = ((Int32U)pRead->TransferLength[0] << 8) + pRead->TransferLength[1];
   \   00000038   0x79E0             LDRB     R0,[R4, #+7]
   \   0000003A   0x7A21             LDRB     R1,[R4, #+8]
   \   0000003C   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000040   0x4920             LDR.N    R1,??ScsiRead10Imp_0+0x8
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x4A20             LDR.N    R2,??ScsiRead10Imp_0+0xC
   \   00000046   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   0000004A   0x6088             STR      R0,[R1, #+8]
   1001                if(ScsiDrv[Lun].Message[2] != 0)
   \   0000004C   0x481D             LDR.N    R0,??ScsiRead10Imp_0+0x8
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x491D             LDR.N    R1,??ScsiRead10Imp_0+0xC
   \   00000052   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   00000056   0x6880             LDR      R0,[R0, #+8]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD020             BEQ.N    ??ScsiRead10Imp_4
   1002                {
   1003                  ScsiDrv[Lun].Message[0] = LunRead10ReqMsg;
   \   0000005C   0x4819             LDR.N    R0,??ScsiRead10Imp_0+0x8
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x0100             LSLS     R0,R0,#+4
   \   00000062   0x4919             LDR.N    R1,??ScsiRead10Imp_0+0xC
   \   00000064   0x2206             MOVS     R2,#+6
   \   00000066   0x5042             STR      R2,[R0, R1]
   1004                  ScsiDrv[Lun].Message[1] = ((Int32U)pRead->LogicalBockAddress[0] << 24) +\
   1005                                            ((Int32U)pRead->LogicalBockAddress[1] << 16) +\
   1006                                            ((Int32U)pRead->LogicalBockAddress[2] << 8 ) +\
   1007                                            pRead->LogicalBockAddress[3];
   \   00000068   0x78A0             LDRB     R0,[R4, #+2]
   \   0000006A   0x78E1             LDRB     R1,[R4, #+3]
   \   0000006C   0x0409             LSLS     R1,R1,#+16
   \   0000006E   0xEB11 0x6000      ADDS     R0,R1,R0, LSL #+24
   \   00000072   0x7921             LDRB     R1,[R4, #+4]
   \   00000074   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   00000078   0x7961             LDRB     R1,[R4, #+5]
   \   0000007A   0x1808             ADDS     R0,R1,R0
   \   0000007C   0x4911             LDR.N    R1,??ScsiRead10Imp_0+0x8
   \   0000007E   0x6809             LDR      R1,[R1, #+0]
   \   00000080   0x4A11             LDR.N    R2,??ScsiRead10Imp_0+0xC
   \   00000082   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   00000086   0x6048             STR      R0,[R1, #+4]
   1008                  pScsiMessage[Lun] = ScsiDrv[Lun].Message;
   \   00000088   0x480E             LDR.N    R0,??ScsiRead10Imp_0+0x8
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x490F             LDR.N    R1,??ScsiRead10Imp_0+0x10
   \   0000008E   0x4A0D             LDR.N    R2,??ScsiRead10Imp_0+0x8
   \   00000090   0x6812             LDR      R2,[R2, #+0]
   \   00000092   0x4B0D             LDR.N    R3,??ScsiRead10Imp_0+0xC
   \   00000094   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   00000098   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \   0000009C   0xE001             B.N      ??ScsiRead10Imp_5
   1009                }
   1010                else
   1011                {
   1012                  BotSendStatus();
   \                     ??ScsiRead10Imp_4:
   \   0000009E   0x.... 0x....      BL       BotSendStatus
   1013                }
   1014                return;
   \                     ??ScsiRead10Imp_5:
   \   000000A2   0xE00A             B.N      ??ScsiRead10Imp_6
   1015              }
   1016            }
   1017            else
   1018            {
   1019              ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiRead10Imp_1:
   \   000000A4   0x2007             MOVS     R0,#+7
   \   000000A6   0x.... 0x....      BL       ScsiCmdStatus
   1020            }
   1021            BotStatus.BotStatus = TRUE;
   \                     ??ScsiRead10Imp_3:
   \   000000AA   0x4809             LDR.N    R0,??ScsiRead10Imp_0+0x14
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000B2   0x4907             LDR.N    R1,??ScsiRead10Imp_0+0x14
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
   1022            BotInEpStall();
   \   000000B6   0x.... 0x....      BL       BotInEpStall
   1023          }
   \                     ??ScsiRead10Imp_6:
   \   000000BA   0xBD10             POP      {R4,PC}          ;; return
   \                     ??ScsiRead10Imp_0:
   \   000000BC   0x........         DC32     Cbw+0xF
   \   000000C0   0x........         DC32     Cbw
   \   000000C4   0x........         DC32     Lun
   \   000000C8   0x........         DC32     ScsiDrv
   \   000000CC   0x........         DC32     pScsiMessage
   \   000000D0   0x........         DC32     BotStatus
   1024          
   1025          /*************************************************************************
   1026           * Function Name: ScsiReadData
   1027           * Parameters: const pInt8U pData, Int32U Size, Boolean DataComplete
   1028           *
   1029           * Return: none
   1030           *
   1031           * Description: Prepare Read data for sending
   1032           *
   1033           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1034          void ScsiReadData(const pInt8U pData, Int32U Size, Boolean DataComplete)
   1035          {
   \                     ScsiReadData:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1036            BotSendDataInit(pData,Size,DataComplete);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       BotSendDataInit
   1037          }
   \   00000012   0xBD70             POP      {R4-R6,PC}       ;; return
   1038          
   1039          /*************************************************************************
   1040           * Function Name: ScsiWrite10Imp
   1041           * Parameters:  none
   1042           *
   1043           * Return: none
   1044           *
   1045           * Description: Write (10) command implement
   1046           *
   1047           *************************************************************************/

   \                                 In section .text, align 4
   1048          inline
   1049          void ScsiWrite10Imp (void)
   1050          {
   \                     ScsiWrite10Imp:
   \   00000000   0xB510             PUSH     {R4,LR}
   1051          pSbc2Write10_t pWrite = (pSbc2Write10_t)Cbw.CBWCB;
   \   00000002   0x4C2E             LDR.N    R4,??ScsiWrite10Imp_0
   1052            if (Cbw.bmCBWFlags.Dir == BotDataFormHostToDev)
   \   00000004   0x482E             LDR.N    R0,??ScsiWrite10Imp_0+0x4
   \   00000006   0x7B00             LDRB     R0,[R0, #+12]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x09C0             LSRS     R0,R0,#+7
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD14B             BNE.N    ??ScsiWrite10Imp_1
   1053            {
   1054              if(ScsiDrv[Lun].UnitSSStatus == UnitEjected)
   \   00000012   0x482C             LDR.N    R0,??ScsiWrite10Imp_0+0x8
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x492C             LDR.N    R1,??ScsiWrite10Imp_0+0xC
   \   00000018   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   0000001C   0x7B40             LDRB     R0,[R0, #+13]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD103             BNE.N    ??ScsiWrite10Imp_2
   1055              {
   1056                ScsiCmdStatus(ScsiMediaNotPresent);
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0x.... 0x....      BL       ScsiCmdStatus
   \   00000028   0xE042             B.N      ??ScsiWrite10Imp_3
   1057              }
   1058              else
   1059              {
   1060                // Clear condition code info
   1061                ScsiDrv[Lun].Status = ScsiCommandNoKey;
   \                     ??ScsiWrite10Imp_2:
   \   0000002A   0x4826             LDR.N    R0,??ScsiWrite10Imp_0+0x8
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x4926             LDR.N    R1,??ScsiWrite10Imp_0+0xC
   \   00000030   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x7301             STRB     R1,[R0, #+12]
   1062                ScsiDrv[Lun].Message[2] = ((Int32U)pWrite->TransferLength[0] << 8) + pWrite->TransferLength[1];
   \   00000038   0x79E0             LDRB     R0,[R4, #+7]
   \   0000003A   0x7A21             LDRB     R1,[R4, #+8]
   \   0000003C   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000040   0x4920             LDR.N    R1,??ScsiWrite10Imp_0+0x8
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x4A20             LDR.N    R2,??ScsiWrite10Imp_0+0xC
   \   00000046   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   0000004A   0x6088             STR      R0,[R1, #+8]
   1063                if(ScsiDrv[Lun].Message[2] != 0)
   \   0000004C   0x481D             LDR.N    R0,??ScsiWrite10Imp_0+0x8
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x491D             LDR.N    R1,??ScsiWrite10Imp_0+0xC
   \   00000052   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   00000056   0x6880             LDR      R0,[R0, #+8]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD023             BEQ.N    ??ScsiWrite10Imp_4
   1064                {
   1065                  ScsiDrv[Lun].Message[0] = LunWrite10ReqMsg;
   \   0000005C   0x4819             LDR.N    R0,??ScsiWrite10Imp_0+0x8
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x0100             LSLS     R0,R0,#+4
   \   00000062   0x4919             LDR.N    R1,??ScsiWrite10Imp_0+0xC
   \   00000064   0x2207             MOVS     R2,#+7
   \   00000066   0x5042             STR      R2,[R0, R1]
   1066                  ScsiDrv[Lun].Message[1] = ((Int32U)pWrite->LogicalBockAddress[0] << 24) +\
   1067                                            ((Int32U)pWrite->LogicalBockAddress[1] << 16) +\
   1068                                            ((Int32U)pWrite->LogicalBockAddress[2] << 8 ) +\
   1069                                            pWrite->LogicalBockAddress[3];
   \   00000068   0x78A0             LDRB     R0,[R4, #+2]
   \   0000006A   0x78E1             LDRB     R1,[R4, #+3]
   \   0000006C   0x0409             LSLS     R1,R1,#+16
   \   0000006E   0xEB11 0x6000      ADDS     R0,R1,R0, LSL #+24
   \   00000072   0x7921             LDRB     R1,[R4, #+4]
   \   00000074   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   00000078   0x7961             LDRB     R1,[R4, #+5]
   \   0000007A   0x1808             ADDS     R0,R1,R0
   \   0000007C   0x4911             LDR.N    R1,??ScsiWrite10Imp_0+0x8
   \   0000007E   0x6809             LDR      R1,[R1, #+0]
   \   00000080   0x4A11             LDR.N    R2,??ScsiWrite10Imp_0+0xC
   \   00000082   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   00000086   0x6048             STR      R0,[R1, #+4]
   1070                  pScsiMessage[Lun] = ScsiDrv[Lun].Message;
   \   00000088   0x480E             LDR.N    R0,??ScsiWrite10Imp_0+0x8
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x490F             LDR.N    R1,??ScsiWrite10Imp_0+0x10
   \   0000008E   0x4A0D             LDR.N    R2,??ScsiWrite10Imp_0+0x8
   \   00000090   0x6812             LDR      R2,[R2, #+0]
   \   00000092   0x4B0D             LDR.N    R3,??ScsiWrite10Imp_0+0xC
   \   00000094   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   00000098   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   1071                  BotState = BotEpDataOut;
   \   0000009C   0x480C             LDR.N    R0,??ScsiWrite10Imp_0+0x14
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0x7001             STRB     R1,[R0, #+0]
   1072                  return;
   \   000000A2   0xE009             B.N      ??ScsiWrite10Imp_5
   1073                }
   1074                else
   1075                {
   1076                  BotSendStatus();
   \                     ??ScsiWrite10Imp_4:
   \   000000A4   0x.... 0x....      BL       BotSendStatus
   1077                }
   1078                return;
   \   000000A8   0xE006             B.N      ??ScsiWrite10Imp_5
   1079              }
   1080            }
   1081            else
   1082            {
   1083              ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiWrite10Imp_1:
   \   000000AA   0x2007             MOVS     R0,#+7
   \   000000AC   0x.... 0x....      BL       ScsiCmdStatus
   1084            }
   1085            BotSendStatus();
   \                     ??ScsiWrite10Imp_3:
   \   000000B0   0x.... 0x....      BL       BotSendStatus
   1086            BotOutEpStall();
   \   000000B4   0x.... 0x....      BL       BotOutEpStall
   1087          }
   \                     ??ScsiWrite10Imp_5:
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
   \   000000BA   0xBF00             Nop      
   \                     ??ScsiWrite10Imp_0:
   \   000000BC   0x........         DC32     Cbw+0xF
   \   000000C0   0x........         DC32     Cbw
   \   000000C4   0x........         DC32     Lun
   \   000000C8   0x........         DC32     ScsiDrv
   \   000000CC   0x........         DC32     pScsiMessage
   \   000000D0   0x........         DC32     BotState
   1088          
   1089          /*************************************************************************
   1090           * Function Name: ScsiWriteData
   1091           * Parameters:  pInt8U pData, Int32U Size, Boolean DataComplete
   1092           *
   1093           * Return: none
   1094           *
   1095           * Description: Prepare Write data for receiving
   1096           *
   1097           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1098          void ScsiWriteData(pInt8U pData, Int32U Size, Boolean DataComplete)
   1099          {
   \                     ScsiWriteData:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1100            if(DataComplete)
   \   00000008   0x2E00             CMP      R6,#+0
   \   0000000A   0xD002             BEQ.N    ??ScsiWriteData_0
   1101            {
   1102              BotSendStatus();
   \   0000000C   0x.... 0x....      BL       BotSendStatus
   \   00000010   0xE004             B.N      ??ScsiWriteData_1
   1103            }
   1104            else
   1105            {
   1106              BotReceiveDataInit(pData,Size,DataComplete);
   \                     ??ScsiWriteData_0:
   \   00000012   0x0032             MOVS     R2,R6
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       BotReceiveDataInit
   1107            }
   1108          }
   \                     ??ScsiWriteData_1:
   \   0000001C   0xBD70             POP      {R4-R6,PC}       ;; return
   1109          
   1110          /*************************************************************************
   1111           * Function Name: ScsiVerify10Imp
   1112           * Parameters:  none
   1113           *
   1114           * Return: none
   1115           *
   1116           * Description: Verify (10) command implement
   1117           *
   1118           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1119          void ScsiVerify10Imp (void)
   1120          {
   \                     ScsiVerify10Imp:
   \   00000000   0xB510             PUSH     {R4,LR}
   1121          pSbc2Verify10_t pVerify = (pSbc2Verify10_t)Cbw.CBWCB;
   \   00000002   0x....             LDR.N    R4,??DataTable20_17
   1122            if (Cbw.bmCBWFlags.Dir == BotDataFormHostToDev)
   \   00000004   0x....             LDR.N    R0,??DataTable20_6
   \   00000006   0x7B00             LDRB     R0,[R0, #+12]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x09C0             LSRS     R0,R0,#+7
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD153             BNE.N    ??ScsiVerify10Imp_0
   1123            {
   1124              if(ScsiDrv[Lun].UnitSSStatus == UnitEjected)
   \   00000012   0x....             LDR.N    R0,??DataTable20_4
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x....             LDR.N    R1,??DataTable20
   \   00000018   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   0000001C   0x7B40             LDRB     R0,[R0, #+13]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD103             BNE.N    ??ScsiVerify10Imp_1
   1125              {
   1126                ScsiCmdStatus(ScsiMediaNotPresent);
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0x.... 0x....      BL       ScsiCmdStatus
   \   00000028   0xE04A             B.N      ??ScsiVerify10Imp_2
   1127              }
   1128              else
   1129              {
   1130                // Clear condition code info
   1131                ScsiDrv[Lun].Status = ScsiCommandNoKey;
   \                     ??ScsiVerify10Imp_1:
   \   0000002A   0x....             LDR.N    R0,??DataTable20_4
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x....             LDR.N    R1,??DataTable20
   \   00000030   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x7301             STRB     R1,[R0, #+12]
   1132                ScsiDrv[Lun].Message[2] = ((Int32U)pVerify->TransferLength[0] << 8) + pVerify->TransferLength[1];
   \   00000038   0x79E0             LDRB     R0,[R4, #+7]
   \   0000003A   0x7A21             LDRB     R1,[R4, #+8]
   \   0000003C   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000040   0x....             LDR.N    R1,??DataTable20_4
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x....             LDR.N    R2,??DataTable20
   \   00000046   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   0000004A   0x6088             STR      R0,[R1, #+8]
   1133                if(ScsiDrv[Lun].Message[2] != 0)
   \   0000004C   0x....             LDR.N    R0,??DataTable20_4
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x....             LDR.N    R1,??DataTable20
   \   00000052   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   00000056   0x6880             LDR      R0,[R0, #+8]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD02B             BEQ.N    ??ScsiVerify10Imp_3
   1134                {
   1135                  ScsiDrv[Lun].Message[1] = ((Int32U)pVerify->LogicalBockAddress[0] << 24) +\
   1136                                            ((Int32U)pVerify->LogicalBockAddress[1] << 16) +\
   1137                                            ((Int32U)pVerify->LogicalBockAddress[2] << 8 ) +\
   1138                                            pVerify->LogicalBockAddress[3];
   \   0000005C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000005E   0x78E1             LDRB     R1,[R4, #+3]
   \   00000060   0x0409             LSLS     R1,R1,#+16
   \   00000062   0xEB11 0x6000      ADDS     R0,R1,R0, LSL #+24
   \   00000066   0x7921             LDRB     R1,[R4, #+4]
   \   00000068   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   0000006C   0x7961             LDRB     R1,[R4, #+5]
   \   0000006E   0x1808             ADDS     R0,R1,R0
   \   00000070   0x....             LDR.N    R1,??DataTable20_4
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0x....             LDR.N    R2,??DataTable20
   \   00000076   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   0000007A   0x6048             STR      R0,[R1, #+4]
   1139                  ScsiDrv[Lun].Message[0] = (pVerify->BYTCHK)?LunVerify10BytChkReqMsg:LunVerify10ReqMsg;
   \   0000007C   0x7860             LDRB     R0,[R4, #+1]
   \   0000007E   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD001             BEQ.N    ??ScsiVerify10Imp_4
   \   00000088   0x2009             MOVS     R0,#+9
   \   0000008A   0xE000             B.N      ??ScsiVerify10Imp_5
   \                     ??ScsiVerify10Imp_4:
   \   0000008C   0x2008             MOVS     R0,#+8
   \                     ??ScsiVerify10Imp_5:
   \   0000008E   0x....             LDR.N    R1,??DataTable20_4
   \   00000090   0x6809             LDR      R1,[R1, #+0]
   \   00000092   0x0109             LSLS     R1,R1,#+4
   \   00000094   0x....             LDR.N    R2,??DataTable20
   \   00000096   0x5088             STR      R0,[R1, R2]
   1140                  pScsiMessage[Lun] = ScsiDrv[Lun].Message;
   \   00000098   0x....             LDR.N    R0,??DataTable20_4
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x....             LDR.N    R1,??DataTable20_1
   \   0000009E   0x....             LDR.N    R2,??DataTable20_4
   \   000000A0   0x6812             LDR      R2,[R2, #+0]
   \   000000A2   0x....             LDR.N    R3,??DataTable20
   \   000000A4   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   000000A8   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   1141                  BotState = BotEpDataOut;
   \   000000AC   0x....             LDR.N    R0,??DataTable20_3
   \   000000AE   0x2101             MOVS     R1,#+1
   \   000000B0   0x7001             STRB     R1,[R0, #+0]
   1142                  return;
   \   000000B2   0xE009             B.N      ??ScsiVerify10Imp_6
   1143                }
   1144                else
   1145                {
   1146                  BotSendStatus();
   \                     ??ScsiVerify10Imp_3:
   \   000000B4   0x.... 0x....      BL       BotSendStatus
   1147                }
   1148                return;
   \   000000B8   0xE006             B.N      ??ScsiVerify10Imp_6
   1149              }
   1150            }
   1151            else
   1152            {
   1153              ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiVerify10Imp_0:
   \   000000BA   0x2007             MOVS     R0,#+7
   \   000000BC   0x.... 0x....      BL       ScsiCmdStatus
   1154            }
   1155            BotSendStatus();
   \                     ??ScsiVerify10Imp_2:
   \   000000C0   0x.... 0x....      BL       BotSendStatus
   1156            BotOutEpStall();
   \   000000C4   0x.... 0x....      BL       BotOutEpStall
   1157          }
   \                     ??ScsiVerify10Imp_6:
   \   000000C8   0xBD10             POP      {R4,PC}          ;; return
   1158          
   1159          /*************************************************************************
   1160           * Function Name: ScsiReadFormatCapcityImp
   1161           * Parameters:  none
   1162           *
   1163           * Return: none
   1164           *
   1165           * Description: READ FORMAT CAPACITIES implement
   1166           *
   1167           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1168          void ScsiReadFormatCapcityImp (void)
   1169          {
   \                     ScsiReadFormatCapcityImp:
   \   00000000   0xB580             PUSH     {R7,LR}
   1170            if (Cbw.bmCBWFlags.Dir == BotDataFormDevToHost)
   \   00000002   0x....             LDR.N    R0,??DataTable20_6
   \   00000004   0x7B00             LDRB     R0,[R0, #+12]
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x09C0             LSRS     R0,R0,#+7
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD017             BEQ.N    ??ScsiReadFormatCapcityImp_0
   1171            {
   1172              // Clear condition code info
   1173              ScsiDrv[Lun].Status = ScsiCommandNoKey;
   \   00000010   0x....             LDR.N    R0,??DataTable20_4
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x....             LDR.N    R1,??DataTable20
   \   00000016   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x7301             STRB     R1,[R0, #+12]
   1174              ScsiDrv[Lun].Message[0] = LunReadFormatCapacityReqMsg;
   \   0000001E   0x....             LDR.N    R0,??DataTable20_4
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x0100             LSLS     R0,R0,#+4
   \   00000024   0x....             LDR.N    R1,??DataTable20
   \   00000026   0x220A             MOVS     R2,#+10
   \   00000028   0x5042             STR      R2,[R0, R1]
   1175              pScsiMessage[Lun] = ScsiDrv[Lun].Message;
   \   0000002A   0x....             LDR.N    R0,??DataTable20_4
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x....             LDR.N    R1,??DataTable20_1
   \   00000030   0x....             LDR.N    R2,??DataTable20_4
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0x....             LDR.N    R3,??DataTable20
   \   00000036   0xEB13 0x1202      ADDS     R2,R3,R2, LSL #+4
   \   0000003A   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   1176              return;
   \   0000003E   0xE00A             B.N      ??ScsiReadFormatCapcityImp_1
   1177            }
   1178            else
   1179            {
   1180              ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiReadFormatCapcityImp_0:
   \   00000040   0x2007             MOVS     R0,#+7
   \   00000042   0x.... 0x....      BL       ScsiCmdStatus
   1181            }
   1182            BotStatus.BotStatus = TRUE;
   \   00000046   0x....             LDR.N    R0,??DataTable20_5
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000004E   0x....             LDR.N    R1,??DataTable20_5
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   1183            BotInEpStall();
   \   00000052   0x.... 0x....      BL       BotInEpStall
   1184          }
   \                     ??ScsiReadFormatCapcityImp_1:
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
   1185          
   1186          /*************************************************************************
   1187           * Function Name: ScsiReadFormatCapcityData
   1188           * Parameters:  pInt8U pData, Int32U Size
   1189           *
   1190           * Return: none
   1191           *
   1192           * Description: Prepare Data of READ FORMAT CAPACITIES command request
   1193           *
   1194           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1195          void ScsiReadFormatCapcityData (pInt8U pData, Int32U Size)
   1196          
   1197          {
   \                     ScsiReadFormatCapcityData:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1198          pMmc3ReadFormatCapacity_t pFormatCapacity = (pMmc3ReadFormatCapacity_t)Cbw.CBWCB;
   \   00000006   0x....             LDR.N    R6,??DataTable20_17
   1199          Int32U AllocationLength = (pFormatCapacity->AllocationLenght[0]<<8) +\
   1200                                     pFormatCapacity->AllocationLenght[1];
   \   00000008   0x79F0             LDRB     R0,[R6, #+7]
   \   0000000A   0x7A31             LDRB     R1,[R6, #+8]
   \   0000000C   0xEB11 0x2700      ADDS     R7,R1,R0, LSL #+8
   1201            BotSendDataInit(pData,MIN(Size,AllocationLength),TRUE);
   \   00000010   0x42BD             CMP      R5,R7
   \   00000012   0xD201             BCS.N    ??ScsiReadFormatCapcityData_0
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0xE000             B.N      ??ScsiReadFormatCapcityData_1
   \                     ??ScsiReadFormatCapcityData_0:
   \   00000018   0x0039             MOVS     R1,R7
   \                     ??ScsiReadFormatCapcityData_1:
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       BotSendDataInit
   1202          }
   \   00000022   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1203          
   1204          /*************************************************************************
   1205           * Function Name: ScsiCmdStatus
   1206           * Parameters:  ScsiStatusCode_t Status
   1207           *
   1208           * Return: none
   1209           *
   1210           * Description: Prepare Status data for sending
   1211           *
   1212           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1213          void ScsiCmdStatus (ScsiStatusCode_t Status)
   1214          {
   1215            ScsiDrv[Lun].Status = Status;
   \                     ScsiCmdStatus:
   \   00000000   0x....             LDR.N    R1,??DataTable20_4
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x....             LDR.N    R2,??DataTable20
   \   00000006   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   0000000A   0x7308             STRB     R0,[R1, #+12]
   1216            switch (Status)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD003             BEQ.N    ??ScsiCmdStatus_0
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x2905             CMP      R1,#+5
   \   00000018   0xD901             BLS.N    ??ScsiCmdStatus_1
   \   0000001A   0xE007             B.N      ??ScsiCmdStatus_2
   1217            {
   1218            case ScsiCommandNoKey:
   1219              break;
   \                     ??ScsiCmdStatus_0:
   \   0000001C   0xE00C             B.N      ??ScsiCmdStatus_3
   1220            case ScsiMediamNotReady:
   1221            case ScsiInvalidCbd:
   1222            case ScsiUnknowCommand:
   1223            case ScsiMediaNotPresent:
   1224            case ScsiMediaChanged:
   1225            case ScsiMiscompare:
   1226              BotStatus.CmdFault = TRUE;
   \                     ??ScsiCmdStatus_1:
   \   0000001E   0x....             LDR.N    R1,??DataTable20_5
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000026   0x....             LDR.N    R2,??DataTable20_5
   \   00000028   0x7011             STRB     R1,[R2, #+0]
   1227              break;
   \   0000002A   0xE005             B.N      ??ScsiCmdStatus_3
   1228            default:
   1229              BotStatus.PhaseError = TRUE;
   \                     ??ScsiCmdStatus_2:
   \   0000002C   0x....             LDR.N    R1,??DataTable20_5
   \   0000002E   0x7809             LDRB     R1,[R1, #+0]
   \   00000030   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000034   0x....             LDR.N    R2,??DataTable20_5
   \   00000036   0x7011             STRB     R1,[R2, #+0]
   1230            }
   1231          }
   \                     ??ScsiCmdStatus_3:
   \   00000038   0x4770             BX       LR               ;; return
   1232          
   1233          /*************************************************************************
   1234           * Function Name: ScsiCmdError
   1235           * Parameters:  Int32U Status, Int32U Stall
   1236           *
   1237           * Return: none
   1238           *
   1239           * Description: Prepare Error data for sending
   1240           *
   1241           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1242          void ScsiCmdError (Int32U Status, Int32U Stall)
   1243          {
   \                     ScsiCmdError:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1244            if(Stall & ScsiStallIn)
   \   00000006   0x07E8             LSLS     R0,R5,#+31
   \   00000008   0xD507             BPL.N    ??ScsiCmdError_0
   1245            {
   1246              BotStatus.BotStatus = TRUE;
   \   0000000A   0x....             LDR.N    R0,??DataTable20_5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000012   0x....             LDR.N    R1,??DataTable20_5
   \   00000014   0x7008             STRB     R0,[R1, #+0]
   1247              BotInEpStall();
   \   00000016   0x.... 0x....      BL       BotInEpStall
   1248            }
   1249            if (Stall & ScsiStallOut)
   \                     ??ScsiCmdError_0:
   \   0000001A   0x07A8             LSLS     R0,R5,#+30
   \   0000001C   0xD501             BPL.N    ??ScsiCmdError_1
   1250            {
   1251              BotOutEpStall();
   \   0000001E   0x.... 0x....      BL       BotOutEpStall
   1252            }
   1253            ScsiCmdStatus((ScsiStatusCode_t)Status);
   \                     ??ScsiCmdError_1:
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       ScsiCmdStatus
   1254            if(!(Stall & ScsiStallIn))
   \   0000002A   0x07E8             LSLS     R0,R5,#+31
   \   0000002C   0xD401             BMI.N    ??ScsiCmdError_2
   1255            {
   1256              BotSendStatus();
   \   0000002E   0x.... 0x....      BL       BotSendStatus
   1257            }
   1258          }
   \                     ??ScsiCmdError_2:
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1259          
   1260          /*************************************************************************
   1261           * Function Name: ScsiMediaStartStopImp
   1262           * Parameters: none
   1263           *
   1264           * Return: none
   1265           *
   1266           * Description: START STOP UNIT command implement
   1267           *
   1268           *************************************************************************/

   \                                 In section .text, align 4
   1269          inline
   1270          void ScsiMediaStartStopImp (void)
   1271          {
   \                     ScsiMediaStartStopImp:
   \   00000000   0xB510             PUSH     {R4,LR}
   1272          pSpc3UnitStartStop_t pMediaStartStop = (pSpc3UnitStartStop_t)Cbw.CBWCB;
   \   00000002   0x4C1B             LDR.N    R4,??ScsiMediaStartStopImp_0
   1273            if (Cbw.dCBWDataTransferLength == 0)
   \   00000004   0x481B             LDR.N    R0,??ScsiMediaStartStopImp_0+0x4
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD12B             BNE.N    ??ScsiMediaStartStopImp_1
   1274            {
   1275              if (pMediaStartStop->PC == 0)
   \   0000000C   0x7920             LDRB     R0,[R4, #+4]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x0900             LSRS     R0,R0,#+4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD11F             BNE.N    ??ScsiMediaStartStopImp_2
   1276              {
   1277                if(pMediaStartStop->LOEJ)
   \   00000018   0x7920             LDRB     R0,[R4, #+4]
   \   0000001A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD013             BEQ.N    ??ScsiMediaStartStopImp_3
   1278                {
   1279                  if(pMediaStartStop->START)
   \   00000024   0x7920             LDRB     R0,[R4, #+4]
   \   00000026   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD007             BEQ.N    ??ScsiMediaStartStopImp_4
   1280                  {
   1281                    ScsiDrv[Lun].UnitSSStatus = UnitStarted;
   \   0000002E   0x4812             LDR.N    R0,??ScsiMediaStartStopImp_0+0x8
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x4912             LDR.N    R1,??ScsiMediaStartStopImp_0+0xC
   \   00000034   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x7341             STRB     R1,[R0, #+13]
   \   0000003C   0xE006             B.N      ??ScsiMediaStartStopImp_3
   1282                  }
   1283                  else
   1284                  {
   1285                    ScsiDrv[Lun].UnitSSStatus = UnitEjected;
   \                     ??ScsiMediaStartStopImp_4:
   \   0000003E   0x480E             LDR.N    R0,??ScsiMediaStartStopImp_0+0x8
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x490E             LDR.N    R1,??ScsiMediaStartStopImp_0+0xC
   \   00000044   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x7341             STRB     R1,[R0, #+13]
   1286                  }
   1287                }
   1288                // Clear condition code info
   1289                ScsiCmdStatus(ScsiCommandNoKey);
   \                     ??ScsiMediaStartStopImp_3:
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      BL       ScsiCmdStatus
   1290                BotSendStatus();
   \   00000052   0x.... 0x....      BL       BotSendStatus
   \   00000056   0xE004             B.N      ??ScsiMediaStartStopImp_5
   1291              }
   1292              else
   1293              {
   1294                ScsiCmdStatus(ScsiInvalidCbd);
   \                     ??ScsiMediaStartStopImp_2:
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x.... 0x....      BL       ScsiCmdStatus
   1295                BotSendStatus();
   \   0000005E   0x.... 0x....      BL       BotSendStatus
   1296              }
   1297              return;
   \                     ??ScsiMediaStartStopImp_5:
   \   00000062   0xE004             B.N      ??ScsiMediaStartStopImp_6
   1298            }
   1299            else
   1300            {
   1301              ScsiCmdStatus(ScsiFatalError);
   \                     ??ScsiMediaStartStopImp_1:
   \   00000064   0x2007             MOVS     R0,#+7
   \   00000066   0x.... 0x....      BL       ScsiCmdStatus
   1302            }
   1303            UsbBotRstInterface();
   \   0000006A   0x.... 0x....      BL       UsbBotRstInterface
   1304          }
   \                     ??ScsiMediaStartStopImp_6:
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
   \                     ??ScsiMediaStartStopImp_0:
   \   00000070   0x........         DC32     Cbw+0xF
   \   00000074   0x........         DC32     Cbw
   \   00000078   0x........         DC32     Lun
   \   0000007C   0x........         DC32     ScsiDrv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     ScsiDrv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     pScsiMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     MSD_Configure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     BotState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     Lun

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     BotStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x........         DC32     Cbw

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     Csw

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x53425355         DC32     0x53425355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \   00000000   0x........         DC32     USB_StatusHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \   00000000   0x........         DC32     LunMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \   00000000   0x........         DC32     `?<Constant "D:\\\\wangfan2\\\\\\327\\300\\303\\346\\\\RT`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \   00000000   0x........         DC32     `?<Constant "EP == BulkOutEp">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \   00000000   0x........         DC32     EpCnfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_14:
   \   00000000   0x........         DC32     `?<Constant "EP == BulkInEp">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_15:
   \   00000000   0x........         DC32     BotOutEP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_16:
   \   00000000   0x........         DC32     BotInEP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_17:
   \   00000000   0x........         DC32     Cbw+0xF

   \                                 In section .rodata, align 4
   \                     `?<Constant "EP == BulkOutEp">`:
   \   00000000   0x45 0x50          DC8 "EP == BulkOutEp"
   \              0x20 0x3D    
   \              0x3D 0x20    
   \              0x42 0x75    
   \              0x6C 0x6B    
   \              0x4F 0x75    
   \              0x74 0x45    
   \              0x70 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "D:\\\\wangfan2\\\\\\327\\300\\303\\346\\\\RT`:
   \   00000000   0x44 0x3A          DC8 "D:\\wangfan2\\\327\300\303\346\\RTU_1.3\\USB\\scsi.c"
   \              0x5C 0x77    
   \              0x61 0x6E    
   \              0x67 0x66    
   \              0x61 0x6E    
   \              0x32 0x5C    
   \              0xD7 0xC0    
   \              0xC3 0xE6    
   \              0x5C 0x52    
   \              0x54 0x55    
   \              0x5F 0x31    
   \              0x2E 0x33    
   \              0x5C 0x55    
   \              0x53 0x42    
   \              0x5C 0x73    
   \              0x63 0x73    
   \              0x69 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "EP == BulkInEp">`:
   \   00000000   0x45 0x50          DC8 "EP == BulkInEp"
   \              0x20 0x3D    
   \              0x3D 0x20    
   \              0x42 0x75    
   \              0x6C 0x6B    
   \              0x49 0x6E    
   \              0x45 0x70    
   \              0x00         
   \   0000000F   0x00               DC8 0
   1305          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BotInEP
         8   -> BotInEpStall
         8   -> BotOutEpStall
         8   -> BotSendStatus
         8   -> USB_IO_Data
         8   -> UsbBotRstInterface
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   BotInEpStall
         8   -> USB_SetStallEP
       8   BotOutEP
         8   -> BotInEpStall
         8   -> BotOutEpStall
         8   -> ScsiCommImpl
         8   -> UsbBotRstInterface
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   BotOutEpStall
         8   -> USB_SetStallEP
      16   BotReceiveDataInit
        16   -> EntrCritSection
        16   -> ExtCritSection
        16   -> USB_IO_Data
      16   BotSendDataInit
        16   -> EntrCritSection
        16   -> ExtCritSection
        16   -> USB_IO_Data
       8   BotSendStatus
         8   -> EntrCritSection
         8   -> ExtCritSection
         8   -> USB_IO_Data
       8   BotUnstallCallBack
         8   -> BotSendStatus
         8   -> UsbBotRstInterface
       0   EntrCritSection
       0   ExtCritSection
       0   IsUsbMSDConfigure
       4   ScsiCbwValid
      16   ScsiCmdError
        16   -> BotInEpStall
        16   -> BotOutEpStall
        16   -> BotSendStatus
        16   -> ScsiCmdStatus
       0   ScsiCmdStatus
       8   ScsiCommImpl
         8   -> BotInEpStall
         8   -> BotOutEpStall
         8   -> ScsiCbwValid
         8   -> ScsiCmdError
         8   -> ScsiInquiryImp
         8   -> ScsiMediaRemovalImp
         8   -> ScsiMediaStartStopImp
         8   -> ScsiModeSelect6Imp
         8   -> ScsiModeSense6Imp
         8   -> ScsiRead10Imp
         8   -> ScsiReadCapacity10Imp
         8   -> ScsiReadFormatCapcityImp
         8   -> ScsiRequestSenseImp
         8   -> ScsiTestUnitReadyImp
         8   -> ScsiVerify10Imp
         8   -> ScsiWrite10Imp
       8   ScsiInit
         8   -> UsbClassBotInit
      16   ScsiInquiryData
        16   -> BotSendDataInit
      16   ScsiInquiryImp
        16   -> BotInEpStall
        16   -> ScsiCmdStatus
       8   ScsiMediaRemovalImp
         8   -> BotSendStatus
         8   -> ScsiCmdStatus
         8   -> UsbBotRstInterface
       8   ScsiMediaStartStopImp
         8   -> BotSendStatus
         8   -> ScsiCmdStatus
         8   -> UsbBotRstInterface
       8   ScsiModeSelect6Imp
         8   -> BotInEpStall
         8   -> BotOutEpStall
         8   -> BotSendStatus
         8   -> ScsiCmdStatus
       8   ScsiModeSense6Imp
         8   -> BotInEpStall
         8   -> ScsiCmdStatus
      16   ScsiModeSenseData
        16   -> BotSendDataInit
        16   -> memset
       8   ScsiRead10Imp
         8   -> BotInEpStall
         8   -> BotSendStatus
         8   -> ScsiCmdStatus
       8   ScsiReadCapacity10Imp
         8   -> BotInEpStall
         8   -> ScsiCmdStatus
      16   ScsiReadCapacityData
        16   -> BotSendDataInit
        16   -> memset
      16   ScsiReadData
        16   -> BotSendDataInit
      24   ScsiReadFormatCapcityData
        24   -> BotSendDataInit
       8   ScsiReadFormatCapcityImp
         8   -> BotInEpStall
         8   -> ScsiCmdStatus
      16   ScsiRequestSenseImp
        16   -> BotInEpStall
        16   -> BotSendDataInit
        16   -> ScsiCmdStatus
        16   -> memset
       8   ScsiTestUnitReadyImp
         8   -> ScsiCmdError
       8   ScsiTestUntilReadyData
         8   -> BotSendStatus
         8   -> ScsiCmdStatus
       8   ScsiVerify10Imp
         8   -> BotOutEpStall
         8   -> BotSendStatus
         8   -> ScsiCmdStatus
       8   ScsiWrite10Imp
         8   -> BotOutEpStall
         8   -> BotSendStatus
         8   -> ScsiCmdStatus
      16   ScsiWriteData
        16   -> BotReceiveDataInit
        16   -> BotSendStatus
       8   UsbBotRstInterface
         8   -> USB_IO_Data
       8   UsbClassBotConfigure
         8   -> UsbBotRstInterface
       8   UsbClassBotInit
         8   -> UsbClassBotConfigure
         8   -> UsbCoreInit
       8   UsbClassBotRequest
         8   -> USB_IO_Data
         8   -> USB_StatusHandler
         8   -> UsbBotRstInterface
      16   memset
        16   -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      36  ?<Constant "D:\\wangfan2\\\327\300\303\346\\RT
      16  ?<Constant "EP == BulkInEp">
      16  ?<Constant "EP == BulkOutEp">
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_16
       4  ??DataTable20_17
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
     334  BotInEP
      12  BotInEpStall
     204  BotOutEP
      12  BotOutEpStall
      92  BotReceiveDataInit
     146  BotSendDataInit
     104  BotSendStatus
       1  BotState
       4  BotStatus
      66  BotUnstallCallBack
      28  EntrCritSection
      24  ExtCritSection
       8  IsUsbMSDConfigure
       4  Lun
       1  LunMax
       4  MSD_Configure
     152  ScsiCbwValid
      52  ScsiCmdError
      58  ScsiCmdStatus
     212  ScsiCommImpl
      16  ScsiDrv
      68  ScsiInit
      32  ScsiInquiryData
     140  ScsiInquiryImp
      76  ScsiMediaRemovalImp
     128  ScsiMediaStartStopImp
      64  ScsiModeSelect6Imp
     152  ScsiModeSense6Imp
      58  ScsiModeSenseData
     212  ScsiRead10Imp
     116  ScsiReadCapacity10Imp
      72  ScsiReadCapacityData
      20  ScsiReadData
      36  ScsiReadFormatCapcityData
      88  ScsiReadFormatCapcityImp
     344  ScsiRequestSenseImp
      72  ScsiTestUnitReadyImp
     100  ScsiTestUntilReadyData
     202  ScsiVerify10Imp
     212  ScsiWrite10Imp
      30  ScsiWriteData
      54  UsbBotRstInterface
      38  UsbClassBotConfigure
      46  UsbClassBotInit
      96  UsbClassBotRequest
      22  memset
       4  pScsiMessage

 
    33 bytes in section .bss
    69 bytes in section .rodata
 4 054 bytes in section .text
 
 2 100 bytes of CODE  memory (+ 1 954 bytes shared)
    69 bytes of CONST memory
    33 bytes of DATA  memory

Errors: none
Warnings: none
