###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      05/Apr/2017  15:06:13 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\桌面\RTU_1.3\USB\usb_hw.c                    #
#    Command line =  D:\wangfan2\桌面\RTU_1.3\USB\usb_hw.c -lCN               #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\List\ -o      #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\Obj\          #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\桌面\RTU_1.3\project\iar\ -I       #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\ -I       #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\ADC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\RTC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\TILT\ -I  #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\RDLevel\  #
#                    -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\RS232\ #
#                     -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\OS-v2 #
#                    \ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\Vibr #
#                    ationString\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\ #
#                    ..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\ -I     #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\ucos2\uCOS-II #
#                    \Source\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\u #
#                    cos2\uC-LIB\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\ #
#                    ..\ucos2\uC-CPU\ -I D:\wangfan2\桌面\RTU_1.3\project\iar #
#                    \..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I                #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\cmsis\Drivers #
#                    \source\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\c #
#                    msis\Drivers\include\ -I D:\wangfan2\桌面\RTU_1.3\projec #
#                    t\iar\..\..\app\ -I D:\wangfan2\桌面\RTU_1.3\project\iar #
#                    \..\..\uC-Probe\Target\Plugins\uCOS-II\ -I               #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Workspaces\ -I                            #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Source\ -I D:\wangfan2\桌面\RTU_1.3\proje #
#                    ct\iar\..\..\uC-Probe\Target\Communication\Generic\Sourc #
#                    e\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Prob #
#                    e\Target\Communication\Generic\RS-232\Source\ -I         #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\Ports\NXP\LPC17xx\ -I    #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\OS\uCOS-II\ -I           #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\cmsis\Core\CM #
#                    3\CoreSupport\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\. #
#                    .\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\ -I     #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp\ -I  #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp\DEVI #
#                    CE_BT\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\Hua #
#                    ceApp\DEVICE_COM\ -I D:\wangfan2\桌面\RTU_1.3\project\ia #
#                    r\..\..\HuaceApp\DEVICE_GPRS\ -I                         #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp\DEVI #
#                    CE_GPS\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\Hu #
#                    aceApp\DEVICE_RADIO\ -I D:\wangfan2\桌面\RTU_1.3\project #
#                    \iar\..\..\HuaceApp\iap\ -I                              #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\FatFs\ -I     #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\USB\ -I       #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\bsp\spi_flash #
#                    \ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp #
#                    \LED\ -On --use_c++_inline                               #
#    List file    =  D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\List\usb_hw.l #
#                    st                                                       #
#    Object file  =  D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\Obj\usb_hw.o  #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\桌面\RTU_1.3\USB\usb_hw.c
      1          /*----------------------------------------------------------------------------
      2           *      U S B  -  K e r n e l
      3           *----------------------------------------------------------------------------
      4           * Name:    usbhw.c
      5           * Purpose: USB Hardware Layer Module for NXP's LPC17xx MCU
      6           * Version: V1.20
      7           *----------------------------------------------------------------------------
      8           *      This software is supplied "AS IS" without any warranties, express,
      9           *      implied or statutory, including but not limited to the implied
     10           *      warranties of fitness for purpose, satisfactory quality and
     11           *      noninfringement. Keil extends you a royalty-free right to reproduce
     12           *      and distribute executable files created using this software for use
     13           *      on NXP Semiconductors LPC family microcontroller devices only. Nothing
     14           *      else gives you the right to use this software.
     15           *
     16           * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
     17           *----------------------------------------------------------------------------
     18           * History:
     19           *          V1.20 Added USB_ClearEPBuf
     20           *          V1.00 Initial Version
     21           *----------------------------------------------------------------------------*/
     22          #define USB_HW_GLOBAL
     23          #include "LPC177x_8x.h"                        /* LPC177x_8x.h definitions */

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable11  ;; 0xe000e100
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x0941             LSRS     R1,R0,#+5
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable11_1  ;; 0xe000e280
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   00000010   0x40A3             LSLS     R3,R3,R4
   \   00000012   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority:
   \   00000000   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD509             BPL.N    ??NVIC_SetPriority_0
   \   00000006   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000008   0xF010 0x020F      ANDS     R2,R0,#0xF
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable11_2  ;; 0xe000ed18
   \   00000010   0x18D2             ADDS     R2,R2,R3
   \   00000012   0x00CB             LSLS     R3,R1,#+3
   \   00000014   0xF802 0x3C04      STRB     R3,[R2, #-4]
   \   00000018   0xE004             B.N      ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0:
   \   0000001A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable11_3  ;; 0xe000e400
   \   00000020   0x00CB             LSLS     R3,R1,#+3
   \   00000022   0x5483             STRB     R3,[R0, R2]
   \                     ??NVIC_SetPriority_1:
   \   00000024   0x4770             BX       LR               ;; return
     24          #include "lpc177x_8x_nvic.h"
     25          #include "lpc_types.h"
     26          #include "io_macros.h"
     27          #include "usb_hw.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void EntrCritSection(void)
   \                     EntrCritSection:
   \   00000000   0x4805             LDR.N    R0,??EntrCritSection_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD100             BNE.N    ??EntrCritSection_1
   \   00000008   0xB672             CPSID i
   \                     ??EntrCritSection_1:
   \   0000000A   0x4803             LDR.N    R0,??EntrCritSection_0
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x4901             LDR.N    R1,??EntrCritSection_0
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0x4770             BX       LR               ;; return
   \   00000016   0xBF00             Nop      
   \                     ??EntrCritSection_0:
   \   00000018   0x........         DC32     CriticalSecCntr

   \                                 In section .text, align 4
   \   __interwork __softfp void ExtCritSection(void)
   \                     ExtCritSection:
   \   00000000   0x4804             LDR.N    R0,??ExtCritSection_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1E40             SUBS     R0,R0,#+1
   \   00000006   0x4903             LDR.N    R1,??ExtCritSection_0
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD100             BNE.N    ??ExtCritSection_1
   \   0000000E   0xB662             CPSIE i
   \                     ??ExtCritSection_1:
   \   00000010   0x4770             BX       LR               ;; return
   \   00000012   0xBF00             Nop      
   \                     ??ExtCritSection_0:
   \   00000014   0x........         DC32     CriticalSecCntr

   \                                 In section .bss, align 4
   \   __absolute EpCnfg_t EpCnfg[(enum _USB_Endpoint_t)32U]
   \                     EpCnfg:
   \   00000000                      DS8 1152
     28          #include "core_cm3.h"
     29          #include "global.h"
     30          
     31          /* USB - Device Interrupt Status Register */
     32          typedef struct {
     33            __REG32 USB_INT_REQ_LP    : 1;
     34            __REG32 USB_INT_REQ_HP    : 1;
     35            __REG32 USB_INT_REQ_DMA   : 1;
     36            __REG32 USB_HOST_INT      : 1;
     37            __REG32 USB_ATX_INT       : 1;
     38            __REG32 USB_OTG_INT       : 1;
     39            __REG32 USB_I2C_INT       : 1;
     40            __REG32                   : 1;
     41            __REG32 USB_NEED_CLOCK    : 1;
     42            __REG32                   :22;
     43            __REG32 EN_USB_INTS       : 1;
     44          } __usbints_bits;
     45          /* USB - Control Register */
     46          typedef struct {
     47            __REG32 RD_EN             : 1;
     48            __REG32 WR_EN             : 1;
     49            __REG32 LOG_ENDPOINT      : 4;
     50            __REG32                   :26;
     51          } __usbctrl_bits;
     52          /* USB - Receive Packet Length Register */
     53          typedef struct {
     54            __REG32 PKT_LNGTH         :10;
     55            __REG32 DV                : 1;
     56            __REG32 PKT_RDY           : 1;
     57            __REG32                   :20;
     58          } __usbrxplen_bits;
     59          typedef struct {
     60            __REG32 FRAME             : 1;
     61            __REG32 EP_FAST           : 1;
     62            __REG32 EP_SLOW           : 1;
     63            __REG32 DEV_STAT          : 1;
     64            __REG32 CCEMTY            : 1;
     65            __REG32 CDFULL            : 1;
     66            __REG32 RXENDPKT          : 1;
     67            __REG32 TXENDPKT          : 1;
     68            __REG32 EP_RLZED          : 1;
     69            __REG32 ERR_INT           : 1;
     70            __REG32                   :22;
     71          } __usbdevintst_bits;

   \                                 In section .noinit, at 0x400fc1c0
     72          __IO_REG32_BIT(USBINTS,               0x400FC1C0,__READ_WRITE ,__usbints_bits);
   \                     _A_USBINTS:
   \   00000000                      DS8 4

   \                                 In section .noinit, at 0x2008c220
     73          __IO_REG32_BIT(USBRXPLEN,             0x2008C220,__READ       ,__usbrxplen_bits);
   \                     _A_USBRXPLEN:
   \   00000000                      DS8 4

   \                                 In section .noinit, at 0x2008c228
     74          __IO_REG32_BIT(USBCTRL,               0x2008C228,__READ_WRITE ,__usbctrl_bits);
   \                     _A_USBCTRL:
   \   00000000                      DS8 4

   \                                 In section .noinit, at 0x2008c200
     75          __IO_REG32_BIT(USBDEVINTST,           0x2008C200,__READ       ,__usbdevintst_bits);
   \                     _A_USBDEVINTST:
   \   00000000                      DS8 4
     76          
     77          extern void NVIC_IntEnable(Int32U IntNumber);
     78          extern void NVIC_IntDisable(Int32U IntNumber);
     79          extern void NVIC_ClrPend(Int32U IntNumber);
     80          extern void NVIC_IntPri(Int32U IntNumber, Int8U Priority);
     81          

   \                                 In section .bss, align 4
     82          static volatile UsbDevStat_t USB_DevStatus;
   \                     USB_DevStatus:
   \   00000000                      DS8 4
     83          

   \                                 In section .rodata, align 4
     84          static const UsbStandardEpDescriptor_t USB_CtrlEpDescr0 =
   \                     USB_CtrlEpDescr0:
   \   00000000   0x07 0x05          DC8 7, 5, 0, 0
   \              0x00 0x00    
   \   00000004   0x0008             DC16 8
   \   00000006   0x00 0x00          DC8 0, 0
     85          {
     86            sizeof(UsbStandardEpDescriptor_t),
     87            UsbDescriptorEp,
     88            UsbEpOut(CTRL_ENP_OUT>>1),
     89            {(Int8U)UsbEpTransferControl | (Int8U)UsbEpSynchNoSynchronization | (Int8U)UsbEpUsageData},
     90            Ep0MaxSize,
     91            0
     92          };
     93          

   \                                 In section .rodata, align 4
     94          static const UsbEP_ExtData_t USB_CtrlEpExtDescr0 =
   \                     USB_CtrlEpExtDescr0:
   \   00000000   0x00000000         DC32 0
     95          {
     96            0
     97          };
     98          

   \                                 In section .rodata, align 4
     99          static const UsbStandardEpDescriptor_t USB_CtrlEpDescr1 =
   \                     USB_CtrlEpDescr1:
   \   00000000   0x07 0x05          DC8 7, 5, 128, 0
   \              0x80 0x00    
   \   00000004   0x0008             DC16 8
   \   00000006   0x00 0x00          DC8 0, 0
    100          {
    101            sizeof(UsbStandardEpDescriptor_t),
    102            UsbDescriptorEp,
    103            UsbEpIn(CTRL_ENP_IN>>1),
    104            {(Int8U)UsbEpTransferControl | (Int8U)UsbEpSynchNoSynchronization | (Int8U)UsbEpUsageData},
    105            Ep0MaxSize,
    106            0
    107          };
    108          

   \                                 In section .rodata, align 4
    109          static const UsbEP_ExtData_t USB_CtrlEpExtDescr1 =
   \                     USB_CtrlEpExtDescr1:
   \   00000000   0x00000000         DC32 0
    110          {
    111            0
    112          };
    113          

   \                                 In section .rodata, align 4
    114          static const Boolean UsbEpDoubleBuffType[] =
   \                     UsbEpDoubleBuffType:
   \   00000000   0x00000000         DC32 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000001   
   \              0x00000001   
   \              0x00000001   
   \              0x00000001   
   \              0x00000000   
   \              0x00000000   
   \              0x00000001   
   \              0x00000001   
   \              0x00000001   
   \              0x00000001   
   \              0x00000000   
   \              0x00000000   
   \              0x00000001   
   \              0x00000001   
   \              0x00000001   
   \              0x00000001   
   \              0x00000000   
   \              0x00000000   
   \   00000058   0x00000001         DC32 1, 1, 1, 1, 0, 0, 1, 1, 1, 1
   \              0x00000001   
   \              0x00000001   
   \              0x00000001   
   \              0x00000000   
   \              0x00000000   
   \              0x00000001   
   \              0x00000001   
   \              0x00000001   
   \              0x00000001   
    115          {
    116            FALSE,  // OUT 0
    117            FALSE,  // IN 0
    118            FALSE,  // OUT 1
    119            FALSE,  // IN 1
    120            TRUE,   // OUT 2
    121            TRUE,   // IN 2
    122            TRUE,   // OUT 3
    123            TRUE,   // IN 3
    124            FALSE,  // OUT 4
    125            FALSE,  // IN 4
    126            TRUE,   // OUT 5
    127            TRUE,   // IN 5
    128            TRUE,   // OUT 6
    129            TRUE,   // IN 6
    130            FALSE,  // OUT 7
    131            FALSE,  // IN 7
    132            TRUE,   // OUT 8
    133            TRUE,   // IN 8
    134            TRUE,   // OUT 9
    135            TRUE,   // IN 9
    136            FALSE,  // OUT 10
    137            FALSE,  // IN 10
    138            TRUE,   // OUT 11
    139            TRUE,   // IN 11
    140            TRUE,   // OUT 12
    141            TRUE,   // IN 12
    142            FALSE,  // OUT 13
    143            FALSE,  // IN 13
    144            TRUE,   // OUT 14
    145            TRUE,   // IN 14
    146            TRUE,   // OUT 15
    147            TRUE,   // IN 15
    148          };
    149          
    150          #if  USB_SOF_EVENT > 0
    151          Int32U  USB_SofNumbHold;
    152          #endif
    153          
    154          #if USB_DMA_DD_MAX_NUMB > 0
    155          
    156          #pragma segment="USB_DMA_RAM"
    157          #pragma location="USB_DMA_RAM"
    158          #pragma data_alignment=128

   \                                 In section USB_DMA_RAM, align 128
    159          __no_init pUSB_DmaDesc_t USB_DDCA[ENP_MAX_NUMB];
   \                     USB_DDCA:
   \   00000000                      DS8 128
    160          
    161          #pragma location="USB_DMA_RAM"

   \                                 In section USB_DMA_RAM, align 4
    162          __no_init USB_DmaDesc_t USB_DmaDesc[USB_DMA_DD_MAX_NUMB];
   \                     USB_DmaDesc:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
    163          pUSB_DmaDesc_t DmaFree[USB_DMA_DD_MAX_NUMB];
   \                     DmaFree:
   \   00000000                      DS8 8
    164          
    165          #if USB_DMA_ID_MAX_NUMB > 0
    166          #pragma location="USB_DMA_RAM"
    167          __no_init DmaIsoPacket_t USB_DmaIsoDesc[USB_DMA_ID_MAX_NUMB];
    168          pDmaIsoPacket_t DmaIsoFree[USB_DMA_ID_MAX_NUMB];
    169          #endif // USB_DMA_ID_MAX_NUMB > 0
    170          #endif // USB_DMA_DD_MAX_NUMB > 0
    171          
    172          /*************************************************************************
    173           * Function Name: USB_Cmd
    174           * Parameters:  Int16U Command, Int8U Data
    175           *
    176           * Return: Int32U - command result
    177           *
    178           * Description: Implement commands transmit to USB Engine
    179           *
    180           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    181          static
    182          Int32U USB_Cmd (Int16U Command, Int8U Data)
    183          {
   \                     USB_Cmd:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    184          Int32U tmp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    185            // Disable interrupt and save current state of the interrupt flags
    186              ENTR_CRT_SECTION();
   \   00000008   0x.... 0x....      BL       EntrCritSection
    187          
    188            LPC_USB->DevIntClr = bmUSB_CommDataFullInterrupt | bmUSB_CommRegEmptyInterrupt;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable11_4  ;; 0x2008c208
   \   00000010   0x2130             MOVS     R1,#+48
   \   00000012   0x6001             STR      R1,[R0, #+0]
    189            // Load command in USB engine
    190            LPC_USB->CmdCode = ((Command&0xFF) << 16) + USB_CMD_WR;
   \   00000014   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000016   0xB2E0             UXTB     R0,R4            ;; ZeroExt  R0,R4,#+24,#+24
   \   00000018   0x0400             LSLS     R0,R0,#+16
   \   0000001A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable11_5  ;; 0x2008c210
   \   00000022   0x6008             STR      R0,[R1, #+0]
    191            // Wait until command is accepted
    192            while ((LPC_USB->DevIntSt & bmUSB_CommRegEmptyInterrupt) == 0);
   \                     ??USB_Cmd_0:
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x2008c200
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x06C0             LSLS     R0,R0,#+27
   \   0000002C   0xD5FA             BPL.N    ??USB_Cmd_0
    193            // clear Command reg. empty interrupt
    194            LPC_USB->DevIntClr = bmUSB_CommRegEmptyInterrupt;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable11_4  ;; 0x2008c208
   \   00000032   0x2110             MOVS     R1,#+16
   \   00000034   0x6001             STR      R1,[R0, #+0]
    195            // determinate next phase of the command
    196            switch (Command)
   \   00000036   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x28D0             CMP      R0,#+208
   \   0000003C   0xD012             BEQ.N    ??USB_Cmd_1
   \   0000003E   0x28D8             CMP      R0,#+216
   \   00000040   0xD010             BEQ.N    ??USB_Cmd_1
   \   00000042   0x28F2             CMP      R0,#+242
   \   00000044   0xD041             BEQ.N    ??USB_Cmd_2
   \   00000046   0x28F3             CMP      R0,#+243
   \   00000048   0xD00C             BEQ.N    ??USB_Cmd_1
   \   0000004A   0x28F5             CMP      R0,#+245
   \   0000004C   0xD017             BEQ.N    ??USB_Cmd_3
   \   0000004E   0x28FB             CMP      R0,#+251
   \   00000050   0xD03B             BEQ.N    ??USB_Cmd_2
   \   00000052   0x28FD             CMP      R0,#+253
   \   00000054   0xD013             BEQ.N    ??USB_Cmd_3
   \   00000056   0x28FE             CMP      R0,#+254
   \   00000058   0xD037             BEQ.N    ??USB_Cmd_2
   \   0000005A   0x28FF             CMP      R0,#+255
   \   0000005C   0xD035             BEQ.N    ??USB_Cmd_2
   \   0000005E   0xF5B0 0x7FFF      CMP      R0,#+510
   \   00000062   0xD143             BNE.N    ??USB_Cmd_4
    197            {
    198            case CMD_USB_SET_ADDRESS:
    199            case CMD_USB_CFG_DEV:
    200            case CMD_USB_SET_MODE:
    201            case CMD_USB_SET_DEV_STAT:
    202              LPC_USB->CmdCode = (Data << 16) + USB_DATA_WR;
   \                     ??USB_Cmd_1:
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x0428             LSLS     R0,R5,#+16
   \   00000068   0xF510 0x7080      ADDS     R0,R0,#+256
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable11_5  ;; 0x2008c210
   \   00000070   0x6008             STR      R0,[R1, #+0]
    203              while ((LPC_USB->DevIntSt & bmUSB_CommRegEmptyInterrupt) == 0);
   \                     ??USB_Cmd_5:
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x2008c200
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x06C0             LSLS     R0,R0,#+27
   \   0000007A   0xD5FA             BPL.N    ??USB_Cmd_5
    204              break;
   \   0000007C   0xE05F             B.N      ??USB_Cmd_6
    205            case CMD_USB_RD_FRAME_NUMB:
    206            case CMD_USB_RD_TEST_REG:
    207              LPC_USB->CmdCode = (Command << 16) + USB_DATA_RD;
   \                     ??USB_Cmd_3:
   \   0000007E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000080   0x0420             LSLS     R0,R4,#+16
   \   00000082   0xF510 0x7000      ADDS     R0,R0,#+512
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable11_5  ;; 0x2008c210
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    208              while ((LPC_USB->DevIntSt & bmUSB_CommDataFullInterrupt) == 0);
   \                     ??USB_Cmd_7:
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x2008c200
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x0680             LSLS     R0,R0,#+26
   \   00000094   0xD5FA             BPL.N    ??USB_Cmd_7
    209              LPC_USB->DevIntClr = bmUSB_CommDataFullInterrupt;
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable11_4  ;; 0x2008c208
   \   0000009A   0x2120             MOVS     R1,#+32
   \   0000009C   0x6001             STR      R1,[R0, #+0]
    210              tmp = LPC_USB->CmdData;
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x2008c214
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x0006             MOVS     R6,R0
    211              LPC_USB->CmdCode = (Command << 16) + USB_DATA_RD;
   \   000000A6   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000A8   0x0420             LSLS     R0,R4,#+16
   \   000000AA   0xF510 0x7000      ADDS     R0,R0,#+512
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable11_5  ;; 0x2008c210
   \   000000B2   0x6008             STR      R0,[R1, #+0]
    212              while ((LPC_USB->DevIntSt & bmUSB_CommDataFullInterrupt) == 0);
   \                     ??USB_Cmd_8:
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x2008c200
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x0680             LSLS     R0,R0,#+26
   \   000000BC   0xD5FA             BPL.N    ??USB_Cmd_8
    213              tmp |= LPC_USB->CmdData << 8;
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x2008c214
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0xEA56 0x2600      ORRS     R6,R6,R0, LSL #+8
    214              break;
   \   000000C8   0xE039             B.N      ??USB_Cmd_6
    215            case CMD_USB_GET_DEV_STAT:
    216            case CMD_USB_GET_ERROR:
    217            case CMD_USB_RD_ERROR_STAT:
    218            case CMD_USB_CLR_BUF:
    219              LPC_USB->CmdCode = (Command << 16) + USB_DATA_RD;
   \                     ??USB_Cmd_2:
   \   000000CA   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000CC   0x0420             LSLS     R0,R4,#+16
   \   000000CE   0xF510 0x7000      ADDS     R0,R0,#+512
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable11_5  ;; 0x2008c210
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    220              while ((LPC_USB->DevIntSt & bmUSB_CommDataFullInterrupt) == 0);
   \                     ??USB_Cmd_9:
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x2008c200
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x0680             LSLS     R0,R0,#+26
   \   000000E0   0xD5FA             BPL.N    ??USB_Cmd_9
    221              tmp = LPC_USB->CmdData;
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x2008c214
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0x0006             MOVS     R6,R0
    222              break;
   \   000000EA   0xE028             B.N      ??USB_Cmd_6
    223            default:
    224              switch (Command & 0x1E0)
   \                     ??USB_Cmd_4:
   \   000000EC   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000EE   0xF414 0x70F0      ANDS     R0,R4,#0x1E0
   \   000000F2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD005             BEQ.N    ??USB_Cmd_10
   \   000000F8   0x2840             CMP      R0,#+64
   \   000000FA   0xD003             BEQ.N    ??USB_Cmd_10
   \   000000FC   0xF5B0 0x7FA0      CMP      R0,#+320
   \   00000100   0xD011             BEQ.N    ??USB_Cmd_11
   \   00000102   0xE01C             B.N      ??USB_Cmd_12
    225              {
    226              case CMD_USB_SEL_EP:
    227              case CMD_USB_SEL_CLR_INT_EP:
    228                LPC_USB->CmdCode = (Command << 16) + USB_DATA_RD;
   \                     ??USB_Cmd_10:
   \   00000104   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000106   0x0420             LSLS     R0,R4,#+16
   \   00000108   0xF510 0x7000      ADDS     R0,R0,#+512
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable11_5  ;; 0x2008c210
   \   00000110   0x6008             STR      R0,[R1, #+0]
    229                while ((LPC_USB->DevIntSt & bmUSB_CommDataFullInterrupt) == 0);
   \                     ??USB_Cmd_13:
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x2008c200
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0x0680             LSLS     R0,R0,#+26
   \   0000011A   0xD5FA             BPL.N    ??USB_Cmd_13
    230                tmp = LPC_USB->CmdData;
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x2008c214
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x0006             MOVS     R6,R0
    231                break;
   \   00000124   0xE00B             B.N      ??USB_Cmd_12
    232              case CMD_USB_SET_EP_STAT:
    233                LPC_USB->CmdCode = (Data << 16) + USB_DATA_WR;
   \                     ??USB_Cmd_11:
   \   00000126   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000128   0x0428             LSLS     R0,R5,#+16
   \   0000012A   0xF510 0x7080      ADDS     R0,R0,#+256
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable11_5  ;; 0x2008c210
   \   00000132   0x6008             STR      R0,[R1, #+0]
    234                while ((LPC_USB->DevIntSt & bmUSB_CommRegEmptyInterrupt) == 0);
   \                     ??USB_Cmd_14:
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x2008c200
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x06C0             LSLS     R0,R0,#+27
   \   0000013C   0xD5FA             BPL.N    ??USB_Cmd_14
    235                break;
    236              }
    237              break;
    238            }
    239            // restore the interrupt flags
    240              EXT_CRT_SECTION();
   \                     ??USB_Cmd_12:
   \                     ??USB_Cmd_6:
   \   0000013E   0x.... 0x....      BL       ExtCritSection
    241            return(tmp);
   \   00000142   0x0030             MOVS     R0,R6
   \   00000144   0xBD70             POP      {R4-R6,PC}       ;; return
    242          }
    243          
    244          /*************************************************************************
    245           * Function Name: USB_EpIntrClr
    246           * Parameters: USB_Endpoint_t EndPoint
    247           *
    248           * Return: Int8U
    249           *
    250           * Description: Clear the EP interrupt flag and return the current EP status
    251           *
    252           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    253          static
    254          Int8U USB_EpIntrClr(USB_Endpoint_t EndPoint)
    255          {
   \                     USB_EpIntrClr:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    256          volatile Int32U TO = 100;
   \   00000006   0x2064             MOVS     R0,#+100
   \   00000008   0x9000             STR      R0,[SP, #+0]
    257          #if __CORE__ < 7
    258          Int32U Save;
    259          #endif // __CORE__ < 7
    260            // Disable interrupt and save current state of the interrupt flags
    261            #if __CORE__ < 7
    262              ENTR_CRT_SECTION(Save);
    263            #else
    264              ENTR_CRT_SECTION();
   \   0000000A   0x.... 0x....      BL       EntrCritSection
    265            #endif // __CORE__ < 7
    266            // the hardware will clear the CDFULL bit in the Device Interrupt Status register
    267            // USBDEVINTCLR = bmUSB_CommDataFullInterrupt;
    268          
    269            LPC_USB->EpIntClr = 1 << EndPoint;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x40A0             LSLS     R0,R0,R4
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable11_8  ;; 0x2008c238
   \   00000016   0x6008             STR      R0,[R1, #+0]
    270            // add some little delay may be is needed bacause the USB engine and Core
    271            // works on differents frequency domains
    272            __no_operation();
   \   00000018   0xBF00             Nop      
    273            __no_operation();
   \   0000001A   0xBF00             Nop      
    274            while ((LPC_USB->DevIntSt & bmUSB_CommDataFullInterrupt) == 0)
   \                     ??USB_EpIntrClr_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x2008c200
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x0680             LSLS     R0,R0,#+26
   \   00000024   0xD40F             BMI.N    ??USB_EpIntrClr_1
    275            {
    276              assert(--TO);
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD1F5             BNE.N    ??USB_EpIntrClr_0
   \   00000030   0xF44F 0x728A      MOV      R2,#+276
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable11_9
   \   0000003C   0x.... 0x....      BL       __aeabi_assert
   \   00000040   0x.... 0x....      BL       __iar_EmptyStepPoint
   \   00000044   0xE7EA             B.N      ??USB_EpIntrClr_0
    277            }
    278            #if __CORE__ < 7
    279              EXT_CRT_SECTION(Save);
    280            #else
    281              EXT_CRT_SECTION();
   \                     ??USB_EpIntrClr_1:
   \   00000046   0x.... 0x....      BL       ExtCritSection
    282            #endif // __CORE__ < 7
    283            return(LPC_USB->CmdData);
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x2008c214
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    284          }
    285          
    286          /*************************************************************************
    287           * Function Name: USB_HwInit
    288           * Parameters: none
    289           *
    290           * Return: none
    291           *
    292           * Description: Init USB
    293           *
    294           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    295          void USB_HwInit(void)
    296          {
   \                     USB_HwInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    297            // Init SOF number hold
    298            #if  USB_SOF_EVENT > 0
    299            USB_SofNumbHold = 0;
    300            #endif
    301          
    302            LPC_IOCON->P0_31 &= ~0x07;    /* P0.31 D2+, D2- is dedicated pin.  */
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable11_10  ;; 0x4002c07c
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x08C0             LSRS     R0,R0,#+3
   \   0000000A   0x00C0             LSLS     R0,R0,#+3
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable11_10  ;; 0x4002c07c
   \   00000010   0x6008             STR      R0,[R1, #+0]
    303            LPC_IOCON->P0_31 |= 0x1;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable11_10  ;; 0x4002c07c
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable11_10  ;; 0x4002c07c
   \   00000020   0x6008             STR      R0,[R1, #+0]
    304          
    305            LPC_IOCON->P0_14  &= ~0x07;    /* USB_SoftConnect */
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable11_11  ;; 0x4002c038
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x08C0             LSRS     R0,R0,#+3
   \   0000002A   0x00C0             LSLS     R0,R0,#+3
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable11_11  ;; 0x4002c038
   \   00000030   0x6008             STR      R0,[R1, #+0]
    306            LPC_IOCON->P0_14  |= 0x3;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable11_11  ;; 0x4002c038
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF050 0x0003      ORRS     R0,R0,#0x3
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable11_11  ;; 0x4002c038
   \   00000040   0x6008             STR      R0,[R1, #+0]
    307          
    308            LPC_IOCON->P1_30  &= ~0x1f;   /* USB_VBUS */  //xuliang 2011-10-20
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable11_12  ;; 0x4002c0f8
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x0940             LSRS     R0,R0,#+5
   \   0000004A   0x0140             LSLS     R0,R0,#+5
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable11_12  ;; 0x4002c0f8
   \   00000050   0x6008             STR      R0,[R1, #+0]
    309            LPC_IOCON->P1_30  |= 0x0a;                    //xuliang 2011-10-20
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable11_12  ;; 0x4002c0f8
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF050 0x000A      ORRS     R0,R0,#0xA
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable11_12  ;; 0x4002c0f8
   \   00000060   0x6008             STR      R0,[R1, #+0]
    310          
    311            LPC_IOCON->P0_13  &= ~0x07;   /* USB_LED */
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable11_13  ;; 0x4002c034
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x08C0             LSRS     R0,R0,#+3
   \   0000006A   0x00C0             LSLS     R0,R0,#+3
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable11_13  ;; 0x4002c034
   \   00000070   0x6008             STR      R0,[R1, #+0]
    312            LPC_IOCON->P0_13  |= 0x1;
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable11_13  ;; 0x4002c034
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable11_13  ;; 0x4002c034
   \   00000080   0x6008             STR      R0,[R1, #+0]
    313          
    314            LPC_SC->PCONP |= (1UL<<31);                /* USB PCLK -> enable USB Per.       */
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x400fc0c4
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x400fc0c4
   \   00000090   0x6008             STR      R0,[R1, #+0]
    315          
    316            LPC_USB->USBClkCtrl = 0x1A;                /* Dev, OTG, AHB clock enable */
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x2008cff4
   \   00000096   0x211A             MOVS     R1,#+26
   \   00000098   0x6001             STR      R1,[R0, #+0]
    317            while ((LPC_USB->USBClkSt & 0x1A) != 0x1A);
   \                     ??USB_HwInit_0:
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x2008cff8
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF010 0x001A      ANDS     R0,R0,#0x1A
   \   000000A4   0x281A             CMP      R0,#+26
   \   000000A6   0xD1F8             BNE.N    ??USB_HwInit_0
    318          
    319            /* Port Select register when USB device is configured. */
    320            LPC_USB->StCtrl = 0x3;
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x2008c110
   \   000000AC   0x2103             MOVS     R1,#+3
   \   000000AE   0x6001             STR      R1,[R0, #+0]
    321            
    322            // Disable USB interrupts
    323            USBINTS_bit.EN_USB_INTS = 0;
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x400fc1c0
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x0040             LSLS     R0,R0,#+1        ;; ZeroExtS R0,R0,#+1,#+1
   \   000000B8   0x0840             LSRS     R0,R0,#+1
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable12_5  ;; 0x400fc1c0
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    324          
    325            // Disconnect device
    326            USB_ConnectRes(FALSE);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       USB_ConnectRes
    327          
    328            // enable suspend mode AP_CLK = 0
    329            USB_Cmd(CMD_USB_SET_MODE,0);    // init to default value
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0x20F3             MOVS     R0,#+243
   \   000000CA   0x.... 0x....      BL       USB_Cmd
    330          
    331            // Set address 0
    332            USB_SetDefAdd();
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x.... 0x....      BL       USB_SetAdd
    333            // clear all pending interrupts
    334            LPC_USB->EpIntClr = 0xFFFFFFFF;
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable11_8  ;; 0x2008c238
   \   000000D8   0xF05F 0x31FF      MOVS     R1,#-1
   \   000000DC   0x6001             STR      R1,[R0, #+0]
    335            // Init controls endpoints
    336            USB_HwReset();
   \   000000DE   0x.... 0x....      BL       USB_HwReset
    337            // Init Device status
    338            UsbSetDevState(UsbDevStatusUnknow);
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x.... 0x....      BL       UsbSetDevState
    339            // Init Device state var
    340            USB_DevStatus.Data = USB_Cmd(CMD_USB_GET_DEV_STAT,0);
   \   000000E8   0x2100             MOVS     R1,#+0
   \   000000EA   0x20FE             MOVS     R0,#+254
   \   000000EC   0x.... 0x....      BL       USB_Cmd
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
    341          
    342            // Enable USB interrupts
    343            // USB interrupt connect to VIC
    344            // USB interrupt enable
    345            ///NVIC_IntEnable(NVIC_USB);
    346            ///NVIC_IntPri(NVIC_USB,USB_INTR_PRIORITY);
    347            NVIC_EnableIRQ(USB_IRQn);               /* enable USB interrupt */
   \   000000F6   0x2018             MOVS     R0,#+24
   \   000000F8   0x.... 0x....      BL       NVIC_EnableIRQ
    348            ///NVIC_IntPri(USB_IRQn,USB_INTR_PRIORITY);
    349            NVIC_SetPriority(USB_IRQn,USB_INTR_PRIORITY);
   \   000000FC   0x2100             MOVS     R1,#+0
   \   000000FE   0x2018             MOVS     R0,#+24
   \   00000100   0x.... 0x....      BL       NVIC_SetPriority
    350            USBINTS_bit.EN_USB_INTS = 1;
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x400fc1c0
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable12_5  ;; 0x400fc1c0
   \   00000112   0x6008             STR      R0,[R1, #+0]
    351          }
   \   00000114   0xBD01             POP      {R0,PC}          ;; return
   \   00000116                      REQUIRE _A_USBINTS
    352          
    353          /*************************************************************************
    354           * Function Name: USB_HwReset
    355           * Parameters: none
    356           *
    357           * Return: none
    358           *
    359           * Description: Reset USB engine
    360           *
    361           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    362          void USB_HwReset (void)
    363          {
   \                     USB_HwReset:
   \   00000000   0xB580             PUSH     {R7,LR}
    364           // unsigned int i;
    365            // Disable all endpoint interrupts
    366            LPC_USB->EpIntEn  = 0;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x2008c234
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6001             STR      R1,[R0, #+0]
    367            // Assign high priority interrupt line
    368            LPC_USB->EpIntPri = USB_DEV_PRIORITY;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x2008c240
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6001             STR      R1,[R0, #+0]
    369            // USB_Configure
    370            USB_Configure(FALSE);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       USB_Configure
    371            // Set EP priority
    372            LPC_USB->EpIntPri = USB_EP_PRIORITY;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x2008c240
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    373            // Control EP Init
    374            USB_RealizeEp(&USB_CtrlEpDescr0,&USB_CtrlEpExtDescr0,TRUE);
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable12_10
   \   0000002A   0x.... 0x....      BL       USB_RealizeEp
    375            USB_RealizeEp(&USB_CtrlEpDescr1,&USB_CtrlEpExtDescr1,TRUE);
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable12_11
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable12_12
   \   00000038   0x.... 0x....      BL       USB_RealizeEp
    376          
    377          #if USB_DMA_DD_MAX_NUMB > 0
    378            // Disable All DMA interrupts
    379            LPC_USB->DMAIntEn     = 0;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable12_13  ;; 0x2008c294
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6001             STR      R1,[R0, #+0]
    380            // DMA Disable
    381            LPC_USB->EpDMADis     = 0xFFFFFFFF;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable12_14  ;; 0x2008c28c
   \   00000048   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    382            // DMA Request clear
    383            LPC_USB->DMARClr      = 0xFFFFFFFF;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable12_15  ;; 0x2008c254
   \   00000052   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000056   0x6001             STR      R1,[R0, #+0]
    384            // End of Transfer Interrupt Clear
    385            LPC_USB->EoTIntClr    = 0xFFFFFFFF;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable12_16  ;; 0x2008c2a4
   \   0000005C   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000060   0x6001             STR      R1,[R0, #+0]
    386            // New DD Request Interrupt Clear
    387            LPC_USB->NDDRIntClr   = 0xFFFFFFFF;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable12_17  ;; 0x2008c2b0
   \   00000066   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000006A   0x6001             STR      R1,[R0, #+0]
    388            // System Error Interrupt Clear
    389            LPC_USB->SysErrIntClr = 0xFFFFFFFF;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable12_18  ;; 0x2008c2bc
   \   00000070   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000074   0x6001             STR      R1,[R0, #+0]
    390          
    391            for(Int32U i = 0; i < ENP_MAX_NUMB; ++i)
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??USB_HwReset_0:
   \   00000078   0x2820             CMP      R0,#+32
   \   0000007A   0xD206             BCS.N    ??USB_HwReset_1
    392            {
    393              USB_DDCA[i] = NULL;
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable12_19
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    394            }
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0xE7F6             B.N      ??USB_HwReset_0
    395           
    396            for(Int32U i = 0; i < USB_DMA_DD_MAX_NUMB; ++i)
   \                     ??USB_HwReset_1:
   \   0000008A   0x2000             MOVS     R0,#+0
   \                     ??USB_HwReset_2:
   \   0000008C   0x2802             CMP      R0,#+2
   \   0000008E   0xD20A             BCS.N    ??USB_HwReset_3
    397            {
    398              DmaFree[i] = &USB_DmaDesc[i];
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable12_20
   \   00000094   0x2214             MOVS     R2,#+20
   \   00000096   0x.... 0x....      LDR.W    R3,??DataTable12_21
   \   0000009A   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   0000009E   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    399            }
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \   000000A4   0xE7F2             B.N      ??USB_HwReset_2
    400          
    401          #if USB_DMA_ID_MAX_NUMB > 0
    402            for(Int32U i = 0; i < USB_DMA_ID_MAX_NUMB; ++i)
    403            {
    404              DmaIsoFree[i] = &USB_DmaIsoDesc[i];
    405            }
    406          #endif // USB_DMA_ID_MAX_NUMB > 0
    407          
    408            // Set USB UDCA Head register
    409            LPC_USB->UDCAH = (Int32U)&USB_DDCA;
   \                     ??USB_HwReset_3:
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable12_22  ;; 0x2008c280
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable12_19
   \   000000AE   0x6001             STR      R1,[R0, #+0]
    410            // Enable DMA interrupts
    411            LPC_USB->DMAIntEn = DMA_INT_ENABLE_MASK;
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable12_13  ;; 0x2008c294
   \   000000B4   0x2105             MOVS     R1,#+5
   \   000000B6   0x6001             STR      R1,[R0, #+0]
    412          #else
    413            LPC_USB->EpDMADis = 0xFFFFFFFF;
    414          #endif
    415          
    416            // Enable Device interrupts
    417            LPC_USB->DevIntEn = bmUSB_SlowInterrupt | bmUSB_DevStatusInterrupt |
    418                         (2==USB_DEV_PRIORITY ? bmUSB_FastInterrupt  : 0)|
    419                         (USB_SOF_EVENT       ? bmUSB_FrameInterrupt : 0)|
    420                         (USB_ERROR_EVENT     ? bmUSB_ErrorInterrupt : 0);
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable12_23  ;; 0x2008c204
   \   000000BC   0xF44F 0x7103      MOV      R1,#+524
   \   000000C0   0x6001             STR      R1,[R0, #+0]
    421          
    422          }
   \   000000C2   0xBD01             POP      {R0,PC}          ;; return
    423          
    424          /*************************************************************************
    425           * Function Name: USB_RealizeEp
    426           * Parameters: const UsbStandardEpDescriptor_t * pEP_Desc,
    427           *             const UsbEP_ExtData_t * pUsbEP_ExtData,
    428           *             Boolean Enable
    429           *
    430           * Return: USB_ErrorCodes_t
    431           *
    432           * Description: Enable or disable an endpoint
    433           *
    434           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    435          USB_ErrorCodes_t USB_RealizeEp(const UsbStandardEpDescriptor_t * pEP_Desc,
    436                                         const UsbEP_ExtData_t * pUsbEP_ExtData,
    437                                         Boolean Enable)
    438          {
   \                     USB_RealizeEp:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    439          USB_Endpoint_t EP = (USB_Endpoint_t)USB_EpLogToPhysAdd(pEP_Desc->bEndpointAddress);
   \   00000008   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000A   0x.... 0x....      BL       USB_EpLogToPhysAdd
   \   0000000E   0x0001             MOVS     R1,R0
    440          Int32U Mask = (1 << EP);
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xFA10 0xF201      LSLS     R2,R0,R1
    441          #if USB_DMA_DD_MAX_NUMB > 0
    442          Int32U i;
    443          #if USB_DMA_ID_MAX_NUMB > 0
    444          Int32U j;
    445          #endif // USB_DMA_ID_MAX_NUMB > 0
    446          #endif // USB_DMA_DD_MAX_NUMB > 0
    447            if (Enable)
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xF000 0x8142      BEQ.W    ??USB_RealizeEp_0
    448            {
    449              // Set EP status
    450              EpCnfg[EP].Status  = NOT_READY;
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0x2024             MOVS     R0,#+36
   \   00000020   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   00000024   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   00000028   0x2700             MOVS     R7,#+0
   \   0000002A   0x7507             STRB     R7,[R0, #+20]
    451              // Init EP flags
    452              EpCnfg[EP].Flags = 0;
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x2024             MOVS     R0,#+36
   \   00000030   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   00000034   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   00000038   0x2700             MOVS     R7,#+0
   \   0000003A   0x7747             STRB     R7,[R0, #+29]
    453              EpCnfg[EP].bDMA_Transfer  = pUsbEP_ExtData->DMA_Transfer;
   \   0000003C   0x6828             LDR      R0,[R5, #+0]
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0x2724             MOVS     R7,#+36
   \   00000042   0x.... 0x....      LDR.W    R12,??DataTable12_24
   \   00000046   0xFB07 0xC701      MLA      R7,R7,R1,R12
   \   0000004A   0x7F7F             LDRB     R7,[R7, #+29]
   \   0000004C   0xF360 0x0741      BFI      R7,R0,#+1,#+1
   \   00000050   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000052   0x2024             MOVS     R0,#+36
   \   00000054   0x.... 0x....      LDR.W    R12,??DataTable12_24
   \   00000058   0xFB00 0xC001      MLA      R0,R0,R1,R12
   \   0000005C   0x7747             STRB     R7,[R0, #+29]
    454              EpCnfg[EP].bDoubleBuffered = UsbEpDoubleBuffType[EP];
   \   0000005E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable12_25
   \   00000064   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000068   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006A   0x2724             MOVS     R7,#+36
   \   0000006C   0x.... 0x....      LDR.W    R12,??DataTable12_24
   \   00000070   0xFB07 0xC701      MLA      R7,R7,R1,R12
   \   00000074   0x7F7F             LDRB     R7,[R7, #+29]
   \   00000076   0xF360 0x0700      BFI      R7,R0,#+0,#+1
   \   0000007A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007C   0x2024             MOVS     R0,#+36
   \   0000007E   0x.... 0x....      LDR.W    R12,??DataTable12_24
   \   00000082   0xFB00 0xC001      MLA      R0,R0,R1,R12
   \   00000086   0x7747             STRB     R7,[R0, #+29]
    455              // Set endpoint type
    456              EpCnfg[EP].EpType = (UsbEpTransferType_t)pEP_Desc->bmAttributes.TransferType;
   \   00000088   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008A   0x2024             MOVS     R0,#+36
   \   0000008C   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   00000090   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   00000094   0x78E7             LDRB     R7,[R4, #+3]
   \   00000096   0xF017 0x0703      ANDS     R7,R7,#0x3
   \   0000009A   0x7107             STRB     R7,[R0, #+4]
    457              // Init EP max packet size
    458              EpCnfg[EP].MaxSize = pEP_Desc->wMaxPacketSize;
   \   0000009C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009E   0x2024             MOVS     R0,#+36
   \   000000A0   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   000000A4   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   000000A8   0x88A7             LDRH     R7,[R4, #+4]
   \   000000AA   0x6007             STR      R7,[R0, #+0]
    459            #if USB_DMA_DD_MAX_NUMB > 0
    460              if(EpCnfg[EP].bDMA_Transfer)
   \   000000AC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AE   0x2024             MOVS     R0,#+36
   \   000000B0   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   000000B4   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   000000B8   0x7F40             LDRB     R0,[R0, #+29]
   \   000000BA   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xF000 0x80A1      BEQ.W    ??USB_RealizeEp_1
    461              {
    462                // search of not used DMA Descriptor
    463                for (i = 0; USB_DMA_DD_MAX_NUMB > i; ++i)
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x0003             MOVS     R3,R0
   \                     ??USB_RealizeEp_2:
   \   000000CA   0x2B02             CMP      R3,#+2
   \   000000CC   0xD207             BCS.N    ??USB_RealizeEp_3
    464                {
    465                  if(DmaFree[i] != NULL)
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable12_20
   \   000000D2   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD101             BNE.N    ??USB_RealizeEp_3
    466                  {
    467                    break;
    468                  }
    469                }
   \                     ??USB_RealizeEp_4:
   \   000000DA   0x1C5B             ADDS     R3,R3,#+1
   \   000000DC   0xE7F5             B.N      ??USB_RealizeEp_2
    470                if(USB_DMA_DD_MAX_NUMB <= i)
   \                     ??USB_RealizeEp_3:
   \   000000DE   0x2B02             CMP      R3,#+2
   \   000000E0   0xD301             BCC.N    ??USB_RealizeEp_5
    471                {
    472                  return (USB_DMA_DESC_OVERFLOW);
   \   000000E2   0x200B             MOVS     R0,#+11
   \   000000E4   0xE11F             B.N      ??USB_RealizeEp_6
    473                }
    474          
    475              #if USB_DMA_ID_MAX_NUMB > 0
    476                if(UsbEpTransferIsochronous == EpCnfg[EP].EpType)
    477                {
    478          
    479                  // search of not used DMA Iso Descriptor
    480                  for (j = 0; USB_DMA_ID_MAX_NUMB > j; ++j)
    481                  {
    482                    if(DmaIsoFree[j] != NULL)
    483                    {
    484                      break;
    485                    }
    486                  }
    487                  if(USB_DMA_ID_MAX_NUMB <= j)
    488                  {
    489                    return (USB_DMA_DESC_OVERFLOW);
    490                  }
    491                  USB_DmaDesc[i].Isochronous = 1;
    492                  EpCnfg[EP].pDmaIsoPacket = DmaIsoFree[j];
    493                  DmaIsoFree[j] = NULL;
    494                }
    495                else
    496                {
    497                  USB_DmaDesc[i].Isochronous = 0;
    498                  EpCnfg[EP].pDmaIsoPacket = NULL;
    499                }
    500              #else
    501                USB_DmaDesc[i].Isochronous = 0;
   \                     ??USB_RealizeEp_5:
   \   000000E6   0x2014             MOVS     R0,#+20
   \   000000E8   0x.... 0x....      LDR.W    R7,??DataTable12_21
   \   000000EC   0xFB00 0x7003      MLA      R0,R0,R3,R7
   \   000000F0   0x6840             LDR      R0,[R0, #+4]
   \   000000F2   0xF030 0x0010      BICS     R0,R0,#0x10
   \   000000F6   0x2714             MOVS     R7,#+20
   \   000000F8   0x.... 0x....      LDR.W    R12,??DataTable12_21
   \   000000FC   0xFB07 0xC703      MLA      R7,R7,R3,R12
   \   00000100   0x6078             STR      R0,[R7, #+4]
    502              #endif // USB_DMA_DD_MAX_NUMB > 0
    503          
    504                // Set DD
    505                USB_DDCA[EP] = EpCnfg[EP].pUSB_DmaDesc = DmaFree[i];
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable12_20
   \   00000106   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \   0000010A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000010C   0x2724             MOVS     R7,#+36
   \   0000010E   0x.... 0x....      LDR.W    R12,??DataTable12_24
   \   00000112   0xFB07 0xC701      MLA      R7,R7,R1,R12
   \   00000116   0x6238             STR      R0,[R7, #+32]
   \   00000118   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011A   0x.... 0x....      LDR.W    R7,??DataTable12_19
   \   0000011E   0xF847 0x0021      STR      R0,[R7, R1, LSL #+2]
    506                DmaFree[i] = NULL;
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable12_20
   \   00000126   0x2700             MOVS     R7,#+0
   \   00000128   0xF840 0x7023      STR      R7,[R0, R3, LSL #+2]
    507          
    508                EpCnfg[EP].pUSB_DmaDesc->pNextDD        = NULL;
   \   0000012C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000012E   0x2024             MOVS     R0,#+36
   \   00000130   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   00000134   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   00000138   0x6A00             LDR      R0,[R0, #+32]
   \   0000013A   0x2700             MOVS     R7,#+0
   \   0000013C   0x6007             STR      R7,[R0, #+0]
    509                EpCnfg[EP].pUSB_DmaDesc->NextDDValid    = FALSE;
   \   0000013E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000140   0x2024             MOVS     R0,#+36
   \   00000142   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   00000146   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   0000014A   0x6A00             LDR      R0,[R0, #+32]
   \   0000014C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000014E   0x2724             MOVS     R7,#+36
   \   00000150   0x.... 0x....      LDR.W    R12,??DataTable12_24
   \   00000154   0xFB07 0xC701      MLA      R7,R7,R1,R12
   \   00000158   0x6A3F             LDR      R7,[R7, #+32]
   \   0000015A   0x687F             LDR      R7,[R7, #+4]
   \   0000015C   0xF037 0x0704      BICS     R7,R7,#0x4
   \   00000160   0x6047             STR      R7,[R0, #+4]
    510                EpCnfg[EP].pUSB_DmaDesc->DmaMode        = UsbDmaNormalMode;
   \   00000162   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000164   0x2024             MOVS     R0,#+36
   \   00000166   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   0000016A   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   0000016E   0x6A00             LDR      R0,[R0, #+32]
   \   00000170   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000172   0x2724             MOVS     R7,#+36
   \   00000174   0x.... 0x....      LDR.W    R12,??DataTable12_24
   \   00000178   0xFB07 0xC701      MLA      R7,R7,R1,R12
   \   0000017C   0x6A3F             LDR      R7,[R7, #+32]
   \   0000017E   0x687F             LDR      R7,[R7, #+4]
   \   00000180   0x08BF             LSRS     R7,R7,#+2
   \   00000182   0x00BF             LSLS     R7,R7,#+2
   \   00000184   0x6047             STR      R7,[R0, #+4]
    511                EpCnfg[EP].pUSB_DmaDesc->pDmaBuffer     = NULL;
   \   00000186   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000188   0x2024             MOVS     R0,#+36
   \   0000018A   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   0000018E   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   00000192   0x6A00             LDR      R0,[R0, #+32]
   \   00000194   0x2700             MOVS     R7,#+0
   \   00000196   0x6087             STR      R7,[R0, #+8]
    512                EpCnfg[EP].pUSB_DmaDesc->DmaBufferLegtn = 0;
   \   00000198   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000019A   0x2024             MOVS     R0,#+36
   \   0000019C   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   000001A0   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   000001A4   0x6A00             LDR      R0,[R0, #+32]
   \   000001A6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001A8   0x2724             MOVS     R7,#+36
   \   000001AA   0x.... 0x....      LDR.W    R12,??DataTable12_24
   \   000001AE   0xFB07 0xC701      MLA      R7,R7,R1,R12
   \   000001B2   0x6A3F             LDR      R7,[R7, #+32]
   \   000001B4   0x687F             LDR      R7,[R7, #+4]
   \   000001B6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001B8   0x6047             STR      R7,[R0, #+4]
    513                EpCnfg[EP].pUSB_DmaDesc->MaxPacketSize  = EpCnfg[EP].MaxSize;
   \   000001BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001BC   0x2024             MOVS     R0,#+36
   \   000001BE   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   000001C2   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   000001C6   0x6A00             LDR      R0,[R0, #+32]
   \   000001C8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001CA   0x2724             MOVS     R7,#+36
   \   000001CC   0x.... 0x....      LDR.W    R12,??DataTable12_24
   \   000001D0   0xFB07 0xC701      MLA      R7,R7,R1,R12
   \   000001D4   0x683F             LDR      R7,[R7, #+0]
   \   000001D6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001D8   0xF05F 0x0C24      MOVS     R12,#+36
   \   000001DC   0x.... 0x....      LDR.W    LR,??DataTable12_24
   \   000001E0   0xFB0C 0xEC01      MLA      R12,R12,R1,LR
   \   000001E4   0xF8DC 0xC020      LDR      R12,[R12, #+32]
   \   000001E8   0xF8DC 0xC004      LDR      R12,[R12, #+4]
   \   000001EC   0xF367 0x1C4F      BFI      R12,R7,#+5,#+11
   \   000001F0   0xF8C0 0xC004      STR      R12,[R0, #+4]
    514                EpCnfg[EP].pUSB_DmaDesc->Status         = UsbDmaNoServiced;
   \   000001F4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001F6   0x2024             MOVS     R0,#+36
   \   000001F8   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   000001FC   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   00000200   0x6A00             LDR      R0,[R0, #+32]
   \   00000202   0x2700             MOVS     R7,#+0
   \   00000204   0x60C7             STR      R7,[R0, #+12]
   \   00000206   0xE004             B.N      ??USB_RealizeEp_7
    515              }
    516              else
    517              {
    518                // Disable DMA Transfer
    519                LPC_USB->EpDMADis = 1UL << EP;
   \                     ??USB_RealizeEp_1:
   \   00000208   0x2001             MOVS     R0,#+1
   \   0000020A   0x4088             LSLS     R0,R0,R1
   \   0000020C   0x.... 0x....      LDR.W    R7,??DataTable12_14  ;; 0x2008c28c
   \   00000210   0x6038             STR      R0,[R7, #+0]
    520              }
    521            #else
    522              // Disable DMA Transfer
    523              LPC_USB->EpDMADis = 1UL << EP;
    524            #endif // USB_DMA_DD_MAX_NUMB > 0
    525          
    526              if (EP & 1)
   \                     ??USB_RealizeEp_7:
   \   00000212   0x07C8             LSLS     R0,R1,#+31
   \   00000214   0xD511             BPL.N    ??USB_RealizeEp_8
    527              {
    528                EpCnfg[EP].AvbBuff = EpCnfg[EP].bDoubleBuffered + 1;
   \   00000216   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000218   0x2024             MOVS     R0,#+36
   \   0000021A   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   0000021E   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   00000222   0x7F40             LDRB     R0,[R0, #+29]
   \   00000224   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000228   0x1C40             ADDS     R0,R0,#+1
   \   0000022A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000022C   0x2724             MOVS     R7,#+36
   \   0000022E   0x.... 0x....      LDR.W    R12,??DataTable12_24
   \   00000232   0xFB07 0xC701      MLA      R7,R7,R1,R12
   \   00000236   0x7738             STRB     R0,[R7, #+28]
   \   00000238   0xE007             B.N      ??USB_RealizeEp_9
    529              }
    530              else
    531              {
    532                EpCnfg[EP].AvbBuff = 0;
   \                     ??USB_RealizeEp_8:
   \   0000023A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000023C   0x2024             MOVS     R0,#+36
   \   0000023E   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   00000242   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   00000246   0x2700             MOVS     R7,#+0
   \   00000248   0x7707             STRB     R7,[R0, #+28]
    533              }
    534          
    535              // Clear  Realize interrupt bit
    536              LPC_USB->DevIntClr = bmUSB_EPRealizeInterrupt;
   \                     ??USB_RealizeEp_9:
   \   0000024A   0x....             LDR.N    R0,??DataTable11_4  ;; 0x2008c208
   \   0000024C   0xF44F 0x7780      MOV      R7,#+256
   \   00000250   0x6007             STR      R7,[R0, #+0]
    537              // Realize endpoint
    538              LPC_USB->ReEp |= Mask;
   \   00000252   0x.... 0x....      LDR.W    R0,??DataTable12_26  ;; 0x2008c244
   \   00000256   0x6800             LDR      R0,[R0, #+0]
   \   00000258   0x4310             ORRS     R0,R2,R0
   \   0000025A   0x.... 0x....      LDR.W    R7,??DataTable12_26  ;; 0x2008c244
   \   0000025E   0x6038             STR      R0,[R7, #+0]
    539              // Set endpoint maximum packet size
    540              LPC_USB->EpInd     = EP;
   \   00000260   0x.... 0x....      LDR.W    R0,??DataTable12_27  ;; 0x2008c248
   \   00000264   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000266   0x6001             STR      R1,[R0, #+0]
    541              LPC_USB->MaxPSize = pEP_Desc->wMaxPacketSize;
   \   00000268   0x88A0             LDRH     R0,[R4, #+4]
   \   0000026A   0x.... 0x....      LDR.W    R7,??DataTable12_28  ;; 0x2008c24c
   \   0000026E   0x6038             STR      R0,[R7, #+0]
    542              // Wait for Realize complete
    543              while ((LPC_USB->DevIntSt & bmUSB_EPRealizeInterrupt) == 0);
   \                     ??USB_RealizeEp_10:
   \   00000270   0x....             LDR.N    R0,??DataTable11_6  ;; 0x2008c200
   \   00000272   0x6800             LDR      R0,[R0, #+0]
   \   00000274   0x05C0             LSLS     R0,R0,#+23
   \   00000276   0xD5FB             BPL.N    ??USB_RealizeEp_10
    544          
    545              if(0 == EpCnfg[EP].bDMA_Transfer)
   \   00000278   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000027A   0x2024             MOVS     R0,#+36
   \   0000027C   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   00000280   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   00000284   0x7F40             LDRB     R0,[R0, #+29]
   \   00000286   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000028A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000028C   0x2800             CMP      R0,#+0
   \   0000028E   0xD149             BNE.N    ??USB_RealizeEp_11
    546              {
    547                // Enable endpoint interrupt
    548                LPC_USB->EpIntEn |= Mask;
   \   00000290   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x2008c234
   \   00000294   0x6800             LDR      R0,[R0, #+0]
   \   00000296   0x4310             ORRS     R0,R2,R0
   \   00000298   0x.... 0x....      LDR.W    R7,??DataTable12_7  ;; 0x2008c234
   \   0000029C   0x6038             STR      R0,[R7, #+0]
   \   0000029E   0xE041             B.N      ??USB_RealizeEp_11
    549              }
    550            }
    551            else
    552            {
    553              // Disable relevant endpoint and interrupt
    554              LPC_USB->ReEp    &= ~Mask;
   \                     ??USB_RealizeEp_0:
   \   000002A0   0x.... 0x....      LDR.W    R0,??DataTable12_26  ;; 0x2008c244
   \   000002A4   0x6800             LDR      R0,[R0, #+0]
   \   000002A6   0x4390             BICS     R0,R0,R2
   \   000002A8   0x.... 0x....      LDR.W    R7,??DataTable12_26  ;; 0x2008c244
   \   000002AC   0x6038             STR      R0,[R7, #+0]
    555              LPC_USB->EpIntEn &= ~Mask;
   \   000002AE   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x2008c234
   \   000002B2   0x6800             LDR      R0,[R0, #+0]
   \   000002B4   0x4390             BICS     R0,R0,R2
   \   000002B6   0x.... 0x....      LDR.W    R7,??DataTable12_7  ;; 0x2008c234
   \   000002BA   0x6038             STR      R0,[R7, #+0]
    556              // Disable DMA Transfer
    557              LPC_USB->EpDMADis = Mask;
   \   000002BC   0x.... 0x....      LDR.W    R0,??DataTable12_14  ;; 0x2008c28c
   \   000002C0   0x6002             STR      R2,[R0, #+0]
    558              EpCnfg[EP].MaxSize = 0;
   \   000002C2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002C4   0x2024             MOVS     R0,#+36
   \   000002C6   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   000002CA   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   000002CE   0x2700             MOVS     R7,#+0
   \   000002D0   0x6007             STR      R7,[R0, #+0]
    559          
    560          #if USB_DMA_DD_MAX_NUMB > 0
    561              // relase DMA Descriptor
    562              if(NULL != EpCnfg[EP].pUSB_DmaDesc)
   \   000002D2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002D4   0x2024             MOVS     R0,#+36
   \   000002D6   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   000002DA   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   000002DE   0x6A00             LDR      R0,[R0, #+32]
   \   000002E0   0x2800             CMP      R0,#+0
   \   000002E2   0xD01F             BEQ.N    ??USB_RealizeEp_11
    563              {
    564                for (i = 0; USB_DMA_DD_MAX_NUMB > i; ++i)
   \   000002E4   0x2000             MOVS     R0,#+0
   \   000002E6   0x0003             MOVS     R3,R0
   \                     ??USB_RealizeEp_12:
   \   000002E8   0x2B02             CMP      R3,#+2
   \   000002EA   0xD21B             BCS.N    ??USB_RealizeEp_11
    565                {
    566                  if(DmaFree[i] == NULL)
   \   000002EC   0x.... 0x....      LDR.W    R0,??DataTable12_20
   \   000002F0   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \   000002F4   0x2800             CMP      R0,#+0
   \   000002F6   0xD113             BNE.N    ??USB_RealizeEp_13
    567                  {
    568                    DmaFree[i] = EpCnfg[EP].pUSB_DmaDesc;
   \   000002F8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002FA   0x2024             MOVS     R0,#+36
   \   000002FC   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   00000300   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   00000304   0x6A00             LDR      R0,[R0, #+32]
   \   00000306   0x.... 0x....      LDR.W    R7,??DataTable12_20
   \   0000030A   0xF847 0x0023      STR      R0,[R7, R3, LSL #+2]
    569                    EpCnfg[EP].pUSB_DmaDesc = NULL;
   \   0000030E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000310   0x2024             MOVS     R0,#+36
   \   00000312   0x.... 0x....      LDR.W    R7,??DataTable12_24
   \   00000316   0xFB00 0x7001      MLA      R0,R0,R1,R7
   \   0000031A   0x2700             MOVS     R7,#+0
   \   0000031C   0x6207             STR      R7,[R0, #+32]
    570                    break;
   \   0000031E   0xE001             B.N      ??USB_RealizeEp_11
    571                  }
    572                }
   \                     ??USB_RealizeEp_13:
   \   00000320   0x1C5B             ADDS     R3,R3,#+1
   \   00000322   0xE7E1             B.N      ??USB_RealizeEp_12
    573              }
    574          #if USB_DMA_ID_MAX_NUMB > 0
    575              // relase DMA Iso Descriptor
    576              if(NULL != EpCnfg[EP].pDmaIsoPacket)
    577              {
    578                for (i = 0; USB_DMA_ID_MAX_NUMB > i; ++i)
    579                {
    580                  if(DmaIsoFree[i] == NULL)
    581                  {
    582                    DmaIsoFree[i] = EpCnfg[EP].pDmaIsoPacket;
    583                    EpCnfg[EP].pDmaIsoPacket = NULL;
    584                    break;
    585                  }
    586                }
    587              }
    588          #endif // USB_DMA_ID_MAX_NUMB > 0
    589          #endif // USB_DMA_DD_MAX_NUMB > 0
    590            }
    591            return(USB_OK);
   \                     ??USB_RealizeEp_11:
   \   00000324   0x2000             MOVS     R0,#+0
   \                     ??USB_RealizeEp_6:
   \   00000326   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    592          }
    593          
    594          /*************************************************************************
    595           * Function Name: USB_SetAdd
    596           * Parameters: Int32U DevAdd - device address between 0 - 127
    597           *
    598           * Return: none
    599           *
    600           * Description: Set device address
    601           *
    602           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    603          void USB_SetAdd(Int32U DevAdd)
    604          {
   \                     USB_SetAdd:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    605            USB_Cmd(CMD_USB_SET_ADDRESS,DevAdd | 0x80);
   \   00000004   0xF054 0x0180      ORRS     R1,R4,#0x80
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x20D0             MOVS     R0,#+208
   \   0000000C   0x.... 0x....      BL       USB_Cmd
    606            USB_Cmd(CMD_USB_SET_ADDRESS,DevAdd | 0x80);
   \   00000010   0xF054 0x0180      ORRS     R1,R4,#0x80
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x20D0             MOVS     R0,#+208
   \   00000018   0x.... 0x....      BL       USB_Cmd
    607          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    608          
    609          /*************************************************************************
    610           * Function Name: USB_ConnectRes
    611           * Parameters: Boolean Conn
    612           *
    613           * Return: none
    614           *
    615           * Description: Connect USB
    616           *
    617           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    618          void USB_ConnectRes (Boolean Conn)
    619          {
   \                     USB_ConnectRes:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    620            USB_Cmd(CMD_USB_SET_DEV_STAT, (Conn ? bmUSB_Connect : 0));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD001             BEQ.N    ??USB_ConnectRes_0
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xE000             B.N      ??USB_ConnectRes_1
   \                     ??USB_ConnectRes_0:
   \   0000000C   0x2100             MOVS     R1,#+0
   \                     ??USB_ConnectRes_1:
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0xF44F 0x70FF      MOV      R0,#+510
   \   00000014   0x.... 0x....      BL       USB_Cmd
    621          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    622          
    623          /*************************************************************************
    624           * Function Name: USB_Configure
    625           * Parameters: Boolean Configure
    626           *
    627           * Return: none
    628           *
    629           * Description: Configure device
    630           *              When Configure != 0 enable all Realize Ep
    631           *
    632           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    633          void USB_Configure (Boolean Configure)
    634          {
   \                     USB_Configure:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    635            USB_Cmd(CMD_USB_CFG_DEV,Configure);
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x20D8             MOVS     R0,#+216
   \   0000000A   0x.... 0x....      BL       USB_Cmd
    636          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    637          
    638          #if USB_REMOTE_WAKEUP != 0
    639          /*************************************************************************
    640           * Function Name: USB_WakeUp
    641           * Parameters: none
    642           *
    643           * Return: none
    644           *
    645           * Description: Wake up USB
    646           *
    647           *************************************************************************/
    648          void USB_WakeUp (void)
    649          {
    650            USBCLKCTRL = (1<<1) |   // Device clk enable
    651                         (1<<4);    // AHB clk enable
    652          
    653            while((USBCLKST & ((1<<1) | (1<<4))) != ((1<<1) | (1<<4)));
    654            USB_Cmd(CMD_USB_SET_DEV_STAT,bmUSB_Connect);
    655          }
    656          #endif // USB_REMOTE_WAKEUP != 0
    657          
    658          /*************************************************************************
    659           * Function Name: USB_GetDevStatus
    660           * Parameters: USB_DevStatusReqType_t Type
    661           *
    662           * Return: Boolean
    663           *
    664           * Description: Return USB device status
    665           *
    666           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    667          Boolean USB_GetDevStatus (USB_DevStatusReqType_t Type)
    668          {
   \                     USB_GetDevStatus:
   \   00000000   0x0001             MOVS     R1,R0
    669            switch (Type)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD003             BEQ.N    ??USB_GetDevStatus_0
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xD00E             BEQ.N    ??USB_GetDevStatus_1
   \   0000000C   0xD306             BCC.N    ??USB_GetDevStatus_2
   \   0000000E   0xE013             B.N      ??USB_GetDevStatus_3
    670            {
    671            case USB_DevConnectStatus:
    672              return(USB_DevStatus.Connect);
   \                     ??USB_GetDevStatus_0:
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000001A   0xE00E             B.N      ??USB_GetDevStatus_4
    673            case USB_SuspendStatus:
    674              return(USB_DevStatus.Suspend);
   \                     ??USB_GetDevStatus_2:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xE007             B.N      ??USB_GetDevStatus_4
    675            case USB_ResetStatus:
    676              return(USB_DevStatus.Reset);
   \                     ??USB_GetDevStatus_1:
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE000             B.N      ??USB_GetDevStatus_4
    677            }
    678            return(FALSE);
   \                     ??USB_GetDevStatus_3:
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??USB_GetDevStatus_4:
   \   0000003A   0x4770             BX       LR               ;; return
    679          }
    680          
    681          /*************************************************************************
    682           * Function Name: USB_SetStallEP
    683           * Parameters: USB_Endpoint_t EndPoint, Boolean Stall
    684           *
    685           * Return: none
    686           *
    687           * Description: The endpoint stall/unstall
    688           *
    689           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    690          void USB_SetStallEP (USB_Endpoint_t EP, Boolean Stall)
    691          {
   \                     USB_SetStallEP:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    692          Boolean CurrStallStatus;
    693            assert((LPC_USB->ReEp & (1UL<<EP)));  // check whether is a realized EP
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable12_26  ;; 0x2008c244
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x40E0             LSRS     R0,R0,R4
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD409             BMI.N    ??USB_SetStallEP_0
   \   00000012   0xF240 0x22B5      MOVW     R2,#+693
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable12
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000001E   0x.... 0x....      BL       __aeabi_assert
   \   00000022   0x.... 0x....      BL       __iar_EmptyStepPoint
    694            USB_GetStallEP(EP,&CurrStallStatus);
   \                     ??USB_SetStallEP_0:
   \   00000026   0xA900             ADD      R1,SP,#+0
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       USB_GetStallEP
    695            if(CurrStallStatus != Stall)
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0x42A8             CMP      R0,R5
   \   00000034   0xD029             BEQ.N    ??USB_SetStallEP_1
    696            {
    697              if ((EP & 1) && !Stall)
   \   00000036   0x07E0             LSLS     R0,R4,#+31
   \   00000038   0xD513             BPL.N    ??USB_SetStallEP_2
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD111             BNE.N    ??USB_SetStallEP_2
    698              {
    699                EpCnfg[EP].AvbBuff = EpCnfg[EP].bDoubleBuffered+1;
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x2024             MOVS     R0,#+36
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000046   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000004A   0x7F40             LDRB     R0,[R0, #+29]
   \   0000004C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2124             MOVS     R1,#+36
   \   00000056   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   0000005A   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000005E   0x7708             STRB     R0,[R1, #+28]
   \   00000060   0xE007             B.N      ??USB_SetStallEP_3
    700              }
    701              else
    702              {
    703                EpCnfg[EP].AvbBuff = 0;
   \                     ??USB_SetStallEP_2:
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0x2024             MOVS     R0,#+36
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000006A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x7701             STRB     R1,[R0, #+28]
    704              }
    705              USB_Cmd(CMD_USB_SET_EP_STAT | EP, (Stall ? bmUSB_EpStall : 0));
   \                     ??USB_SetStallEP_3:
   \   00000072   0x2D00             CMP      R5,#+0
   \   00000074   0xD001             BEQ.N    ??USB_SetStallEP_4
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0xE000             B.N      ??USB_SetStallEP_5
   \                     ??USB_SetStallEP_4:
   \   0000007A   0x2100             MOVS     R1,#+0
   \                     ??USB_SetStallEP_5:
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0xF454 0x70A0      ORRS     R0,R4,#0x140
   \   00000084   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000086   0x.... 0x....      BL       USB_Cmd
    706            }
    707          }
   \                     ??USB_SetStallEP_1:
   \   0000008A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    708          
    709          /*************************************************************************
    710           * Function Name: USB_StallCtrlEP
    711           * Parameters: none
    712           *
    713           * Return: none
    714           *
    715           * Description: Stall both direction of the CTRL EP
    716           *
    717           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    718          void USB_StallCtrlEP (void)
    719          {
   \                     USB_StallCtrlEP:
   \   00000000   0xB580             PUSH     {R7,LR}
    720            EpCnfg[CTRL_ENP_OUT].AvbBuff = 0;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7701             STRB     R1,[R0, #+28]
    721            EpCnfg[CTRL_ENP_IN].AvbBuff  = EpCnfg[CTRL_ENP_IN].bDoubleBuffered + 1;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   0000000E   0xF890 0x0041      LDRB     R0,[R0, #+65]
   \   00000012   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000001C   0xF881 0x0040      STRB     R0,[R1, #+64]
    722            USB_Cmd(CMD_USB_SET_EP_STAT | CTRL_ENP_OUT, bmUSB_EpCondStall);
   \   00000020   0x2180             MOVS     R1,#+128
   \   00000022   0xF44F 0x70A0      MOV      R0,#+320
   \   00000026   0x.... 0x....      BL       USB_Cmd
    723          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    724          
    725          /*************************************************************************
    726           * Function Name: USB_GetStallEP
    727           * Parameters: USB_Endpoint_t EndPoint, pBoolean pStall
    728           *
    729           * Return: none
    730           *
    731           * Description: Get stall state of the endpoint
    732           *
    733           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    734          void USB_GetStallEP (USB_Endpoint_t EndPoint, pBoolean pStall)
    735          {
   \                     USB_GetStallEP:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    736            assert((LPC_USB->ReEp & (1UL<<EndPoint)));  // check whether is a realized EP
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable12_26  ;; 0x2008c244
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x40E0             LSRS     R0,R0,R4
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD409             BMI.N    ??USB_GetStallEP_0
   \   00000012   0xF44F 0x7238      MOV      R2,#+736
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable12
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   0000001E   0x.... 0x....      BL       __aeabi_assert
   \   00000022   0x.... 0x....      BL       __iar_EmptyStepPoint
    737            *pStall = (USB_Cmd(CMD_USB_SEL_EP | EndPoint, 0) & bmUSB_EpStallStatus) != 0;
   \                     ??USB_GetStallEP_0:
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0x.... 0x....      BL       USB_Cmd
   \   00000032   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000036   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000003A   0x6028             STR      R0,[R5, #+0]
    738          }
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    739          
    740          /*************************************************************************
    741           * Function Name: USB_EP_IO
    742           * Parameters: USB_Endpoint_t EndPoint
    743           *
    744           * Return: none
    745           *
    746           * Description: Endpoint Write (IN)
    747           *
    748           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    749          void USB_EP_IO(USB_Endpoint_t EP)
    750          {
   \                     USB_EP_IO:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    751          Int32U Data, Count;
    752          
    753            if(EpCnfg[EP].Status != BEGIN_SERVICED &&
    754               EpCnfg[EP].Status != NO_SERVICED)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2024             MOVS     R0,#+36
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000000C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000010   0x7D00             LDRB     R0,[R0, #+20]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD00B             BEQ.N    ??USB_EP_IO_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2024             MOVS     R0,#+36
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000001E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000022   0x7D00             LDRB     R0,[R0, #+20]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD002             BEQ.N    ??USB_EP_IO_0
    755            {
    756              volatile int dummu = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x9000             STR      R0,[SP, #+0]
    757              return;
   \   0000002C   0xE34E             B.N      ??USB_EP_IO_1
    758            }
    759            if(EP & 1)
   \                     ??USB_EP_IO_0:
   \   0000002E   0x07E0             LSLS     R0,R4,#+31
   \   00000030   0xF140 0x81BF      BPL.W    ??USB_EP_IO_2
    760            {
    761              // IN
    762            #if USB_DMA_DD_MAX_NUMB > 0
    763              if(EpCnfg[EP].bDMA_Transfer)
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2024             MOVS     R0,#+36
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000003C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000040   0x7F40             LDRB     R0,[R0, #+29]
   \   00000042   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD045             BEQ.N    ??USB_EP_IO_3
    764              {
    765                // Set Data buffer
    766                EpCnfg[EP].pUSB_DmaDesc->pDmaBuffer     = EpCnfg[EP].pBuffer;
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x2024             MOVS     R0,#+36
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000054   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000058   0x6A00             LDR      R0,[R0, #+32]
   \   0000005A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005C   0x2124             MOVS     R1,#+36
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   00000062   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000066   0x6989             LDR      R1,[R1, #+24]
   \   00000068   0x6081             STR      R1,[R0, #+8]
    767              #if USB_DMA_ID_MAX_NUMB > 0
    768                // Set Iso packet descrptor
    769                if(EpCnfg[EP].pUSB_DmaDesc->Isochronous)
    770                {
    771                  // Iso packet descriptor
    772                  EpCnfg[EP].pUSB_DmaDesc->pDmaIsoPacket = EpCnfg[EP].pDmaIsoPacket;
    773                  // Set Data size
    774                  EpCnfg[EP].pDmaIsoPacket->PacketLength = EpCnfg[EP].Size;
    775                  // Number of packets
    776                  EpCnfg[EP].pUSB_DmaDesc->DmaBufferLegtn = 1;
    777                }
    778                else
    779                {
    780                  // Set Data size
    781                  EpCnfg[EP].pUSB_DmaDesc->DmaBufferLegtn = EpCnfg[EP].Size;
    782                }
    783                // Set DMA status
    784                EpCnfg[EP].pUSB_DmaDesc->Status         = 0;
    785                // Enable DMA Transfer
    786                USBEPDMAEN = 1UL << EP;
    787                if(0 == EpCnfg[EP].pUSB_DmaDesc->Isochronous)
    788                {
    789                  // Trigger transfer
    790                  Int32U EpReg = USB_Cmd(CMD_USB_SEL_EP | EP,0);
    791                  if(0 == (EpReg & 0x60))
    792                  {
    793                    // Retrigger DMA Transfer
    794                    USBDMARSET = 1 << EP;
    795                  }
    796                }
    797              #else
    798                // Set Data size
    799                EpCnfg[EP].pUSB_DmaDesc->DmaBufferLegtn = EpCnfg[EP].Size;
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0x2024             MOVS     R0,#+36
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000072   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000076   0x6A00             LDR      R0,[R0, #+32]
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x2124             MOVS     R1,#+36
   \   0000007C   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   00000080   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000084   0x6909             LDR      R1,[R1, #+16]
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0x2224             MOVS     R2,#+36
   \   0000008A   0x.... 0x....      LDR.W    R3,??DataTable13_2
   \   0000008E   0xFB02 0x3204      MLA      R2,R2,R4,R3
   \   00000092   0x6A12             LDR      R2,[R2, #+32]
   \   00000094   0x6852             LDR      R2,[R2, #+4]
   \   00000096   0xF361 0x421F      BFI      R2,R1,#+16,#+16
   \   0000009A   0x6042             STR      R2,[R0, #+4]
    800                // Set DMA status
    801                EpCnfg[EP].pUSB_DmaDesc->Status         = 0;
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x2024             MOVS     R0,#+36
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000000A4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000A8   0x6A00             LDR      R0,[R0, #+32]
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x60C1             STR      R1,[R0, #+12]
    802                // Enable DMA Transfer
    803                LPC_USB->EpDMAEn = 1UL << EP;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x40A0             LSLS     R0,R0,R4
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x2008c288
   \   000000B6   0x6008             STR      R0,[R1, #+0]
    804                // Trigger transfer
    805                Int32U EpReg = USB_Cmd(CMD_USB_SEL_EP | EP,0);
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C0   0x.... 0x....      BL       USB_Cmd
    806                if(0 == (EpReg & 0x60))
   \   000000C4   0xF010 0x0F60      TST      R0,#0x60
   \   000000C8   0xF040 0x8300      BNE.W    ??USB_EP_IO_4
    807                {
    808                  // Retrigger DMA Transfer
    809                  LPC_USB->DMARSet = 1 << EP;
   \   000000CC   0x2101             MOVS     R1,#+1
   \   000000CE   0x40A1             LSLS     R1,R1,R4
   \   000000D0   0x.... 0x....      LDR.W    R2,??DataTable13_5  ;; 0x2008c258
   \   000000D4   0x6011             STR      R1,[R2, #+0]
   \   000000D6   0xE2F9             B.N      ??USB_EP_IO_4
    810                }
    811          
    812              #endif // USB_DMA_ID_MAX_NUMB > 0
    813              }
    814              else
    815              {
    816            #endif
    817                Count = EpCnfg[EP].Size - EpCnfg[EP].Offset;
   \                     ??USB_EP_IO_3:
   \   000000D8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DA   0x2024             MOVS     R0,#+36
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000000E0   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000E4   0x6900             LDR      R0,[R0, #+16]
   \   000000E6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E8   0x2124             MOVS     R1,#+36
   \   000000EA   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   000000EE   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000F2   0x68C9             LDR      R1,[R1, #+12]
   \   000000F4   0x1A40             SUBS     R0,R0,R1
   \   000000F6   0x0006             MOVS     R6,R0
    818          
    819                while(EpCnfg[EP].AvbBuff)
   \                     ??USB_EP_IO_5:
   \   000000F8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FA   0x2024             MOVS     R0,#+36
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000100   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000104   0x7F00             LDRB     R0,[R0, #+28]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xF000 0x8126      BEQ.W    ??USB_EP_IO_6
    820                {
    821                  if(Count == 0 && !EpCnfg[EP].bZeroPacket)
   \   0000010C   0x2E00             CMP      R6,#+0
   \   0000010E   0xD10C             BNE.N    ??USB_EP_IO_7
   \   00000110   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000112   0x2024             MOVS     R0,#+36
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000118   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000011C   0x7F40             LDRB     R0,[R0, #+29]
   \   0000011E   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000122   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xF000 0x8117      BEQ.W    ??USB_EP_IO_6
    822                  {
    823                    break;
    824                  }
    825          
    826                  // Set Status
    827                  EpCnfg[EP].Status = BEGIN_SERVICED;
   \                     ??USB_EP_IO_7:
   \   0000012A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012C   0x2024             MOVS     R0,#+36
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000132   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000136   0x2102             MOVS     R1,#+2
   \   00000138   0x7501             STRB     R1,[R0, #+20]
    828                  // Get data size
    829                  if(EpCnfg[EP].bZeroPacketPossible && Count == EpCnfg[EP].MaxSize)
   \   0000013A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013C   0x2024             MOVS     R0,#+36
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000142   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000146   0x7F40             LDRB     R0,[R0, #+29]
   \   00000148   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   0000014C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD028             BEQ.N    ??USB_EP_IO_8
   \   00000152   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000154   0x2024             MOVS     R0,#+36
   \   00000156   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000015A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000015E   0x6800             LDR      R0,[R0, #+0]
   \   00000160   0x4286             CMP      R6,R0
   \   00000162   0xD11F             BNE.N    ??USB_EP_IO_8
    830                  {
    831                    EpCnfg[EP].bZeroPacketPossible = 0;
   \   00000164   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000166   0x2024             MOVS     R0,#+36
   \   00000168   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000016C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000170   0x7F40             LDRB     R0,[R0, #+29]
   \   00000172   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000176   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000178   0x2124             MOVS     R1,#+36
   \   0000017A   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   0000017E   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000182   0x7748             STRB     R0,[R1, #+29]
    832                    EpCnfg[EP].bZeroPacket = 1;
   \   00000184   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000186   0x2024             MOVS     R0,#+36
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000018C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000190   0x7F40             LDRB     R0,[R0, #+29]
   \   00000192   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000196   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000198   0x2124             MOVS     R1,#+36
   \   0000019A   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   0000019E   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000001A2   0x7748             STRB     R0,[R1, #+29]
    833                  }
    834          
    835                  Count = MIN(Count,EpCnfg[EP].MaxSize);
   \                     ??USB_EP_IO_8:
   \   000001A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001A6   0x2024             MOVS     R0,#+36
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000001AC   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001B0   0x6800             LDR      R0,[R0, #+0]
   \   000001B2   0x4286             CMP      R6,R0
   \   000001B4   0xD306             BCC.N    ??USB_EP_IO_9
   \                     ??USB_EP_IO_10:
   \   000001B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B8   0x2024             MOVS     R0,#+36
   \   000001BA   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000001BE   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001C2   0x6806             LDR      R6,[R0, #+0]
    836                  Int32U Offset = EpCnfg[EP].Offset;
   \                     ??USB_EP_IO_9:
   \   000001C4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001C6   0x2024             MOVS     R0,#+36
   \   000001C8   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000001CC   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001D0   0x68C7             LDR      R7,[R0, #+12]
    837                  EpCnfg[EP].Offset += Count;
   \   000001D2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001D4   0x2024             MOVS     R0,#+36
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000001DA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001DE   0x68C0             LDR      R0,[R0, #+12]
   \   000001E0   0x1830             ADDS     R0,R6,R0
   \   000001E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001E4   0x2124             MOVS     R1,#+36
   \   000001E6   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   000001EA   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000001EE   0x60C8             STR      R0,[R1, #+12]
    838                  // Convert EP physical address to logical and set write enable bit
    839                  LPC_USB->Ctrl = ((EP << 1) & 0x3C) | bmUSB_CtrlWrEna;
   \   000001F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F2   0x0060             LSLS     R0,R4,#+1
   \   000001F4   0xF010 0x003C      ANDS     R0,R0,#0x3C
   \   000001F8   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000001FC   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x2008c228
   \   00000200   0x6008             STR      R0,[R1, #+0]
    840                  LPC_USB->TxPLen = Count;
   \   00000202   0x.... 0x....      LDR.W    R0,??DataTable13_7  ;; 0x2008c224
   \   00000206   0x6006             STR      R6,[R0, #+0]
    841                  // Write data to SIE buffer
    842                  if(Count)
   \   00000208   0x2E00             CMP      R6,#+0
   \   0000020A   0xD05C             BEQ.N    ??USB_EP_IO_11
    843                  {
    844                    do
    845                    {
    846                      assert(USBCTRL_bit.WR_EN);
   \                     ??USB_EP_IO_12:
   \   0000020C   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x2008c228
   \   00000210   0x6800             LDR      R0,[R0, #+0]
   \   00000212   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000216   0x2800             CMP      R0,#+0
   \   00000218   0xD109             BNE.N    ??USB_EP_IO_13
   \   0000021A   0xF240 0x324E      MOVW     R2,#+846
   \   0000021E   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000222   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000226   0x.... 0x....      BL       __aeabi_assert
   \   0000022A   0x.... 0x....      BL       __iar_EmptyStepPoint
    847                      Data = *(EpCnfg[EP].pBuffer+Offset++);
   \                     ??USB_EP_IO_13:
   \   0000022E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000230   0x2024             MOVS     R0,#+36
   \   00000232   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000236   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000023A   0x6980             LDR      R0,[R0, #+24]
   \   0000023C   0x5C38             LDRB     R0,[R7, R0]
   \   0000023E   0x0005             MOVS     R5,R0
   \   00000240   0x1C7F             ADDS     R7,R7,#+1
    848                      if (--Count)
   \   00000242   0x1E76             SUBS     R6,R6,#+1
   \   00000244   0x2E00             CMP      R6,#+0
   \   00000246   0xD027             BEQ.N    ??USB_EP_IO_14
    849                      {
    850                        Data |= (Int32U)(*(EpCnfg[EP].pBuffer+Offset++))<<8;
   \   00000248   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000024A   0x2024             MOVS     R0,#+36
   \   0000024C   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000250   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000254   0x6980             LDR      R0,[R0, #+24]
   \   00000256   0x5C38             LDRB     R0,[R7, R0]
   \   00000258   0xEA55 0x2500      ORRS     R5,R5,R0, LSL #+8
   \   0000025C   0x1C7F             ADDS     R7,R7,#+1
    851                        if (--Count)
   \   0000025E   0x1E76             SUBS     R6,R6,#+1
   \   00000260   0x2E00             CMP      R6,#+0
   \   00000262   0xD019             BEQ.N    ??USB_EP_IO_14
    852                        {
    853                          Data |= (Int32U)(*(EpCnfg[EP].pBuffer+Offset++))<<16;
   \   00000264   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000266   0x2024             MOVS     R0,#+36
   \   00000268   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000026C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000270   0x6980             LDR      R0,[R0, #+24]
   \   00000272   0x5C38             LDRB     R0,[R7, R0]
   \   00000274   0xEA55 0x4500      ORRS     R5,R5,R0, LSL #+16
   \   00000278   0x1C7F             ADDS     R7,R7,#+1
    854                          if (--Count)
   \   0000027A   0x1E76             SUBS     R6,R6,#+1
   \   0000027C   0x2E00             CMP      R6,#+0
   \   0000027E   0xD00B             BEQ.N    ??USB_EP_IO_14
    855                          {
    856                            Data |= (Int32U)(*(EpCnfg[EP].pBuffer+Offset++))<<24;
   \   00000280   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000282   0x2024             MOVS     R0,#+36
   \   00000284   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000288   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000028C   0x6980             LDR      R0,[R0, #+24]
   \   0000028E   0x5C38             LDRB     R0,[R7, R0]
   \   00000290   0xEA55 0x6500      ORRS     R5,R5,R0, LSL #+24
   \   00000294   0x1C7F             ADDS     R7,R7,#+1
    857                            --Count;
   \   00000296   0x1E76             SUBS     R6,R6,#+1
    858                          }
    859                        }
    860                      }
    861                      LPC_USB->TxData = Data;
   \                     ??USB_EP_IO_14:
   \   00000298   0x.... 0x....      LDR.W    R0,??DataTable13_9  ;; 0x2008c21c
   \   0000029C   0x6005             STR      R5,[R0, #+0]
    862                    }
    863                    while (Count);
   \   0000029E   0x2E00             CMP      R6,#+0
   \   000002A0   0xD1B4             BNE.N    ??USB_EP_IO_12
    864                    assert(!USBCTRL_bit.WR_EN);
   \   000002A2   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x2008c228
   \   000002A6   0x6800             LDR      R0,[R0, #+0]
   \   000002A8   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000002AC   0x2800             CMP      R0,#+0
   \   000002AE   0xD025             BEQ.N    ??USB_EP_IO_15
   \   000002B0   0xF44F 0x7258      MOV      R2,#+864
   \   000002B4   0x.... 0x....      LDR.W    R1,??DataTable12
   \   000002B8   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   000002BC   0x.... 0x....      BL       __aeabi_assert
   \   000002C0   0x.... 0x....      BL       __iar_EmptyStepPoint
   \   000002C4   0xE01A             B.N      ??USB_EP_IO_15
    865                  }
    866                  else
    867                  {
    868                    EpCnfg[EP].bZeroPacket = 0;
   \                     ??USB_EP_IO_11:
   \   000002C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002C8   0x2024             MOVS     R0,#+36
   \   000002CA   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000002CE   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000002D2   0x7F40             LDRB     R0,[R0, #+29]
   \   000002D4   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   000002D8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002DA   0x2124             MOVS     R1,#+36
   \   000002DC   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   000002E0   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000002E4   0x7748             STRB     R0,[R1, #+29]
    869                    do
    870                    {
    871                      LPC_USB->TxData = 0;
   \                     ??USB_EP_IO_16:
   \   000002E6   0x.... 0x....      LDR.W    R0,??DataTable13_9  ;; 0x2008c21c
   \   000002EA   0x2100             MOVS     R1,#+0
   \   000002EC   0x6001             STR      R1,[R0, #+0]
    872                    }
    873                    while (USBCTRL_bit.WR_EN);
   \   000002EE   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x2008c228
   \   000002F2   0x6800             LDR      R0,[R0, #+0]
   \   000002F4   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000002F8   0x2800             CMP      R0,#+0
   \   000002FA   0xD1F4             BNE.N    ??USB_EP_IO_16
    874                  }
    875          
    876                  LPC_USB->Ctrl = 0;
   \                     ??USB_EP_IO_15:
   \   000002FC   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x2008c228
   \   00000300   0x2100             MOVS     R1,#+0
   \   00000302   0x6001             STR      R1,[R0, #+0]
    877          
    878                  --EpCnfg[EP].AvbBuff;
   \   00000304   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000306   0x2024             MOVS     R0,#+36
   \   00000308   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000030C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000310   0x7F00             LDRB     R0,[R0, #+28]
   \   00000312   0x1E40             SUBS     R0,R0,#+1
   \   00000314   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000316   0x2124             MOVS     R1,#+36
   \   00000318   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   0000031C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000320   0x7708             STRB     R0,[R1, #+28]
    879                  USB_Cmd(CMD_USB_SEL_EP | EP, 0);
   \   00000322   0x2100             MOVS     R1,#+0
   \   00000324   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000326   0x0020             MOVS     R0,R4
   \   00000328   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000032A   0x.... 0x....      BL       USB_Cmd
    880                  USB_Cmd(CMD_USB_VAL_BUF, 0);
   \   0000032E   0x2100             MOVS     R1,#+0
   \   00000330   0x20FA             MOVS     R0,#+250
   \   00000332   0x.... 0x....      BL       USB_Cmd
    881                  Count = EpCnfg[EP].Size - EpCnfg[EP].Offset;
   \   00000336   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000338   0x2024             MOVS     R0,#+36
   \   0000033A   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000033E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000342   0x6900             LDR      R0,[R0, #+16]
   \   00000344   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000346   0x2124             MOVS     R1,#+36
   \   00000348   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   0000034C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000350   0x68C9             LDR      R1,[R1, #+12]
   \   00000352   0x1A40             SUBS     R0,R0,R1
   \   00000354   0x0006             MOVS     R6,R0
   \   00000356   0xE6CF             B.N      ??USB_EP_IO_5
    882                }
    883          
    884                if(!EpCnfg[EP].bZeroPacket && !Count)
   \                     ??USB_EP_IO_6:
   \   00000358   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000035A   0x2024             MOVS     R0,#+36
   \   0000035C   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000360   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000364   0x7F40             LDRB     R0,[R0, #+29]
   \   00000366   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   0000036A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000036C   0x2800             CMP      R0,#+0
   \   0000036E   0xF040 0x81AD      BNE.W    ??USB_EP_IO_4
   \   00000372   0x2E00             CMP      R6,#+0
   \   00000374   0xF040 0x81AA      BNE.W    ??USB_EP_IO_4
    885                {
    886                  EpCnfg[EP].Status = COMPLETE;
   \   00000378   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000037A   0x2024             MOVS     R0,#+36
   \   0000037C   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000380   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000384   0x2103             MOVS     R1,#+3
   \   00000386   0x7501             STRB     R1,[R0, #+20]
    887                  //call callback function
    888                  if(EpCnfg[EP].pFn)
   \   00000388   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000038A   0x2024             MOVS     R0,#+36
   \   0000038C   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000390   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000394   0x6880             LDR      R0,[R0, #+8]
   \   00000396   0x2800             CMP      R0,#+0
   \   00000398   0xF000 0x8198      BEQ.W    ??USB_EP_IO_4
    889                  {
    890                    ((void(*)(USB_Endpoint_t))EpCnfg[EP].pFn)(EP);
   \   0000039C   0x0020             MOVS     R0,R4
   \   0000039E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003A2   0x2124             MOVS     R1,#+36
   \   000003A4   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   000003A8   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000003AC   0x6889             LDR      R1,[R1, #+8]
   \   000003AE   0x4788             BLX      R1
   \   000003B0   0xE18C             B.N      ??USB_EP_IO_4
    891                  }
    892                }
    893          #if USB_DMA_DD_MAX_NUMB > 0
    894              }
    895          #endif // USB_DMA_DD_MAX_NUMB > 0
    896            }
    897            else
    898            {
    899              // OUT
    900            #if USB_DMA_DD_MAX_NUMB > 0
    901              if(EpCnfg[EP].bDMA_Transfer)
   \                     ??USB_EP_IO_2:
   \   000003B2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003B4   0x2024             MOVS     R0,#+36
   \   000003B6   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000003BA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000003BE   0x7F40             LDRB     R0,[R0, #+29]
   \   000003C0   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000003C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003C6   0x2800             CMP      R0,#+0
   \   000003C8   0xD048             BEQ.N    ??USB_EP_IO_17
    902              {
    903                // Set Data buffer
    904                EpCnfg[EP].pUSB_DmaDesc->pDmaBuffer     = EpCnfg[EP].pBuffer;
   \   000003CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003CC   0x2024             MOVS     R0,#+36
   \   000003CE   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000003D2   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000003D6   0x6A00             LDR      R0,[R0, #+32]
   \   000003D8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003DA   0x2124             MOVS     R1,#+36
   \   000003DC   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   000003E0   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000003E4   0x6989             LDR      R1,[R1, #+24]
   \   000003E6   0x6081             STR      R1,[R0, #+8]
    905            #if USB_DMA_ID_MAX_NUMB > 0
    906                // Set Iso packet descrptor
    907                if(EpCnfg[EP].pUSB_DmaDesc->Isochronous)
    908                {
    909                  // Iso packet descriptor
    910                  EpCnfg[EP].pUSB_DmaDesc->pDmaIsoPacket = EpCnfg[EP].pDmaIsoPacket;
    911                  // Set Data size
    912                  EpCnfg[EP].pUSB_DmaDesc->DmaBufferLegtn = 1;
    913                }
    914                else
    915                {
    916                  // Set Data size
    917                  EpCnfg[EP].pUSB_DmaDesc->DmaBufferLegtn = EpCnfg[EP].Size;
    918                }
    919                // Set DMA status
    920                EpCnfg[EP].pUSB_DmaDesc->Status         = 0;
    921                // Enable DMA Transfer
    922                LPC_USB->EpDMAEn = 1UL << EP;
    923                if(0 == EpCnfg[EP].pUSB_DmaDesc->Isochronous)
    924                {
    925                  // Trigger transfer
    926                  Int32U EpReg = USB_Cmd(CMD_USB_SEL_EP | EP,0);
    927                  if (0x60 == (EpReg & 0x60))
    928                  {
    929                    // Retrigger DMA Transfer
    930                    LPC_USB->DMARSet = 1 << EP;
    931                  }
    932                }
    933            #else
    934                // Set Data size
    935                EpCnfg[EP].pUSB_DmaDesc->DmaBufferLegtn = EpCnfg[EP].Size;
   \   000003E8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003EA   0x2024             MOVS     R0,#+36
   \   000003EC   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000003F0   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000003F4   0x6A00             LDR      R0,[R0, #+32]
   \   000003F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003F8   0x2124             MOVS     R1,#+36
   \   000003FA   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   000003FE   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000402   0x6909             LDR      R1,[R1, #+16]
   \   00000404   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000406   0x2224             MOVS     R2,#+36
   \   00000408   0x.... 0x....      LDR.W    R3,??DataTable13_2
   \   0000040C   0xFB02 0x3204      MLA      R2,R2,R4,R3
   \   00000410   0x6A12             LDR      R2,[R2, #+32]
   \   00000412   0x6852             LDR      R2,[R2, #+4]
   \   00000414   0xF361 0x421F      BFI      R2,R1,#+16,#+16
   \   00000418   0x6042             STR      R2,[R0, #+4]
    936                // Set DMA status
    937                EpCnfg[EP].pUSB_DmaDesc->Status         = 0;
   \   0000041A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000041C   0x2024             MOVS     R0,#+36
   \   0000041E   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000422   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000426   0x6A00             LDR      R0,[R0, #+32]
   \   00000428   0x2100             MOVS     R1,#+0
   \   0000042A   0x60C1             STR      R1,[R0, #+12]
    938                // Enable DMA Transfer
    939                LPC_USB->EpDMAEn = 1UL << EP;
   \   0000042C   0x2001             MOVS     R0,#+1
   \   0000042E   0x40A0             LSLS     R0,R0,R4
   \   00000430   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x2008c288
   \   00000434   0x6008             STR      R0,[R1, #+0]
    940                // Trigger transfer
    941                Int32U EpReg = USB_Cmd(CMD_USB_SEL_EP | EP,0);
   \   00000436   0x2100             MOVS     R1,#+0
   \   00000438   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000043A   0x0020             MOVS     R0,R4
   \   0000043C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000043E   0x.... 0x....      BL       USB_Cmd
    942                if ((EP & 1) && !(EpReg & 0x60))
   \   00000442   0x07E1             LSLS     R1,R4,#+31
   \   00000444   0xF140 0x8142      BPL.W    ??USB_EP_IO_4
   \   00000448   0xF010 0x0F60      TST      R0,#0x60
   \   0000044C   0xF040 0x813E      BNE.W    ??USB_EP_IO_4
    943                {
    944                  // Retrigger DMA Transfer
    945                  LPC_USB->DMARSet = 1 << EP;
   \   00000450   0x2101             MOVS     R1,#+1
   \   00000452   0x40A1             LSLS     R1,R1,R4
   \   00000454   0x.... 0x....      LDR.W    R2,??DataTable13_5  ;; 0x2008c258
   \   00000458   0x6011             STR      R1,[R2, #+0]
   \   0000045A   0xE137             B.N      ??USB_EP_IO_4
    946                }
    947            #endif // USB_DMA_ID_MAX_NUMB > 0
    948              }
    949              else
    950              {
    951            #endif
    952                while(EpCnfg[EP].AvbBuff)
   \                     ??USB_EP_IO_17:
   \   0000045C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000045E   0x2024             MOVS     R0,#+36
   \   00000460   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000464   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000468   0x7F00             LDRB     R0,[R0, #+28]
   \   0000046A   0x2800             CMP      R0,#+0
   \   0000046C   0xF000 0x8109      BEQ.W    ??USB_EP_IO_18
    953                {
    954                  // Convert EP physical address to logical and set read enable bit
    955                  LPC_USB->Ctrl = ((EP << 1) & 0x3C) | bmUSB_CtrlRdEna;
   \   00000470   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000472   0x0060             LSLS     R0,R4,#+1
   \   00000474   0xF010 0x003C      ANDS     R0,R0,#0x3C
   \   00000478   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000047C   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x2008c228
   \   00000480   0x6008             STR      R0,[R1, #+0]
    956                  while (USBRXPLEN_bit.PKT_RDY == 0);
   \                     ??USB_EP_IO_19:
   \   00000482   0x.... 0x....      LDR.W    R0,??DataTable13_11  ;; 0x2008c220
   \   00000486   0x6800             LDR      R0,[R0, #+0]
   \   00000488   0xF3C0 0x20C0      UBFX     R0,R0,#+11,#+1
   \   0000048C   0x2800             CMP      R0,#+0
   \   0000048E   0xD0F8             BEQ.N    ??USB_EP_IO_19
    957                  // Get data size
    958                  Count = USBRXPLEN_bit.PKT_LNGTH;
   \   00000490   0x.... 0x....      LDR.W    R0,??DataTable13_11  ;; 0x2008c220
   \   00000494   0x6800             LDR      R0,[R0, #+0]
   \   00000496   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   00000498   0x0D80             LSRS     R0,R0,#+22
   \   0000049A   0x0006             MOVS     R6,R0
    959                  if(Count > (EpCnfg[EP].Size - EpCnfg[EP].Offset))
   \   0000049C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000049E   0x2024             MOVS     R0,#+36
   \   000004A0   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000004A4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000004A8   0x6900             LDR      R0,[R0, #+16]
   \   000004AA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004AC   0x2124             MOVS     R1,#+36
   \   000004AE   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   000004B2   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000004B6   0x68C9             LDR      R1,[R1, #+12]
   \   000004B8   0x1A40             SUBS     R0,R0,R1
   \   000004BA   0x42B0             CMP      R0,R6
   \   000004BC   0xD216             BCS.N    ??USB_EP_IO_20
    960                  {
    961                    EpCnfg[EP].Status = BUFFER_OVERRUN;
   \   000004BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004C0   0x2024             MOVS     R0,#+36
   \   000004C2   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000004C6   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000004CA   0x2105             MOVS     R1,#+5
   \   000004CC   0x7501             STRB     R1,[R0, #+20]
    962                    EpCnfg[EP].Size = EpCnfg[EP].Offset;
   \   000004CE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004D0   0x2024             MOVS     R0,#+36
   \   000004D2   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000004D6   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000004DA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004DC   0x2124             MOVS     R1,#+36
   \   000004DE   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   000004E2   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000004E6   0x68C9             LDR      R1,[R1, #+12]
   \   000004E8   0x6101             STR      R1,[R0, #+16]
    963                    break;
   \   000004EA   0xE0CA             B.N      ??USB_EP_IO_18
    964                  }
    965                  else if (Count < EpCnfg[EP].MaxSize)
   \                     ??USB_EP_IO_20:
   \   000004EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004EE   0x2024             MOVS     R0,#+36
   \   000004F0   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000004F4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000004F8   0x6800             LDR      R0,[R0, #+0]
   \   000004FA   0x4286             CMP      R6,R0
   \   000004FC   0xD217             BCS.N    ??USB_EP_IO_21
    966                  {
    967                    EpCnfg[EP].Status = BUFFER_UNDERRUN;
   \   000004FE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000500   0x2024             MOVS     R0,#+36
   \   00000502   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000506   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000050A   0x2104             MOVS     R1,#+4
   \   0000050C   0x7501             STRB     R1,[R0, #+20]
    968                    EpCnfg[EP].Size = EpCnfg[EP].Offset + Count;
   \   0000050E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000510   0x2024             MOVS     R0,#+36
   \   00000512   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000516   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000051A   0x68C0             LDR      R0,[R0, #+12]
   \   0000051C   0x1830             ADDS     R0,R6,R0
   \   0000051E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000520   0x2124             MOVS     R1,#+36
   \   00000522   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   00000526   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000052A   0x6108             STR      R0,[R1, #+16]
   \   0000052C   0xE007             B.N      ??USB_EP_IO_22
    969                  }
    970                  else
    971                  {
    972                    EpCnfg[EP].Status = BEGIN_SERVICED;
   \                     ??USB_EP_IO_21:
   \   0000052E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000530   0x2024             MOVS     R0,#+36
   \   00000532   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000536   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000053A   0x2102             MOVS     R1,#+2
   \   0000053C   0x7501             STRB     R1,[R0, #+20]
    973                  }
    974          
    975                  Int32U Offset = EpCnfg[EP].Offset;
   \                     ??USB_EP_IO_22:
   \   0000053E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000540   0x2024             MOVS     R0,#+36
   \   00000542   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000546   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000054A   0x68C7             LDR      R7,[R0, #+12]
    976                  EpCnfg[EP].Offset += Count;
   \   0000054C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000054E   0x2024             MOVS     R0,#+36
   \   00000550   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000554   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000558   0x68C0             LDR      R0,[R0, #+12]
   \   0000055A   0x1830             ADDS     R0,R6,R0
   \   0000055C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000055E   0x2124             MOVS     R1,#+36
   \   00000560   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   00000564   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000568   0x60C8             STR      R0,[R1, #+12]
    977          
    978                  // Read data from SIE buffer
    979                  do
    980                  {
    981                    //assert(RCVEPKTLEN_bit.DV);
    982                    Data = LPC_USB->RxData;
   \                     ??USB_EP_IO_23:
   \   0000056A   0x.... 0x....      LDR.W    R0,??DataTable13_12  ;; 0x2008c218
   \   0000056E   0x6800             LDR      R0,[R0, #+0]
   \   00000570   0x0005             MOVS     R5,R0
    983                    // because zero lenght packe is possible
    984                    if(Count)
   \   00000572   0x2E00             CMP      R6,#+0
   \   00000574   0xD030             BEQ.N    ??USB_EP_IO_24
    985                    {
    986                      *(EpCnfg[EP].pBuffer+Offset++) = Data;
   \   00000576   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000578   0x2024             MOVS     R0,#+36
   \   0000057A   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000057E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000582   0x6980             LDR      R0,[R0, #+24]
   \   00000584   0x543D             STRB     R5,[R7, R0]
   \   00000586   0x1C7F             ADDS     R7,R7,#+1
    987                      if (--Count)
   \   00000588   0x1E76             SUBS     R6,R6,#+1
   \   0000058A   0x2E00             CMP      R6,#+0
   \   0000058C   0xD024             BEQ.N    ??USB_EP_IO_24
    988                      {
    989                        Data >>= 8;
   \   0000058E   0x0A2D             LSRS     R5,R5,#+8
    990                        *(EpCnfg[EP].pBuffer+Offset++) = Data;
   \   00000590   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000592   0x2024             MOVS     R0,#+36
   \   00000594   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000598   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000059C   0x6980             LDR      R0,[R0, #+24]
   \   0000059E   0x543D             STRB     R5,[R7, R0]
   \   000005A0   0x1C7F             ADDS     R7,R7,#+1
    991                        if (--Count)
   \   000005A2   0x1E76             SUBS     R6,R6,#+1
   \   000005A4   0x2E00             CMP      R6,#+0
   \   000005A6   0xD017             BEQ.N    ??USB_EP_IO_24
    992                        {
    993                          Data >>= 8;
   \   000005A8   0x0A2D             LSRS     R5,R5,#+8
    994                          *(EpCnfg[EP].pBuffer+Offset++) = Data;
   \   000005AA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005AC   0x2024             MOVS     R0,#+36
   \   000005AE   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000005B2   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000005B6   0x6980             LDR      R0,[R0, #+24]
   \   000005B8   0x543D             STRB     R5,[R7, R0]
   \   000005BA   0x1C7F             ADDS     R7,R7,#+1
    995                          if (--Count)
   \   000005BC   0x1E76             SUBS     R6,R6,#+1
   \   000005BE   0x2E00             CMP      R6,#+0
   \   000005C0   0xD00A             BEQ.N    ??USB_EP_IO_24
    996                          {
    997                            --Count;
   \   000005C2   0x1E76             SUBS     R6,R6,#+1
    998                            Data >>= 8;
   \   000005C4   0x0A2D             LSRS     R5,R5,#+8
    999                            *(EpCnfg[EP].pBuffer+Offset++) = Data;
   \   000005C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005C8   0x2024             MOVS     R0,#+36
   \   000005CA   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000005CE   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000005D2   0x6980             LDR      R0,[R0, #+24]
   \   000005D4   0x543D             STRB     R5,[R7, R0]
   \   000005D6   0x1C7F             ADDS     R7,R7,#+1
   1000                          }
   1001                        }
   1002                      }
   1003                    }
   1004                  }
   1005                  while (Count);
   \                     ??USB_EP_IO_24:
   \   000005D8   0x2E00             CMP      R6,#+0
   \   000005DA   0xD1C6             BNE.N    ??USB_EP_IO_23
   1006                  assert(!USBRXPLEN_bit.DV);
   \   000005DC   0x.... 0x....      LDR.W    R0,??DataTable13_11  ;; 0x2008c220
   \   000005E0   0x6800             LDR      R0,[R0, #+0]
   \   000005E2   0xF3C0 0x2080      UBFX     R0,R0,#+10,#+1
   \   000005E6   0x2800             CMP      R0,#+0
   \   000005E8   0xD008             BEQ.N    ??USB_EP_IO_25
   \   000005EA   0xF240 0x32EE      MOVW     R2,#+1006
   \   000005EE   0x....             LDR.N    R1,??DataTable12
   \   000005F0   0x.... 0x....      LDR.W    R0,??DataTable13_13
   \   000005F4   0x.... 0x....      BL       __aeabi_assert
   \   000005F8   0x.... 0x....      BL       __iar_EmptyStepPoint
   1007                  
   1008                  LPC_USB->Ctrl = 0;
   \                     ??USB_EP_IO_25:
   \   000005FC   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x2008c228
   \   00000600   0x2100             MOVS     R1,#+0
   \   00000602   0x6001             STR      R1,[R0, #+0]
   1009                  --EpCnfg[EP].AvbBuff;
   \   00000604   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000606   0x2024             MOVS     R0,#+36
   \   00000608   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000060C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000610   0x7F00             LDRB     R0,[R0, #+28]
   \   00000612   0x1E40             SUBS     R0,R0,#+1
   \   00000614   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000616   0x2124             MOVS     R1,#+36
   \   00000618   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   0000061C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000620   0x7708             STRB     R0,[R1, #+28]
   1010                  USB_Cmd(CMD_USB_SEL_EP | EP, 0);
   \   00000622   0x2100             MOVS     R1,#+0
   \   00000624   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000626   0x0020             MOVS     R0,R4
   \   00000628   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000062A   0x.... 0x....      BL       USB_Cmd
   1011                  if(USB_Cmd(CMD_USB_CLR_BUF, 0) & bmUSB_PacketOverWritten)
   \   0000062E   0x2100             MOVS     R1,#+0
   \   00000630   0x20F2             MOVS     R0,#+242
   \   00000632   0x.... 0x....      BL       USB_Cmd
   \   00000636   0x07C0             LSLS     R0,R0,#+31
   \   00000638   0xD508             BPL.N    ??USB_EP_IO_26
   1012                  {
   1013                    EpCnfg[EP].Status = SETUP_OVERWRITE;
   \   0000063A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000063C   0x2024             MOVS     R0,#+36
   \   0000063E   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000642   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000646   0x2106             MOVS     R1,#+6
   \   00000648   0x7501             STRB     R1,[R0, #+20]
   1014                    return;
   \   0000064A   0xE03F             B.N      ??USB_EP_IO_1
   1015                  }
   1016                  if (!(Count = (EpCnfg[EP].Size - EpCnfg[EP].Offset)))
   \                     ??USB_EP_IO_26:
   \   0000064C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000064E   0x2024             MOVS     R0,#+36
   \   00000650   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000654   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000658   0x6900             LDR      R0,[R0, #+16]
   \   0000065A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000065C   0x2124             MOVS     R1,#+36
   \   0000065E   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   00000662   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000666   0x68C9             LDR      R1,[R1, #+12]
   \   00000668   0x1A40             SUBS     R0,R0,R1
   \   0000066A   0x0006             MOVS     R6,R0
   \   0000066C   0x2800             CMP      R0,#+0
   \   0000066E   0xF47F 0xAEF5      BNE.W    ??USB_EP_IO_17
   1017                  {
   1018                    EpCnfg[EP].Status = COMPLETE;
   \   00000672   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000674   0x2024             MOVS     R0,#+36
   \   00000676   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000067A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000067E   0x2103             MOVS     R1,#+3
   \   00000680   0x7501             STRB     R1,[R0, #+20]
   1019                    break;
   1020                  }
   1021                }
   1022          
   1023                if (EpCnfg[EP].Status != BEGIN_SERVICED && EpCnfg[EP].Status != NO_SERVICED)
   \                     ??USB_EP_IO_18:
   \   00000682   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000684   0x2024             MOVS     R0,#+36
   \   00000686   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000068A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000068E   0x7D00             LDRB     R0,[R0, #+20]
   \   00000690   0x2802             CMP      R0,#+2
   \   00000692   0xD01B             BEQ.N    ??USB_EP_IO_4
   \   00000694   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000696   0x2024             MOVS     R0,#+36
   \   00000698   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000069C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000006A0   0x7D00             LDRB     R0,[R0, #+20]
   \   000006A2   0x2801             CMP      R0,#+1
   \   000006A4   0xD012             BEQ.N    ??USB_EP_IO_4
   1024                {
   1025                  //call callback function
   1026                  if(EpCnfg[EP].pFn)
   \   000006A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000006A8   0x2024             MOVS     R0,#+36
   \   000006AA   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000006AE   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000006B2   0x6880             LDR      R0,[R0, #+8]
   \   000006B4   0x2800             CMP      R0,#+0
   \   000006B6   0xD009             BEQ.N    ??USB_EP_IO_4
   1027                  {
   1028                    ((void(*)(USB_Endpoint_t))EpCnfg[EP].pFn)(EP);
   \   000006B8   0x0020             MOVS     R0,R4
   \   000006BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000006BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000006BE   0x2124             MOVS     R1,#+36
   \   000006C0   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   000006C4   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000006C8   0x6889             LDR      R1,[R1, #+8]
   \   000006CA   0x4788             BLX      R1
   1029                  }
   1030                }
   1031          #if USB_DMA_DD_MAX_NUMB > 0
   1032              }
   1033          #endif // USB_DMA_DD_MAX_NUMB > 0
   1034            }
   1035          }
   \                     ??USB_EP_IO_4:
   \                     ??USB_EP_IO_1:
   \   000006CC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \   000006CE                      REQUIRE _A_USBCTRL
   \   000006CE                      REQUIRE _A_USBRXPLEN
   1036          
   1037          /*************************************************************************
   1038           * Function Name: USB_EpLogToPhysAdd
   1039           * Parameters: Int8U EpLogAdd
   1040           *
   1041           * Return: USB_Endpoint_t
   1042           *
   1043           * Description: Convert the logical to physical address
   1044           *
   1045           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1046          USB_Endpoint_t USB_EpLogToPhysAdd (Int8U EpLogAdd)
   1047          {
   \                     USB_EpLogToPhysAdd:
   \   00000000   0x0001             MOVS     R1,R0
   1048          USB_Endpoint_t Address = (USB_Endpoint_t)((EpLogAdd & 0x0F)<<1);
   \   00000002   0xF011 0x000F      ANDS     R0,R1,#0xF
   \   00000006   0x0040             LSLS     R0,R0,#+1
   1049            if(EpLogAdd & 0x80)
   \   00000008   0x060A             LSLS     R2,R1,#+24
   \   0000000A   0xD500             BPL.N    ??USB_EpLogToPhysAdd_0
   1050            {
   1051              ++Address;
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   1052            }
   1053            return(Address);
   \                     ??USB_EpLogToPhysAdd_0:
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x4770             BX       LR               ;; return
   1054          }
   1055          
   1056          #if USB_SOF_EVENT > 0
   1057          /*************************************************************************
   1058           * Function Name: USB_GetFrameNumb
   1059           * Parameters: none
   1060           *
   1061           * Return: Int32U
   1062           *
   1063           * Description: Return current value of SOF number
   1064           *
   1065           *************************************************************************/
   1066          Int32U USB_GetFrameNumb (void)
   1067          {
   1068            return(USB_SofNumbHold);
   1069          }
   1070          #endif
   1071          
   1072          /*************************************************************************
   1073           * Function Name: USB_StatusPhase
   1074           * Parameters: Boolean In
   1075           *
   1076           * Return: none
   1077           *
   1078           * Description: Prepare status phase
   1079           *
   1080           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1081          void USB_StatusPhase (Boolean In)
   1082          {
   \                     USB_StatusPhase:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1083            if(In)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD005             BEQ.N    ??USB_StatusPhase_0
   1084            {
   1085              USB_IO_Data(CTRL_ENP_IN,NULL,0,NULL);
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       USB_IO_Data
   1086            }
   1087          }
   \                     ??USB_StatusPhase_0:
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
   1088          
   1089          /*************************************************************************
   1090           * Function Name: USB_IRQHandler
   1091           * Parameters: none
   1092           *
   1093           * Return: none
   1094           *
   1095           * Description: USB interrupt subroutine
   1096           *
   1097           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1098          void USB_IRQHandler (void)
   1099          {
   \                     USB_IRQHandler:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1100          Int32U Val;
   1101          
   1102            USB_INTR_ENTRY_HOOK();
   \   00000004   0x.... 0x....      BL       USB_INTR_ENTRY_HOOK
   1103          
   1104          #if 0 != USB_DEV_PRIORITY
   1105            if (USBINTS_bit.USB_INT_REQ_HP)
   1106            {
   1107          #if 2 == USB_DEV_PRIORITY
   1108              // high priority EPs
   1109              while(USBDEVINTST_bit.EP_FAST)
   1110              {
   1111                Int32U Mask = 1;
   1112                USB_Endpoint_t EP = CTRL_ENP_OUT;
   1113                Int32U EpIntr;
   1114                EpIntr  = USBEPINTST;
   1115                EpIntr &= USBEPINTEN;
   1116                EpIntr &= USB_EP_PRIORITY; // clear low priority EPs interrutp flags
   1117                while (EpIntr)
   1118                {
   1119                  if(EpIntr & Mask)
   1120                  {
   1121                    Val = USB_EpIntrClr(EP) ^ ((EP & 1)?((1<<6)|(1<<5)):0);
   1122                    if (!EpCnfg[EP].bDoubleBuffered)
   1123                    {
   1124                      Val &= ~(1<<6);
   1125                    }
   1126                    switch (Val & ((1<<6)|(1<<5)))
   1127                    {
   1128                    case 0:
   1129                      EpCnfg[EP].AvbBuff = 0;
   1130                      break;
   1131                    case (1<<5):
   1132                      EpCnfg[EP].AvbBuff = 1;
   1133                      break;
   1134                    case (1<<6):
   1135                      EpCnfg[EP].AvbBuff = 1;
   1136                      break;
   1137                    case (1<<5) | (1<<6):
   1138                      EpCnfg[EP].AvbBuff = 2;
   1139                      break;
   1140                    }
   1141          
   1142                    if(Val & bmUSB_EpSetupPacket)
   1143                    {
   1144                      // only ctrl EP can receive setup packets
   1145                      assert(EP == CTRL_ENP_OUT);
   1146                      EpCnfg[CTRL_ENP_IN].AvbBuff  = 1;
   1147                      // init IO to receive Setup packet
   1148                      USB_IO_Data(CTRL_ENP_IN,NULL,(Int32U)-1,NULL);
   1149                      USB_IO_Data(CTRL_ENP_OUT,UsbEp0SetupPacket.Data,sizeof(UsbSetupPacket_t),NULL);
   1150          
   1151                      // reset EP IO ctrl
   1152                      if (UsbEp0SetupPacket.mRequestType.Dir == UsbDevice2Host)
   1153                      {
   1154                        USB_StatusHandler(CTRL_ENP_OUT);
   1155                      }
   1156          
   1157                      USB_SetupHandler();
   1158          
   1159                      if(EpCnfg[CTRL_ENP_OUT].Status == STALLED)
   1160                      {
   1161                        USB_StallCtrlEP();
   1162                      }
   1163                      break;
   1164                    }
   1165                    else
   1166                    {
   1167                      if(EP == CTRL_ENP_OUT)
   1168                      {
   1169                        if(UsbEp0SetupPacket.mRequestType.Dir == UsbDevice2Host &&
   1170                           EpCnfg[CTRL_ENP_OUT].pFn)
   1171                        {
   1172                          ((void(*)(USB_Endpoint_t))EpCnfg[CTRL_ENP_OUT].pFn)(CTRL_ENP_OUT);
   1173                          break;
   1174                        }
   1175                      }
   1176                      else if(EP == CTRL_ENP_IN)
   1177                      {
   1178                        if(UsbEp0SetupPacket.mRequestType.Dir == UsbHost2Device &&
   1179                           EpCnfg[CTRL_ENP_IN].pFn)
   1180                        {
   1181                          ((void(*)(USB_Endpoint_t))EpCnfg[CTRL_ENP_IN].pFn)(CTRL_ENP_IN);
   1182                          break;
   1183                        }
   1184                      }
   1185                      assert(EpCnfg[EP].AvbBuff <= (EpCnfg[EP].bDoubleBuffered + 1));
   1186                      USB_EP_IO(EP);
   1187                    }
   1188                    break;
   1189                  }
   1190                  ++EP; Mask <<= 1;
   1191                }
   1192                // Clear Fast EP interrupt
   1193                // EPs' pending interrupts are cleared
   1194                if(EpIntr == 0)
   1195                {
   1196                  USBDEVINTCLR = bmUSB_FastInterrupt;
   1197                }
   1198              }
   1199          #else
   1200              // high priority SOF
   1201            #if USB_SOF_EVENT > 0
   1202              // Frame interrupt
   1203              if(USBDEVINTST_bit.FRAME)
   1204              {
   1205                USBDEVINTCLR = bmUSB_FrameInterrupt;
   1206              #if USB_SOF_FRAME_NUMB > 0
   1207                USB_FRAME_HOOK(USB_Cmd(CMD_USB_RD_FRAME_NUMB,0));
   1208              #else
   1209                USB_FRAME_HOOK(0);
   1210              #endif
   1211              }
   1212            #endif
   1213          #endif  // 2 == USB_DEV_PRIORITY
   1214            }
   1215          #endif  // USB_DEV_PRIORITY != 0
   1216          
   1217          #if USB_DMA_DD_MAX_NUMB > 0
   1218            if (USBINTS_bit.USB_INT_REQ_DMA)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13_14  ;; 0x400fc1c0
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD078             BEQ.N    ??USB_IRQHandler_0
   1219            {
   1220              Int32U UsbDmaInt = 0;
   \   00000016   0x2500             MOVS     R5,#+0
   1221              Int32U Tmp;
   1222              // Collect Interrupts status flags and clear interrupt flags
   1223            #if DMA_INT_ENABLE_MASK & 1
   1224              Tmp = LPC_USB->EoTIntSt;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable13_15  ;; 0x2008c2a0
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0006             MOVS     R6,R0
   1225              if(LPC_USB->DMAIntEn & 1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable13_16  ;; 0x2008c294
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD500             BPL.N    ??USB_IRQHandler_1
   1226              {
   1227                UsbDmaInt |= Tmp;
   \   0000002A   0x4335             ORRS     R5,R6,R5
   1228              }
   1229              LPC_USB->EoTIntClr = Tmp;
   \                     ??USB_IRQHandler_1:
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable13_17  ;; 0x2008c2a4
   \   00000030   0x6006             STR      R6,[R0, #+0]
   1230            #endif // DMA_INT_ENABLE_MASK & 1
   1231          
   1232            #if DMA_INT_ENABLE_MASK & 2
   1233              Tmp = USBNDDRINTST;
   1234              if(LPC_USB->DMAIntEn & 2)
   1235              {
   1236                UsbDmaInt |= Tmp;
   1237              }
   1238              LPC_USB->NDDRIntClr = Tmp;
   1239            #endif // DMA_INT_ENABLE_MASK & 2
   1240          
   1241            #if DMA_INT_ENABLE_MASK & 4
   1242              Tmp = LPC_USB->SysErrIntSt;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable13_18  ;; 0x2008c2b8
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x0006             MOVS     R6,R0
   1243              if(LPC_USB->DMAIntEn & 4)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable13_16  ;; 0x2008c294
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x0740             LSLS     R0,R0,#+29
   \   00000042   0xD500             BPL.N    ??USB_IRQHandler_2
   1244              {
   1245                UsbDmaInt |= Tmp;
   \   00000044   0x4335             ORRS     R5,R6,R5
   1246              }
   1247              LPC_USB->SysErrIntClr = Tmp;
   \                     ??USB_IRQHandler_2:
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable13_19  ;; 0x2008c2bc
   \   0000004A   0x6006             STR      R6,[R0, #+0]
   1248            #endif // DMA_INT_ENABLE_MASK & 4
   1249              USB_Endpoint_t EP;
   1250              Int32U EpMask;
   1251          
   1252              // All endpoints without ctrl EP_In, ctrl EP_Out
   1253              for(EP = ENP1_OUT, EpMask = 4; UsbDmaInt; ++EP, EpMask <<= 1)
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x0007             MOVS     R7,R0
   \   00000050   0x2004             MOVS     R0,#+4
   \   00000052   0x4680             MOV      R8,R0
   \                     ??USB_IRQHandler_3:
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD057             BEQ.N    ??USB_IRQHandler_0
   1254              {
   1255                if(0 == (UsbDmaInt & EpMask))
   \   00000058   0xEA15 0x0F08      TST      R5,R8
   \   0000005C   0xD050             BEQ.N    ??USB_IRQHandler_4
   1256                {
   1257                  continue;
   1258                }
   1259                UsbDmaInt &= ~EpMask;
   \                     ??USB_IRQHandler_5:
   \   0000005E   0xEA35 0x0508      BICS     R5,R5,R8
   1260                //call callback function
   1261              #if USB_DMA_ID_MAX_NUMB > 0
   1262                if(EpCnfg[EP].pUSB_DmaDesc->Isochronous)
   1263                {
   1264                  EpCnfg[EP].Size = EpCnfg[EP].pDmaIsoPacket->PacketLength;
   1265                  EpCnfg[EP].Status = COMPLETE;
   1266                }
   1267                else
   1268                {
   1269                  EpCnfg[EP].Size = EpCnfg[EP].pUSB_DmaDesc->PresentCnt;
   1270                  switch (EpCnfg[EP].pUSB_DmaDesc->DdState)
   1271                  {
   1272                  case UsbDmaNormalCompletion:
   1273                    EpCnfg[EP].Status = COMPLETE;
   1274                    break;
   1275                  case UsbDmaDataUnderrun:
   1276                    EpCnfg[EP].Status = BUFFER_UNDERRUN;
   1277                    break;
   1278                  case UsbDmaDataOverrun:
   1279                    EpCnfg[EP].Status = BUFFER_OVERRUN;
   1280                    break;
   1281                  default:
   1282                    EpCnfg[EP].Offset = 0;
   1283                  }
   1284                }
   1285              #else
   1286                EpCnfg[EP].Size = EpCnfg[EP].pUSB_DmaDesc->PresentCnt;
   \   00000062   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000064   0x2024             MOVS     R0,#+36
   \   00000066   0x....             LDR.N    R1,??DataTable13_2
   \   00000068   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   0000006C   0x6A00             LDR      R0,[R0, #+32]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0x0C00             LSRS     R0,R0,#+16
   \   00000072   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000074   0x2124             MOVS     R1,#+36
   \   00000076   0x....             LDR.N    R2,??DataTable13_2
   \   00000078   0xFB01 0x2107      MLA      R1,R1,R7,R2
   \   0000007C   0x6108             STR      R0,[R1, #+16]
   1287                switch (EpCnfg[EP].pUSB_DmaDesc->DdState)
   \   0000007E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000080   0x2024             MOVS     R0,#+36
   \   00000082   0x....             LDR.N    R1,??DataTable13_2
   \   00000084   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   00000088   0x6A00             LDR      R0,[R0, #+32]
   \   0000008A   0x68C0             LDR      R0,[R0, #+12]
   \   0000008C   0x0840             LSRS     R0,R0,#+1
   \   0000008E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000092   0x2802             CMP      R0,#+2
   \   00000094   0xD004             BEQ.N    ??USB_IRQHandler_6
   \   00000096   0x2803             CMP      R0,#+3
   \   00000098   0xD00A             BEQ.N    ??USB_IRQHandler_7
   \   0000009A   0x2808             CMP      R0,#+8
   \   0000009C   0xD010             BEQ.N    ??USB_IRQHandler_8
   \   0000009E   0xE017             B.N      ??USB_IRQHandler_9
   1288                {
   1289                case UsbDmaNormalCompletion:
   1290                  EpCnfg[EP].Status = COMPLETE;
   \                     ??USB_IRQHandler_6:
   \   000000A0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A2   0x2024             MOVS     R0,#+36
   \   000000A4   0x....             LDR.N    R1,??DataTable13_2
   \   000000A6   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000000AA   0x2103             MOVS     R1,#+3
   \   000000AC   0x7501             STRB     R1,[R0, #+20]
   1291                  break;
   \   000000AE   0xE016             B.N      ??USB_IRQHandler_10
   1292                case UsbDmaDataUnderrun:
   1293                  EpCnfg[EP].Status = BUFFER_UNDERRUN;
   \                     ??USB_IRQHandler_7:
   \   000000B0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B2   0x2024             MOVS     R0,#+36
   \   000000B4   0x....             LDR.N    R1,??DataTable13_2
   \   000000B6   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000000BA   0x2104             MOVS     R1,#+4
   \   000000BC   0x7501             STRB     R1,[R0, #+20]
   1294                  break;
   \   000000BE   0xE00E             B.N      ??USB_IRQHandler_10
   1295                case UsbDmaDataOverrun:
   1296                  EpCnfg[EP].Status = BUFFER_OVERRUN;
   \                     ??USB_IRQHandler_8:
   \   000000C0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000C2   0x2024             MOVS     R0,#+36
   \   000000C4   0x....             LDR.N    R1,??DataTable13_2
   \   000000C6   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000000CA   0x2105             MOVS     R1,#+5
   \   000000CC   0x7501             STRB     R1,[R0, #+20]
   1297                  break;
   \   000000CE   0xE006             B.N      ??USB_IRQHandler_10
   1298                default:
   1299                  EpCnfg[EP].Offset = 0;
   \                     ??USB_IRQHandler_9:
   \   000000D0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D2   0x2024             MOVS     R0,#+36
   \   000000D4   0x....             LDR.N    R1,??DataTable13_2
   \   000000D6   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000000DA   0x2100             MOVS     R1,#+0
   \   000000DC   0x60C1             STR      R1,[R0, #+12]
   1300                }
   1301              #endif // USB_DMA_ID_MAX_NUMB > 0
   1302                if(EpCnfg[EP].pFn)
   \                     ??USB_IRQHandler_10:
   \   000000DE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E0   0x2024             MOVS     R0,#+36
   \   000000E2   0x....             LDR.N    R1,??DataTable13_2
   \   000000E4   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000000E8   0x6880             LDR      R0,[R0, #+8]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD008             BEQ.N    ??USB_IRQHandler_4
   1303                {
   1304                  ((void(*)(USB_Endpoint_t))EpCnfg[EP].pFn)(EP);
   \   000000EE   0x0038             MOVS     R0,R7
   \   000000F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F4   0x2124             MOVS     R1,#+36
   \   000000F6   0x....             LDR.N    R2,??DataTable13_2
   \   000000F8   0xFB01 0x2107      MLA      R1,R1,R7,R2
   \   000000FC   0x6889             LDR      R1,[R1, #+8]
   \   000000FE   0x4788             BLX      R1
   1305                }
   1306              }
   \                     ??USB_IRQHandler_4:
   \   00000100   0x1C7F             ADDS     R7,R7,#+1
   \   00000102   0xEA5F 0x0848      LSLS     R8,R8,#+1
   \   00000106   0xE7A5             B.N      ??USB_IRQHandler_3
   1307            }
   1308          #endif // USB_DMA_DD_MAX_NUMB > 0
   1309          
   1310            if (USBINTS_bit.USB_INT_REQ_LP)
   \                     ??USB_IRQHandler_0:
   \   00000108   0x....             LDR.N    R0,??DataTable13_14  ;; 0x400fc1c0
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0x07C0             LSLS     R0,R0,#+31
   \   0000010E   0xF140 0x8128      BPL.W    ??USB_IRQHandler_11
   1311            {
   1312            #if USB_ERROR_EVENT > 0
   1313              // USB engine error interrupt
   1314              if(USBDEVINTST_bit.ERR_INT)
   \   00000112   0x....             LDR.N    R0,??DataTable13_20  ;; 0x2008c200
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0xF3C0 0x2040      UBFX     R0,R0,#+9,#+1
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD009             BEQ.N    ??USB_IRQHandler_12
   1315              {
   1316                LPC_USB->DevIntClr = bmUSB_ErrorInterrupt;
   \   0000011E   0x....             LDR.N    R0,??DataTable13_21  ;; 0x2008c208
   \   00000120   0xF44F 0x7100      MOV      R1,#+512
   \   00000124   0x6001             STR      R1,[R0, #+0]
   1317                USB_ERR_HOOK(USB_Cmd(CMD_USB_RD_ERROR_STAT,0));
   \   00000126   0x2100             MOVS     R1,#+0
   \   00000128   0x20FB             MOVS     R0,#+251
   \   0000012A   0x.... 0x....      BL       USB_Cmd
   \   0000012E   0x.... 0x....      BL       USB_ERR_HOOK
   1318              }
   1319            #endif
   1320            #if USB_SOF_EVENT > 0 && 1 != USB_DEV_PRIORITY
   1321              // Frame interrupt
   1322              if(USBDEVINTST_bit.FRAME)
   1323              {
   1324                LPC_USB->DevIntClr = bmUSB_FrameInterrupt;
   1325              #if USB_SOF_FRAME_NUMB > 0
   1326                USB_FRAME_HOOK(USB_Cmd(CMD_USB_RD_FRAME_NUMB,0));
   1327              #else
   1328                USB_FRAME_HOOK(0);
   1329              #endif
   1330              }
   1331            #endif
   1332              // Device Status interrupt
   1333              if(USBDEVINTST_bit.DEV_STAT)
   \                     ??USB_IRQHandler_12:
   \   00000132   0x....             LDR.N    R0,??DataTable13_20  ;; 0x2008c200
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD03B             BEQ.N    ??USB_IRQHandler_13
   1334              {
   1335                // Clear Device status interrupt
   1336                LPC_USB->DevIntClr = bmUSB_DevStatusInterrupt;
   \   0000013E   0x....             LDR.N    R0,??DataTable13_21  ;; 0x2008c208
   \   00000140   0x2108             MOVS     R1,#+8
   \   00000142   0x6001             STR      R1,[R0, #+0]
   1337                // Get device status
   1338                USB_DevStatus.Data = USB_Cmd(CMD_USB_GET_DEV_STAT,0);
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0x20FE             MOVS     R0,#+254
   \   00000148   0x.... 0x....      BL       USB_Cmd
   \   0000014C   0x....             LDR.N    R1,??DataTable13
   \   0000014E   0x7008             STRB     R0,[R1, #+0]
   1339                // Device connection status
   1340                if(USB_DevStatus.ConnectChange)
   \   00000150   0x....             LDR.N    R0,??DataTable13
   \   00000152   0x7800             LDRB     R0,[R0, #+0]
   \   00000154   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000158   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD005             BEQ.N    ??USB_IRQHandler_14
   1341                {
   1342                  UsbDevConnectCallback(USB_DevStatus.Connect);
   \   0000015E   0x....             LDR.N    R0,??DataTable13
   \   00000160   0x7800             LDRB     R0,[R0, #+0]
   \   00000162   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000166   0x.... 0x....      BL       UsbDevConnectCallback
   1343                }
   1344                // Device suspend status
   1345                if(USB_DevStatus.SuspendChange)
   \                     ??USB_IRQHandler_14:
   \   0000016A   0x....             LDR.N    R0,??DataTable13
   \   0000016C   0x7800             LDRB     R0,[R0, #+0]
   \   0000016E   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   00000172   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD006             BEQ.N    ??USB_IRQHandler_15
   1346                {
   1347                  UsbDevSuspendCallback(USB_DevStatus.Suspend);
   \   00000178   0x....             LDR.N    R0,??DataTable13
   \   0000017A   0x7800             LDRB     R0,[R0, #+0]
   \   0000017C   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000180   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000182   0x.... 0x....      BL       UsbDevSuspendCallback
   1348                }
   1349                /************xuliang 2011-10-20**********/
   1350                if(USB_DevStatus.Connect)
   \                     ??USB_IRQHandler_15:
   \   00000186   0x....             LDR.N    R0,??DataTable13
   \   00000188   0x7800             LDRB     R0,[R0, #+0]
   \   0000018A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000018E   0x2800             CMP      R0,#+0
   \   00000190   0xD003             BEQ.N    ??USB_IRQHandler_16
   1351                {
   1352                  USB_CONNECT_FLAG = 1;
   \   00000192   0x....             LDR.N    R0,??DataTable13_22
   \   00000194   0x2101             MOVS     R1,#+1
   \   00000196   0x7001             STRB     R1,[R0, #+0]
   \   00000198   0xE002             B.N      ??USB_IRQHandler_17
   1353                }
   1354                else
   1355                {
   1356                  USB_CONNECT_FLAG = 0;
   \                     ??USB_IRQHandler_16:
   \   0000019A   0x....             LDR.N    R0,??DataTable13_22
   \   0000019C   0x2100             MOVS     R1,#+0
   \   0000019E   0x7001             STRB     R1,[R0, #+0]
   1357                }  
   1358                 /************xuliang 2011-10-20 **********/
   1359                // Device reset
   1360                if(USB_DevStatus.Reset)
   \                     ??USB_IRQHandler_17:
   \   000001A0   0x....             LDR.N    R0,??DataTable13
   \   000001A2   0x7800             LDRB     R0,[R0, #+0]
   \   000001A4   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   000001A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AA   0x2800             CMP      R0,#+0
   \   000001AC   0xD003             BEQ.N    ??USB_IRQHandler_13
   1361                {
   1362                  USB_HwReset();
   \   000001AE   0x.... 0x....      BL       USB_HwReset
   1363                  UsbDevResetCallback();
   \   000001B2   0x.... 0x....      BL       UsbDevResetCallback
   1364                }
   1365              }
   1366          
   1367              // Slow EP interrupt
   1368              while(USBDEVINTST_bit.EP_SLOW)
   \                     ??USB_IRQHandler_13:
   \   000001B6   0x....             LDR.N    R0,??DataTable13_20  ;; 0x2008c200
   \   000001B8   0x6800             LDR      R0,[R0, #+0]
   \   000001BA   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xF000 0x80CF      BEQ.W    ??USB_IRQHandler_11
   1369              {
   1370                Int32U Mask = 1;
   \   000001C4   0x2501             MOVS     R5,#+1
   1371                USB_Endpoint_t EP = CTRL_ENP_OUT;
   \   000001C6   0x2600             MOVS     R6,#+0
   1372                Int32U EpIntr;
   1373                EpIntr  = LPC_USB->EpIntSt;
   \   000001C8   0x....             LDR.N    R0,??DataTable13_23  ;; 0x2008c230
   \   000001CA   0x6800             LDR      R0,[R0, #+0]
   \   000001CC   0x0007             MOVS     R7,R0
   1374                EpIntr &= LPC_USB->EpIntEn;
   \   000001CE   0x....             LDR.N    R0,??DataTable13_24  ;; 0x2008c234
   \   000001D0   0x6800             LDR      R0,[R0, #+0]
   \   000001D2   0x4007             ANDS     R7,R0,R7
   1375              #if 2 == USB_DEV_PRIORITY
   1376                EpIntr &= ~USB_EP_PRIORITY; // clear high priority EPs interrutp flags
   1377              #endif // 2 == USB_DEV_PRIORITY
   1378                while (EpIntr)
   \                     ??USB_IRQHandler_18:
   \   000001D4   0x2F00             CMP      R7,#+0
   \   000001D6   0xF000 0x80BD      BEQ.W    ??USB_IRQHandler_19
   1379                {
   1380                  if(EpIntr & Mask)
   \   000001DA   0x422F             TST      R7,R5
   \   000001DC   0xF000 0x80B7      BEQ.W    ??USB_IRQHandler_20
   1381                  {
   1382                    Val = USB_EpIntrClr(EP) ^ ((EP & 1)?((1<<6)|(1<<5)):0);
   \   000001E0   0x0030             MOVS     R0,R6
   \   000001E2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001E4   0x.... 0x....      BL       USB_EpIntrClr
   \   000001E8   0x07F1             LSLS     R1,R6,#+31
   \   000001EA   0xD501             BPL.N    ??USB_IRQHandler_21
   \   000001EC   0x2160             MOVS     R1,#+96
   \   000001EE   0xE000             B.N      ??USB_IRQHandler_22
   \                     ??USB_IRQHandler_21:
   \   000001F0   0x2100             MOVS     R1,#+0
   \                     ??USB_IRQHandler_22:
   \   000001F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F4   0xEA91 0x0400      EORS     R4,R1,R0
   1383                    if (!EpCnfg[EP].bDoubleBuffered)
   \   000001F8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001FA   0x2024             MOVS     R0,#+36
   \   000001FC   0x....             LDR.N    R1,??DataTable13_2
   \   000001FE   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000202   0x7F40             LDRB     R0,[R0, #+29]
   \   00000204   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000208   0x2800             CMP      R0,#+0
   \   0000020A   0xD101             BNE.N    ??USB_IRQHandler_23
   1384                    {
   1385                      Val &= ~(1<<6);
   \   0000020C   0xF034 0x0440      BICS     R4,R4,#0x40
   1386                    }
   1387                    switch (Val & ((1<<6)|(1<<5)))
   \                     ??USB_IRQHandler_23:
   \   00000210   0xF014 0x0060      ANDS     R0,R4,#0x60
   \   00000214   0x2800             CMP      R0,#+0
   \   00000216   0xD006             BEQ.N    ??USB_IRQHandler_24
   \   00000218   0x2820             CMP      R0,#+32
   \   0000021A   0xD00C             BEQ.N    ??USB_IRQHandler_25
   \   0000021C   0x2840             CMP      R0,#+64
   \   0000021E   0xD012             BEQ.N    ??USB_IRQHandler_26
   \   00000220   0x2860             CMP      R0,#+96
   \   00000222   0xD018             BEQ.N    ??USB_IRQHandler_27
   \   00000224   0xE01E             B.N      ??USB_IRQHandler_28
   1388                    {
   1389                    case 0:
   1390                      EpCnfg[EP].AvbBuff = 0;
   \                     ??USB_IRQHandler_24:
   \   00000226   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000228   0x2024             MOVS     R0,#+36
   \   0000022A   0x....             LDR.N    R1,??DataTable13_2
   \   0000022C   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000230   0x2100             MOVS     R1,#+0
   \   00000232   0x7701             STRB     R1,[R0, #+28]
   1391                      break;
   \   00000234   0xE016             B.N      ??USB_IRQHandler_28
   1392                    case (1<<5):
   1393                      EpCnfg[EP].AvbBuff = 1;
   \                     ??USB_IRQHandler_25:
   \   00000236   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000238   0x2024             MOVS     R0,#+36
   \   0000023A   0x....             LDR.N    R1,??DataTable13_2
   \   0000023C   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000240   0x2101             MOVS     R1,#+1
   \   00000242   0x7701             STRB     R1,[R0, #+28]
   1394                      break;
   \   00000244   0xE00E             B.N      ??USB_IRQHandler_28
   1395                    case (1<<6):
   1396                      EpCnfg[EP].AvbBuff = 1;
   \                     ??USB_IRQHandler_26:
   \   00000246   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000248   0x2024             MOVS     R0,#+36
   \   0000024A   0x....             LDR.N    R1,??DataTable13_2
   \   0000024C   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000250   0x2101             MOVS     R1,#+1
   \   00000252   0x7701             STRB     R1,[R0, #+28]
   1397                      break;
   \   00000254   0xE006             B.N      ??USB_IRQHandler_28
   1398                    case (1<<5) | (1<<6):
   1399                      EpCnfg[EP].AvbBuff = 2;
   \                     ??USB_IRQHandler_27:
   \   00000256   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000258   0x2024             MOVS     R0,#+36
   \   0000025A   0x....             LDR.N    R1,??DataTable13_2
   \   0000025C   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000260   0x2102             MOVS     R1,#+2
   \   00000262   0x7701             STRB     R1,[R0, #+28]
   1400                      break;
   1401                    }
   1402          
   1403                    if(Val & bmUSB_EpSetupPacket)
   \                     ??USB_IRQHandler_28:
   \   00000264   0x0760             LSLS     R0,R4,#+29
   \   00000266   0xD52E             BPL.N    ??USB_IRQHandler_29
   1404                    {
   1405                      // only ctrl EP can receive setup packets
   1406                      assert(EP == CTRL_ENP_OUT);
   \   00000268   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000026A   0x2E00             CMP      R6,#+0
   \   0000026C   0xD007             BEQ.N    ??USB_IRQHandler_30
   \   0000026E   0xF240 0x527E      MOVW     R2,#+1406
   \   00000272   0x....             LDR.N    R1,??DataTable13_25
   \   00000274   0x....             LDR.N    R0,??DataTable13_26
   \   00000276   0x.... 0x....      BL       __aeabi_assert
   \   0000027A   0x.... 0x....      BL       __iar_EmptyStepPoint
   1407                      EpCnfg[CTRL_ENP_IN].AvbBuff  = 1;
   \                     ??USB_IRQHandler_30:
   \   0000027E   0x....             LDR.N    R0,??DataTable13_2
   \   00000280   0x2101             MOVS     R1,#+1
   \   00000282   0xF880 0x1040      STRB     R1,[R0, #+64]
   1408                      // init IO to receive Setup packet
   1409                      USB_IO_Data(CTRL_ENP_IN,NULL,(Int32U)-1,NULL);
   \   00000286   0x2300             MOVS     R3,#+0
   \   00000288   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000028C   0x2100             MOVS     R1,#+0
   \   0000028E   0x2001             MOVS     R0,#+1
   \   00000290   0x.... 0x....      BL       USB_IO_Data
   1410                      USB_IO_Data(CTRL_ENP_OUT,UsbEp0SetupPacket.Data,sizeof(UsbSetupPacket_t),NULL);
   \   00000294   0x2300             MOVS     R3,#+0
   \   00000296   0x2208             MOVS     R2,#+8
   \   00000298   0x....             LDR.N    R1,??DataTable13_27
   \   0000029A   0x2000             MOVS     R0,#+0
   \   0000029C   0x.... 0x....      BL       USB_IO_Data
   1411          
   1412                      // reset EP IO ctrl
   1413                      if (UsbEp0SetupPacket.mRequestType.Dir == UsbDevice2Host)
   \   000002A0   0x....             LDR.N    R0,??DataTable13_27
   \   000002A2   0x7800             LDRB     R0,[R0, #+0]
   \   000002A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002A6   0x09C0             LSRS     R0,R0,#+7
   \   000002A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002AA   0x2800             CMP      R0,#+0
   \   000002AC   0xD002             BEQ.N    ??USB_IRQHandler_31
   1414                      {
   1415                        USB_StatusHandler(CTRL_ENP_OUT);
   \   000002AE   0x2000             MOVS     R0,#+0
   \   000002B0   0x.... 0x....      BL       USB_StatusHandler
   1416                      }
   1417          
   1418                      USB_SetupHandler();
   \                     ??USB_IRQHandler_31:
   \   000002B4   0x.... 0x....      BL       USB_SetupHandler
   1419          
   1420                      if(EpCnfg[CTRL_ENP_OUT].Status == STALLED)
   \   000002B8   0x....             LDR.N    R0,??DataTable13_2
   \   000002BA   0x7D00             LDRB     R0,[R0, #+20]
   \   000002BC   0x2807             CMP      R0,#+7
   \   000002BE   0xD101             BNE.N    ??USB_IRQHandler_32
   1421                      {
   1422                        USB_StallCtrlEP();
   \   000002C0   0x.... 0x....      BL       USB_StallCtrlEP
   1423                      }
   1424                      break;
   \                     ??USB_IRQHandler_32:
   \   000002C4   0xE046             B.N      ??USB_IRQHandler_19
   1425                    }
   1426                    else
   1427                    {
   1428                      if(EP == CTRL_ENP_OUT)
   \                     ??USB_IRQHandler_29:
   \   000002C6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000002C8   0x2E00             CMP      R6,#+0
   \   000002CA   0xD10F             BNE.N    ??USB_IRQHandler_33
   1429                      {
   1430                        if(UsbEp0SetupPacket.mRequestType.Dir == UsbDevice2Host &&
   1431                           EpCnfg[CTRL_ENP_OUT].pFn)
   \   000002CC   0x....             LDR.N    R0,??DataTable13_27
   \   000002CE   0x7800             LDRB     R0,[R0, #+0]
   \   000002D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002D2   0x09C0             LSRS     R0,R0,#+7
   \   000002D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002D6   0x2800             CMP      R0,#+0
   \   000002D8   0xD01B             BEQ.N    ??USB_IRQHandler_34
   \   000002DA   0x....             LDR.N    R0,??DataTable13_2
   \   000002DC   0x6880             LDR      R0,[R0, #+8]
   \   000002DE   0x2800             CMP      R0,#+0
   \   000002E0   0xD017             BEQ.N    ??USB_IRQHandler_34
   1432                        {
   1433                          ((void(*)(USB_Endpoint_t))EpCnfg[CTRL_ENP_OUT].pFn)(CTRL_ENP_OUT);
   \   000002E2   0x2000             MOVS     R0,#+0
   \   000002E4   0x....             LDR.N    R1,??DataTable13_2
   \   000002E6   0x6889             LDR      R1,[R1, #+8]
   \   000002E8   0x4788             BLX      R1
   1434                          break;
   \   000002EA   0xE033             B.N      ??USB_IRQHandler_19
   1435                        }
   1436                      }
   1437                      else if(EP == CTRL_ENP_IN)//insert int
   \                     ??USB_IRQHandler_33:
   \   000002EC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000002EE   0x2E01             CMP      R6,#+1
   \   000002F0   0xD10F             BNE.N    ??USB_IRQHandler_34
   1438                      {
   1439                        if(UsbEp0SetupPacket.mRequestType.Dir == UsbHost2Device &&
   1440                           EpCnfg[CTRL_ENP_IN].pFn)
   \   000002F2   0x....             LDR.N    R0,??DataTable13_27
   \   000002F4   0x7800             LDRB     R0,[R0, #+0]
   \   000002F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002F8   0x09C0             LSRS     R0,R0,#+7
   \   000002FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002FC   0x2800             CMP      R0,#+0
   \   000002FE   0xD108             BNE.N    ??USB_IRQHandler_34
   \   00000300   0x....             LDR.N    R0,??DataTable13_2
   \   00000302   0x6AC0             LDR      R0,[R0, #+44]
   \   00000304   0x2800             CMP      R0,#+0
   \   00000306   0xD004             BEQ.N    ??USB_IRQHandler_34
   1441                        {
   1442                          ((void(*)(USB_Endpoint_t))EpCnfg[CTRL_ENP_IN].pFn)(CTRL_ENP_IN);
   \   00000308   0x2001             MOVS     R0,#+1
   \   0000030A   0x....             LDR.N    R1,??DataTable13_2
   \   0000030C   0x6AC9             LDR      R1,[R1, #+44]
   \   0000030E   0x4788             BLX      R1
   1443                          break;
   \   00000310   0xE020             B.N      ??USB_IRQHandler_19
   1444                        }
   1445                      }
   1446                      assert(EpCnfg[EP].AvbBuff <= (EpCnfg[EP].bDoubleBuffered + 1));
   \                     ??USB_IRQHandler_34:
   \   00000312   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000314   0x2024             MOVS     R0,#+36
   \   00000316   0x....             LDR.N    R1,??DataTable13_2
   \   00000318   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000031C   0x7F40             LDRB     R0,[R0, #+29]
   \   0000031E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000322   0x1C40             ADDS     R0,R0,#+1
   \   00000324   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000326   0x2124             MOVS     R1,#+36
   \   00000328   0x....             LDR.N    R2,??DataTable13_2
   \   0000032A   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   0000032E   0x7F09             LDRB     R1,[R1, #+28]
   \   00000330   0x4288             CMP      R0,R1
   \   00000332   0xDA07             BGE.N    ??USB_IRQHandler_35
   \   00000334   0xF240 0x52A6      MOVW     R2,#+1446
   \   00000338   0x....             LDR.N    R1,??DataTable13_25
   \   0000033A   0x....             LDR.N    R0,??DataTable13_28
   \   0000033C   0x.... 0x....      BL       __aeabi_assert
   \   00000340   0x.... 0x....      BL       __iar_EmptyStepPoint
   1447                      USB_EP_IO(EP);
   \                     ??USB_IRQHandler_35:
   \   00000344   0x0030             MOVS     R0,R6
   \   00000346   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000348   0x.... 0x....      BL       USB_EP_IO
   1448                    }
   1449                    break;
   \   0000034C   0xE002             B.N      ??USB_IRQHandler_19
   1450                  }
   1451                  ++EP; Mask <<= 1;
   \                     ??USB_IRQHandler_20:
   \   0000034E   0x1C76             ADDS     R6,R6,#+1
   \   00000350   0x006D             LSLS     R5,R5,#+1
   \   00000352   0xE73F             B.N      ??USB_IRQHandler_18
   1452                }
   1453                // Clear Slow EP interrupt
   1454                // EPs' pending interrupts are cleared
   1455                if(EpIntr == 0)
   \                     ??USB_IRQHandler_19:
   \   00000354   0x2F00             CMP      R7,#+0
   \   00000356   0xF47F 0xAF2E      BNE.W    ??USB_IRQHandler_13
   1456                {
   1457                  LPC_USB->DevIntClr = bmUSB_SlowInterrupt;
   \   0000035A   0x....             LDR.N    R0,??DataTable13_21  ;; 0x2008c208
   \   0000035C   0x2104             MOVS     R1,#+4
   \   0000035E   0x6001             STR      R1,[R0, #+0]
   \   00000360   0xE729             B.N      ??USB_IRQHandler_13
   1458                }
   1459              }
   1460            }
   1461          
   1462            USB_INTR_EXIT_HOOK();
   \                     ??USB_IRQHandler_11:
   \   00000362   0x.... 0x....      BL       USB_INTR_EXIT_HOOK
   1463            //NVIC_ClrPend(USB_IRQn);
   1464            NVIC_ClearPendingIRQ(USB_IRQn);
   \   00000366   0x2018             MOVS     R0,#+24
   \   00000368   0x.... 0x....      BL       NVIC_ClearPendingIRQ
   1465          }
   \   0000036C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \   00000370                      REQUIRE _A_USBINTS
   \   00000370                      REQUIRE _A_USBDEVINTST

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x2008C208         DC32     0x2008c208

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x2008C210         DC32     0x2008c210

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x2008C200         DC32     0x2008c200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x2008C214         DC32     0x2008c214

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x2008C238         DC32     0x2008c238

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     `?<Constant "--TO">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x4002C07C         DC32     0x4002c07c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x4002C038         DC32     0x4002c038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x4002C0F8         DC32     0x4002c0f8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x4002C034         DC32     0x4002c034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     `?<Constant "D:\\\\wangfan2\\\\\\327\\300\\303\\346\\\\RT`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x400FC0C4         DC32     0x400fc0c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x2008CFF4         DC32     0x2008cff4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x2008CFF8         DC32     0x2008cff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x2008C110         DC32     0x2008c110

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x400FC1C0         DC32     0x400fc1c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     USB_DevStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x2008C234         DC32     0x2008c234

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x2008C240         DC32     0x2008c240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x........         DC32     USB_CtrlEpExtDescr0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x........         DC32     USB_CtrlEpDescr0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x........         DC32     USB_CtrlEpExtDescr1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x........         DC32     USB_CtrlEpDescr1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   0x2008C294         DC32     0x2008c294

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   0x2008C28C         DC32     0x2008c28c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   0x2008C254         DC32     0x2008c254

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   0x2008C2A4         DC32     0x2008c2a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   0x2008C2B0         DC32     0x2008c2b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \   00000000   0x2008C2BC         DC32     0x2008c2bc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \   00000000   0x........         DC32     USB_DDCA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \   00000000   0x........         DC32     DmaFree

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_21:
   \   00000000   0x........         DC32     USB_DmaDesc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_22:
   \   00000000   0x2008C280         DC32     0x2008c280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_23:
   \   00000000   0x2008C204         DC32     0x2008c204

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_24:
   \   00000000   0x........         DC32     EpCnfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_25:
   \   00000000   0x........         DC32     UsbEpDoubleBuffType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_26:
   \   00000000   0x2008C244         DC32     0x2008c244

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_27:
   \   00000000   0x2008C248         DC32     0x2008c248

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_28:
   \   00000000   0x2008C24C         DC32     0x2008c24c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     USB_DevStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     `?<Constant "(LPC_USB->ReEp & (1UL...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     EpCnfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     `?<Constant "(LPC_USB->ReEp & (1UL...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x2008C288         DC32     0x2008c288

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x2008C258         DC32     0x2008c258

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x2008C228         DC32     0x2008c228

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x2008C224         DC32     0x2008c224

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x........         DC32     `?<Constant "USBCTRL_bit.WR_EN">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x2008C21C         DC32     0x2008c21c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     `?<Constant "!USBCTRL_bit.WR_EN">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x2008C220         DC32     0x2008c220

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x2008C218         DC32     0x2008c218

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x........         DC32     `?<Constant "!USBRXPLEN_bit.DV">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x400FC1C0         DC32     0x400fc1c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x2008C2A0         DC32     0x2008c2a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x2008C294         DC32     0x2008c294

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \   00000000   0x2008C2A4         DC32     0x2008c2a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \   00000000   0x2008C2B8         DC32     0x2008c2b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \   00000000   0x2008C2BC         DC32     0x2008c2bc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_20:
   \   00000000   0x2008C200         DC32     0x2008c200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_21:
   \   00000000   0x2008C208         DC32     0x2008c208

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_22:
   \   00000000   0x........         DC32     USB_CONNECT_FLAG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_23:
   \   00000000   0x2008C230         DC32     0x2008c230

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_24:
   \   00000000   0x2008C234         DC32     0x2008c234

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_25:
   \   00000000   0x........         DC32     `?<Constant "D:\\\\wangfan2\\\\\\327\\300\\303\\346\\\\RT`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_26:
   \   00000000   0x........         DC32     `?<Constant "EP == CTRL_ENP_OUT">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_27:
   \   00000000   0x........         DC32     UsbEp0SetupPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_28:
   \   00000000   0x........         DC32     `?<Constant "EpCnfg[EP].AvbBuff <=...">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "--TO">`:
   \   00000000   0x2D 0x2D          DC8 "--TO"
   \              0x54 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "D:\\\\wangfan2\\\\\\327\\300\\303\\346\\\\RT`:
   \   00000000   0x44 0x3A          DC8 "D:\\wangfan2\\\327\300\303\346\\RTU_1.3\\USB\\usb_hw.c"
   \              0x5C 0x77    
   \              0x61 0x6E    
   \              0x67 0x66    
   \              0x61 0x6E    
   \              0x32 0x5C    
   \              0xD7 0xC0    
   \              0xC3 0xE6    
   \              0x5C 0x52    
   \              0x54 0x55    
   \              0x5F 0x31    
   \              0x2E 0x33    
   \              0x5C 0x55    
   \              0x53 0x42    
   \              0x5C 0x75    
   \              0x73 0x62    
   \              0x5F 0x68    
   \              0x77 0x2E    
   \              0x63 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "(LPC_USB->ReEp & (1UL...">`:
   \   00000000   0x28 0x4C          DC8 "(LPC_USB->ReEp & (1UL<<EP))"
   \              0x50 0x43    
   \              0x5F 0x55    
   \              0x53 0x42    
   \              0x2D 0x3E    
   \              0x52 0x65    
   \              0x45 0x70    
   \              0x20 0x26    
   \              0x20 0x28    
   \              0x31 0x55    
   \              0x4C 0x3C    
   \              0x3C 0x45    
   \              0x50 0x29    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "(LPC_USB->ReEp & (1UL...">_1`:
   \   00000000   0x28 0x4C          DC8 "(LPC_USB->ReEp & (1UL<<EndPoint))"
   \              0x50 0x43    
   \              0x5F 0x55    
   \              0x53 0x42    
   \              0x2D 0x3E    
   \              0x52 0x65    
   \              0x45 0x70    
   \              0x20 0x26    
   \              0x20 0x28    
   \              0x31 0x55    
   \              0x4C 0x3C    
   \              0x3C 0x45    
   \              0x6E 0x64    
   \              0x50 0x6F    
   \              0x69 0x6E    
   \              0x74 0x29    
   \              0x29 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "USBCTRL_bit.WR_EN">`:
   \   00000000   0x55 0x53          DC8 "USBCTRL_bit.WR_EN"
   \              0x42 0x43    
   \              0x54 0x52    
   \              0x4C 0x5F    
   \              0x62 0x69    
   \              0x74 0x2E    
   \              0x57 0x52    
   \              0x5F 0x45    
   \              0x4E 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "!USBCTRL_bit.WR_EN">`:
   \   00000000   0x21 0x55          DC8 "!USBCTRL_bit.WR_EN"
   \              0x53 0x42    
   \              0x43 0x54    
   \              0x52 0x4C    
   \              0x5F 0x62    
   \              0x69 0x74    
   \              0x2E 0x57    
   \              0x52 0x5F    
   \              0x45 0x4E    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "!USBRXPLEN_bit.DV">`:
   \   00000000   0x21 0x55          DC8 "!USBRXPLEN_bit.DV"
   \              0x53 0x42    
   \              0x52 0x58    
   \              0x50 0x4C    
   \              0x45 0x4E    
   \              0x5F 0x62    
   \              0x69 0x74    
   \              0x2E 0x44    
   \              0x56 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "EP == CTRL_ENP_OUT">`:
   \   00000000   0x45 0x50          DC8 "EP == CTRL_ENP_OUT"
   \              0x20 0x3D    
   \              0x3D 0x20    
   \              0x43 0x54    
   \              0x52 0x4C    
   \              0x5F 0x45    
   \              0x4E 0x50    
   \              0x5F 0x4F    
   \              0x55 0x54    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "EpCnfg[EP].AvbBuff <=...">`:
   \   00000000   0x45 0x70          DC8 45H, 70H, 43H, 6EH, 66H, 67H, 5BH, 45H
   \              0x43 0x6E    
   \              0x66 0x67    
   \              0x5B 0x45    
   \   00000008   0x50 0x5D          DC8 50H, 5DH, 2EH, 41H, 76H, 62H, 42H, 75H
   \              0x2E 0x41    
   \              0x76 0x62    
   \              0x42 0x75    
   \   00000010   0x66 0x66          DC8 66H, 66H, 20H, 3CH, 3DH, 20H, 28H, 45H
   \              0x20 0x3C    
   \              0x3D 0x20    
   \              0x28 0x45    
   \   00000018   0x70 0x43          DC8 70H, 43H, 6EH, 66H, 67H, 5BH, 45H, 50H
   \              0x6E 0x66    
   \              0x67 0x5B    
   \              0x45 0x50    
   \   00000020   0x5D 0x2E          DC8 5DH, 2EH, 62H, 44H, 6FH, 75H, 62H, 6CH
   \              0x62 0x44    
   \              0x6F 0x75    
   \              0x62 0x6C    
   \   00000028   0x65 0x42          DC8 65H, 42H, 75H, 66H, 66H, 65H, 72H, 65H
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x65    
   \   00000030   0x64 0x20          DC8 64H, 20H, 2BH, 20H, 31H, 29H, 0
   \              0x2B 0x20    
   \              0x31 0x29    
   \              0x00         
   \   00000037   0x00               DC8 0
   1466          
   1467          
   1468          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   EntrCritSection
       0   ExtCritSection
       4   NVIC_ClearPendingIRQ
       4   NVIC_EnableIRQ
       0   NVIC_SetPriority
      16   USB_Cmd
        16   -> EntrCritSection
        16   -> ExtCritSection
       8   USB_Configure
         8   -> USB_Cmd
       8   USB_ConnectRes
         8   -> USB_Cmd
      24   USB_EP_IO
        24   -- Indirect call
        24   -> USB_Cmd
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      16   USB_EpIntrClr
        16   -> EntrCritSection
        16   -> ExtCritSection
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   USB_EpLogToPhysAdd
       0   USB_GetDevStatus
      16   USB_GetStallEP
        16   -> USB_Cmd
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   USB_HwInit
         8   -> NVIC_EnableIRQ
         8   -> NVIC_SetPriority
         8   -> USB_Cmd
         8   -> USB_ConnectRes
         8   -> USB_HwReset
         8   -> USB_SetAdd
         8   -> UsbSetDevState
       8   USB_HwReset
         8   -> USB_Configure
         8   -> USB_RealizeEp
      24   USB_IRQHandler
        24   -- Indirect call
        24   -> NVIC_ClearPendingIRQ
        24   -> USB_Cmd
        24   -> USB_EP_IO
        24   -> USB_ERR_HOOK
        24   -> USB_EpIntrClr
        24   -> USB_HwReset
        24   -> USB_INTR_ENTRY_HOOK
        24   -> USB_INTR_EXIT_HOOK
        24   -> USB_IO_Data
        24   -> USB_SetupHandler
        24   -> USB_StallCtrlEP
        24   -> USB_StatusHandler
        24   -> UsbDevConnectCallback
        24   -> UsbDevResetCallback
        24   -> UsbDevSuspendCallback
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   USB_RealizeEp
        24   -> USB_EpLogToPhysAdd
       8   USB_SetAdd
         8   -> USB_Cmd
      16   USB_SetStallEP
        16   -> USB_Cmd
        16   -> USB_GetStallEP
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   USB_StallCtrlEP
         8   -> USB_Cmd
       8   USB_StatusPhase
         8   -> USB_IO_Data


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "!USBCTRL_bit.WR_EN">
      20  ?<Constant "!USBRXPLEN_bit.DV">
      28  ?<Constant "(LPC_USB->ReEp & (1UL...">
      36  ?<Constant "(LPC_USB->ReEp & (1UL...">_1
       8  ?<Constant "--TO">
      40  ?<Constant "D:\\wangfan2\\\327\300\303\346\\RT
      20  ?<Constant "EP == CTRL_ENP_OUT">
      56  ?<Constant "EpCnfg[EP].AvbBuff <=...">
      20  ?<Constant "USBCTRL_bit.WR_EN">
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_25
       4  ??DataTable12_26
       4  ??DataTable12_27
       4  ??DataTable12_28
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_22
       4  ??DataTable13_23
       4  ??DataTable13_24
       4  ??DataTable13_25
       4  ??DataTable13_26
       4  ??DataTable13_27
       4  ??DataTable13_28
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       8  DmaFree
      28  EntrCritSection
    1152  EpCnfg
      24  ExtCritSection
      26  NVIC_ClearPendingIRQ
      26  NVIC_EnableIRQ
      38  NVIC_SetPriority
     326  USB_Cmd
      16  USB_Configure
      26  USB_ConnectRes
       8  USB_CtrlEpDescr0
       8  USB_CtrlEpDescr1
       4  USB_CtrlEpExtDescr0
       4  USB_CtrlEpExtDescr1
     128  USB_DDCA
       4  USB_DevStatus
      40  USB_DmaDesc
    1742  USB_EP_IO
      84  USB_EpIntrClr
      18  USB_EpLogToPhysAdd
      60  USB_GetDevStatus
      62  USB_GetStallEP
     278  USB_HwInit
     196  USB_HwReset
     880  USB_IRQHandler
     808  USB_RealizeEp
      30  USB_SetAdd
     140  USB_SetStallEP
      44  USB_StallCtrlEP
      22  USB_StatusPhase
     128  UsbEpDoubleBuffType
       4  _A_USBCTRL
       4  _A_USBDEVINTST
       4  _A_USBINTS
       4  _A_USBRXPLEN

 
 1 164 bytes in section .bss
    16 bytes in section .noinit     (abs)
   400 bytes in section .rodata
 5 162 bytes in section .text
   168 bytes in section USB_DMA_RAM
 
 5 110 bytes of CODE  memory (+ 52 bytes shared)
   400 bytes of CONST memory
 1 332 bytes of DATA  memory (+ 16 bytes shared)

Errors: none
Warnings: none
