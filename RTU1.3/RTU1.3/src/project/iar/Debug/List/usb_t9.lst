###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.6.4896/W32 for ARM      05/Apr/2017  15:06:14 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\wangfan2\桌面\RTU_1.3\USB\usb_t9.c                    #
#    Command line =  D:\wangfan2\桌面\RTU_1.3\USB\usb_t9.c -lCN               #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\List\ -o      #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\Obj\          #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I D:\wangfan2\桌面\RTU_1.3\project\iar\ -I       #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\ -I       #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\ADC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\RTC\ -I   #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\TILT\ -I  #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\RDLevel\  #
#                    -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\RS232\ #
#                     -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\OS-v2 #
#                    \ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\BSP\Vibr #
#                    ationString\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\ #
#                    ..\ucos2\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\ -I     #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\ucos2\uCOS-II #
#                    \Source\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\u #
#                    cos2\uC-LIB\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\ #
#                    ..\ucos2\uC-CPU\ -I D:\wangfan2\桌面\RTU_1.3\project\iar #
#                    \..\..\ucos2\uC-CPU\ARM-Cortex-M3\IAR\ -I                #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\cmsis\Drivers #
#                    \source\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\c #
#                    msis\Drivers\include\ -I D:\wangfan2\桌面\RTU_1.3\projec #
#                    t\iar\..\..\app\ -I D:\wangfan2\桌面\RTU_1.3\project\iar #
#                    \..\..\uC-Probe\Target\Plugins\uCOS-II\ -I               #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Workspaces\ -I                            #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Demos\Intro\Source\ -I D:\wangfan2\桌面\RTU_1.3\proje #
#                    ct\iar\..\..\uC-Probe\Target\Communication\Generic\Sourc #
#                    e\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Prob #
#                    e\Target\Communication\Generic\RS-232\Source\ -I         #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\Ports\NXP\LPC17xx\ -I    #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\uC-Probe\Targ #
#                    et\Communication\Generic\RS-232\OS\uCOS-II\ -I           #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\cmsis\Core\CM #
#                    3\CoreSupport\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\. #
#                    .\..\cmsis\Core\CM3\DeviceSupport\NXP\LPC177x_8x\ -I     #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp\ -I  #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp\DEVI #
#                    CE_BT\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\Hua #
#                    ceApp\DEVICE_COM\ -I D:\wangfan2\桌面\RTU_1.3\project\ia #
#                    r\..\..\HuaceApp\DEVICE_GPRS\ -I                         #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp\DEVI #
#                    CE_GPS\ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\Hu #
#                    aceApp\DEVICE_RADIO\ -I D:\wangfan2\桌面\RTU_1.3\project #
#                    \iar\..\..\HuaceApp\iap\ -I                              #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\FatFs\ -I     #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\USB\ -I       #
#                    D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\bsp\spi_flash #
#                    \ -I D:\wangfan2\桌面\RTU_1.3\project\iar\..\..\HuaceApp #
#                    \LED\ -On --use_c++_inline                               #
#    List file    =  D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\List\usb_t9.l #
#                    st                                                       #
#    Object file  =  D:\wangfan2\桌面\RTU_1.3\project\iar\Debug\Obj\usb_t9.o  #
#                                                                             #
#                                                                             #
###############################################################################

D:\wangfan2\桌面\RTU_1.3\USB\usb_t9.c
      1          /*************************************************************************
      2           *
      3           *    Used with ICCARM and AARM.
      4           *
      5           *    (c) Copyright IAR Systems 2007
      6           *
      7           *    File name   : usb_t9.c
      8           *    Description : USB T9 subroutines
      9           *
     10           *    History :
     11           *    1. Date        : June 16, 2007
     12           *       Author      : Stanimir Bonev
     13           *       Description : Create
     14           *
     15           *    $Revision: 30123 $
     16           **************************************************************************/
     17          #define USB_T9_GLOBAL
     18          #include "usb_t9.h"

   \                                 In section .bss, align 4
   \   __absolute UsbSetupPacket_t UsbEp0SetupPacket
   \                     UsbEp0SetupPacket:
   \   00000000                      DS8 8
     19          

   \                                 In section .bss, align 4
     20          static UsbDevCtrl_t UsbDevCtrl;
   \                     UsbDevCtrl:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
     21          static Int32U InData;
   \                     InData:
   \   00000000                      DS8 4
     22          
     23          /*************************************************************************
     24           * Function Name: UsbCoreInit
     25           * Parameters: none
     26           *
     27           * Return: none
     28           *
     29           * Description: Init USB core
     30           *
     31           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     32          void UsbCoreInit (void)
     33          {
   \                     UsbCoreInit:
   \   00000000   0xB580             PUSH     {R7,LR}
     34            UsbDevCtrl.State.DS      = UsbDevStatusUnknow;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000010   0x7008             STRB     R0,[R1, #+0]
     35            UsbDevCtrl.State.Suspend = FALSE;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000020   0x7008             STRB     R0,[R1, #+0]
     36            UsbDevCtrl.Feature.RemoteWakeupEnable = FALSE;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000026   0x7E00             LDRB     R0,[R0, #+24]
   \   00000028   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000030   0x7608             STRB     R0,[R1, #+24]
     37            UsbDevCtrl.Feature.SelfPowered = USB_SELF_POWERED;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000036   0x7E00             LDRB     R0,[R0, #+24]
   \   00000038   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000040   0x7608             STRB     R0,[R1, #+24]
     38          #if USB_HIGH_SPEED > 0
     39            UsbDevCtrl.HighSpeed = 0;
     40          #endif // USB_HIGH_SPEED > 0
     41            // Init HW
     42            USB_HwInit();
   \   00000042   0x.... 0x....      BL       USB_HwInit
     43          }
   \   00000046   0xBD01             POP      {R0,PC}          ;; return
     44          
     45          /*************************************************************************
     46           * Function Name: UsbCoreReq
     47           * Parameters:  UsbCoreReqType_t Type
     48           *
     49           * Return: Int32U
     50           *
     51           * Description: Return device states
     52           *
     53           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     54          Int32U UsbCoreReq (UsbCoreReqType_t Type)
     55          {
   \                     UsbCoreReq:
   \   00000000   0x0001             MOVS     R1,R0
     56            switch(Type)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD009             BEQ.N    ??UsbCoreReq_0
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xD014             BEQ.N    ??UsbCoreReq_1
   \   0000000C   0xD30C             BCC.N    ??UsbCoreReq_2
   \   0000000E   0x2904             CMP      R1,#+4
   \   00000010   0xD019             BEQ.N    ??UsbCoreReq_3
   \   00000012   0xD314             BCC.N    ??UsbCoreReq_4
   \   00000014   0x2906             CMP      R1,#+6
   \   00000016   0xD021             BEQ.N    ??UsbCoreReq_5
   \   00000018   0xD319             BCC.N    ??UsbCoreReq_6
   \   0000001A   0xE021             B.N      ??UsbCoreReq_7
     57            {
     58            case UsbCoreReqDevState:
     59              return(UsbDevCtrl.State.DS);
   \                     ??UsbCoreReq_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000026   0xE01D             B.N      ??UsbCoreReq_8
     60            case UsbCoreReqDevSusState:
     61              return(UsbDevCtrl.State.Suspend);
   \                     ??UsbCoreReq_2:
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x09C0             LSRS     R0,R0,#+7
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xE016             B.N      ??UsbCoreReq_8
     62            case UsbCoreReqConfiquration:
     63              return(UsbDevCtrl.Configuration);
   \                     ??UsbCoreReq_1:
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0xE012             B.N      ??UsbCoreReq_8
     64            case UsbCoreReqInterface:
     65              return(UsbDevCtrl.Interfaces);
   \                     ??UsbCoreReq_4:
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000042   0x68C0             LDR      R0,[R0, #+12]
   \   00000044   0xE00E             B.N      ??UsbCoreReq_8
     66            case UsbCoreReqDevOwnAddress:
     67              return(UsbDevCtrl.DevAdd);
   \                     ??UsbCoreReq_3:
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000004A   0x6940             LDR      R0,[R0, #+20]
   \   0000004C   0xE00A             B.N      ??UsbCoreReq_8
     68            case UsbCoreReqWakeUpEnableStatus:
     69              return(UsbDevCtrl.Feature.RemoteWakeupEnable);
   \                     ??UsbCoreReq_6:
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000052   0x7E00             LDRB     R0,[R0, #+24]
   \   00000054   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0xE003             B.N      ??UsbCoreReq_8
     70            case UsbCoreReqSelfPoweredStatus:
     71              return(USB_SELF_POWERED);
   \                     ??UsbCoreReq_5:
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE001             B.N      ??UsbCoreReq_8
     72          #if USB_HIGH_SPEED > 0
     73            case UsbCoreReqSpeed:
     74              return(UsbDevCtrl.HighSpeed);
     75          #endif // USB_HIGH_SPEED > 0
     76            }
     77            return((Int32U) -1);
   \                     ??UsbCoreReq_7:
   \   00000060   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??UsbCoreReq_8:
   \   00000064   0x4770             BX       LR               ;; return
     78          }
     79          
     80          #if USB_REMOTE_WAKEUP != 0
     81          /*************************************************************************
     82           * Function Name: UsbWakeUp
     83           * Parameters:  none
     84           *
     85           * Return: none
     86           *
     87           * Description: Wake-up device from suspend mode
     88           *
     89           *************************************************************************/
     90          void UsbWakeUp (void)
     91          {
     92            if(UsbDevCtrl.Feature.RemoteWakeupEnable && UsbDevCtrl.State.Suspend)
     93            {
     94              USB_WakeUp();
     95            }
     96          }
     97          #endif // USB_REMOTE_WAKEUP != 0
     98          
     99          /*************************************************************************
    100           * Function Name: UsbSetDevState
    101           * Parameters:  UsbT9DevState_t DevState
    102           *
    103           * Return: none
    104           *
    105           * Description: Set device state
    106           *
    107           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    108          void UsbSetDevState (UsbT9DevState_t DevState)
    109          {
   \                     UsbSetDevState:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    110          pUsbStandardInterfaceDescriptor_t pInterface;
    111            if(UsbDevCtrl.State.DS == UsbDevStatusConfigured)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000E   0x2805             CMP      R0,#+5
   \   00000010   0xD117             BNE.N    ??UsbSetDevState_0
    112            {
    113              // deconfigure device
    114              for (Int32U i = 0; i < UsbDevCtrl.Interfaces; ++i)
   \   00000012   0x2600             MOVS     R6,#+0
   \                     ??UsbSetDevState_1:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000018   0x68C0             LDR      R0,[R0, #+12]
   \   0000001A   0x4286             CMP      R6,R0
   \   0000001C   0xD211             BCS.N    ??UsbSetDevState_0
    115              {
    116                pInterface = UsbFindInterface(UsbDevCtrl.pCnfg,i,UsbDevCtrl.AlternateSetting[i]);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000022   0xEB10 0x0086      ADDS     R0,R0,R6, LSL #+2
   \   00000026   0x6902             LDR      R2,[R0, #+16]
   \   00000028   0x0031             MOVS     R1,R6
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000002E   0x6880             LDR      R0,[R0, #+8]
   \   00000030   0x.... 0x....      BL       UsbFindInterface
   \   00000034   0x0005             MOVS     R5,R0
    117                UsbEpInterfaceCnfg(pInterface,FALSE);
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       UsbEpInterfaceCnfg
    118              }
   \   0000003E   0x1C76             ADDS     R6,R6,#+1
   \   00000040   0xE7E8             B.N      ??UsbSetDevState_1
    119            }
    120            switch (DevState)
   \                     ??UsbSetDevState_0:
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x1E40             SUBS     R0,R0,#+1
   \   00000048   0x2802             CMP      R0,#+2
   \   0000004A   0xD904             BLS.N    ??UsbSetDevState_2
   \   0000004C   0x1EC0             SUBS     R0,R0,#+3
   \   0000004E   0xD013             BEQ.N    ??UsbSetDevState_3
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \   00000052   0xD019             BEQ.N    ??UsbSetDevState_4
   \   00000054   0xE034             B.N      ??UsbSetDevState_5
    121            {
    122            case UsbDevStatusAttached:
    123            case UsbDevStatusPowered:
    124            case UsbDevStatusDefault:
    125              USB_Configure(FALSE);
   \                     ??UsbSetDevState_2:
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      BL       USB_Configure
    126              USB_SetDefAdd();  // Set address 0
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x.... 0x....      BL       USB_SetAdd
    127              USB_CONFIGURE_HOOK(NULL);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      BL       USB_CONFIGURE_HOOK
    128              UsbDevCtrl.DevAdd = UsbDevCtrl.Configuration = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable29
   \   0000006E   0x6048             STR      R0,[R1, #+4]
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000074   0x6148             STR      R0,[R1, #+20]
    129              break;
   \   00000076   0xE030             B.N      ??UsbSetDevState_6
    130            case UsbDevStatusAddress:
    131              USB_Configure(FALSE);
   \                     ??UsbSetDevState_3:
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      BL       USB_Configure
    132              UsbDevCtrl.Configuration = 0;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x6041             STR      R1,[R0, #+4]
    133              break;
   \   00000086   0xE028             B.N      ??UsbSetDevState_6
    134            case UsbDevStatusConfigured:
    135              // configure device
    136              for (Int32U i = 0; i < UsbDevCtrl.Interfaces; ++i)
   \                     ??UsbSetDevState_4:
   \   00000088   0x2600             MOVS     R6,#+0
   \                     ??UsbSetDevState_7:
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000008E   0x68C0             LDR      R0,[R0, #+12]
   \   00000090   0x4286             CMP      R6,R0
   \   00000092   0xD211             BCS.N    ??UsbSetDevState_8
    137              {
    138                pInterface = UsbFindInterface(UsbDevCtrl.pCnfg,i,UsbDevCtrl.AlternateSetting[i]);
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000098   0xEB10 0x0086      ADDS     R0,R0,R6, LSL #+2
   \   0000009C   0x6902             LDR      R2,[R0, #+16]
   \   0000009E   0x0031             MOVS     R1,R6
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable29
   \   000000A4   0x6880             LDR      R0,[R0, #+8]
   \   000000A6   0x.... 0x....      BL       UsbFindInterface
   \   000000AA   0x0005             MOVS     R5,R0
    139                UsbEpInterfaceCnfg(pInterface,TRUE);
   \   000000AC   0x2101             MOVS     R1,#+1
   \   000000AE   0x0028             MOVS     R0,R5
   \   000000B0   0x.... 0x....      BL       UsbEpInterfaceCnfg
    140              }
   \   000000B4   0x1C76             ADDS     R6,R6,#+1
   \   000000B6   0xE7E8             B.N      ??UsbSetDevState_7
    141              USB_Configure(TRUE);
   \                     ??UsbSetDevState_8:
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x.... 0x....      BL       USB_Configure
    142              break;
   \   000000BE   0xE00C             B.N      ??UsbSetDevState_6
    143            default:  // unknown state - disconnected or in process of a connection
    144              USB_Configure(FALSE);
   \                     ??UsbSetDevState_5:
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       USB_Configure
    145              USB_CONFIGURE_HOOK(NULL);
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x.... 0x....      BL       USB_CONFIGURE_HOOK
    146              UsbDevCtrl.DevAdd = UsbDevCtrl.Configuration = 0;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable29
   \   000000D2   0x6048             STR      R0,[R1, #+4]
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable29
   \   000000D8   0x6148             STR      R0,[R1, #+20]
    147            }
    148            UsbDevCtrl.State.DS = DevState;
   \                     ??UsbSetDevState_6:
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable29
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0xF364 0x0002      BFI      R0,R4,#+0,#+3
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable29
   \   000000E8   0x7008             STRB     R0,[R1, #+0]
    149          }
   \   000000EA   0xBD70             POP      {R4-R6,PC}       ;; return
    150          
    151          /*************************************************************************
    152           * Function Name: UsbDevConnectCallback
    153           * Parameters:  void * pArg
    154           *
    155           * Return: none
    156           *
    157           * Description: USB connect callback
    158           *
    159           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    160          void UsbDevConnectCallback (Boolean Connect)
    161          {
   \                     UsbDevConnectCallback:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    162            UsbSetDevState(Connect?UsbDevStatusAttached:UsbDevStatusUnknow);
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD001             BEQ.N    ??UsbDevConnectCallback_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??UsbDevConnectCallback_1
   \                     ??UsbDevConnectCallback_0:
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??UsbDevConnectCallback_1:
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       UsbSetDevState
    163            USB_CONNECT_HOOK(Connect);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       USB_CONNECT_HOOK
    164          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    165          
    166          /*************************************************************************
    167           * Function Name: UsbDevSuspendCallback
    168           * Parameters:  Boolean Suspend
    169           *
    170           * Return: none
    171           *
    172           * Description: USB suspend callback
    173           *
    174           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    175          void UsbDevSuspendCallback (Boolean Suspend)
    176          {
   \                     UsbDevSuspendCallback:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    177            UsbDevCtrl.State.Suspend = Suspend ? UsbDevStatusSuspend : UsbDevStatusNoSuspend;
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD001             BEQ.N    ??UsbDevSuspendCallback_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??UsbDevSuspendCallback_1
   \                     ??UsbDevSuspendCallback_0:
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??UsbDevSuspendCallback_1:
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   00000018   0xEA51 0x10C0      ORRS     R0,R1,R0, LSL #+7
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    178            USB_SUSPEND_HOOK(Suspend);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       USB_SUSPEND_HOOK
    179          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    180          
    181          /*************************************************************************
    182           * Function Name: UsbDevResetCallback
    183           * Parameters: none
    184           *
    185           * Return: none
    186           *
    187           * Description: USB reset callback
    188           *
    189           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    190          void UsbDevResetCallback (void)
    191          {
   \                     UsbDevResetCallback:
   \   00000000   0xB580             PUSH     {R7,LR}
    192            UsbSetDevState(UsbDevStatusDefault);
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x.... 0x....      BL       UsbSetDevState
    193            USB_RESET_HOOK();
   \   00000008   0x.... 0x....      BL       USB_RESET_HOOK
    194          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    195          
    196          #if USB_HIGH_SPEED > 0
    197          /*************************************************************************
    198           * Function Name: UsbDevSpeedCallback
    199           * Parameters: Boolean HighSpeed
    200           *
    201           * Return: none
    202           *
    203           * Description: USB Speed change callback
    204           *
    205           *************************************************************************/
    206          void UsbDevSpeedCallback(Boolean HighSpeed)
    207          {
    208            UsbDevCtrl.HighSpeed = HighSpeed;
    209          }
    210          #endif // USB_HIGH_SPEED > 0
    211          
    212          /*************************************************************************
    213           * Function Name: USB_T9_Size
    214           * Parameters:  Int32U Size,Int32U HostExpSize
    215           *
    216           * Return: Int32U
    217           *
    218           * Description: Return lower from Host expected size and size and set
    219           * a flag bZeroPacketPossible when size is lower that host expected size
    220           *
    221           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    222          Int32U USB_T9_Size(Int32U Size,Int32U HostExpSize)
    223          {
   \                     USB_T9_Size:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    224          Int32U ActSize = HostExpSize;
   \   00000004   0x0008             MOVS     R0,R1
    225            if(Size < HostExpSize)
   \   00000006   0x428A             CMP      R2,R1
   \   00000008   0xD20A             BCS.N    ??USB_T9_Size_0
    226            {
    227              ActSize = Size;
   \   0000000A   0x0010             MOVS     R0,R2
    228              EpCnfg[CTRL_ENP_IN].bZeroPacketPossible = 1;
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable32
   \   00000010   0xF893 0x3041      LDRB     R3,[R3, #+65]
   \   00000014   0xF053 0x0308      ORRS     R3,R3,#0x8
   \   00000018   0x.... 0x....      LDR.W    R4,??DataTable32
   \   0000001C   0xF884 0x3041      STRB     R3,[R4, #+65]
    229            }
    230            return(ActSize);
   \                     ??USB_T9_Size_0:
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    231          }
    232          
    233          /*************************************************************************
    234           * Function Name: USB_SetupHandler
    235           * Parameters: void
    236           *
    237           * Return: none
    238           *
    239           * Description: Setup packet handler
    240           *
    241           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    242          void USB_SetupHandler (void)
    243          {
   \                     USB_SetupHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    244            switch(UsbEp0SetupPacket.mRequestType.Type)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x0940             LSRS     R0,R0,#+5
   \   0000000C   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??USB_SetupHandler_0
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD066             BEQ.N    ??USB_SetupHandler_1
   \   00000018   0xD35A             BCC.N    ??USB_SetupHandler_2
   \   0000001A   0xE06F             B.N      ??USB_SetupHandler_3
    245            {
    246            // Standard
    247            case UsbTypeStandart:
    248              // Decoding standard request
    249              switch (UsbEp0SetupPacket.bRequest)
   \                     ??USB_SetupHandler_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000020   0x7840             LDRB     R0,[R0, #+1]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD014             BEQ.N    ??USB_SetupHandler_4
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD015             BEQ.N    ??USB_SetupHandler_5
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD016             BEQ.N    ??USB_SetupHandler_6
   \   0000002E   0x2805             CMP      R0,#+5
   \   00000030   0xD017             BEQ.N    ??USB_SetupHandler_7
   \   00000032   0x2806             CMP      R0,#+6
   \   00000034   0xD018             BEQ.N    ??USB_SetupHandler_8
   \   00000036   0x2807             CMP      R0,#+7
   \   00000038   0xD033             BEQ.N    ??USB_SetupHandler_9
   \   0000003A   0x2808             CMP      R0,#+8
   \   0000003C   0xD034             BEQ.N    ??USB_SetupHandler_10
   \   0000003E   0x2809             CMP      R0,#+9
   \   00000040   0xD035             BEQ.N    ??USB_SetupHandler_11
   \   00000042   0x280A             CMP      R0,#+10
   \   00000044   0xD036             BEQ.N    ??USB_SetupHandler_12
   \   00000046   0x280B             CMP      R0,#+11
   \   00000048   0xD037             BEQ.N    ??USB_SetupHandler_13
   \   0000004A   0x280C             CMP      R0,#+12
   \   0000004C   0xD038             BEQ.N    ??USB_SetupHandler_14
   \   0000004E   0xE03A             B.N      ??USB_SetupHandler_15
    250              {
    251              case GET_STATUS:
    252                UsbGetStatus();
   \                     ??USB_SetupHandler_4:
   \   00000050   0x.... 0x....      BL       UsbGetStatus
    253                break;
   \   00000054   0xE03B             B.N      ??USB_SetupHandler_16
    254              case CLEAR_FEATURE:
    255                UsbClearFeature();
   \                     ??USB_SetupHandler_5:
   \   00000056   0x.... 0x....      BL       UsbClearFeature
    256                break;
   \   0000005A   0xE038             B.N      ??USB_SetupHandler_16
    257              case SET_FEATURE:
    258                UsbSetFeature();
   \                     ??USB_SetupHandler_6:
   \   0000005C   0x.... 0x....      BL       UsbSetFeature
    259                break;
   \   00000060   0xE035             B.N      ??USB_SetupHandler_16
    260              case SET_ADDRESS:
    261                UsbSetAddress();
   \                     ??USB_SetupHandler_7:
   \   00000062   0x.... 0x....      BL       UsbSetAddress
    262                break;
   \   00000066   0xE032             B.N      ??USB_SetupHandler_16
    263              case GET_DESCRIPTOR:
    264                if(UsbEp0SetupPacket.mRequestType.Recipient == UsbRecipientDevice)
   \                     ??USB_SetupHandler_8:
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD102             BNE.N    ??USB_SetupHandler_17
    265                {
    266                  UsbGetDescriptor();
   \   00000076   0x.... 0x....      BL       UsbGetDescriptor
   \   0000007A   0xE011             B.N      ??USB_SetupHandler_18
    267                }
    268                // Only get descriptor for device is standard request
    269                else if ((UsbEp0SetupPacket.mRequestType.Dir == UsbDevice2Host) &&
    270                         (USB_GET_DESCRIPTOR_HOOK(&UsbEp0SetupPacket) == UsbPass))
   \                     ??USB_SetupHandler_17:
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x09C0             LSRS     R0,R0,#+7
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD005             BEQ.N    ??USB_SetupHandler_19
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000090   0x.... 0x....      BL       USB_GET_DESCRIPTOR_HOOK
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD003             BEQ.N    ??USB_SetupHandler_18
    271                {
    272                }
    273                else
    274                {
    275                  USB_T9_ERROR_REQUEST();
   \                     ??USB_SetupHandler_19:
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000009C   0x2107             MOVS     R1,#+7
   \   0000009E   0x7501             STRB     R1,[R0, #+20]
    276                }
    277                break;
   \                     ??USB_SetupHandler_18:
   \   000000A0   0xE015             B.N      ??USB_SetupHandler_16
    278              case SET_DESCRIPTOR:
    279                // Optional (only for configuration and string descriptors)
    280                UsbSetDescriptor();
   \                     ??USB_SetupHandler_9:
   \   000000A2   0x.... 0x....      BL       UsbSetDescriptor
    281                break;
   \   000000A6   0xE012             B.N      ??USB_SetupHandler_16
    282              case GET_CONFIGURATION:
    283                UsbGetConfiguration();
   \                     ??USB_SetupHandler_10:
   \   000000A8   0x.... 0x....      BL       UsbGetConfiguration
    284                break;
   \   000000AC   0xE00F             B.N      ??USB_SetupHandler_16
    285              case SET_CONFIGURATION:
    286                UsbSetConfiguration();
   \                     ??USB_SetupHandler_11:
   \   000000AE   0x.... 0x....      BL       UsbSetConfiguration
    287                break;
   \   000000B2   0xE00C             B.N      ??USB_SetupHandler_16
    288              case GET_INTERFACE:
    289                UsbGetInterface();
   \                     ??USB_SetupHandler_12:
   \   000000B4   0x.... 0x....      BL       UsbGetInterface
    290                break;
   \   000000B8   0xE009             B.N      ??USB_SetupHandler_16
    291              case SET_INTERFACE:
    292                UsbSetInterface();
   \                     ??USB_SetupHandler_13:
   \   000000BA   0x.... 0x....      BL       UsbSetInterface
    293                break;
   \   000000BE   0xE006             B.N      ??USB_SetupHandler_16
    294              case SYNCH_FRAME:
    295                UsbSynchFrame();
   \                     ??USB_SetupHandler_14:
   \   000000C0   0x.... 0x....      BL       UsbSynchFrame
    296                break;
   \   000000C4   0xE003             B.N      ??USB_SetupHandler_16
    297              default:
    298                USB_T9_ERROR_REQUEST();
   \                     ??USB_SetupHandler_15:
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000CA   0x2107             MOVS     R1,#+7
   \   000000CC   0x7501             STRB     R1,[R0, #+20]
    299              }
    300              break;
   \                     ??USB_SetupHandler_16:
   \   000000CE   0xE019             B.N      ??USB_SetupHandler_20
    301            // Class
    302            case UsbTypeClass:
    303              if(USB_CLASS_REQUEST_HOOK(&UsbEp0SetupPacket) != UsbPass)
   \                     ??USB_SetupHandler_2:
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   000000D4   0x.... 0x....      BL       USB_CLASS_REQUEST_HOOK
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD003             BEQ.N    ??USB_SetupHandler_21
    304              {
    305                USB_T9_ERROR_REQUEST();
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000E0   0x2107             MOVS     R1,#+7
   \   000000E2   0x7501             STRB     R1,[R0, #+20]
    306              }
    307              else
    308              {
    309              }
    310              break;
   \                     ??USB_SetupHandler_21:
   \   000000E4   0xE00E             B.N      ??USB_SetupHandler_20
    311            // Vendor
    312            case UsbTypeVendor:
    313              if( USB_VENDOR_REQUEST_HOOK(&UsbEp0SetupPacket) != UsbPass)
   \                     ??USB_SetupHandler_1:
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   000000EA   0x.... 0x....      BL       USB_VENDOR_REQUEST_HOOK
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD003             BEQ.N    ??USB_SetupHandler_22
    314              {
    315                USB_T9_ERROR_REQUEST();
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000F6   0x2107             MOVS     R1,#+7
   \   000000F8   0x7501             STRB     R1,[R0, #+20]
    316              }
    317              else
    318              {
    319              }
    320              break;
   \                     ??USB_SetupHandler_22:
   \   000000FA   0xE003             B.N      ??USB_SetupHandler_20
    321            // Other
    322            default:
    323              USB_T9_ERROR_REQUEST();
   \                     ??USB_SetupHandler_3:
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000100   0x2107             MOVS     R1,#+7
   \   00000102   0x7501             STRB     R1,[R0, #+20]
    324            }
    325          }
   \                     ??USB_SetupHandler_20:
   \   00000104   0xBD01             POP      {R0,PC}          ;; return
    326          
    327          /*************************************************************************
    328           * Function Name: USB_StatusHandler
    329           * Parameters: USB_Endpoint_t EP
    330           *
    331           * Return: none
    332           *
    333           * Description: Address status handler
    334           *
    335           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    336          void USB_StatusHandler (USB_Endpoint_t EP)
    337          {
   \                     USB_StatusHandler:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    338            if (UsbEp0SetupPacket.mRequestType.Dir == UsbDevice2Host)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x09C0             LSRS     R0,R0,#+7
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD008             BEQ.N    ??USB_StatusHandler_0
    339            {
    340              USB_StatusPhase(CTRL_ENP_OUT);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       USB_StatusPhase
    341              EpCnfg[CTRL_ENP_OUT].pFn = (void *)USB_StatusEndHandler;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000001E   0x.... 0x....      ADR.W    R1,USB_StatusEndHandler
   \   00000022   0x6081             STR      R1,[R0, #+8]
   \   00000024   0xE00F             B.N      ??USB_StatusHandler_1
    342            }
    343            else
    344            {
    345              USB_StatusPhase(CTRL_ENP_IN);
   \                     ??USB_StatusHandler_0:
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       USB_StatusPhase
    346              EpCnfg[CTRL_ENP_IN].pFn = (UsbEp0SetupPacket.bRequest == SET_ADDRESS)
    347                                         ?(void *)USB_AddStatusEndHandler
    348                                         :(void *)USB_StatusEndHandler;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000030   0x7840             LDRB     R0,[R0, #+1]
   \   00000032   0x2805             CMP      R0,#+5
   \   00000034   0xD102             BNE.N    ??USB_StatusHandler_2
   \   00000036   0x.... 0x....      ADR.W    R0,USB_AddStatusEndHandler
   \   0000003A   0xE001             B.N      ??USB_StatusHandler_3
   \                     ??USB_StatusHandler_2:
   \   0000003C   0x.... 0x....      ADR.W    R0,USB_StatusEndHandler
   \                     ??USB_StatusHandler_3:
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable32
   \   00000044   0x62C8             STR      R0,[R1, #+44]
    349            }
    350          }
   \                     ??USB_StatusHandler_1:
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    351          
    352          /*************************************************************************
    353           * Function Name: USB_AddStatusEndHandler
    354           * Parameters: USB_Endpoint_t EP
    355           *
    356           * Return: none
    357           *
    358           * Description: Setup packet status phase end handler
    359           *
    360           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    361          static
    362          void USB_StatusEndHandler (USB_Endpoint_t EP)
    363          {
   \                     USB_StatusEndHandler:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    364            USB_IO_Data(CTRL_ENP_IN ,NULL,(Int32U)-1,NULL);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       USB_IO_Data
    365            USB_IO_Data(CTRL_ENP_OUT,NULL,(Int32U)-1,NULL);
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       USB_IO_Data
    366          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    367          
    368          /*************************************************************************
    369           * Function Name: USB_AddStatusEndHandler
    370           * Parameters: USB_Endpoint_t EP
    371           *
    372           * Return: none
    373           *
    374           * Description: Setup packet - set address status phase end handler
    375           *
    376           *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    377          static
    378          void USB_AddStatusEndHandler (USB_Endpoint_t EP)
    379          {
   \                     USB_AddStatusEndHandler:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    380            // Device address is set after status phase of set address request
    381            UsbDevCtrl.DevAdd = UsbEp0SetupPacket.wValue.Lo;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \   0000000C   0x7889             LDRB     R1,[R1, #+2]
   \   0000000E   0x6141             STR      R1,[R0, #+20]
    382            USB_SetAdd(UsbDevCtrl.DevAdd);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0x.... 0x....      BL       USB_SetAdd
    383            if(UsbDevCtrl.DevAdd)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000001E   0x6940             LDR      R0,[R0, #+20]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD003             BEQ.N    ??USB_AddStatusEndHandler_0
    384            {
    385              UsbSetDevState(UsbDevStatusAddress);
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x.... 0x....      BL       UsbSetDevState
   \   0000002A   0xE002             B.N      ??USB_AddStatusEndHandler_1
    386            }
    387            else
    388            {
    389              // when address is 0 put device init configuration state
    390              UsbSetDevState(UsbDevStatusDefault);
   \                     ??USB_AddStatusEndHandler_0:
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0x.... 0x....      BL       UsbSetDevState
    391            }
    392            USB_IO_Data(CTRL_ENP_IN ,NULL,(Int32U)-1,NULL);
   \                     ??USB_AddStatusEndHandler_1:
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       USB_IO_Data
    393            USB_IO_Data(CTRL_ENP_OUT,NULL,(Int32U)-1,NULL);
   \   00000040   0x2300             MOVS     R3,#+0
   \   00000042   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      BL       USB_IO_Data
    394          }
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    395          
    396          /*************************************************************************
    397           * Function Name: UsbFindInterface
    398           * Parameters:  UsbStandardConfigurationDescriptor_t * pConfiguration,
    399           *              Int32U Interface, Int32U AlternateSetting
    400           *
    401           * Return: pUsbStandardInterfaceDescriptor_t
    402           *
    403           * Description: Set Interface and  Alternative setting state
    404           *
    405           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    406          static
    407          pUsbStandardInterfaceDescriptor_t UsbFindInterface (
    408                                UsbStandardConfigurationDescriptor_t * pConfiguration,
    409                                Int32U Interface, Int32U AlternateSetting)
    410          {
   \                     UsbFindInterface:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    411          pUsbStandardInterfaceDescriptor_t pData;
    412            assert(pConfiguration != NULL);
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD109             BNE.N    ??UsbFindInterface_0
   \   0000000C   0xF44F 0x72CE      MOV      R2,#+412
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable32_2
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \   00000018   0x.... 0x....      BL       __aeabi_assert
   \   0000001C   0x.... 0x....      BL       __iar_EmptyStepPoint
    413            // Find Interface
    414            for( pData = (UsbStandardInterfaceDescriptor_t *)pConfiguration;
   \                     ??UsbFindInterface_0:
   \   00000020   0x0027             MOVS     R7,R4
    415                (Int8U*)pData < (Int8U *)pConfiguration + pConfiguration->wTotalLength;
   \                     ??UsbFindInterface_1:
   \   00000022   0x8860             LDRH     R0,[R4, #+2]
   \   00000024   0x1900             ADDS     R0,R0,R4
   \   00000026   0x4287             CMP      R7,R0
   \   00000028   0xD20D             BCS.N    ??UsbFindInterface_2
    416                 pData =(UsbStandardInterfaceDescriptor_t *)((Int8U *)pData + pData->bLength))
    417            {
    418              if((pData->bDescriptorType == UsbDescriptorInterface) &&
    419                 (pData->bInterfaceNumber == Interface) &&
    420                 (pData->bAlternateSetting == AlternateSetting))
   \   0000002A   0x7878             LDRB     R0,[R7, #+1]
   \   0000002C   0x2804             CMP      R0,#+4
   \   0000002E   0xD107             BNE.N    ??UsbFindInterface_3
   \   00000030   0x78B8             LDRB     R0,[R7, #+2]
   \   00000032   0x42A8             CMP      R0,R5
   \   00000034   0xD104             BNE.N    ??UsbFindInterface_3
   \   00000036   0x78F8             LDRB     R0,[R7, #+3]
   \   00000038   0x42B0             CMP      R0,R6
   \   0000003A   0xD101             BNE.N    ??UsbFindInterface_3
    421              {
    422                return(pData);
   \   0000003C   0x0038             MOVS     R0,R7
   \   0000003E   0xE003             B.N      ??UsbFindInterface_4
    423              }
    424            }
   \                     ??UsbFindInterface_3:
   \   00000040   0x7838             LDRB     R0,[R7, #+0]
   \   00000042   0x19C7             ADDS     R7,R0,R7
   \   00000044   0xE7ED             B.N      ??UsbFindInterface_1
    425            return(NULL);
   \                     ??UsbFindInterface_2:
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??UsbFindInterface_4:
   \   00000048   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    426          }
    427          
    428          /*************************************************************************
    429           * Function Name: UsbFindConfiguration
    430           * Parameters:  Int32U
    431           *
    432           * Return: UsbStandardConfigurationDescriptor_t *
    433           *
    434           * Description: Return pointer to current configuration
    435           *
    436           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    437          static
    438          UsbStandardConfigurationDescriptor_t * UsbFindConfiguration(Int32U Configuration)
    439          {
   \                     UsbFindConfiguration:
   \   00000000   0x0001             MOVS     R1,R0
    440          #if USB_HIGH_SPEED > 0
    441          const Int8U ** ppCfgArray = (const Int8U**)UsbDescArray[(UsbDevCtrl.HighSpeed?USB_HS_CFG_ARRAY:USB_FS_CFG_ARRAY)];
    442          #else
    443          const Int8U ** ppCfgArray = (const Int8U**)UsbDescArray[USB_FS_CFG_ARRAY];
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable32_4
   \   00000006   0x6802             LDR      R2,[R0, #+0]
    444          #endif
    445          pUsbStandardConfigurationDescriptor_t pData = (pUsbStandardConfigurationDescriptor_t)*ppCfgArray;
   \   00000008   0x6813             LDR      R3,[R2, #+0]
    446            while((pData = (pUsbStandardConfigurationDescriptor_t)*ppCfgArray) != NULL)
   \                     ??UsbFindConfiguration_0:
   \   0000000A   0x6810             LDR      R0,[R2, #+0]
   \   0000000C   0x0003             MOVS     R3,R0
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00B             BEQ.N    ??UsbFindConfiguration_1
    447            {
    448              if(pData->bDescriptorType == UsbDescriptorConfiguration)
   \   00000012   0x7858             LDRB     R0,[R3, #+1]
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD104             BNE.N    ??UsbFindConfiguration_2
    449              {
    450                if(pData->bConfigurationValue == Configuration)
   \   00000018   0x7958             LDRB     R0,[R3, #+5]
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??UsbFindConfiguration_2
    451                {
    452                   return(pData);
   \   0000001E   0x0018             MOVS     R0,R3
   \   00000020   0xE004             B.N      ??UsbFindConfiguration_3
    453                }
    454          
    455              }
    456              ++*ppCfgArray;
   \                     ??UsbFindConfiguration_2:
   \   00000022   0x6810             LDR      R0,[R2, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x6010             STR      R0,[R2, #+0]
   \   00000028   0xE7EF             B.N      ??UsbFindConfiguration_0
    457            }
    458            return(NULL);
   \                     ??UsbFindConfiguration_1:
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??UsbFindConfiguration_3:
   \   0000002C   0x4770             BX       LR               ;; return
    459          }
    460          
    461          /*************************************************************************
    462           * Function Name: UsbFindEP
    463           * Parameters: pUsbStandardInterfaceDescriptor_t pInterface,
    464           *             pUsbStandardEpDescriptor_t pEp
    465           *
    466           * Return: pUsbStandardEpDescriptor_t
    467           *
    468           * Description: Return pointer to next EP
    469           *
    470           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    471          static
    472          pUsbStandardEpDescriptor_t UsbFindEP(pUsbStandardInterfaceDescriptor_t pInterface,
    473                                               pUsbStandardEpDescriptor_t pEp)
    474          {
   \                     UsbFindEP:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    475          pUsbStandardEpDescriptor_t pEpNext;
    476          static Int32U ep_numbers;
    477            assert(pInterface != NULL);
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD109             BNE.N    ??UsbFindEP_0
   \   0000000A   0xF240 0x12DD      MOVW     R2,#+477
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable32_2
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable32_5
   \   00000016   0x.... 0x....      BL       __aeabi_assert
   \   0000001A   0x.... 0x....      BL       __iar_EmptyStepPoint
    478            if (pEp == NULL)
   \                     ??UsbFindEP_0:
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD107             BNE.N    ??UsbFindEP_1
    479            {
    480              ep_numbers = pInterface->bNumEndpoints;
   \   00000022   0x7920             LDRB     R0,[R4, #+4]
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable32_6
   \   00000028   0x6008             STR      R0,[R1, #+0]
    481              pEpNext = (pUsbStandardEpDescriptor_t)(((pInt8U)pInterface)+pInterface->bLength);
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x1900             ADDS     R0,R0,R4
   \   0000002E   0x0006             MOVS     R6,R0
   \   00000030   0xE002             B.N      ??UsbFindEP_2
    482            }
    483            else
    484            {
    485              pEpNext = (pUsbStandardEpDescriptor_t)(((pInt8U)pEp) + pEp->bLength);
   \                     ??UsbFindEP_1:
   \   00000032   0x7828             LDRB     R0,[R5, #+0]
   \   00000034   0x1940             ADDS     R0,R0,R5
   \   00000036   0x0006             MOVS     R6,R0
    486            }
    487            // Find Interface
    488            for(;ep_numbers != 0 && pEpNext->bLength;
   \                     ??UsbFindEP_2:
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable32_6
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD018             BEQ.N    ??UsbFindEP_3
   \   00000042   0x7830             LDRB     R0,[R6, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD015             BEQ.N    ??UsbFindEP_3
    489                 pEpNext = (pUsbStandardEpDescriptor_t)(((pInt8U)pEpNext) + pEpNext->bLength))
    490            {
    491              if(pEpNext->bDescriptorType == UsbDescriptorEp)
   \   00000048   0x7870             LDRB     R0,[R6, #+1]
   \   0000004A   0x2805             CMP      R0,#+5
   \   0000004C   0xD108             BNE.N    ??UsbFindEP_4
    492              {
    493                --ep_numbers;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable32_6
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x1E40             SUBS     R0,R0,#+1
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable32_6
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    494                return(pEpNext);
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0xE00A             B.N      ??UsbFindEP_5
    495              }
    496              else if (pEpNext->bDescriptorType == UsbDescriptorInterface ||
    497                       pEpNext->bDescriptorType == UsbDescriptorConfiguration)
   \                     ??UsbFindEP_4:
   \   00000060   0x7870             LDRB     R0,[R6, #+1]
   \   00000062   0x2804             CMP      R0,#+4
   \   00000064   0xD002             BEQ.N    ??UsbFindEP_6
   \   00000066   0x7870             LDRB     R0,[R6, #+1]
   \   00000068   0x2802             CMP      R0,#+2
   \   0000006A   0xD100             BNE.N    ??UsbFindEP_7
    498              {
    499                break;
   \                     ??UsbFindEP_6:
   \   0000006C   0xE002             B.N      ??UsbFindEP_3
    500              }
    501            }
   \                     ??UsbFindEP_7:
   \   0000006E   0x7830             LDRB     R0,[R6, #+0]
   \   00000070   0x1986             ADDS     R6,R0,R6
   \   00000072   0xE7E1             B.N      ??UsbFindEP_2
    502            return(NULL);
   \                     ??UsbFindEP_3:
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??UsbFindEP_5:
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
    503          }

   \                                 In section .bss, align 4
   \                     ??ep_numbers:
   \   00000000                      DS8 4
    504          
    505          /*************************************************************************
    506           * Function Name: UsbSetConfigurtonState
    507           * Parameters:  Int32U
    508           *
    509           * Return: UsbCommStatus_t
    510           *
    511           * Description: Set configuration state
    512           *
    513           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    514          inline static
    515          UsbCommStatus_t UsbSetConfigurtonState (Int32U Configuration)
    516          {
   \                     UsbSetConfigurtonState:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    517          pUsbStandardConfigurationDescriptor_t pCnfg;
    518            if(Configuration)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD043             BEQ.N    ??UsbSetConfigurtonState_0
    519            {
    520              // Find configuration
    521              pCnfg = UsbFindConfiguration(Configuration);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       UsbFindConfiguration
   \   0000000E   0x0005             MOVS     R5,R0
    522              if(pCnfg == NULL)
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD101             BNE.N    ??UsbSetConfigurtonState_1
    523              {
    524                return(UsbFault);
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE042             B.N      ??UsbSetConfigurtonState_2
    525              }
    526          
    527              // deinit current configuration
    528              UsbSetDevState(UsbDevStatusAddress);
   \                     ??UsbSetConfigurtonState_1:
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x.... 0x....      BL       UsbSetDevState
    529              USB_CONFIGURE_HOOK(NULL);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       USB_CONFIGURE_HOOK
    530              UsbDevCtrl.pCnfg = pCnfg;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000028   0x6085             STR      R5,[R0, #+8]
    531          
    532              // Set Interface and Alternative Setting
    533              UsbDevCtrl.Configuration = Configuration;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000002E   0x6044             STR      R4,[R0, #+4]
    534              UsbDevCtrl.Feature.RemoteWakeupEnable = 0;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000034   0x7E00             LDRB     R0,[R0, #+24]
   \   00000036   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable29
   \   0000003E   0x7608             STRB     R0,[R1, #+24]
    535              UsbDevCtrl.Feature.SelfPowered = pCnfg->bmAttributes.SelfPowered?1:0;
   \   00000040   0x79E8             LDRB     R0,[R5, #+7]
   \   00000042   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable29
   \   0000004A   0x7E09             LDRB     R1,[R1, #+24]
   \   0000004C   0xF011 0x01FE      ANDS     R1,R1,#0xFE
   \   00000050   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000054   0x4308             ORRS     R0,R0,R1
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable29
   \   0000005A   0x7608             STRB     R0,[R1, #+24]
    536              // configure all existing interfaces alternative  setting 0
    537              // Whether the interface exist into current configuration?
    538              UsbDevCtrl.Interfaces = pCnfg->bNumInterfaces;
   \   0000005C   0x7928             LDRB     R0,[R5, #+4]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000062   0x60C8             STR      R0,[R1, #+12]
    539              for(Int32U i = 0; i < UsbDevCtrl.Interfaces; i++)
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??UsbSetConfigurtonState_3:
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable29
   \   0000006A   0x68C9             LDR      R1,[R1, #+12]
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD207             BCS.N    ??UsbSetConfigurtonState_4
    540              {
    541                UsbDevCtrl.AlternateSetting[i] = 0;
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable29
   \   00000074   0xEB11 0x0180      ADDS     R1,R1,R0, LSL #+2
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0x610A             STR      R2,[R1, #+16]
    542              }
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0xE7F2             B.N      ??UsbSetConfigurtonState_3
    543              UsbSetDevState(UsbDevStatusConfigured);
   \                     ??UsbSetConfigurtonState_4:
   \   00000080   0x2005             MOVS     R0,#+5
   \   00000082   0x.... 0x....      BL       UsbSetDevState
    544              USB_CONFIGURE_HOOK(&UsbDevCtrl);
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000008A   0x.... 0x....      BL       USB_CONFIGURE_HOOK
   \   0000008E   0xE005             B.N      ??UsbSetConfigurtonState_5
    545            }
    546            else
    547            {
    548              USB_CONFIGURE_HOOK(NULL);
   \                     ??UsbSetConfigurtonState_0:
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x.... 0x....      BL       USB_CONFIGURE_HOOK
    549              UsbSetDevState(UsbDevStatusAddress);
   \   00000096   0x2004             MOVS     R0,#+4
   \   00000098   0x.... 0x....      BL       UsbSetDevState
    550            }
    551            return(UsbPass);
   \                     ??UsbSetConfigurtonState_5:
   \   0000009C   0x2000             MOVS     R0,#+0
   \                     ??UsbSetConfigurtonState_2:
   \   0000009E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    552          }
    553          
    554          /*************************************************************************
    555           * Function Name: UsbDevStatus
    556           * Parameters:  Int16U Index
    557           *
    558           * Return: UsbCommStatus_t
    559           *
    560           * Description: Usb Return device status
    561           *
    562           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    563          inline static
    564          UsbCommStatus_t UsbDevStatus(Int16U Index)
    565          {
   \                     UsbDevStatus:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    566            if(Index == 0)
   \   00000004   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD10F             BNE.N    ??UsbDevStatus_0
    567            {
    568              InData = ((Int32U)UsbDevCtrl.Feature.Data) & 0xFF;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000000E   0x7E00             LDRB     R0,[R0, #+24]
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable32_7
   \   00000014   0x6008             STR      R0,[R1, #+0]
    569              USB_IO_Data(CTRL_ENP_IN,(pInt8U)&InData,2,(void*)USB_StatusHandler);
   \   00000016   0x.... 0x....      LDR.W    R3,??DataTable32_8
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable32_7
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       USB_IO_Data
    570              return(UsbPass);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE000             B.N      ??UsbDevStatus_1
    571            }
    572            return(UsbFault);
   \                     ??UsbDevStatus_0:
   \   0000002A   0x2001             MOVS     R0,#+1
   \                     ??UsbDevStatus_1:
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    573          }
    574          
    575          /*************************************************************************
    576           * Function Name: UsbInterfaceStatus
    577           * Parameters:  Int16U Index
    578           *
    579           * Return: UsbCommStatus_t
    580           *
    581           * Description: USB Return interface status into pData
    582           *
    583           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    584          inline static
    585          UsbCommStatus_t UsbInterfaceStatus(Int16U Index)
    586          {
   \                     UsbInterfaceStatus:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    587            InData = 0;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_7
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    588            USB_IO_Data(CTRL_ENP_IN,(pInt8U)&InData,2,(void*)USB_StatusHandler);
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable32_8
   \   00000010   0x2202             MOVS     R2,#+2
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable32_7
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       USB_IO_Data
    589            return(UsbPass);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    590          }
    591          
    592          /*************************************************************************
    593           * Function Name: UsbEpStatus
    594           * Parameters:  Int16U Index
    595           *
    596           * Return: UsbCommStatus_t
    597           *
    598           * Description: USB Return EP status into pData
    599           *
    600           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    601          inline static
    602          UsbCommStatus_t UsbEpStatus(Int16U Index)
    603          {
   \                     UsbEpStatus:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    604            if((Index & 0x7F) > 16)
   \   00000004   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000006   0xF014 0x007F      ANDS     R0,R4,#0x7F
   \   0000000A   0x2811             CMP      R0,#+17
   \   0000000C   0xDB01             BLT.N    ??UsbEpStatus_0
    605            {
    606              return(UsbFault);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE015             B.N      ??UsbEpStatus_1
    607            }
    608            InData = 0;
   \                     ??UsbEpStatus_0:
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable32_7
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6001             STR      R1,[R0, #+0]
    609            USB_GetStallEP(USB_EpLogToPhysAdd(Index),(pBoolean)&InData);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       USB_EpLogToPhysAdd
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable32_7
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       USB_GetStallEP
    610            USB_IO_Data(CTRL_ENP_IN,(pInt8U)&InData,2,(void*)USB_StatusHandler);
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable32_8
   \   00000030   0x2202             MOVS     R2,#+2
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable32_7
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       USB_IO_Data
    611            return(UsbPass);
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??UsbEpStatus_1:
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    612          }
    613          
    614          /*************************************************************************
    615           * Function Name: UsbGetStatus
    616           * Parameters:  none
    617           *
    618           * Return: none
    619           *
    620           * Description: USB Get status implement
    621           *
    622           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    623          inline static
    624          void UsbGetStatus (void)
    625          {
   \                     UsbGetStatus:
   \   00000000   0xB580             PUSH     {R7,LR}
    626            if((UsbDevCtrl.State.DS >= UsbDevStatusAddress) &&
    627               // Length must be 2
    628               (UsbEp0SetupPacket.wLength.Word == 2) &&
    629               // Direction of data from device
    630               (UsbEp0SetupPacket.mRequestType.Dir == 1) &&
    631               // wValue must be 0
    632               (UsbEp0SetupPacket.wValue.Word == 0) )
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xDB45             BLT.N    ??UsbGetStatus_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000014   0x88C0             LDRH     R0,[R0, #+6]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD140             BNE.N    ??UsbGetStatus_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x09C0             LSRS     R0,R0,#+7
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD038             BEQ.N    ??UsbGetStatus_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000002E   0x8840             LDRH     R0,[R0, #+2]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD133             BNE.N    ??UsbGetStatus_0
    633            {
    634              // This request is valid only for Address and Configured device's states
    635              switch(UsbEp0SetupPacket.mRequestType.Recipient)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD003             BEQ.N    ??UsbGetStatus_1
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xD019             BEQ.N    ??UsbGetStatus_2
   \   00000046   0xD30C             BCC.N    ??UsbGetStatus_3
   \   00000048   0xE023             B.N      ??UsbGetStatus_4
    636              {
    637              case UsbRecipientDevice:
    638                if(UsbDevStatus(UsbEp0SetupPacket.wIndex.Word) != UsbPass)
   \                     ??UsbGetStatus_1:
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000004E   0x8880             LDRH     R0,[R0, #+4]
   \   00000050   0x.... 0x....      BL       UsbDevStatus
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD003             BEQ.N    ??UsbGetStatus_5
    639                {
    640                  USB_T9_ERROR_REQUEST();
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000005C   0x2107             MOVS     R1,#+7
   \   0000005E   0x7501             STRB     R1,[R0, #+20]
    641                }
    642                break;
   \                     ??UsbGetStatus_5:
   \   00000060   0xE020             B.N      ??UsbGetStatus_6
    643              case UsbRecipientInterface:
    644                if(UsbInterfaceStatus(UsbEp0SetupPacket.wIndex.Word) != UsbPass)
   \                     ??UsbGetStatus_3:
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000066   0x8880             LDRH     R0,[R0, #+4]
   \   00000068   0x.... 0x....      BL       UsbInterfaceStatus
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD003             BEQ.N    ??UsbGetStatus_7
    645                {
    646                  USB_T9_ERROR_REQUEST();
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000074   0x2107             MOVS     R1,#+7
   \   00000076   0x7501             STRB     R1,[R0, #+20]
    647                }
    648                break;
   \                     ??UsbGetStatus_7:
   \   00000078   0xE014             B.N      ??UsbGetStatus_6
    649              case UsbRecipientEndpoint:
    650                if(UsbEpStatus(UsbEp0SetupPacket.wIndex.Word) != UsbPass)
   \                     ??UsbGetStatus_2:
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000007E   0x8880             LDRH     R0,[R0, #+4]
   \   00000080   0x.... 0x....      BL       UsbEpStatus
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD003             BEQ.N    ??UsbGetStatus_8
    651                {
    652                  USB_T9_ERROR_REQUEST();
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000008C   0x2107             MOVS     R1,#+7
   \   0000008E   0x7501             STRB     R1,[R0, #+20]
    653                }
    654                break;
   \                     ??UsbGetStatus_8:
   \   00000090   0xE008             B.N      ??UsbGetStatus_6
    655              default:
    656                USB_T9_ERROR_REQUEST();
   \                     ??UsbGetStatus_4:
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000096   0x2107             MOVS     R1,#+7
   \   00000098   0x7501             STRB     R1,[R0, #+20]
   \   0000009A   0xE003             B.N      ??UsbGetStatus_6
    657              }
    658            }
    659            else
    660            {
    661              USB_T9_ERROR_REQUEST();
   \                     ??UsbGetStatus_0:
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000A0   0x2107             MOVS     R1,#+7
   \   000000A2   0x7501             STRB     R1,[R0, #+20]
    662            }
    663          }
   \                     ??UsbGetStatus_6:
   \   000000A4   0xBD01             POP      {R0,PC}          ;; return
    664          
    665          /*************************************************************************
    666           * Function Name: UsbClearFeature
    667           * Parameters:  Int16U Feature,Int16U Index
    668           *
    669           * Return: UsbCommStatus_t
    670           *
    671           * Description: USB Clear Device feature implement
    672           *
    673           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    674          inline static
    675          UsbCommStatus_t UsbClearDevFeature(Int16U Feature,Int16U Index)
    676          {
   \                     UsbClearDevFeature:
   \   00000000   0x0002             MOVS     R2,R0
    677            if((Index != 0) || (Feature != UsbDeviceRemoteWakeupSelector))
   \   00000002   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD102             BNE.N    ??UsbClearDevFeature_0
   \   00000008   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD001             BEQ.N    ??UsbClearDevFeature_1
    678            {
    679              return(UsbFault);
   \                     ??UsbClearDevFeature_0:
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE008             B.N      ??UsbClearDevFeature_2
    680            }
    681            UsbDevCtrl.Feature.RemoteWakeupEnable = 0;
   \                     ??UsbClearDevFeature_1:
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000016   0x7E00             LDRB     R0,[R0, #+24]
   \   00000018   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   0000001C   0x.... 0x....      LDR.W    R3,??DataTable29
   \   00000020   0x7618             STRB     R0,[R3, #+24]
    682            return(UsbPass);
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??UsbClearDevFeature_2:
   \   00000024   0x4770             BX       LR               ;; return
    683          }
    684          /*************************************************************************
    685           * Function Name: UsbClearInterfaceFeature
    686           * Parameters:  Int16U Feature,Int16U Index
    687           *
    688           * Return: UsbCommStatus_t
    689           *
    690           * Description: USB Clear Interface feature implement
    691           *
    692           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    693          inline static
    694          UsbCommStatus_t UsbClearInterfaceFeature(Int16U Feature,Int16U Index)
    695          {
   \                     UsbClearInterfaceFeature:
   \   00000000   0x0002             MOVS     R2,R0
    696            return(UsbFault);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4770             BX       LR               ;; return
    697          }
    698          
    699          /*************************************************************************
    700           * Function Name: UsbClearEpFeature
    701           * Parameters:  Int16U Feature,Int16U Index
    702           *
    703           * Return: UsbCommStatus_t
    704           *
    705           * Description: USB Clear EP feature implement
    706           *
    707           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    708          inline static
    709          UsbCommStatus_t UsbClearEpFeature(Int16U Feature,Int16U Index)
    710          {
   \                     UsbClearEpFeature:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    711          USB_Endpoint_t UsbEpAdd;
    712            if(((Index & 0x7F) > 16) || (Feature != UsbEpHaltSelector))
   \   00000006   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000008   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   0000000C   0x2811             CMP      R0,#+17
   \   0000000E   0xDA02             BGE.N    ??UsbClearEpFeature_0
   \   00000010   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD001             BEQ.N    ??UsbClearEpFeature_1
    713            {
    714              return(UsbFault);
   \                     ??UsbClearEpFeature_0:
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00E             B.N      ??UsbClearEpFeature_2
    715            }
    716            UsbEpAdd = USB_EpLogToPhysAdd(Index);
   \                     ??UsbClearEpFeature_1:
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       USB_EpLogToPhysAdd
   \   00000022   0x0006             MOVS     R6,R0
    717            USB_SetStallEP(UsbEpAdd,FALSE);
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       USB_SetStallEP
    718            USB_EP_UNSTALL_HOOK(UsbEpAdd);
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       USB_EP_UNSTALL_HOOK
    719            return(UsbPass);
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??UsbClearEpFeature_2:
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    720          }
    721          
    722          /*************************************************************************
    723           * Function Name: UsbClearFeature
    724           * Parameters:  none
    725           *
    726           * Return: none
    727           *
    728           * Description: USB Clear feature implement
    729           *
    730           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    731          inline static
    732          void UsbClearFeature (void)
    733          {
   \                     UsbClearFeature:
   \   00000000   0xB580             PUSH     {R7,LR}
    734            if((UsbDevCtrl.State.DS >= UsbDevStatusAddress) &&
    735               // Length must be 0
    736               (UsbEp0SetupPacket.wLength.Word == 0))
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xDB65             BLT.N    ??UsbClearFeature_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000014   0x88C0             LDRH     R0,[R0, #+6]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD160             BNE.N    ??UsbClearFeature_0
    737            {
    738              switch(UsbEp0SetupPacket.mRequestType.Recipient)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD003             BEQ.N    ??UsbClearFeature_1
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD032             BEQ.N    ??UsbClearFeature_2
   \   0000002C   0xD313             BCC.N    ??UsbClearFeature_3
   \   0000002E   0xE050             B.N      ??UsbClearFeature_4
    739              {
    740              case UsbRecipientDevice:
    741                if(UsbClearDevFeature(UsbEp0SetupPacket.wValue.Word,UsbEp0SetupPacket.wIndex.Word) == UsbPass)
   \                     ??UsbClearFeature_1:
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000034   0x8881             LDRH     R1,[R0, #+4]
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000003A   0x8840             LDRH     R0,[R0, #+2]
   \   0000003C   0x.... 0x....      BL       UsbClearDevFeature
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD103             BNE.N    ??UsbClearFeature_5
    742                {
    743                  USB_StatusHandler(CTRL_ENP_OUT);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      BL       USB_StatusHandler
   \   0000004A   0xE003             B.N      ??UsbClearFeature_6
    744                }
    745                else
    746                {
    747                  USB_T9_ERROR_REQUEST();
   \                     ??UsbClearFeature_5:
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000050   0x2107             MOVS     R1,#+7
   \   00000052   0x7501             STRB     R1,[R0, #+20]
    748                }
    749                break;
   \                     ??UsbClearFeature_6:
   \   00000054   0xE046             B.N      ??UsbClearFeature_7
    750              case UsbRecipientInterface:
    751                if((UsbDevCtrl.State.DS > UsbDevStatusAddress) &&
    752                   (UsbClearInterfaceFeature(UsbEp0SetupPacket.wValue.Word,UsbEp0SetupPacket.wIndex.Word) == UsbPass))
   \                     ??UsbClearFeature_3:
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000060   0x2805             CMP      R0,#+5
   \   00000062   0xDB11             BLT.N    ??UsbClearFeature_8
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000068   0x8881             LDRH     R1,[R0, #+4]
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000006E   0x8840             LDRH     R0,[R0, #+2]
   \   00000070   0x.... 0x....      BL       UsbClearInterfaceFeature
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD107             BNE.N    ??UsbClearFeature_8
    753                {
    754                  USB_IO_Data(CTRL_ENP_IN,NULL,0,(void*)USB_StatusHandler);
   \   00000078   0x.... 0x....      LDR.W    R3,??DataTable32_8
   \   0000007C   0x2200             MOVS     R2,#+0
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x.... 0x....      BL       USB_IO_Data
   \   00000086   0xE003             B.N      ??UsbClearFeature_9
    755                }
    756                else
    757                {
    758                  USB_T9_ERROR_REQUEST();
   \                     ??UsbClearFeature_8:
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000008C   0x2107             MOVS     R1,#+7
   \   0000008E   0x7501             STRB     R1,[R0, #+20]
    759                }
    760                break;
   \                     ??UsbClearFeature_9:
   \   00000090   0xE028             B.N      ??UsbClearFeature_7
    761              case UsbRecipientEndpoint:
    762                if(((UsbDevCtrl.State.DS > UsbDevStatusAddress) || ((UsbEp0SetupPacket.wIndex.Word & 0x7F) == 0)) &&
    763                   (UsbClearEpFeature(UsbEp0SetupPacket.wValue.Word,UsbEp0SetupPacket.wIndex.Word) == UsbPass))
   \                     ??UsbClearFeature_2:
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000009C   0x2805             CMP      R0,#+5
   \   0000009E   0xDA05             BGE.N    ??UsbClearFeature_10
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   000000A4   0x7900             LDRB     R0,[R0, #+4]
   \   000000A6   0x217F             MOVS     R1,#+127
   \   000000A8   0x4208             TST      R0,R1
   \   000000AA   0xD10D             BNE.N    ??UsbClearFeature_11
   \                     ??UsbClearFeature_10:
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   000000B0   0x8881             LDRH     R1,[R0, #+4]
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   000000B6   0x8840             LDRH     R0,[R0, #+2]
   \   000000B8   0x.... 0x....      BL       UsbClearEpFeature
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD103             BNE.N    ??UsbClearFeature_11
    764                {
    765                  USB_StatusHandler(CTRL_ENP_OUT);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       USB_StatusHandler
   \   000000C6   0xE003             B.N      ??UsbClearFeature_12
    766                }
    767                else
    768                {
    769                  USB_T9_ERROR_REQUEST();
   \                     ??UsbClearFeature_11:
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000CC   0x2107             MOVS     R1,#+7
   \   000000CE   0x7501             STRB     R1,[R0, #+20]
    770                }
    771                break;
   \                     ??UsbClearFeature_12:
   \   000000D0   0xE008             B.N      ??UsbClearFeature_7
    772              default:
    773                USB_T9_ERROR_REQUEST();
   \                     ??UsbClearFeature_4:
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000D6   0x2107             MOVS     R1,#+7
   \   000000D8   0x7501             STRB     R1,[R0, #+20]
   \   000000DA   0xE003             B.N      ??UsbClearFeature_7
    774              }
    775            }
    776            else
    777            {
    778              USB_T9_ERROR_REQUEST();
   \                     ??UsbClearFeature_0:
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000E0   0x2107             MOVS     R1,#+7
   \   000000E2   0x7501             STRB     R1,[R0, #+20]
    779            }
    780          }
   \                     ??UsbClearFeature_7:
   \   000000E4   0xBD01             POP      {R0,PC}          ;; return
    781          
    782          /*************************************************************************
    783           * Function Name: UsbSetFeature
    784           * Parameters:  Int16U Feature,Int16U Index
    785           *
    786           * Return: UsbCommStatus_t
    787           *
    788           * Description: USB Set Device feature implement
    789           *
    790           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    791          inline static
    792          UsbCommStatus_t UsbSetDevFeature(Int16U Feature,Int16U Index)
    793          {
   \                     UsbSetDevFeature:
   \   00000000   0x0002             MOVS     R2,R0
    794            if((Index != 0) || (Feature != UsbDeviceRemoteWakeupSelector))
   \   00000002   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD102             BNE.N    ??UsbSetDevFeature_0
   \   00000008   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD001             BEQ.N    ??UsbSetDevFeature_1
    795            {
    796              return(UsbFault);
   \                     ??UsbSetDevFeature_0:
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE008             B.N      ??UsbSetDevFeature_2
    797            }
    798            UsbDevCtrl.Feature.RemoteWakeupEnable = 1;
   \                     ??UsbSetDevFeature_1:
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000016   0x7E00             LDRB     R0,[R0, #+24]
   \   00000018   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000001C   0x.... 0x....      LDR.W    R3,??DataTable29
   \   00000020   0x7618             STRB     R0,[R3, #+24]
    799            return(UsbPass);
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??UsbSetDevFeature_2:
   \   00000024   0x4770             BX       LR               ;; return
    800          }
    801          /*************************************************************************
    802           * Function Name: UsbSetInterfaceFeature
    803           * Parameters:  Int16U Feature,Int16U Index
    804           *
    805           * Return: UsbCommStatus_t
    806           *
    807           * Description: USB Set Interface feature implement
    808           *
    809           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    810          inline static
    811          UsbCommStatus_t UsbSetInterfaceFeature(Int16U Feature,Int16U Index)
    812          {
   \                     UsbSetInterfaceFeature:
   \   00000000   0x0002             MOVS     R2,R0
    813            return(UsbFault);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4770             BX       LR               ;; return
    814          }
    815          
    816          /*************************************************************************
    817           * Function Name: UsbSetEpFeature
    818           * Parameters:  Int16U Feature,Int16U Index
    819           *
    820           * Return: UsbCommStatus_t
    821           *
    822           * Description: USB Set EP feature implement
    823           *
    824           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    825          inline static
    826          UsbCommStatus_t UsbSetEpFeature(Int16U Feature,Int16U Index)
    827          {
   \                     UsbSetEpFeature:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    828          USB_Endpoint_t UsbEpAdd;
    829            if(((Index & 0x7F) > 16) || (Feature != UsbEpHaltSelector))
   \   00000006   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000008   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   0000000C   0x2811             CMP      R0,#+17
   \   0000000E   0xDA02             BGE.N    ??UsbSetEpFeature_0
   \   00000010   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD001             BEQ.N    ??UsbSetEpFeature_1
    830            {
    831              return(UsbFault);
   \                     ??UsbSetEpFeature_0:
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00E             B.N      ??UsbSetEpFeature_2
    832            }
    833          
    834            UsbEpAdd = USB_EpLogToPhysAdd(Index);
   \                     ??UsbSetEpFeature_1:
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       USB_EpLogToPhysAdd
   \   00000022   0x0006             MOVS     R6,R0
    835            USB_SetStallEP(UsbEpAdd,TRUE);
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       USB_SetStallEP
    836            USB_EP_STALL_HOOK(UsbEpAdd);
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       USB_EP_STALL_HOOK
    837            return(UsbPass);
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??UsbSetEpFeature_2:
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    838          }
    839          
    840          /*************************************************************************
    841           * Function Name: UsbSetFeature
    842           * Parameters:  none
    843           *
    844           * Return: none
    845           *
    846           * Description: USB Set feature implement
    847           *
    848           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    849          inline static
    850          void UsbSetFeature (void)
    851          {
   \                     UsbSetFeature:
   \   00000000   0xB580             PUSH     {R7,LR}
    852            if((UsbDevCtrl.State.DS >= UsbDevStatusAddress) &&
    853               // Length must be 0
    854               (UsbEp0SetupPacket.wLength.Word == 0))
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xDB61             BLT.N    ??UsbSetFeature_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000014   0x88C0             LDRH     R0,[R0, #+6]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD15C             BNE.N    ??UsbSetFeature_0
    855            {
    856              switch(UsbEp0SetupPacket.mRequestType.Recipient)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD003             BEQ.N    ??UsbSetFeature_1
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD02E             BEQ.N    ??UsbSetFeature_2
   \   0000002C   0xD313             BCC.N    ??UsbSetFeature_3
   \   0000002E   0xE04C             B.N      ??UsbSetFeature_4
    857              {
    858              case UsbRecipientDevice:
    859                if(UsbSetDevFeature(UsbEp0SetupPacket.wValue.Word,UsbEp0SetupPacket.wIndex.Word) == UsbPass)
   \                     ??UsbSetFeature_1:
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000034   0x8881             LDRH     R1,[R0, #+4]
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000003A   0x8840             LDRH     R0,[R0, #+2]
   \   0000003C   0x.... 0x....      BL       UsbSetDevFeature
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD103             BNE.N    ??UsbSetFeature_5
    860                {
    861                  USB_StatusHandler(CTRL_ENP_OUT);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      BL       USB_StatusHandler
   \   0000004A   0xE003             B.N      ??UsbSetFeature_6
    862                }
    863                else
    864                {
    865                  USB_T9_ERROR_REQUEST();
   \                     ??UsbSetFeature_5:
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000050   0x2107             MOVS     R1,#+7
   \   00000052   0x7501             STRB     R1,[R0, #+20]
    866                }
    867                break;
   \                     ??UsbSetFeature_6:
   \   00000054   0xE042             B.N      ??UsbSetFeature_7
    868              case UsbRecipientInterface:
    869                if((UsbDevCtrl.State.DS > UsbDevStatusAddress) &&
    870                   (UsbSetInterfaceFeature(UsbEp0SetupPacket.wValue.Word,UsbEp0SetupPacket.wIndex.Word) == UsbPass))
   \                     ??UsbSetFeature_3:
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000060   0x2805             CMP      R0,#+5
   \   00000062   0xDB0D             BLT.N    ??UsbSetFeature_8
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000068   0x8881             LDRH     R1,[R0, #+4]
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000006E   0x8840             LDRH     R0,[R0, #+2]
   \   00000070   0x.... 0x....      BL       UsbSetInterfaceFeature
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD103             BNE.N    ??UsbSetFeature_8
    871                {
    872                  USB_StatusHandler(CTRL_ENP_OUT);
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      BL       USB_StatusHandler
   \   0000007E   0xE003             B.N      ??UsbSetFeature_9
    873                }
    874                else
    875                {
    876                  USB_T9_ERROR_REQUEST();
   \                     ??UsbSetFeature_8:
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000084   0x2107             MOVS     R1,#+7
   \   00000086   0x7501             STRB     R1,[R0, #+20]
    877                }
    878                break;
   \                     ??UsbSetFeature_9:
   \   00000088   0xE028             B.N      ??UsbSetFeature_7
    879              case UsbRecipientEndpoint:
    880                if(((UsbDevCtrl.State.DS > UsbDevStatusAddress) || ((UsbEp0SetupPacket.wIndex.Word & 0x7F) == 0)) &&
    881                   (UsbSetEpFeature(UsbEp0SetupPacket.wValue.Word,UsbEp0SetupPacket.wIndex.Word) == UsbPass))
   \                     ??UsbSetFeature_2:
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable29
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000094   0x2805             CMP      R0,#+5
   \   00000096   0xDA05             BGE.N    ??UsbSetFeature_10
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000009C   0x7900             LDRB     R0,[R0, #+4]
   \   0000009E   0x217F             MOVS     R1,#+127
   \   000000A0   0x4208             TST      R0,R1
   \   000000A2   0xD10D             BNE.N    ??UsbSetFeature_11
   \                     ??UsbSetFeature_10:
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   000000A8   0x8881             LDRH     R1,[R0, #+4]
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   000000AE   0x8840             LDRH     R0,[R0, #+2]
   \   000000B0   0x.... 0x....      BL       UsbSetEpFeature
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD103             BNE.N    ??UsbSetFeature_11
    882                {
    883                  USB_StatusHandler(CTRL_ENP_OUT);
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x.... 0x....      BL       USB_StatusHandler
   \   000000BE   0xE003             B.N      ??UsbSetFeature_12
    884                }
    885                else
    886                {
    887                  USB_T9_ERROR_REQUEST();
   \                     ??UsbSetFeature_11:
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000C4   0x2107             MOVS     R1,#+7
   \   000000C6   0x7501             STRB     R1,[R0, #+20]
    888                }
    889                break;
   \                     ??UsbSetFeature_12:
   \   000000C8   0xE008             B.N      ??UsbSetFeature_7
    890              default:
    891                USB_T9_ERROR_REQUEST();
   \                     ??UsbSetFeature_4:
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000CE   0x2107             MOVS     R1,#+7
   \   000000D0   0x7501             STRB     R1,[R0, #+20]
   \   000000D2   0xE003             B.N      ??UsbSetFeature_7
    892              }
    893            }
    894            else
    895            {
    896              USB_T9_ERROR_REQUEST();
   \                     ??UsbSetFeature_0:
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable32
   \   000000D8   0x2107             MOVS     R1,#+7
   \   000000DA   0x7501             STRB     R1,[R0, #+20]
    897            }
    898          }
   \                     ??UsbSetFeature_7:
   \   000000DC   0xBD01             POP      {R0,PC}          ;; return
    899          
    900          /*************************************************************************
    901           * Function Name: UsbSetAddress
    902           * Parameters:  none
    903           *
    904           * Return: none
    905           *
    906           * Description: USB Set address request implement
    907           *
    908           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    909          inline static
    910          void UsbSetAddress (void)
    911          {
   \                     UsbSetAddress:
   \   00000000   0xB580             PUSH     {R7,LR}
    912            if((UsbDevCtrl.State.DS >= UsbDevStatusDefault) &&
    913               (UsbEp0SetupPacket.mRequestType.Recipient == 0) &&
    914               (UsbEp0SetupPacket.wIndex.Word  == 0) &&
    915               (UsbEp0SetupPacket.wLength.Word == 0) &&
    916               (UsbEp0SetupPacket.wValue.Word < 128))
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xDB19             BLT.N    ??UsbSetAddress_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD112             BNE.N    ??UsbSetAddress_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000022   0x8880             LDRH     R0,[R0, #+4]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD10D             BNE.N    ??UsbSetAddress_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000002C   0x88C0             LDRH     R0,[R0, #+6]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD108             BNE.N    ??UsbSetAddress_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000036   0x8840             LDRH     R0,[R0, #+2]
   \   00000038   0x2880             CMP      R0,#+128
   \   0000003A   0xDA03             BGE.N    ??UsbSetAddress_0
    917            {
    918              USB_StatusHandler(CTRL_ENP_IN);
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       USB_StatusHandler
   \   00000042   0xE003             B.N      ??UsbSetAddress_1
    919            }
    920            else
    921            {
    922              USB_T9_ERROR_REQUEST();
   \                     ??UsbSetAddress_0:
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000048   0x2107             MOVS     R1,#+7
   \   0000004A   0x7501             STRB     R1,[R0, #+20]
    923            }
    924          }
   \                     ??UsbSetAddress_1:
   \   0000004C   0xBD01             POP      {R0,PC}          ;; return
    925          
    926          /*************************************************************************
    927           * Function Name: UsbGetDescriptorDevice
    928           * Parameters:  Int8U Index - must be 0
    929           *
    930           * Return: UsbCommStatus_t
    931           *
    932           * Description: USB get device's descriptor request implement
    933           *
    934           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    935          inline static
    936          UsbCommStatus_t UsbGetDescriptorDevice(Int8U Index)
    937          {
   \                     UsbGetDescriptorDevice:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    938            if(Index == 0)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD111             BNE.N    ??UsbGetDescriptorDevice_0
    939            {
    940              USB_IO_Data(CTRL_ENP_IN,
    941                         (Int8U *)&UsbStandardDeviceDescriptorStr,
    942                          USB_T9_Size(UsbStandardDeviceDescriptorStr.bLength,UsbEp0SetupPacket.wLength.Word),
    943                         (void*)USB_StatusHandler);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   0000000E   0x88C1             LDRH     R1,[R0, #+6]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_9
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       USB_T9_Size
   \   0000001A   0x.... 0x....      LDR.W    R3,??DataTable32_8
   \   0000001E   0x0002             MOVS     R2,R0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable32_9
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       USB_IO_Data
    944              return(UsbPass);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE000             B.N      ??UsbGetDescriptorDevice_1
    945            }
    946            return(UsbFault);
   \                     ??UsbGetDescriptorDevice_0:
   \   0000002E   0x2001             MOVS     R0,#+1
   \                     ??UsbGetDescriptorDevice_1:
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    947          }
    948          
    949          /*************************************************************************
    950           * Function Name: UsbGetDescriptorConfiguration
    951           * Parameters:  Int8U Index
    952           *
    953           * Return: UsbCommStatus_t
    954           *
    955           * Description: USB get configuration's descriptor request implement
    956           *
    957           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    958          inline static
    959          UsbCommStatus_t UsbGetDescriptorConfiguration(Int8U Index)
    960          {
   \                     UsbGetDescriptorConfiguration:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    961          pUsbStandardConfigurationDescriptor_t pCfg;
    962            if (Index >= UsbStandardDeviceDescriptorStr.bNumConfigurations)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable32_9
   \   00000008   0x7C40             LDRB     R0,[R0, #+17]
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD301             BCC.N    ??UsbGetDescriptorConfiguration_0
    963            {
    964               return(UsbFault);
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE014             B.N      ??UsbGetDescriptorConfiguration_1
    965            }
    966          #if USB_HIGH_SPEED > 0
    967            pCfg = (pUsbStandardConfigurationDescriptor_t)(*(Int8U **)UsbDescArray[(UsbDevCtrl.HighSpeed?USB_HS_CFG_ARRAY:USB_FS_CFG_ARRAY)] + Index);
    968          #else
    969            pCfg = (pUsbStandardConfigurationDescriptor_t)(*(Int8U **)UsbDescArray[USB_FS_CFG_ARRAY] + Index);
   \                     ??UsbGetDescriptorConfiguration_0:
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable32_4
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x1820             ADDS     R0,R4,R0
   \   00000020   0x0005             MOVS     R5,R0
    970          #endif // USB_HIGH_SPEED > 0
    971            USB_IO_Data(CTRL_ENP_IN,
    972                       (pInt8U)pCfg,
    973                        USB_T9_Size(pCfg->wTotalLength,UsbEp0SetupPacket.wLength.Word),
    974                       (void*)USB_StatusHandler);
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000026   0x88C1             LDRH     R1,[R0, #+6]
   \   00000028   0x8868             LDRH     R0,[R5, #+2]
   \   0000002A   0x.... 0x....      BL       USB_T9_Size
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable32_8
   \   00000032   0x0002             MOVS     R2,R0
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       USB_IO_Data
    975            return(UsbPass);
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??UsbGetDescriptorConfiguration_1:
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    976          }
    977          
    978          /*************************************************************************
    979           * Function Name: UsbGetDescriptorString
    980           * Parameters:  Int8U Index
    981           *
    982           * Return: UsbCommStatus_t
    983           *
    984           * Description: USB get string's descriptor request implement
    985           *
    986           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    987          inline static
    988          UsbCommStatus_t UsbGetDescriptorString(Int8U Index)
    989          {
   \                     UsbGetDescriptorString:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    990          Int8U **ppData;
    991          #if USB_HIGH_SPEED > 0
    992          pInt8U pLangStr = (pInt8U)UsbDescArray[(UsbDevCtrl.HighSpeed?USB_HS_LANG_STR:USB_FS_LANG_STR)];
    993          #else
    994          pInt8U pLangStr = (pInt8U)UsbDescArray[USB_FS_LANG_STR];
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable32_4
   \   0000000A   0x6886             LDR      R6,[R0, #+8]
    995          #endif // USB_HIGH_SPEED > 0
    996          Int32U i;
    997            if(Index == 0)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD10D             BNE.N    ??UsbGetDescriptorString_0
    998            {
    999              USB_IO_Data(CTRL_ENP_IN,
   1000                          pLangStr,
   1001                          USB_T9_Size(pLangStr[UsbDescLengthOffset],UsbEp0SetupPacket.wLength.Word),
   1002                         (void*)USB_StatusHandler);
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000016   0x88C1             LDRH     R1,[R0, #+6]
   \   00000018   0x7830             LDRB     R0,[R6, #+0]
   \   0000001A   0x.... 0x....      BL       USB_T9_Size
   \   0000001E   0x.... 0x....      LDR.W    R3,??DataTable32_8
   \   00000022   0x0002             MOVS     R2,R0
   \   00000024   0x0031             MOVS     R1,R6
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       USB_IO_Data
   \   0000002C   0xE039             B.N      ??UsbGetDescriptorString_1
   1003            }
   1004            else
   1005            {
   1006              Int32U LanguagesOffset = 0;
   \                     ??UsbGetDescriptorString_0:
   \   0000002E   0xF05F 0x0800      MOVS     R8,#+0
   1007              // Find Languages index
   1008              for(i = 2; i < pLangStr[UsbDescLengthOffset]; i+=2)
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x0007             MOVS     R7,R0
   \                     ??UsbGetDescriptorString_2:
   \   00000036   0x7830             LDRB     R0,[R6, #+0]
   \   00000038   0x4287             CMP      R7,R0
   \   0000003A   0xD20F             BCS.N    ??UsbGetDescriptorString_3
   1009              {
   1010                if((pLangStr[i] == UsbEp0SetupPacket.wIndex.Lo) &&
   1011                   (pLangStr[i+1] == UsbEp0SetupPacket.wIndex.Hi))
   \   0000003C   0x5DB8             LDRB     R0,[R7, R6]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \   00000042   0x7909             LDRB     R1,[R1, #+4]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD105             BNE.N    ??UsbGetDescriptorString_4
   \   00000048   0x19B8             ADDS     R0,R7,R6
   \   0000004A   0x7840             LDRB     R0,[R0, #+1]
   \   0000004C   0x....             LDR.N    R1,??DataTable32_1
   \   0000004E   0x7949             LDRB     R1,[R1, #+5]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD003             BEQ.N    ??UsbGetDescriptorString_3
   1012                {
   1013                  break;
   1014                }
   1015                ++LanguagesOffset;
   \                     ??UsbGetDescriptorString_4:
   \   00000054   0xF118 0x0801      ADDS     R8,R8,#+1
   1016              }
   \   00000058   0x1CBF             ADDS     R7,R7,#+2
   \   0000005A   0xE7EC             B.N      ??UsbGetDescriptorString_2
   1017              if(i >= pLangStr[UsbDescLengthOffset])
   \                     ??UsbGetDescriptorString_3:
   \   0000005C   0x7830             LDRB     R0,[R6, #+0]
   \   0000005E   0x4287             CMP      R7,R0
   \   00000060   0xD301             BCC.N    ??UsbGetDescriptorString_5
   1018              {
   1019                return(UsbFault);
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xE01E             B.N      ??UsbGetDescriptorString_6
   1020              }
   1021              // Find String index
   1022            #if USB_HIGH_SPEED > 0
   1023              for(ppData = (*((Int8U***)UsbDescArray[(UsbDevCtrl.HighSpeed?USB_HS_STR_ARRAY:USB_FS_STR_ARRAY)] + LanguagesOffset));
   1024            #else
   1025              for(ppData = (*((Int8U***)UsbDescArray[USB_FS_STR_ARRAY] + LanguagesOffset));
   \                     ??UsbGetDescriptorString_5:
   \   00000066   0x....             LDR.N    R0,??DataTable32_4
   \   00000068   0x68C0             LDR      R0,[R0, #+12]
   \   0000006A   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   0000006E   0x0005             MOVS     R5,R0
   1026            #endif // USB_HIGH_SPEED > 0
   1027                  ppData ;
   \                     ??UsbGetDescriptorString_7:
   \   00000070   0x2D00             CMP      R5,#+0
   \   00000072   0xD006             BEQ.N    ??UsbGetDescriptorString_8
   1028                  ++ppData)
   1029              {
   1030                if(--Index == 0)
   \   00000074   0x1E64             SUBS     R4,R4,#+1
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD001             BEQ.N    ??UsbGetDescriptorString_8
   1031                {
   1032                  break;
   1033                }
   1034              }
   \                     ??UsbGetDescriptorString_9:
   \   0000007E   0x1D2D             ADDS     R5,R5,#+4
   \   00000080   0xE7F6             B.N      ??UsbGetDescriptorString_7
   1035              if(ppData == NULL)
   \                     ??UsbGetDescriptorString_8:
   \   00000082   0x2D00             CMP      R5,#+0
   \   00000084   0xD101             BNE.N    ??UsbGetDescriptorString_10
   1036              {
   1037                return(UsbFault);
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0xE00C             B.N      ??UsbGetDescriptorString_6
   1038              }
   1039          
   1040              USB_IO_Data(CTRL_ENP_IN,
   1041                         (pInt8U)*ppData,
   1042                          USB_T9_Size(*(*ppData+UsbDescLengthOffset),UsbEp0SetupPacket.wLength.Word),
   1043                         (void*)USB_StatusHandler);
   \                     ??UsbGetDescriptorString_10:
   \   0000008A   0x....             LDR.N    R0,??DataTable32_1
   \   0000008C   0x88C1             LDRH     R1,[R0, #+6]
   \   0000008E   0x6828             LDR      R0,[R5, #+0]
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x.... 0x....      BL       USB_T9_Size
   \   00000096   0x0002             MOVS     R2,R0
   \   00000098   0x....             LDR.N    R3,??DataTable32_8
   \   0000009A   0x6829             LDR      R1,[R5, #+0]
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x.... 0x....      BL       USB_IO_Data
   1044            }
   1045            return(UsbPass);
   \                     ??UsbGetDescriptorString_1:
   \   000000A2   0x2000             MOVS     R0,#+0
   \                     ??UsbGetDescriptorString_6:
   \   000000A4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1046          }
   1047          
   1048          #if USB_HIGH_SPEED > 0
   1049          /*************************************************************************
   1050           * Function Name: UsbGetQualifierDescriptor
   1051           * Parameters:  眍礤
   1052           *
   1053           * Return: UsbCommStatus_t
   1054           *
   1055           * Description: USB get device's qualifier descriptor request implement
   1056           *
   1057           *************************************************************************/
   1058          inline static
   1059          UsbCommStatus_t UsbGetQualifierDescriptor(Int8U Index)
   1060          {
   1061            USB_IO_Data(CTRL_ENP_IN,
   1062                       (Int8U *)&UsbQualifierDescriptor,
   1063                        USB_T9_Size(UsbQualifierDescriptor.bLength,UsbEp0SetupPacket.wLength.Word),
   1064                       (void*)USB_StatusHandler);
   1065            return(UsbPass);
   1066          }
   1067          
   1068          /*************************************************************************
   1069           * Function Name: UsbGetOtherSpeedDescriptor
   1070           * Parameters:  Int8U Index
   1071           *
   1072           * Return: UsbCommStatus_t
   1073           *
   1074           * Description: USB get device's other descriptor request implement
   1075           *
   1076           *************************************************************************/
   1077          inline static
   1078          UsbCommStatus_t UsbGetOtherSpeedDescriptorConfiguration(Int8U Index)
   1079          {
   1080          pUsbStandardConfigurationDescriptor_t pCfg;
   1081            if (Index >= UsbStandardDeviceDescriptorStr.bNumConfigurations)
   1082            {
   1083               return(UsbFault);
   1084            }
   1085            pCfg = (pUsbStandardConfigurationDescriptor_t)(*(Int8U **)UsbDescArray[(UsbDevCtrl.HighSpeed?USB_HS_OTHER_CFG_ARRAY:USB_FS_OTHER_CFG_ARRAY)] + Index);
   1086            USB_IO_Data(CTRL_ENP_IN,
   1087                       (pInt8U)pCfg,
   1088                        USB_T9_Size(pCfg->wTotalLength,UsbEp0SetupPacket.wLength.Word),
   1089                       (void*)USB_StatusHandler);
   1090            return(UsbPass);
   1091          }
   1092          
   1093          #endif // USB_HIGH_SPEED > 0
   1094          
   1095          /*************************************************************************
   1096           * Function Name: UsbGetDescriptor
   1097           * Parameters:  none
   1098           *
   1099           * Return: none
   1100           *
   1101           * Description: USB get descriptor request implement
   1102           *
   1103           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1104          inline static
   1105          void UsbGetDescriptor (void)
   1106          {
   \                     UsbGetDescriptor:
   \   00000000   0xB580             PUSH     {R7,LR}
   1107            if(UsbDevCtrl.State.DS >= UsbDevStatusDefault)
   \   00000002   0x....             LDR.N    R0,??DataTable29
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xDB2F             BLT.N    ??UsbGetDescriptor_0
   1108            {
   1109              switch(UsbEp0SetupPacket.wValue.Hi)
   \   0000000E   0x....             LDR.N    R0,??DataTable32_1
   \   00000010   0x78C0             LDRB     R0,[R0, #+3]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD004             BEQ.N    ??UsbGetDescriptor_1
   \   00000016   0xD321             BCC.N    ??UsbGetDescriptor_2
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD015             BEQ.N    ??UsbGetDescriptor_3
   \   0000001C   0xD30A             BCC.N    ??UsbGetDescriptor_4
   \   0000001E   0xE01D             B.N      ??UsbGetDescriptor_2
   1110              {
   1111              case UsbDescriptorDevice:
   1112                if(UsbGetDescriptorDevice(UsbEp0SetupPacket.wValue.Lo) != UsbPass)
   \                     ??UsbGetDescriptor_1:
   \   00000020   0x....             LDR.N    R0,??DataTable32_1
   \   00000022   0x7880             LDRB     R0,[R0, #+2]
   \   00000024   0x.... 0x....      BL       UsbGetDescriptorDevice
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD002             BEQ.N    ??UsbGetDescriptor_5
   1113                {
   1114                  USB_T9_ERROR_REQUEST();
   \   0000002C   0x....             LDR.N    R0,??DataTable32
   \   0000002E   0x2107             MOVS     R1,#+7
   \   00000030   0x7501             STRB     R1,[R0, #+20]
   1115                }
   1116                else
   1117                {
   1118                }
   1119                break;
   \                     ??UsbGetDescriptor_5:
   \   00000032   0xE01F             B.N      ??UsbGetDescriptor_6
   1120              case UsbDescriptorConfiguration:
   1121                if(UsbGetDescriptorConfiguration(UsbEp0SetupPacket.wValue.Lo) != UsbPass)
   \                     ??UsbGetDescriptor_4:
   \   00000034   0x....             LDR.N    R0,??DataTable32_1
   \   00000036   0x7880             LDRB     R0,[R0, #+2]
   \   00000038   0x.... 0x....      BL       UsbGetDescriptorConfiguration
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??UsbGetDescriptor_7
   1122                {
   1123                  USB_T9_ERROR_REQUEST();
   \   00000040   0x....             LDR.N    R0,??DataTable32
   \   00000042   0x2107             MOVS     R1,#+7
   \   00000044   0x7501             STRB     R1,[R0, #+20]
   1124                }
   1125                else
   1126                {
   1127                }
   1128                break;
   \                     ??UsbGetDescriptor_7:
   \   00000046   0xE015             B.N      ??UsbGetDescriptor_6
   1129              case UsbDescriptorString:
   1130                if(UsbGetDescriptorString(UsbEp0SetupPacket.wValue.Lo) != UsbPass)
   \                     ??UsbGetDescriptor_3:
   \   00000048   0x....             LDR.N    R0,??DataTable32_1
   \   0000004A   0x7880             LDRB     R0,[R0, #+2]
   \   0000004C   0x.... 0x....      BL       UsbGetDescriptorString
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD002             BEQ.N    ??UsbGetDescriptor_8
   1131                {
   1132                  USB_T9_ERROR_REQUEST();
   \   00000054   0x....             LDR.N    R0,??DataTable32
   \   00000056   0x2107             MOVS     R1,#+7
   \   00000058   0x7501             STRB     R1,[R0, #+20]
   1133                }
   1134                else
   1135                {
   1136                }
   1137                break;
   \                     ??UsbGetDescriptor_8:
   \   0000005A   0xE00B             B.N      ??UsbGetDescriptor_6
   1138            #if USB_HIGH_SPEED > 0
   1139              case UsbDescriptorDeviceQualifier:
   1140                if(UsbGetQualifierDescriptor(UsbEp0SetupPacket.wValue.Lo) != UsbPass)
   1141                {
   1142                  USB_T9_ERROR_REQUEST();
   1143                }
   1144                else
   1145                {
   1146                }
   1147                break;
   1148              case UsbDescriptorOtherSeedConfiguration:
   1149                if(UsbGetOtherSpeedDescriptorConfiguration(UsbEp0SetupPacket.wValue.Lo) != UsbPass)
   1150                {
   1151                  USB_T9_ERROR_REQUEST();
   1152                }
   1153                else
   1154                {
   1155                }
   1156                break;
   1157            #endif // USB_HIGH_SPEED > 0
   1158              default:
   1159                if (USB_GET_DESCRIPTOR_HOOK(&UsbEp0SetupPacket) != UsbPass)
   \                     ??UsbGetDescriptor_2:
   \   0000005C   0x....             LDR.N    R0,??DataTable32_1
   \   0000005E   0x.... 0x....      BL       USB_GET_DESCRIPTOR_HOOK
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD006             BEQ.N    ??UsbGetDescriptor_6
   1160                {
   1161                  USB_T9_ERROR_REQUEST();
   \   00000066   0x....             LDR.N    R0,??DataTable32
   \   00000068   0x2107             MOVS     R1,#+7
   \   0000006A   0x7501             STRB     R1,[R0, #+20]
   \   0000006C   0xE002             B.N      ??UsbGetDescriptor_6
   1162                }
   1163                else
   1164                {
   1165                }
   1166              }
   1167            }
   1168            else
   1169            {
   1170              USB_T9_ERROR_REQUEST();
   \                     ??UsbGetDescriptor_0:
   \   0000006E   0x....             LDR.N    R0,??DataTable32
   \   00000070   0x2107             MOVS     R1,#+7
   \   00000072   0x7501             STRB     R1,[R0, #+20]
   1171            }
   1172          }
   \                     ??UsbGetDescriptor_6:
   \   00000074   0xBD01             POP      {R0,PC}          ;; return
   1173          
   1174          /*************************************************************************
   1175           * Function Name: UsbSetDescriptor
   1176           * Parameters:  none
   1177           *
   1178           * Return: none
   1179           *
   1180           * Description: USB Set descriptor
   1181           *
   1182           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1183          inline static
   1184          void UsbSetDescriptor(void)
   1185          {
   1186            if(UsbDevCtrl.State.DS >= UsbDevStatusAddress)
   \                     UsbSetDescriptor:
   \   00000000   0x....             LDR.N    R0,??DataTable29
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xDB03             BLT.N    ??UsbSetDescriptor_0
   1187            {
   1188              // This request is valid only for Address state and Configured state.
   1189              // If supported
   1190              USB_T9_ERROR_REQUEST();
   \   0000000C   0x....             LDR.N    R0,??DataTable32
   \   0000000E   0x2107             MOVS     R1,#+7
   \   00000010   0x7501             STRB     R1,[R0, #+20]
   \   00000012   0xE002             B.N      ??UsbSetDescriptor_1
   1191            }
   1192            else
   1193            {
   1194              USB_T9_ERROR_REQUEST();
   \                     ??UsbSetDescriptor_0:
   \   00000014   0x....             LDR.N    R0,??DataTable32
   \   00000016   0x2107             MOVS     R1,#+7
   \   00000018   0x7501             STRB     R1,[R0, #+20]
   1195            }
   1196          }
   \                     ??UsbSetDescriptor_1:
   \   0000001A   0x4770             BX       LR               ;; return
   1197          
   1198          /*************************************************************************
   1199           * Function Name: UsbGetConfiguration
   1200           * Parameters:  none
   1201           *
   1202           * Return: none
   1203           *
   1204           * Description: USB Get configuration implement
   1205           *
   1206           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1207          inline static
   1208          void UsbGetConfiguration(void)
   1209          {
   \                     UsbGetConfiguration:
   \   00000000   0xB580             PUSH     {R7,LR}
   1210            if((UsbDevCtrl.State.DS >= UsbDevStatusAddress) &&
   1211               (UsbEp0SetupPacket.wValue.Word == 0) &&
   1212               (UsbEp0SetupPacket.wIndex.Word == 0) &&
   1213               (UsbEp0SetupPacket.wLength.Word == 1))
   \   00000002   0x....             LDR.N    R0,??DataTable29
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xDB17             BLT.N    ??UsbGetConfiguration_0
   \   0000000E   0x....             LDR.N    R0,??DataTable32_1
   \   00000010   0x8840             LDRH     R0,[R0, #+2]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD113             BNE.N    ??UsbGetConfiguration_0
   \   00000016   0x....             LDR.N    R0,??DataTable32_1
   \   00000018   0x8880             LDRH     R0,[R0, #+4]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD10F             BNE.N    ??UsbGetConfiguration_0
   \   0000001E   0x....             LDR.N    R0,??DataTable32_1
   \   00000020   0x88C0             LDRH     R0,[R0, #+6]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD10B             BNE.N    ??UsbGetConfiguration_0
   1214            {
   1215              InData = UsbCoreReq(UsbCoreReqConfiquration);
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x.... 0x....      BL       UsbCoreReq
   \   0000002C   0x....             LDR.N    R1,??DataTable32_7
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   1216              USB_IO_Data(CTRL_ENP_IN,(pInt8U)&InData,1,(void*)USB_StatusHandler);
   \   00000030   0x....             LDR.N    R3,??DataTable32_8
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x....             LDR.N    R1,??DataTable32_7
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       USB_IO_Data
   \   0000003C   0xE002             B.N      ??UsbGetConfiguration_1
   1217            }
   1218            else
   1219            {
   1220              USB_T9_ERROR_REQUEST();
   \                     ??UsbGetConfiguration_0:
   \   0000003E   0x....             LDR.N    R0,??DataTable32
   \   00000040   0x2107             MOVS     R1,#+7
   \   00000042   0x7501             STRB     R1,[R0, #+20]
   1221            }
   1222          }
   \                     ??UsbGetConfiguration_1:
   \   00000044   0xBD01             POP      {R0,PC}          ;; return
   1223          
   1224          /*************************************************************************
   1225           * Function Name: UsbSetConfiguration
   1226           * Parameters:  none
   1227           *
   1228           * Return: none
   1229           *
   1230           * Description: USB Set configuration implement
   1231           *
   1232           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1233          inline static
   1234          void UsbSetConfiguration(void)
   1235          {
   \                     UsbSetConfiguration:
   \   00000000   0xB580             PUSH     {R7,LR}
   1236            if((UsbDevCtrl.State.DS >= UsbDevStatusAddress) &&
   1237               (UsbEp0SetupPacket.wIndex.Word == 0) &&
   1238               (UsbEp0SetupPacket.wLength.Word == 0) &&
   1239               (UsbSetConfigurtonState(UsbEp0SetupPacket.wValue.Lo) == UsbPass))
   \   00000002   0x....             LDR.N    R0,??DataTable29
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xDB11             BLT.N    ??UsbSetConfiguration_0
   \   0000000E   0x....             LDR.N    R0,??DataTable32_1
   \   00000010   0x8880             LDRH     R0,[R0, #+4]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD10D             BNE.N    ??UsbSetConfiguration_0
   \   00000016   0x....             LDR.N    R0,??DataTable32_1
   \   00000018   0x88C0             LDRH     R0,[R0, #+6]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD109             BNE.N    ??UsbSetConfiguration_0
   \   0000001E   0x....             LDR.N    R0,??DataTable32_1
   \   00000020   0x7880             LDRB     R0,[R0, #+2]
   \   00000022   0x.... 0x....      BL       UsbSetConfigurtonState
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD103             BNE.N    ??UsbSetConfiguration_0
   1240            {
   1241              USB_StatusHandler(CTRL_ENP_OUT);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       USB_StatusHandler
   \   00000030   0xE002             B.N      ??UsbSetConfiguration_1
   1242            }
   1243            else
   1244            {
   1245              USB_T9_ERROR_REQUEST();
   \                     ??UsbSetConfiguration_0:
   \   00000032   0x....             LDR.N    R0,??DataTable32
   \   00000034   0x2107             MOVS     R1,#+7
   \   00000036   0x7501             STRB     R1,[R0, #+20]
   1246            }
   1247          }
   \                     ??UsbSetConfiguration_1:
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
   1248          
   1249          /*************************************************************************
   1250           * Function Name: UsbGetInterface
   1251           * Parameters:  none
   1252           *
   1253           * Return: none
   1254           *
   1255           * Description: Implement get interface request
   1256           *
   1257           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1258          inline static
   1259          void UsbGetInterface (void)
   1260          {
   \                     UsbGetInterface:
   \   00000000   0xB580             PUSH     {R7,LR}
   1261            if((UsbDevCtrl.State.DS == UsbDevStatusConfigured) &&
   1262               (UsbEp0SetupPacket.wIndex.Word <= UsbDevCtrl.Interfaces) &&
   1263               (UsbEp0SetupPacket.wLength.Word == 1) &&
   1264               (UsbEp0SetupPacket.wValue.Word == 0))
   \   00000002   0x....             LDR.N    R0,??DataTable29
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000A   0x2805             CMP      R0,#+5
   \   0000000C   0xD11A             BNE.N    ??UsbGetInterface_0
   \   0000000E   0x....             LDR.N    R0,??DataTable29
   \   00000010   0x68C0             LDR      R0,[R0, #+12]
   \   00000012   0x....             LDR.N    R1,??DataTable32_1
   \   00000014   0x8889             LDRH     R1,[R1, #+4]
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD314             BCC.N    ??UsbGetInterface_0
   \   0000001A   0x....             LDR.N    R0,??DataTable32_1
   \   0000001C   0x88C0             LDRH     R0,[R0, #+6]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD110             BNE.N    ??UsbGetInterface_0
   \   00000022   0x....             LDR.N    R0,??DataTable32_1
   \   00000024   0x8840             LDRH     R0,[R0, #+2]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD10C             BNE.N    ??UsbGetInterface_0
   1265            {
   1266              USB_IO_Data(CTRL_ENP_IN,
   1267                         (pInt8U)&UsbDevCtrl.AlternateSetting[UsbEp0SetupPacket.wIndex.Word],
   1268                          1,
   1269                         (void*)USB_StatusHandler);
   \   0000002A   0x....             LDR.N    R3,??DataTable32_8
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x....             LDR.N    R0,??DataTable32_1
   \   00000030   0x8880             LDRH     R0,[R0, #+4]
   \   00000032   0x....             LDR.N    R1,??DataTable29
   \   00000034   0xEB11 0x0080      ADDS     R0,R1,R0, LSL #+2
   \   00000038   0xF110 0x0110      ADDS     R1,R0,#+16
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       USB_IO_Data
   \   00000042   0xE002             B.N      ??UsbGetInterface_1
   1270            }
   1271            else
   1272            {
   1273              USB_T9_ERROR_REQUEST();
   \                     ??UsbGetInterface_0:
   \   00000044   0x....             LDR.N    R0,??DataTable32
   \   00000046   0x2107             MOVS     R1,#+7
   \   00000048   0x7501             STRB     R1,[R0, #+20]
   1274            }
   1275          }
   \                     ??UsbGetInterface_1:
   \   0000004A   0xBD01             POP      {R0,PC}          ;; return
   1276          
   1277          /*************************************************************************
   1278           * Function Name: UsbSetInterface
   1279           * Parameters:  none
   1280           *
   1281           * Return: none
   1282           *
   1283           * Description: Implement set interface request
   1284           *
   1285           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1286          inline static
   1287          void UsbSetInterface (void)
   1288          {
   \                     UsbSetInterface:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1289          pUsbStandardInterfaceDescriptor_t pInterface, pInterfaceCurrent;
   1290          
   1291            if((UsbDevCtrl.State.DS == UsbDevStatusConfigured) &&
   1292               (UsbEp0SetupPacket.wLength.Word == 0))
   \   00000002   0x....             LDR.N    R0,??DataTable29
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000A   0x2805             CMP      R0,#+5
   \   0000000C   0xD143             BNE.N    ??UsbSetInterface_0
   \   0000000E   0x....             LDR.N    R0,??DataTable32_1
   \   00000010   0x88C0             LDRH     R0,[R0, #+6]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD13F             BNE.N    ??UsbSetInterface_0
   1293            {
   1294          
   1295              // Whether the interface is exist into current configuration?
   1296              if((pInterface = UsbFindInterface(UsbDevCtrl.pCnfg,
   1297                                                UsbEp0SetupPacket.wIndex.Word,
   1298                                                UsbEp0SetupPacket.wValue.Word)) == NULL)
   \   00000016   0x....             LDR.N    R0,??DataTable32_1
   \   00000018   0x8842             LDRH     R2,[R0, #+2]
   \   0000001A   0x....             LDR.N    R0,??DataTable32_1
   \   0000001C   0x8881             LDRH     R1,[R0, #+4]
   \   0000001E   0x....             LDR.N    R0,??DataTable29
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0x.... 0x....      BL       UsbFindInterface
   \   00000026   0x0004             MOVS     R4,R0
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD103             BNE.N    ??UsbSetInterface_1
   1299              {
   1300                USB_T9_ERROR_REQUEST();
   \   0000002C   0x....             LDR.N    R0,??DataTable32
   \   0000002E   0x2107             MOVS     R1,#+7
   \   00000030   0x7501             STRB     R1,[R0, #+20]
   1301                return;
   \   00000032   0xE033             B.N      ??UsbSetInterface_2
   1302              }
   1303          
   1304              // deconfigure current alternative setting EPs
   1305              pInterfaceCurrent =  UsbFindInterface(UsbDevCtrl.pCnfg,
   1306                                                    UsbEp0SetupPacket.wIndex.Word,
   1307                                                    UsbDevCtrl.AlternateSetting[UsbEp0SetupPacket.wIndex.Word]);
   \                     ??UsbSetInterface_1:
   \   00000034   0x....             LDR.N    R0,??DataTable32_1
   \   00000036   0x8880             LDRH     R0,[R0, #+4]
   \   00000038   0x....             LDR.N    R1,??DataTable29
   \   0000003A   0xEB11 0x0080      ADDS     R0,R1,R0, LSL #+2
   \   0000003E   0x6902             LDR      R2,[R0, #+16]
   \   00000040   0x....             LDR.N    R0,??DataTable32_1
   \   00000042   0x8881             LDRH     R1,[R0, #+4]
   \   00000044   0x....             LDR.N    R0,??DataTable29
   \   00000046   0x6880             LDR      R0,[R0, #+8]
   \   00000048   0x.... 0x....      BL       UsbFindInterface
   \   0000004C   0x0005             MOVS     R5,R0
   1308              assert(pInterfaceCurrent);
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD107             BNE.N    ??UsbSetInterface_3
   \   00000052   0xF240 0x521C      MOVW     R2,#+1308
   \   00000056   0x....             LDR.N    R1,??DataTable32_2
   \   00000058   0x....             LDR.N    R0,??DataTable32_10
   \   0000005A   0x.... 0x....      BL       __aeabi_assert
   \   0000005E   0x.... 0x....      BL       __iar_EmptyStepPoint
   1309              UsbEpInterfaceCnfg(pInterfaceCurrent,FALSE);
   \                     ??UsbSetInterface_3:
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x.... 0x....      BL       UsbEpInterfaceCnfg
   1310              // set new alternative settings
   1311              UsbDevCtrl.AlternateSetting[UsbEp0SetupPacket.wIndex.Word] = UsbEp0SetupPacket.wValue.Word;
   \   0000006A   0x....             LDR.N    R0,??DataTable32_1
   \   0000006C   0x8880             LDRH     R0,[R0, #+4]
   \   0000006E   0x....             LDR.N    R1,??DataTable29
   \   00000070   0xEB11 0x0080      ADDS     R0,R1,R0, LSL #+2
   \   00000074   0x....             LDR.N    R1,??DataTable32_1
   \   00000076   0x8849             LDRH     R1,[R1, #+2]
   \   00000078   0x6101             STR      R1,[R0, #+16]
   1312              // configure EPs
   1313              UsbEpInterfaceCnfg(pInterface,TRUE);
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       UsbEpInterfaceCnfg
   1314          
   1315              USB_CONFIGURE_HOOK(&UsbDevCtrl);
   \   00000082   0x....             LDR.N    R0,??DataTable29
   \   00000084   0x.... 0x....      BL       USB_CONFIGURE_HOOK
   1316              USB_IO_Data(CTRL_ENP_IN,NULL,0,(void*)USB_StatusHandler);
   \   00000088   0x....             LDR.N    R3,??DataTable32_8
   \   0000008A   0x2200             MOVS     R2,#+0
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x.... 0x....      BL       USB_IO_Data
   \   00000094   0xE002             B.N      ??UsbSetInterface_4
   1317            }
   1318            else
   1319            {
   1320              USB_T9_ERROR_REQUEST();
   \                     ??UsbSetInterface_0:
   \   00000096   0x....             LDR.N    R0,??DataTable32
   \   00000098   0x2107             MOVS     R1,#+7
   \   0000009A   0x7501             STRB     R1,[R0, #+20]
   1321            }
   1322          }
   \                     ??UsbSetInterface_4:
   \                     ??UsbSetInterface_2:
   \   0000009C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1323          
   1324          /*************************************************************************
   1325           * Function Name: UsbEpInterfaceCnfg
   1326           * Parameters: pUsbStandardInterfaceDescriptor_t pInterface
   1327           *             Boolean Configure
   1328           *
   1329           * Return: none
   1330           *
   1331           * Description: Configure/deconfigure EPs of a certain interface
   1332           *
   1333           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1334          const UsbEP_ExtData_t * USB_EP_ExtFind(Int8U EP)
   1335          {
   \                     USB_EP_ExtFind:
   \   00000000   0x0001             MOVS     R1,R0
   1336          #if USB_HIGH_SPEED > 0
   1337          const UsbEP_ExtDesc_t ** pEP_ExtCfg = ((const UsbEP_ExtDesc_t **)UsbDescArray[(UsbDevCtrl.HighSpeed?USB_HS_EP_EXT_ARRAY:USB_FS_EP_EXT_ARRAY)]);
   1338          #else
   1339          UsbEP_ExtDesc_t ** pEP_ExtCfg = ((UsbEP_ExtDesc_t **)UsbDescArray[USB_FS_EP_EXT_ARRAY]);
   \   00000002   0x....             LDR.N    R0,??DataTable32_4
   \   00000004   0x6842             LDR      R2,[R0, #+4]
   1340          #endif
   1341            while(*pEP_ExtCfg)
   \                     ??USB_EP_ExtFind_0:
   \   00000006   0x6810             LDR      R0,[R2, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00F             BEQ.N    ??USB_EP_ExtFind_1
   1342            {
   1343              if ((*pEP_ExtCfg)->Configuration == UsbDevCtrl.Configuration &&
   1344                  (*pEP_ExtCfg)->EndpointAddress == EP)
   \   0000000C   0x6810             LDR      R0,[R2, #+0]
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x....             LDR.N    R3,??DataTable32_11
   \   00000012   0x685B             LDR      R3,[R3, #+4]
   \   00000014   0x4298             CMP      R0,R3
   \   00000016   0xD107             BNE.N    ??USB_EP_ExtFind_2
   \   00000018   0x6810             LDR      R0,[R2, #+0]
   \   0000001A   0x7840             LDRB     R0,[R0, #+1]
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD102             BNE.N    ??USB_EP_ExtFind_2
   1345              {
   1346                return(&((*pEP_ExtCfg)->EP_ExtData));
   \   00000022   0x6810             LDR      R0,[R2, #+0]
   \   00000024   0x1D00             ADDS     R0,R0,#+4
   \   00000026   0xE002             B.N      ??USB_EP_ExtFind_3
   1347              }
   1348              ++pEP_ExtCfg;
   \                     ??USB_EP_ExtFind_2:
   \   00000028   0x1D12             ADDS     R2,R2,#+4
   \   0000002A   0xE7EC             B.N      ??USB_EP_ExtFind_0
   1349            }
   1350            return(NULL);
   \                     ??USB_EP_ExtFind_1:
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??USB_EP_ExtFind_3:
   \   0000002E   0x4770             BX       LR               ;; return
   1351          }
   1352          
   1353          /*************************************************************************
   1354           * Function Name: UsbEpInterfaceCnfg
   1355           * Parameters: pUsbStandardInterfaceDescriptor_t pInterface
   1356           *             Boolean Configure
   1357           *
   1358           * Return: none
   1359           *
   1360           * Description: Configure/deconfigure EPs of a certain interface
   1361           *
   1362           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1363          static
   1364          void UsbEpInterfaceCnfg(pUsbStandardInterfaceDescriptor_t pInterface,
   1365                                  Boolean Configure)
   1366          {
   \                     UsbEpInterfaceCnfg:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1367          pUsbStandardEpDescriptor_t pEp = NULL;
   \   00000006   0x2600             MOVS     R6,#+0
   1368          const UsbEP_ExtData_t * pUsbEP_ExtData;
   1369          
   1370            assert(pInterface);
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD107             BNE.N    ??UsbEpInterfaceCnfg_0
   \   0000000C   0xF240 0x525A      MOVW     R2,#+1370
   \   00000010   0x....             LDR.N    R1,??DataTable32_2
   \   00000012   0x....             LDR.N    R0,??DataTable32_12
   \   00000014   0x.... 0x....      BL       __aeabi_assert
   \   00000018   0x.... 0x....      BL       __iar_EmptyStepPoint
   1371            while((pEp = UsbFindEP(pInterface,pEp)) != NULL)
   \                     ??UsbEpInterfaceCnfg_0:
   \   0000001C   0x0031             MOVS     R1,R6
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       UsbFindEP
   \   00000024   0x0006             MOVS     R6,R0
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD013             BEQ.N    ??UsbEpInterfaceCnfg_1
   1372            {
   1373              pUsbEP_ExtData = USB_EP_ExtFind(pEp->bEndpointAddress);
   \   0000002A   0x78B0             LDRB     R0,[R6, #+2]
   \   0000002C   0x.... 0x....      BL       USB_EP_ExtFind
   \   00000030   0x0007             MOVS     R7,R0
   1374              assert(pUsbEP_ExtData);
   \   00000032   0x2F00             CMP      R7,#+0
   \   00000034   0xD107             BNE.N    ??UsbEpInterfaceCnfg_2
   \   00000036   0xF240 0x525E      MOVW     R2,#+1374
   \   0000003A   0x....             LDR.N    R1,??DataTable32_2
   \   0000003C   0x....             LDR.N    R0,??DataTable32_13
   \   0000003E   0x.... 0x....      BL       __aeabi_assert
   \   00000042   0x.... 0x....      BL       __iar_EmptyStepPoint
   1375              USB_RealizeEp(pEp,pUsbEP_ExtData,Configure);
   \                     ??UsbEpInterfaceCnfg_2:
   \   00000046   0x002A             MOVS     R2,R5
   \   00000048   0x0039             MOVS     R1,R7
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0x.... 0x....      BL       USB_RealizeEp
   \   00000050   0xE7E4             B.N      ??UsbEpInterfaceCnfg_0
   1376            }
   1377          }
   \                     ??UsbEpInterfaceCnfg_1:
   \   00000052   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1378          
   1379          /*************************************************************************
   1380           * Function Name: UsbSynchFrame
   1381           * Parameters:  none
   1382           *
   1383           * Return: none
   1384           *
   1385           * Description: Implement synch frame request
   1386           *
   1387           *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1388          inline static
   1389          void UsbSynchFrame (void)
   1390          {
   1391            if( USB_SOF_EVENT &&
   1392               (UsbDevCtrl.State.DS == UsbDevStatusConfigured) &&
   1393               (UsbEp0SetupPacket.wLength.Word == 2) &&
   1394               (UsbEp0SetupPacket.wValue.Word == 0))
   1395            {
   1396            #if USB_SOF_EVENT > 0
   1397              InData = USB_GetFrameNumb();
   1398            #else
   1399              InData = 0;
   1400            #endif
   1401              USB_IO_Data(CTRL_ENP_IN,(pInt8U)&InData,2,(void*)USB_StatusHandler);
   1402            }
   1403            else
   1404            {
   1405              USB_T9_ERROR_REQUEST();
   \                     UsbSynchFrame:
   \   00000000   0x....             LDR.N    R0,??DataTable32
   \   00000002   0x2107             MOVS     R1,#+7
   \   00000004   0x7501             STRB     R1,[R0, #+20]
   1406            }
   1407          }
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     UsbDevCtrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x........         DC32     EpCnfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x........         DC32     UsbEp0SetupPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x........         DC32     `?<Constant "D:\\\\wangfan2\\\\\\327\\300\\303\\346\\\\RT`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x........         DC32     `?<Constant "pConfiguration != NULL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \   00000000   0x........         DC32     UsbDescArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_5:
   \   00000000   0x........         DC32     `?<Constant "pInterface != NULL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_6:
   \   00000000   0x........         DC32     ??ep_numbers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_7:
   \   00000000   0x........         DC32     InData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_8:
   \   00000000   0x........         DC32     USB_StatusHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_9:
   \   00000000   0x........         DC32     UsbStandardDeviceDescriptorStr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_10:
   \   00000000   0x........         DC32     `?<Constant "pInterfaceCurrent">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_11:
   \   00000000   0x........         DC32     UsbDevCtrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_12:
   \   00000000   0x........         DC32     `?<Constant "pInterface">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_13:
   \   00000000   0x........         DC32     `?<Constant "pUsbEP_ExtData">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "pConfiguration != NULL">`:
   \   00000000   0x70 0x43          DC8 "pConfiguration != NULL"
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x75    
   \              0x72 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x21    
   \              0x3D 0x20    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "D:\\\\wangfan2\\\\\\327\\300\\303\\346\\\\RT`:
   \   00000000   0x44 0x3A          DC8 "D:\\wangfan2\\\327\300\303\346\\RTU_1.3\\USB\\usb_t9.c"
   \              0x5C 0x77    
   \              0x61 0x6E    
   \              0x67 0x66    
   \              0x61 0x6E    
   \              0x32 0x5C    
   \              0xD7 0xC0    
   \              0xC3 0xE6    
   \              0x5C 0x52    
   \              0x54 0x55    
   \              0x5F 0x31    
   \              0x2E 0x33    
   \              0x5C 0x55    
   \              0x53 0x42    
   \              0x5C 0x75    
   \              0x73 0x62    
   \              0x5F 0x74    
   \              0x39 0x2E    
   \              0x63 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "pInterface != NULL">`:
   \   00000000   0x70 0x49          DC8 "pInterface != NULL"
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x66 0x61    
   \              0x63 0x65    
   \              0x20 0x21    
   \              0x3D 0x20    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "pInterfaceCurrent">`:
   \   00000000   0x70 0x49          DC8 "pInterfaceCurrent"
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x66 0x61    
   \              0x63 0x65    
   \              0x43 0x75    
   \              0x72 0x72    
   \              0x65 0x6E    
   \              0x74 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "pInterface">`:
   \   00000000   0x70 0x49          DC8 "pInterface"
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x66 0x61    
   \              0x63 0x65    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "pUsbEP_ExtData">`:
   \   00000000   0x70 0x55          DC8 "pUsbEP_ExtData"
   \              0x73 0x62    
   \              0x45 0x50    
   \              0x5F 0x45    
   \              0x78 0x74    
   \              0x44 0x61    
   \              0x74 0x61    
   \              0x00         
   \   0000000F   0x00               DC8 0
   1408          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USB_AddStatusEndHandler
         8   -> USB_IO_Data
         8   -> USB_SetAdd
         8   -> UsbSetDevState
       0   USB_EP_ExtFind
       8   USB_SetupHandler
         8   -> USB_CLASS_REQUEST_HOOK
         8   -> USB_GET_DESCRIPTOR_HOOK
         8   -> USB_VENDOR_REQUEST_HOOK
         8   -> UsbClearFeature
         8   -> UsbGetConfiguration
         8   -> UsbGetDescriptor
         8   -> UsbGetInterface
         8   -> UsbGetStatus
         8   -> UsbSetAddress
         8   -> UsbSetConfiguration
         8   -> UsbSetDescriptor
         8   -> UsbSetFeature
         8   -> UsbSetInterface
         8   -> UsbSynchFrame
       8   USB_StatusEndHandler
         8   -> USB_IO_Data
       8   USB_StatusHandler
         8   -> USB_StatusPhase
       4   USB_T9_Size
       0   UsbClearDevFeature
      16   UsbClearEpFeature
        16   -> USB_EP_UNSTALL_HOOK
        16   -> USB_EpLogToPhysAdd
        16   -> USB_SetStallEP
       8   UsbClearFeature
         8   -> USB_IO_Data
         8   -> USB_StatusHandler
         8   -> UsbClearDevFeature
         8   -> UsbClearEpFeature
         8   -> UsbClearInterfaceFeature
       0   UsbClearInterfaceFeature
       8   UsbCoreInit
         8   -> USB_HwInit
       0   UsbCoreReq
       8   UsbDevConnectCallback
         8   -> USB_CONNECT_HOOK
         8   -> UsbSetDevState
       8   UsbDevResetCallback
         8   -> USB_RESET_HOOK
         8   -> UsbSetDevState
       8   UsbDevStatus
         8   -> USB_IO_Data
       8   UsbDevSuspendCallback
         8   -> USB_SUSPEND_HOOK
      24   UsbEpInterfaceCnfg
        24   -> USB_EP_ExtFind
        24   -> USB_RealizeEp
        24   -> UsbFindEP
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
       8   UsbEpStatus
         8   -> USB_EpLogToPhysAdd
         8   -> USB_GetStallEP
         8   -> USB_IO_Data
       0   UsbFindConfiguration
      16   UsbFindEP
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   UsbFindInterface
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
       8   UsbGetConfiguration
         8   -> USB_IO_Data
         8   -> UsbCoreReq
       8   UsbGetDescriptor
         8   -> USB_GET_DESCRIPTOR_HOOK
         8   -> UsbGetDescriptorConfiguration
         8   -> UsbGetDescriptorDevice
         8   -> UsbGetDescriptorString
      16   UsbGetDescriptorConfiguration
        16   -> USB_IO_Data
        16   -> USB_T9_Size
       8   UsbGetDescriptorDevice
         8   -> USB_IO_Data
         8   -> USB_T9_Size
      24   UsbGetDescriptorString
        24   -> USB_IO_Data
        24   -> USB_T9_Size
       8   UsbGetInterface
         8   -> USB_IO_Data
       8   UsbGetStatus
         8   -> UsbDevStatus
         8   -> UsbEpStatus
         8   -> UsbInterfaceStatus
       8   UsbInterfaceStatus
         8   -> USB_IO_Data
       8   UsbSetAddress
         8   -> USB_StatusHandler
       8   UsbSetConfiguration
         8   -> USB_StatusHandler
         8   -> UsbSetConfigurtonState
      16   UsbSetConfigurtonState
        16   -> USB_CONFIGURE_HOOK
        16   -> UsbFindConfiguration
        16   -> UsbSetDevState
       0   UsbSetDescriptor
       0   UsbSetDevFeature
      16   UsbSetDevState
        16   -> USB_CONFIGURE_HOOK
        16   -> USB_Configure
        16   -> USB_SetAdd
        16   -> UsbEpInterfaceCnfg
        16   -> UsbFindInterface
      16   UsbSetEpFeature
        16   -> USB_EP_STALL_HOOK
        16   -> USB_EpLogToPhysAdd
        16   -> USB_SetStallEP
       8   UsbSetFeature
         8   -> USB_StatusHandler
         8   -> UsbSetDevFeature
         8   -> UsbSetEpFeature
         8   -> UsbSetInterfaceFeature
      16   UsbSetInterface
        16   -> USB_CONFIGURE_HOOK
        16   -> USB_IO_Data
        16   -> UsbEpInterfaceCnfg
        16   -> UsbFindInterface
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   UsbSetInterfaceFeature
       0   UsbSynchFrame


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      40  ?<Constant "D:\\wangfan2\\\327\300\303\346\\RT
      24  ?<Constant "pConfiguration != NULL">
      20  ?<Constant "pInterface != NULL">
      12  ?<Constant "pInterface">
      20  ?<Constant "pInterfaceCurrent">
      16  ?<Constant "pUsbEP_ExtData">
       4  ??DataTable29
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_10
       4  ??DataTable32_11
       4  ??DataTable32_12
       4  ??DataTable32_13
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable32_6
       4  ??DataTable32_7
       4  ??DataTable32_8
       4  ??DataTable32_9
       4  InData
      80  USB_AddStatusEndHandler
      48  USB_EP_ExtFind
     262  USB_SetupHandler
      34  USB_StatusEndHandler
      72  USB_StatusHandler
      36  USB_T9_Size
      38  UsbClearDevFeature
      58  UsbClearEpFeature
     230  UsbClearFeature
       6  UsbClearInterfaceFeature
      72  UsbCoreInit
     102  UsbCoreReq
      28  UsbDevConnectCallback
      28  UsbDevCtrl
      14  UsbDevResetCallback
      46  UsbDevStatus
      42  UsbDevSuspendCallback
       8  UsbEp0SetupPacket
      84  UsbEpInterfaceCnfg
      64  UsbEpStatus
      46  UsbFindConfiguration
     120  UsbFindEP
      74  UsbFindInterface
      70  UsbGetConfiguration
     118  UsbGetDescriptor
      64  UsbGetDescriptorConfiguration
      50  UsbGetDescriptorDevice
     168  UsbGetDescriptorString
      76  UsbGetInterface
     166  UsbGetStatus
      32  UsbInterfaceStatus
      78  UsbSetAddress
      58  UsbSetConfiguration
     160  UsbSetConfigurtonState
      28  UsbSetDescriptor
      38  UsbSetDevFeature
     236  UsbSetDevState
      58  UsbSetEpFeature
     222  UsbSetFeature
     158  UsbSetInterface
       6  UsbSetInterfaceFeature
       8  UsbSynchFrame
       4  ep_numbers

 
    44 bytes in section .bss
   132 bytes in section .rodata
 3 410 bytes in section .text
 
 3 410 bytes of CODE  memory
   132 bytes of CONST memory
    44 bytes of DATA  memory

Errors: none
Warnings: none
